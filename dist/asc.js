!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(function(){try{return require("assemblyscript")}catch(e){}}()):"function"==typeof define&&define.amd?define(["assemblyscript"],n):"object"==typeof exports?exports.asc=n(function(){try{return require("assemblyscript")}catch(e){}}()):e.asc=n(e.assemblyscript)}("undefined"!=typeof self?self:this,function(__WEBPACK_EXTERNAL_MODULE__6__){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=14)}([function(e,n,t){var r,i;n.nextTick=function(e){setTimeout(e,0)},n.platform=n.arch=n.execPath=n.title="browser",n.pid=1,n.browser=!0,n.env={},n.argv=[],n.binding=function(e){throw new Error("No such module. (Possibly not yet loaded)")},i="/",n.cwd=function(){return i},n.chdir=function(e){r||(r=t(2)),i=r.resolve(e,i)},n.exit=n.kill=n.umask=n.dlopen=n.uptime=n.memoryUsage=n.uvCounters=function(){},n.features={}},function(e,n){var t;t=function(){return this}();try{t=t||Function("return this")()||(0,eval)("this")}catch(e){"object"==typeof window&&(t=window)}e.exports=t},function(e,n,t){(function(e){function t(e,n){for(var t=0,r=e.length-1;r>=0;r--){var i=e[r];"."===i?e.splice(r,1):".."===i?(e.splice(r,1),t++):t&&(e.splice(r,1),t--)}if(n)for(;t--;t)e.unshift("..");return e}var r=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,i=function(e){return r.exec(e).slice(1)};function o(e,n){if(e.filter)return e.filter(n);for(var t=[],r=0;r<e.length;r++)n(e[r],r,e)&&t.push(e[r]);return t}n.resolve=function(){for(var n="",r=!1,i=arguments.length-1;i>=-1&&!r;i--){var s=i>=0?arguments[i]:e.cwd();if("string"!=typeof s)throw new TypeError("Arguments to path.resolve must be strings");s&&(n=s+"/"+n,r="/"===s.charAt(0))}return n=t(o(n.split("/"),function(e){return!!e}),!r).join("/"),(r?"/":"")+n||"."},n.normalize=function(e){var r=n.isAbsolute(e),i="/"===s(e,-1);return(e=t(o(e.split("/"),function(e){return!!e}),!r).join("/"))||r||(e="."),e&&i&&(e+="/"),(r?"/":"")+e},n.isAbsolute=function(e){return"/"===e.charAt(0)},n.join=function(){var e=Array.prototype.slice.call(arguments,0);return n.normalize(o(e,function(e,n){if("string"!=typeof e)throw new TypeError("Arguments to path.join must be strings");return e}).join("/"))},n.relative=function(e,t){function r(e){for(var n=0;n<e.length&&""===e[n];n++);for(var t=e.length-1;t>=0&&""===e[t];t--);return n>t?[]:e.slice(n,t-n+1)}e=n.resolve(e).substr(1),t=n.resolve(t).substr(1);for(var i=r(e.split("/")),o=r(t.split("/")),s=Math.min(i.length,o.length),a=s,l=0;l<s;l++)if(i[l]!==o[l]){a=l;break}var u=[];for(l=a;l<i.length;l++)u.push("..");return(u=u.concat(o.slice(a))).join("/")},n.sep="/",n.delimiter=":",n.dirname=function(e){var n=i(e),t=n[0],r=n[1];return t||r?(r&&(r=r.substr(0,r.length-1)),t+r):"."},n.basename=function(e,n){var t=i(e)[2];return n&&t.substr(-1*n.length)===n&&(t=t.substr(0,t.length-n.length)),t},n.extname=function(e){return i(e)[3]};var s="b"==="ab".substr(-1)?function(e,n,t){return e.substr(n,t)}:function(e,n,t){return n<0&&(n=e.length+n),e.substr(n,t)}}).call(this,t(0))},function(e,n,t){(function(n,t){e.exports=n.hrtime||function(e){var n=.001*i.call(r),t=Math.floor(n),o=Math.floor(n%1*1e9);e&&(t-=e[0],(o-=e[1])<0&&(t--,o+=1e9));return[t,o]};var r=t.performance||{},i=r.now||r.mozNow||r.msNow||r.oNow||r.webkitNow||function(){return(new Date).getTime()}}).call(this,t(0),t(1))},function(e,n){function t(e){return"number"==typeof e||(!!/^0x[0-9a-f]+$/i.test(e)||/^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(e))}e.exports=function(e,n){n||(n={});var r={bools:{},strings:{},unknownFn:null};"function"==typeof n.unknown&&(r.unknownFn=n.unknown),"boolean"==typeof n.boolean&&n.boolean?r.allBools=!0:[].concat(n.boolean).filter(Boolean).forEach(function(e){r.bools[e]=!0});var i={};Object.keys(n.alias||{}).forEach(function(e){i[e]=[].concat(n.alias[e]),i[e].forEach(function(n){i[n]=[e].concat(i[e].filter(function(e){return n!==e}))})}),[].concat(n.string).filter(Boolean).forEach(function(e){r.strings[e]=!0,i[e]&&(r.strings[i[e]]=!0)});var o=n.default||{},s={_:[]};Object.keys(r.bools).forEach(function(e){l(e,void 0!==o[e]&&o[e])});var a=[];function l(e,n,o){if(!o||!r.unknownFn||function(e,n){return r.allBools&&/^--[^=]+$/.test(n)||r.strings[e]||r.bools[e]||i[e]}(e,o)||!1!==r.unknownFn(o)){var a=!r.strings[e]&&t(n)?Number(n):n;u(s,e.split("."),a),(i[e]||[]).forEach(function(e){u(s,e.split("."),a)})}}function u(e,n,t){var i=e;n.slice(0,-1).forEach(function(e){void 0===i[e]&&(i[e]={}),i=i[e]});var o=n[n.length-1];void 0===i[o]||r.bools[o]||"boolean"==typeof i[o]?i[o]=t:Array.isArray(i[o])?i[o].push(t):i[o]=[i[o],t]}function f(e){return i[e].some(function(e){return r.bools[e]})}-1!==e.indexOf("--")&&(a=e.slice(e.indexOf("--")+1),e=e.slice(0,e.indexOf("--")));for(var c=0;c<e.length;c++){var p=e[c];if(/^--.+=/.test(p)){var h=p.match(/^--([^=]+)=([\s\S]*)$/),d=h[1],m=h[2];r.bools[d]&&(m="false"!==m),l(d,m,p)}else if(/^--no-.+/.test(p)){l(d=p.match(/^--no-(.+)/)[1],!1,p)}else if(/^--.+/.test(p)){d=p.match(/^--(.+)/)[1];void 0===(x=e[c+1])||/^-/.test(x)||r.bools[d]||r.allBools||i[d]&&f(d)?/^(true|false)$/.test(x)?(l(d,"true"===x,p),c++):l(d,!r.strings[d]||"",p):(l(d,x,p),c++)}else if(/^-[^-]+/.test(p)){for(var g=p.slice(1,-1).split(""),b=!1,y=0;y<g.length;y++){var x;if("-"!==(x=p.slice(y+2))){if(/[A-Za-z]/.test(g[y])&&/=/.test(x)){l(g[y],x.split("=")[1],p),b=!0;break}if(/[A-Za-z]/.test(g[y])&&/-?\d+(\.\d*)?(e-?\d+)?$/.test(x)){l(g[y],x,p),b=!0;break}if(g[y+1]&&g[y+1].match(/\W/)){l(g[y],p.slice(y+2),p),b=!0;break}l(g[y],!r.strings[g[y]]||"",p)}else l(g[y],x,p)}d=p.slice(-1)[0];b||"-"===d||(!e[c+1]||/^(-|--)[^-]/.test(e[c+1])||r.bools[d]||i[d]&&f(d)?e[c+1]&&/true|false/.test(e[c+1])?(l(d,"true"===e[c+1],p),c++):l(d,!r.strings[d]||"",p):(l(d,e[c+1],p),c++))}else if(r.unknownFn&&!1===r.unknownFn(p)||s._.push(r.strings._||!t(p)?p:Number(p)),n.stopEarly){s._.push.apply(s._,e.slice(c+1));break}}return Object.keys(o).forEach(function(e){var n,t,r;n=s,t=e.split("."),r=n,t.slice(0,-1).forEach(function(e){r=r[e]||{}}),t[t.length-1]in r||(u(s,e.split("."),o[e]),(i[e]||[]).forEach(function(n){u(s,n.split("."),o[e])}))}),n["--"]?(s["--"]=new Array,a.forEach(function(e){s["--"].push(e)})):a.forEach(function(e){s._.push(e)}),s}},function(e){e.exports={version:{desc:"Prints just the compiler's version and exits.",type:"boolean",aliases:["v"]},help:{desc:"Prints this message and exits.",type:"boolean",aliases:["h"]},optimize:{desc:["Optimizes the module. Also accepts the optimize level:",""," -O     Uses defaults. Equivalent to -O2s"," -O0    Equivalent to --optimizeLevel 0"," -O1    Equivalent to --optimizeLevel 1"," -O2    Equivalent to --optimizeLevel 2"," -O3    Equivalent to --optimizeLevel 3"," -Oz    Equivalent to -O but with --shrinkLevel 2"," -O3s   Equivalent to -O3 with --shrinkLevel 1 etc.",""],type:"boolean",aliases:["O"]},optimizeLevel:{desc:"How much to focus on optimizing code. [0-3]",type:"number"},shrinkLevel:{desc:"How much to focus on shrinking code size. [0-2, s=1, z=2]",type:"number"},validate:{desc:"Validates the module using Binaryen. Exits if invalid.",type:"boolean",aliases:["c","check"]},baseDir:{desc:"Specifies the base directory of input and output files.",type:"string"},outFile:{desc:"Specifies the output file. File extension indicates format.",type:"string",aliases:["o"]},binaryFile:{desc:"Specifies the binary output file (.wasm).",type:"string",aliases:["b"]},textFile:{desc:"Specifies the text output file (.wat).",type:"string",aliases:["t"]},asmjsFile:{desc:"Specifies the asm.js output file (.js).",type:"string",aliases:["a"]},idlFile:{desc:"Specifies the WebIDL output file (.webidl).",type:"string",aliases:["i"]},tsdFile:{desc:"Specifies the TypeScript definition output file (.d.ts).",type:"string",aliases:["d","dtsFile"]},sourceMap:{desc:["Enables source map generation. Optionally takes the URL","used to reference the source map from the binary file."],type:"string"},noTreeShaking:{desc:"Disables compiler-level tree-shaking, compiling everything.",type:"boolean"},noDebug:{desc:"Disables maintaining of debug information in binaries.",type:"boolean"},noAssert:{desc:"Replaces assertions with just their value without trapping.",type:"boolean"},noEmit:{desc:"Performs compilation as usual but does not emit code.",type:"boolean"},noMemory:{desc:"Does not set up a memory. Useful for low-level WebAssembly.",type:"boolean"},importMemory:{desc:"Imports the memory instance provided by the embedder.",type:"boolean"},memoryBase:{desc:"Sets the start offset of compiler-generated static memory.",type:"number"},importTable:{desc:"Imports the function table instance provided by the embedder.",type:"boolean"},noLib:{desc:"Does not include the shipped standard library.",type:"boolean"},lib:{desc:["Adds one or multiple paths to custom library components and","uses exports of all top-level files at this path as globals."],type:"string"},trapMode:{desc:["Sets the trap mode to use.",""," allow  Allow trapping operations. This is the default."," clamp  Replace trapping operations with clamping semantics."," js     Replace trapping operations with JS semantics.",""],type:"string",default:"allow"},runPasses:{desc:["Specifies additional Binaryen passes to run after other","optimizations, if any. See: Binaryen/src/passes/pass.cpp"],type:"string"},measure:{desc:"Prints measuring information on I/O and compile times.",type:"boolean"}}},function(e,n){if(void 0===__WEBPACK_EXTERNAL_MODULE__6__){var t=new Error('Cannot find module "assemblyscript"');throw t.code="MODULE_NOT_FOUND",t}e.exports=__WEBPACK_EXTERNAL_MODULE__6__},function(e,n){n.endianness=function(){return"LE"},n.hostname=function(){return"undefined"!=typeof location?location.hostname:""},n.loadavg=function(){return[]},n.uptime=function(){return 0},n.freemem=function(){return Number.MAX_VALUE},n.totalmem=function(){return Number.MAX_VALUE},n.cpus=function(){return[]},n.type=function(){return"Browser"},n.release=function(){return"undefined"!=typeof navigator?navigator.appVersion:""},n.networkInterfaces=n.getNetworkInterfaces=function(){return{}},n.arch=function(){return"javascript"},n.platform=function(){return"browser"},n.tmpdir=n.tmpDir=function(){return"/tmp"},n.EOL="\n",n.homedir=function(){return"/"}},function(e,n){},function(e,n){var t={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==t.call(e)}},function(e,n){n.read=function(e,n,t,r,i){var o,s,a=8*i-r-1,l=(1<<a)-1,u=l>>1,f=-7,c=t?i-1:0,p=t?-1:1,h=e[n+c];for(c+=p,o=h&(1<<-f)-1,h>>=-f,f+=a;f>0;o=256*o+e[n+c],c+=p,f-=8);for(s=o&(1<<-f)-1,o>>=-f,f+=r;f>0;s=256*s+e[n+c],c+=p,f-=8);if(0===o)o=1-u;else{if(o===l)return s?NaN:1/0*(h?-1:1);s+=Math.pow(2,r),o-=u}return(h?-1:1)*s*Math.pow(2,o-r)},n.write=function(e,n,t,r,i,o){var s,a,l,u=8*o-i-1,f=(1<<u)-1,c=f>>1,p=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,h=r?0:o-1,d=r?1:-1,m=n<0||0===n&&1/n<0?1:0;for(n=Math.abs(n),isNaN(n)||n===1/0?(a=isNaN(n)?1:0,s=f):(s=Math.floor(Math.log(n)/Math.LN2),n*(l=Math.pow(2,-s))<1&&(s--,l*=2),(n+=s+c>=1?p/l:p*Math.pow(2,1-c))*l>=2&&(s++,l/=2),s+c>=f?(a=0,s=f):s+c>=1?(a=(n*l-1)*Math.pow(2,i),s+=c):(a=n*Math.pow(2,c-1)*Math.pow(2,i),s=0));i>=8;e[t+h]=255&a,h+=d,a/=256,i-=8);for(s=s<<i|a,u+=i;u>0;e[t+h]=255&s,h+=d,s/=256,u-=8);e[t+h-d]|=128*m}},function(e,n,t){"use strict";n.byteLength=function(e){return 3*e.length/4-u(e)},n.toByteArray=function(e){var n,t,r,s,a,l=e.length;s=u(e),a=new o(3*l/4-s),t=s>0?l-4:l;var f=0;for(n=0;n<t;n+=4)r=i[e.charCodeAt(n)]<<18|i[e.charCodeAt(n+1)]<<12|i[e.charCodeAt(n+2)]<<6|i[e.charCodeAt(n+3)],a[f++]=r>>16&255,a[f++]=r>>8&255,a[f++]=255&r;2===s?(r=i[e.charCodeAt(n)]<<2|i[e.charCodeAt(n+1)]>>4,a[f++]=255&r):1===s&&(r=i[e.charCodeAt(n)]<<10|i[e.charCodeAt(n+1)]<<4|i[e.charCodeAt(n+2)]>>2,a[f++]=r>>8&255,a[f++]=255&r);return a},n.fromByteArray=function(e){for(var n,t=e.length,i=t%3,o="",s=[],a=0,l=t-i;a<l;a+=16383)s.push(f(e,a,a+16383>l?l:a+16383));1===i?(n=e[t-1],o+=r[n>>2],o+=r[n<<4&63],o+="=="):2===i&&(n=(e[t-2]<<8)+e[t-1],o+=r[n>>10],o+=r[n>>4&63],o+=r[n<<2&63],o+="=");return s.push(o),s.join("")};for(var r=[],i=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0,l=s.length;a<l;++a)r[a]=s[a],i[s.charCodeAt(a)]=a;function u(e){var n=e.length;if(n%4>0)throw new Error("Invalid string. Length must be a multiple of 4");return"="===e[n-2]?2:"="===e[n-1]?1:0}function f(e,n,t){for(var i,o,s=[],a=n;a<t;a+=3)i=(e[a]<<16&16711680)+(e[a+1]<<8&65280)+(255&e[a+2]),s.push(r[(o=i)>>18&63]+r[o>>12&63]+r[o>>6&63]+r[63&o]);return s.join("")}i["-".charCodeAt(0)]=62,i["_".charCodeAt(0)]=63},function(e,n,t){"use strict";(function(e){var r=t(11),i=t(10),o=t(9);function s(){return l.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(e,n){if(s()<n)throw new RangeError("Invalid typed array length");return l.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(n)).__proto__=l.prototype:(null===e&&(e=new l(n)),e.length=n),e}function l(e,n,t){if(!(l.TYPED_ARRAY_SUPPORT||this instanceof l))return new l(e,n,t);if("number"==typeof e){if("string"==typeof n)throw new Error("If encoding is specified then the first argument must be a string");return c(this,e)}return u(this,e,n,t)}function u(e,n,t,r){if("number"==typeof n)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&n instanceof ArrayBuffer?function(e,n,t,r){if(n.byteLength,t<0||n.byteLength<t)throw new RangeError("'offset' is out of bounds");if(n.byteLength<t+(r||0))throw new RangeError("'length' is out of bounds");n=void 0===t&&void 0===r?new Uint8Array(n):void 0===r?new Uint8Array(n,t):new Uint8Array(n,t,r);l.TYPED_ARRAY_SUPPORT?(e=n).__proto__=l.prototype:e=p(e,n);return e}(e,n,t,r):"string"==typeof n?function(e,n,t){"string"==typeof t&&""!==t||(t="utf8");if(!l.isEncoding(t))throw new TypeError('"encoding" must be a valid string encoding');var r=0|d(n,t),i=(e=a(e,r)).write(n,t);i!==r&&(e=e.slice(0,i));return e}(e,n,t):function(e,n){if(l.isBuffer(n)){var t=0|h(n.length);return 0===(e=a(e,t)).length?e:(n.copy(e,0,0,t),e)}if(n){if("undefined"!=typeof ArrayBuffer&&n.buffer instanceof ArrayBuffer||"length"in n)return"number"!=typeof n.length||(r=n.length)!=r?a(e,0):p(e,n);if("Buffer"===n.type&&o(n.data))return p(e,n.data)}var r;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,n)}function f(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function c(e,n){if(f(n),e=a(e,n<0?0:0|h(n)),!l.TYPED_ARRAY_SUPPORT)for(var t=0;t<n;++t)e[t]=0;return e}function p(e,n){var t=n.length<0?0:0|h(n.length);e=a(e,t);for(var r=0;r<t;r+=1)e[r]=255&n[r];return e}function h(e){if(e>=s())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s().toString(16)+" bytes");return 0|e}function d(e,n){if(l.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var t=e.length;if(0===t)return 0;for(var r=!1;;)switch(n){case"ascii":case"latin1":case"binary":return t;case"utf8":case"utf-8":case void 0:return D(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*t;case"hex":return t>>>1;case"base64":return j(e).length;default:if(r)return D(e).length;n=(""+n).toLowerCase(),r=!0}}function m(e,n,t){var r=e[n];e[n]=e[t],e[t]=r}function g(e,n,t,r,i){if(0===e.length)return-1;if("string"==typeof t?(r=t,t=0):t>2147483647?t=2147483647:t<-2147483648&&(t=-2147483648),t=+t,isNaN(t)&&(t=i?0:e.length-1),t<0&&(t=e.length+t),t>=e.length){if(i)return-1;t=e.length-1}else if(t<0){if(!i)return-1;t=0}if("string"==typeof n&&(n=l.from(n,r)),l.isBuffer(n))return 0===n.length?-1:b(e,n,t,r,i);if("number"==typeof n)return n&=255,l.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,n,t):Uint8Array.prototype.lastIndexOf.call(e,n,t):b(e,[n],t,r,i);throw new TypeError("val must be string, number or Buffer")}function b(e,n,t,r,i){var o,s=1,a=e.length,l=n.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||n.length<2)return-1;s=2,a/=2,l/=2,t/=2}function u(e,n){return 1===s?e[n]:e.readUInt16BE(n*s)}if(i){var f=-1;for(o=t;o<a;o++)if(u(e,o)===u(n,-1===f?0:o-f)){if(-1===f&&(f=o),o-f+1===l)return f*s}else-1!==f&&(o-=o-f),f=-1}else for(t+l>a&&(t=a-l),o=t;o>=0;o--){for(var c=!0,p=0;p<l;p++)if(u(e,o+p)!==u(n,p)){c=!1;break}if(c)return o}return-1}function y(e,n,t,r){t=Number(t)||0;var i=e.length-t;r?(r=Number(r))>i&&(r=i):r=i;var o=n.length;if(o%2!=0)throw new TypeError("Invalid hex string");r>o/2&&(r=o/2);for(var s=0;s<r;++s){var a=parseInt(n.substr(2*s,2),16);if(isNaN(a))return s;e[t+s]=a}return s}function x(e,n,t,r){return H(D(n,e.length-t),e,t,r)}function _(e,n,t,r){return H(function(e){for(var n=[],t=0;t<e.length;++t)n.push(255&e.charCodeAt(t));return n}(n),e,t,r)}function v(e,n,t,r){return _(e,n,t,r)}function E(e,n,t,r){return H(j(n),e,t,r)}function T(e,n,t,r){return H(function(e,n){for(var t,r,i,o=[],s=0;s<e.length&&!((n-=2)<0);++s)t=e.charCodeAt(s),r=t>>8,i=t%256,o.push(i),o.push(r);return o}(n,e.length-t),e,t,r)}function z(e,n,t){return 0===n&&t===e.length?r.fromByteArray(e):r.fromByteArray(e.slice(n,t))}function S(e,n,t){t=Math.min(e.length,t);for(var r=[],i=n;i<t;){var o,s,a,l,u=e[i],f=null,c=u>239?4:u>223?3:u>191?2:1;if(i+c<=t)switch(c){case 1:u<128&&(f=u);break;case 2:128==(192&(o=e[i+1]))&&(l=(31&u)<<6|63&o)>127&&(f=l);break;case 3:o=e[i+1],s=e[i+2],128==(192&o)&&128==(192&s)&&(l=(15&u)<<12|(63&o)<<6|63&s)>2047&&(l<55296||l>57343)&&(f=l);break;case 4:o=e[i+1],s=e[i+2],a=e[i+3],128==(192&o)&&128==(192&s)&&128==(192&a)&&(l=(15&u)<<18|(63&o)<<12|(63&s)<<6|63&a)>65535&&l<1114112&&(f=l)}null===f?(f=65533,c=1):f>65535&&(f-=65536,r.push(f>>>10&1023|55296),f=56320|1023&f),r.push(f),i+=c}return function(e){var n=e.length;if(n<=A)return String.fromCharCode.apply(String,e);var t="",r=0;for(;r<n;)t+=String.fromCharCode.apply(String,e.slice(r,r+=A));return t}(r)}n.Buffer=l,n.SlowBuffer=function(e){+e!=e&&(e=0);return l.alloc(+e)},n.INSPECT_MAX_BYTES=50,l.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),n.kMaxLength=s(),l.poolSize=8192,l._augment=function(e){return e.__proto__=l.prototype,e},l.from=function(e,n,t){return u(null,e,n,t)},l.TYPED_ARRAY_SUPPORT&&(l.prototype.__proto__=Uint8Array.prototype,l.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&l[Symbol.species]===l&&Object.defineProperty(l,Symbol.species,{value:null,configurable:!0})),l.alloc=function(e,n,t){return function(e,n,t,r){return f(n),n<=0?a(e,n):void 0!==t?"string"==typeof r?a(e,n).fill(t,r):a(e,n).fill(t):a(e,n)}(null,e,n,t)},l.allocUnsafe=function(e){return c(null,e)},l.allocUnsafeSlow=function(e){return c(null,e)},l.isBuffer=function(e){return!(null==e||!e._isBuffer)},l.compare=function(e,n){if(!l.isBuffer(e)||!l.isBuffer(n))throw new TypeError("Arguments must be Buffers");if(e===n)return 0;for(var t=e.length,r=n.length,i=0,o=Math.min(t,r);i<o;++i)if(e[i]!==n[i]){t=e[i],r=n[i];break}return t<r?-1:r<t?1:0},l.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(e,n){if(!o(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);var t;if(void 0===n)for(n=0,t=0;t<e.length;++t)n+=e[t].length;var r=l.allocUnsafe(n),i=0;for(t=0;t<e.length;++t){var s=e[t];if(!l.isBuffer(s))throw new TypeError('"list" argument must be an Array of Buffers');s.copy(r,i),i+=s.length}return r},l.byteLength=d,l.prototype._isBuffer=!0,l.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var n=0;n<e;n+=2)m(this,n,n+1);return this},l.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var n=0;n<e;n+=4)m(this,n,n+3),m(this,n+1,n+2);return this},l.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var n=0;n<e;n+=8)m(this,n,n+7),m(this,n+1,n+6),m(this,n+2,n+5),m(this,n+3,n+4);return this},l.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?S(this,0,e):function(e,n,t){var r=!1;if((void 0===n||n<0)&&(n=0),n>this.length)return"";if((void 0===t||t>this.length)&&(t=this.length),t<=0)return"";if((t>>>=0)<=(n>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return I(this,n,t);case"utf8":case"utf-8":return S(this,n,t);case"ascii":return w(this,n,t);case"latin1":case"binary":return L(this,n,t);case"base64":return z(this,n,t);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return k(this,n,t);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0}}.apply(this,arguments)},l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){var e="",t=n.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,t).match(/.{2}/g).join(" "),this.length>t&&(e+=" ... ")),"<Buffer "+e+">"},l.prototype.compare=function(e,n,t,r,i){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===n&&(n=0),void 0===t&&(t=e?e.length:0),void 0===r&&(r=0),void 0===i&&(i=this.length),n<0||t>e.length||r<0||i>this.length)throw new RangeError("out of range index");if(r>=i&&n>=t)return 0;if(r>=i)return-1;if(n>=t)return 1;if(n>>>=0,t>>>=0,r>>>=0,i>>>=0,this===e)return 0;for(var o=i-r,s=t-n,a=Math.min(o,s),u=this.slice(r,i),f=e.slice(n,t),c=0;c<a;++c)if(u[c]!==f[c]){o=u[c],s=f[c];break}return o<s?-1:s<o?1:0},l.prototype.includes=function(e,n,t){return-1!==this.indexOf(e,n,t)},l.prototype.indexOf=function(e,n,t){return g(this,e,n,t,!0)},l.prototype.lastIndexOf=function(e,n,t){return g(this,e,n,t,!1)},l.prototype.write=function(e,n,t,r){if(void 0===n)r="utf8",t=this.length,n=0;else if(void 0===t&&"string"==typeof n)r=n,t=this.length,n=0;else{if(!isFinite(n))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");n|=0,isFinite(t)?(t|=0,void 0===r&&(r="utf8")):(r=t,t=void 0)}var i=this.length-n;if((void 0===t||t>i)&&(t=i),e.length>0&&(t<0||n<0)||n>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");for(var o=!1;;)switch(r){case"hex":return y(this,e,n,t);case"utf8":case"utf-8":return x(this,e,n,t);case"ascii":return _(this,e,n,t);case"latin1":case"binary":return v(this,e,n,t);case"base64":return E(this,e,n,t);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return T(this,e,n,t);default:if(o)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),o=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var A=4096;function w(e,n,t){var r="";t=Math.min(e.length,t);for(var i=n;i<t;++i)r+=String.fromCharCode(127&e[i]);return r}function L(e,n,t){var r="";t=Math.min(e.length,t);for(var i=n;i<t;++i)r+=String.fromCharCode(e[i]);return r}function I(e,n,t){var r=e.length;(!n||n<0)&&(n=0),(!t||t<0||t>r)&&(t=r);for(var i="",o=n;o<t;++o)i+=P(e[o]);return i}function k(e,n,t){for(var r=e.slice(n,t),i="",o=0;o<r.length;o+=2)i+=String.fromCharCode(r[o]+256*r[o+1]);return i}function M(e,n,t){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+n>t)throw new RangeError("Trying to access beyond buffer length")}function N(e,n,t,r,i,o){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(n>i||n<o)throw new RangeError('"value" argument is out of bounds');if(t+r>e.length)throw new RangeError("Index out of range")}function O(e,n,t,r){n<0&&(n=65535+n+1);for(var i=0,o=Math.min(e.length-t,2);i<o;++i)e[t+i]=(n&255<<8*(r?i:1-i))>>>8*(r?i:1-i)}function R(e,n,t,r){n<0&&(n=4294967295+n+1);for(var i=0,o=Math.min(e.length-t,4);i<o;++i)e[t+i]=n>>>8*(r?i:3-i)&255}function C(e,n,t,r,i,o){if(t+r>e.length)throw new RangeError("Index out of range");if(t<0)throw new RangeError("Index out of range")}function F(e,n,t,r,o){return o||C(e,0,t,4),i.write(e,n,t,r,23,4),t+4}function B(e,n,t,r,o){return o||C(e,0,t,8),i.write(e,n,t,r,52,8),t+8}l.prototype.slice=function(e,n){var t,r=this.length;if(e=~~e,n=void 0===n?r:~~n,e<0?(e+=r)<0&&(e=0):e>r&&(e=r),n<0?(n+=r)<0&&(n=0):n>r&&(n=r),n<e&&(n=e),l.TYPED_ARRAY_SUPPORT)(t=this.subarray(e,n)).__proto__=l.prototype;else{var i=n-e;t=new l(i,void 0);for(var o=0;o<i;++o)t[o]=this[o+e]}return t},l.prototype.readUIntLE=function(e,n,t){e|=0,n|=0,t||M(e,n,this.length);for(var r=this[e],i=1,o=0;++o<n&&(i*=256);)r+=this[e+o]*i;return r},l.prototype.readUIntBE=function(e,n,t){e|=0,n|=0,t||M(e,n,this.length);for(var r=this[e+--n],i=1;n>0&&(i*=256);)r+=this[e+--n]*i;return r},l.prototype.readUInt8=function(e,n){return n||M(e,1,this.length),this[e]},l.prototype.readUInt16LE=function(e,n){return n||M(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUInt16BE=function(e,n){return n||M(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUInt32LE=function(e,n){return n||M(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUInt32BE=function(e,n){return n||M(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readIntLE=function(e,n,t){e|=0,n|=0,t||M(e,n,this.length);for(var r=this[e],i=1,o=0;++o<n&&(i*=256);)r+=this[e+o]*i;return r>=(i*=128)&&(r-=Math.pow(2,8*n)),r},l.prototype.readIntBE=function(e,n,t){e|=0,n|=0,t||M(e,n,this.length);for(var r=n,i=1,o=this[e+--r];r>0&&(i*=256);)o+=this[e+--r]*i;return o>=(i*=128)&&(o-=Math.pow(2,8*n)),o},l.prototype.readInt8=function(e,n){return n||M(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,n){n||M(e,2,this.length);var t=this[e]|this[e+1]<<8;return 32768&t?4294901760|t:t},l.prototype.readInt16BE=function(e,n){n||M(e,2,this.length);var t=this[e+1]|this[e]<<8;return 32768&t?4294901760|t:t},l.prototype.readInt32LE=function(e,n){return n||M(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,n){return n||M(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readFloatLE=function(e,n){return n||M(e,4,this.length),i.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,n){return n||M(e,4,this.length),i.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,n){return n||M(e,8,this.length),i.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,n){return n||M(e,8,this.length),i.read(this,e,!1,52,8)},l.prototype.writeUIntLE=function(e,n,t,r){(e=+e,n|=0,t|=0,r)||N(this,e,n,t,Math.pow(2,8*t)-1,0);var i=1,o=0;for(this[n]=255&e;++o<t&&(i*=256);)this[n+o]=e/i&255;return n+t},l.prototype.writeUIntBE=function(e,n,t,r){(e=+e,n|=0,t|=0,r)||N(this,e,n,t,Math.pow(2,8*t)-1,0);var i=t-1,o=1;for(this[n+i]=255&e;--i>=0&&(o*=256);)this[n+i]=e/o&255;return n+t},l.prototype.writeUInt8=function(e,n,t){return e=+e,n|=0,t||N(this,e,n,1,255,0),l.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[n]=255&e,n+1},l.prototype.writeUInt16LE=function(e,n,t){return e=+e,n|=0,t||N(this,e,n,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[n]=255&e,this[n+1]=e>>>8):O(this,e,n,!0),n+2},l.prototype.writeUInt16BE=function(e,n,t){return e=+e,n|=0,t||N(this,e,n,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[n]=e>>>8,this[n+1]=255&e):O(this,e,n,!1),n+2},l.prototype.writeUInt32LE=function(e,n,t){return e=+e,n|=0,t||N(this,e,n,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[n+3]=e>>>24,this[n+2]=e>>>16,this[n+1]=e>>>8,this[n]=255&e):R(this,e,n,!0),n+4},l.prototype.writeUInt32BE=function(e,n,t){return e=+e,n|=0,t||N(this,e,n,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[n]=e>>>24,this[n+1]=e>>>16,this[n+2]=e>>>8,this[n+3]=255&e):R(this,e,n,!1),n+4},l.prototype.writeIntLE=function(e,n,t,r){if(e=+e,n|=0,!r){var i=Math.pow(2,8*t-1);N(this,e,n,t,i-1,-i)}var o=0,s=1,a=0;for(this[n]=255&e;++o<t&&(s*=256);)e<0&&0===a&&0!==this[n+o-1]&&(a=1),this[n+o]=(e/s>>0)-a&255;return n+t},l.prototype.writeIntBE=function(e,n,t,r){if(e=+e,n|=0,!r){var i=Math.pow(2,8*t-1);N(this,e,n,t,i-1,-i)}var o=t-1,s=1,a=0;for(this[n+o]=255&e;--o>=0&&(s*=256);)e<0&&0===a&&0!==this[n+o+1]&&(a=1),this[n+o]=(e/s>>0)-a&255;return n+t},l.prototype.writeInt8=function(e,n,t){return e=+e,n|=0,t||N(this,e,n,1,127,-128),l.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[n]=255&e,n+1},l.prototype.writeInt16LE=function(e,n,t){return e=+e,n|=0,t||N(this,e,n,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[n]=255&e,this[n+1]=e>>>8):O(this,e,n,!0),n+2},l.prototype.writeInt16BE=function(e,n,t){return e=+e,n|=0,t||N(this,e,n,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[n]=e>>>8,this[n+1]=255&e):O(this,e,n,!1),n+2},l.prototype.writeInt32LE=function(e,n,t){return e=+e,n|=0,t||N(this,e,n,4,2147483647,-2147483648),l.TYPED_ARRAY_SUPPORT?(this[n]=255&e,this[n+1]=e>>>8,this[n+2]=e>>>16,this[n+3]=e>>>24):R(this,e,n,!0),n+4},l.prototype.writeInt32BE=function(e,n,t){return e=+e,n|=0,t||N(this,e,n,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),l.TYPED_ARRAY_SUPPORT?(this[n]=e>>>24,this[n+1]=e>>>16,this[n+2]=e>>>8,this[n+3]=255&e):R(this,e,n,!1),n+4},l.prototype.writeFloatLE=function(e,n,t){return F(this,e,n,!0,t)},l.prototype.writeFloatBE=function(e,n,t){return F(this,e,n,!1,t)},l.prototype.writeDoubleLE=function(e,n,t){return B(this,e,n,!0,t)},l.prototype.writeDoubleBE=function(e,n,t){return B(this,e,n,!1,t)},l.prototype.copy=function(e,n,t,r){if(t||(t=0),r||0===r||(r=this.length),n>=e.length&&(n=e.length),n||(n=0),r>0&&r<t&&(r=t),r===t)return 0;if(0===e.length||0===this.length)return 0;if(n<0)throw new RangeError("targetStart out of bounds");if(t<0||t>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-n<r-t&&(r=e.length-n+t);var i,o=r-t;if(this===e&&t<n&&n<r)for(i=o-1;i>=0;--i)e[i+n]=this[i+t];else if(o<1e3||!l.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)e[i+n]=this[i+t];else Uint8Array.prototype.set.call(e,this.subarray(t,t+o),n);return o},l.prototype.fill=function(e,n,t,r){if("string"==typeof e){if("string"==typeof n?(r=n,n=0,t=this.length):"string"==typeof t&&(r=t,t=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!l.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof e&&(e&=255);if(n<0||this.length<n||this.length<t)throw new RangeError("Out of range index");if(t<=n)return this;var o;if(n>>>=0,t=void 0===t?this.length:t>>>0,e||(e=0),"number"==typeof e)for(o=n;o<t;++o)this[o]=e;else{var s=l.isBuffer(e)?e:D(new l(e,r).toString()),a=s.length;for(o=0;o<t-n;++o)this[o+n]=s[o%a]}return this};var U=/[^+\/0-9A-Za-z-_]/g;function P(e){return e<16?"0"+e.toString(16):e.toString(16)}function D(e,n){var t;n=n||1/0;for(var r=e.length,i=null,o=[],s=0;s<r;++s){if((t=e.charCodeAt(s))>55295&&t<57344){if(!i){if(t>56319){(n-=3)>-1&&o.push(239,191,189);continue}if(s+1===r){(n-=3)>-1&&o.push(239,191,189);continue}i=t;continue}if(t<56320){(n-=3)>-1&&o.push(239,191,189),i=t;continue}t=65536+(i-55296<<10|t-56320)}else i&&(n-=3)>-1&&o.push(239,191,189);if(i=null,t<128){if((n-=1)<0)break;o.push(t)}else if(t<2048){if((n-=2)<0)break;o.push(t>>6|192,63&t|128)}else if(t<65536){if((n-=3)<0)break;o.push(t>>12|224,t>>6&63|128,63&t|128)}else{if(!(t<1114112))throw new Error("Invalid code point");if((n-=4)<0)break;o.push(t>>18|240,t>>12&63|128,t>>6&63|128,63&t|128)}}return o}function j(e){return r.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(U,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function H(e,n,t,r){for(var i=0;i<r&&!(i+t>=n.length||i>=e.length);++i)n[i+t]=e[i];return i}}).call(this,t(1))},function(module,exports,__webpack_require__){(function(process,Buffer){const fs=__webpack_require__(8),path=__webpack_require__(2),os=__webpack_require__(7);var assemblyscript,isDev;function parseArguments(e){const n={};return Object.keys(exports.options).forEach(e=>{const t=exports.options[e];t.aliases&&((n.alias||(n.alias={}))[e]=t.aliases),void 0!==t.default&&((n.default||(n.default={}))[e]=t.default),"string"===t.type?(n.string||(n.string=[])).push(e):"boolean"===t.type&&(n.boolean||(n.boolean=[])).push(e)}),__webpack_require__(4)(e,n)}function checkDiagnostics(e,n){for(var t,r=!1;null!=(t=assemblyscript.nextDiagnostic(e));)n.write(assemblyscript.formatDiagnostic(t,n.isTTY,!0)+os.EOL+os.EOL),assemblyscript.isError(t)&&(r=!0);return r}function createStats(){return{readTime:0,readCount:0,writeTime:0,writeCount:0,parseTime:0,parseCount:0,compileTime:0,compileCount:0,emitTime:0,emitCount:0,validateTime:0,validateCount:0,optimizeTime:0,optimizeCount:0}}function measure(e){const n=process.hrtime();e();const t=process.hrtime(n);return 1e9*t[0]+t[1]}function printStats(e,n){function t(e,n){return e?(e/1e6).toFixed(3)+" ms":"N/A"}(n||process.stdout).write(["I/O Read  : "+t(e.readTime,e.readCount),"I/O Write : "+t(e.writeTime,e.writeCount),"Parse     : "+t(e.parseTime,e.parseCount),"Compile   : "+t(e.compileTime,e.compileCount),"Emit      : "+t(e.emitTime,e.emitCount),"Validate  : "+t(e.validateTime,e.validateCount),"Optimize  : "+t(e.optimizeTime,e.optimizeCount)].join(os.EOL)+os.EOL)}function createMemoryStream(e){var n=[];return n.write=function(n){"string"==typeof n?this.push(Buffer.from(n,"utf8")):this.push(n),e&&e(n)},n.toBuffer=function(){return Buffer.concat(this)},n.toString=function(){return this.toBuffer().toString("utf8")},n}(()=>{try{assemblyscript=__webpack_require__(6),isDev=!1;try{__webpack_require__(!function(){var e=new Error('Cannot find module "source-map-support"');throw e.code="MODULE_NOT_FOUND",e}()).install()}catch(e){}}catch(e){try{__webpack_require__(!function(){var e=new Error('Cannot find module "ts-node"');throw e.code="MODULE_NOT_FOUND",e}()).register({project:path.join(".","..","src","tsconfig.json")}),__webpack_require__(!function(){var e=new Error('Cannot find module "../src/glue/js"');throw e.code="MODULE_NOT_FOUND",e}()),assemblyscript=__webpack_require__(!function(){var e=new Error('Cannot find module "../src"');throw e.code="MODULE_NOT_FOUND",e}()),isDev=!0}catch(e){assemblyscript=eval("require('./assemblyscript')"),isDev=!1}}})(),exports.isBundle=!0,exports.isDev=isDev,exports.version=exports.isBundle?"0.5.0":__webpack_require__(!function(){var e=new Error('Cannot find module "../package.json"');throw e.code="MODULE_NOT_FOUND",e}()).version,exports.options=__webpack_require__(5),exports.sourceMapRoot="assemblyscript:///",exports.libraryPrefix=assemblyscript.LIBRARY_PREFIX,exports.defaultOptimizeLevel=2,exports.defaultShrinkLevel=1,exports.libraryFiles=exports.isBundle?Object({"(lib)/allocator/arena":'/**\n * Arena Memory Allocator\n *\n * Provides a `reset_memory` function to reset the heap to its initial state. A user has to make\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/arena\n *//***/\n\nimport { MASK as AL_MASK } from "./common/alignment";\n\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\nvar offset: usize = startOffset;\n\n@global\nexport function allocate_memory(size: usize): usize {\n  if (!size) return 0;\n  var ptr = offset;\n  var newPtr = (ptr + size + AL_MASK) & ~AL_MASK;\n  var pagesBefore = current_memory();\n  if (newPtr > <usize>pagesBefore << 16) {\n    let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (grow_memory(pagesWanted) < 0) {\n      if (grow_memory(pagesNeeded) < 0) {\n        unreachable(); // out of memory\n      }\n    }\n  }\n  offset = newPtr;\n  return ptr;\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  // nop\n}\n\n@global\nexport function reset_memory(): void {\n  offset = startOffset;\n}\n',"(lib)/allocator/buddy":'/**\n * Buddy Memory Allocator.\n * @module stdd/assembly/allocator/buddy\n *//***/\n\n/*\n  Copyright 2018 Evan Wallace\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the "Software"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in all\n  copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n*/// see: https://github.com/evanw/buddy-malloc\n\n/*\n * This file implements a buddy memory allocator, which is an allocator that\n * allocates memory within a fixed linear address range. It spans the address\n * range with a binary tree that tracks free space. Both "malloc" and "free"\n * are O(log N) time where N is the maximum possible number of allocations.\n *\n * The "buddy" term comes from how the tree is used. When memory is allocated,\n * nodes in the tree are split recursively until a node of the appropriate size\n * is reached. Every split results in two child nodes, each of which is the\n * buddy of the other. When a node is freed, the node and its buddy can be\n * merged again if the buddy is also free. This makes the memory available\n * for larger allocations again.\n */\n\n/*\n * Every allocation needs an 8-byte header to store the allocation size while\n * staying 8-byte aligned. The address returned by "malloc" is the address\n * right after this header (i.e. the size occupies the 8 bytes before the\n * returned address).\n */\nconst HEADER_SIZE: usize = 8;\n\n/*\n * The minimum allocation size is 16 bytes because we have an 8-byte header and\n * we need to stay 8-byte aligned.\n */\nconst MIN_ALLOC_LOG2: usize = 4;\nconst MIN_ALLOC: usize = 1 << MIN_ALLOC_LOG2;\n\n/*\n * The maximum allocation size is currently set to 2gb. This is the total size\n * of the heap. It\'s technically also the maximum allocation size because the\n * heap could consist of a single allocation of this size. But of course real\n * heaps will have multiple allocations, so the real maximum allocation limit\n * is at most 1gb.\n */\nconst MAX_ALLOC_LOG2: usize = 30; // 31;\nconst MAX_ALLOC: usize = 1 << MAX_ALLOC_LOG2;\n\n/*\n * Allocations are done in powers of two starting from MIN_ALLOC and ending at\n * MAX_ALLOC inclusive. Each allocation size has a bucket that stores the free\n * list for that allocation size.\n *\n * Given a bucket index, the size of the allocations in that bucket can be\n * found with "(size_t)1 << (MAX_ALLOC_LOG2 - bucket)".\n */\nconst BUCKET_COUNT: usize = MAX_ALLOC_LOG2 - MIN_ALLOC_LOG2 + 1;\n\n/*\n * Free lists are stored as circular doubly-linked lists. Every possible\n * allocation size has an associated free list that is threaded through all\n * currently free blocks of that size. That means MIN_ALLOC must be at least\n * "sizeof(list_t)". MIN_ALLOC is currently 16 bytes, so this will be true for\n * both 32-bit and 64-bit.\n */\n@unmanaged\nclass List {\n  prev: List;\n  next: List;\n  static readonly SIZE: usize = 2 * sizeof<usize>();\n}\n\n/*\n * Each bucket corresponds to a certain allocation size and stores a free list\n * for that size. The bucket at index 0 corresponds to an allocation size of\n * MAX_ALLOC (i.e. the whole address space).\n */\nvar BUCKETS_START: usize = HEAP_BASE;\nvar BUCKETS_END: usize = BUCKETS_START + BUCKET_COUNT * List.SIZE;\n\nfunction buckets$get(index: usize): List {\n  assert(index < BUCKET_COUNT);\n  return changetype<List>(BUCKETS_START + index * List.SIZE);\n}\n\n/*\n * We could initialize the allocator by giving it one free block the size of\n * the entire address space. However, this would cause us to instantly reserve\n * half of the entire address space on the first allocation, since the first\n * split would store a free list entry at the start of the right child of the\n * root. Instead, we have the tree start out small and grow the size of the\n * tree as we use more memory. The size of the tree is tracked by this value.\n */\nvar bucket_limit: usize;\n\n/*\n * This array represents a linearized binary tree of bits. Every possible\n * allocation larger than MIN_ALLOC has a node in this tree (and therefore a\n * bit in this array).\n *\n * Given the index for a node, lineraized binary trees allow you to traverse to\n * the parent node or the child nodes just by doing simple arithmetic on the\n * index:\n *\n * - Move to parent:         index = (index - 1) / 2;\n * - Move to left child:     index = index * 2 + 1;\n * - Move to right child:    index = index * 2 + 2;\n * - Move to sibling:        index = ((index - 1) ^ 1) + 1;\n *\n * Each node in this tree can be in one of several states:\n *\n * - UNUSED (both children are UNUSED)\n * - SPLIT (one child is UNUSED and the other child isn\'t)\n * - USED (neither children are UNUSED)\n *\n * These states take two bits to store. However, it turns out we have enough\n * information to distinguish between UNUSED and USED from context, so we only\n * need to store SPLIT or not, which only takes a single bit.\n *\n * Note that we don\'t need to store any nodes for allocations of size MIN_ALLOC\n * since we only ever care about parent nodes.\n */\nconst SPLIT_COUNT: usize = (1 << (BUCKET_COUNT - 1)) / 8;\nvar NODE_IS_SPLIT_START: usize = BUCKETS_END;\nvar NODE_IS_SPLIT_END: usize = NODE_IS_SPLIT_START + SPLIT_COUNT * sizeof<u8>();\n\nfunction node_is_split$get(index: usize): i32 {\n  assert(index < SPLIT_COUNT);\n  return load<u8>(NODE_IS_SPLIT_START + index);\n}\n\nfunction node_is_split$set(index: usize, state: i32): void {\n  assert(index < SPLIT_COUNT);\n  store<u8>(NODE_IS_SPLIT_START + index, state);\n}\n\n/*\n * This is the starting address of the address range for this allocator. Every\n * returned allocation will be an offset of this pointer from 0 to MAX_ALLOC.\n */\nvar base_ptr: usize;\n\n/*\n * This is the maximum address that has ever been used by the allocator. It\'s\n * used to know when to call "brk" to request more memory from the kernel.\n */\nvar max_ptr: usize;\n\n/*\n * Make sure all addresses before "new_value" are valid and can be used. Memory\n * is allocated in a 2gb address range but that memory is not reserved up\n * front. It\'s only reserved when it\'s needed by calling this function. This\n * will return false if the memory could not be reserved.\n */\nfunction update_max_ptr(new_value: usize): i32 {\n  if (new_value > max_ptr) {\n    // if (brk(new_value)) {\n    //   return 0;\n    // }\n    let oldPages = <u32>current_memory();\n    let newPages = <u32>(((new_value + 0xffff) & ~0xffff) >> 16);\n    assert(newPages > oldPages);\n    if (grow_memory(newPages - oldPages) < 0) {\n      return 0;\n    }\n    // max_ptr = new_value;\n    max_ptr = <usize>newPages << 16;\n  }\n  return 1;\n}\n\n/*\n * Initialize a list to empty. Because these are circular lists, an "empty"\n * list is an entry where both links point to itself. This makes insertion\n * and removal simpler because they don\'t need any branches.\n */\nfunction list_init(list: List): void {\n  list.prev = list;\n  list.next = list;\n}\n\n/*\n * Append the provided entry to the end of the list. This assumes the entry\n * isn\'t in a list already because it overwrites the linked list pointers.\n */\nfunction list_push(list: List, entry: List): void {\n  var prev = list.prev;\n  entry.prev = prev;\n  entry.next = list;\n  prev.next = entry;\n  list.prev = entry;\n}\n\n/*\n * Remove the provided entry from whichever list it\'s currently in. This\n * assumes that the entry is in a list. You don\'t need to provide the list\n * because the lists are circular, so the list\'s pointers will automatically\n * be updated if the first or last entries are removed.\n */\nfunction list_remove(entry: List): void {\n  var prev = entry.prev;\n  var next = entry.next;\n  prev.next = next;\n  next.prev = prev;\n}\n\n/*\n * Remove and return the first entry in the list or NULL if the list is empty.\n */\nfunction list_pop(list: List): List | null {\n  var back = list.prev;\n  if (back == list) return null;\n  list_remove(back);\n  return back;\n}\n\n/*\n * This maps from the index of a node to the address of memory that node\n * represents. The bucket can be derived from the index using a loop but is\n * required to be provided here since having them means we can avoid the loop\n * and have this function return in constant time.\n */\nfunction ptr_for_node(index: usize, bucket: usize): usize {\n  return base_ptr + ((index - (1 << bucket) + 1) << (MAX_ALLOC_LOG2 - bucket));\n}\n\n/*\n * This maps from an address of memory to the node that represents that\n * address. There are often many nodes that all map to the same address, so\n * the bucket is needed to uniquely identify a node.\n */\nfunction node_for_ptr(ptr: usize, bucket: usize): usize {\n  return ((ptr - base_ptr) >> (MAX_ALLOC_LOG2 - bucket)) + (1 << bucket) - 1;\n}\n\n/*\n * Given the index of a node, this returns the "is split" flag of the parent.\n */\nfunction parent_is_split(index: usize): i32 {\n  index = (index - 1) / 2;\n  return (node_is_split$get(index / 8) >>> <i32>(index % 8)) & 1;\n}\n\n/*\n * Given the index of a node, this flips the "is split" flag of the parent.\n */\nfunction flip_parent_is_split(index: usize): void {\n  index = (index - 1) / 2;\n  var indexDiv8 = index / 8;\n  node_is_split$set(indexDiv8,\n    node_is_split$get(indexDiv8) ^ <i32>(1 << (index % 8))\n  );\n}\n\n/*\n * Given the requested size passed to "malloc", this function returns the index\n * of the smallest bucket that can fit that size.\n */\nfunction bucket_for_request(request: usize): usize {\n  var bucket = BUCKET_COUNT - 1;\n  var size = MIN_ALLOC;\n\n  while (size < request) {\n    bucket--;\n    size *= 2;\n  }\n\n  return bucket;\n}\n\n/*\n * The tree is always rooted at the current bucket limit. This call grows the\n * tree by repeatedly doubling it in size until the root lies at the provided\n * bucket index. Each doubling lowers the bucket limit by 1.\n */\nfunction lower_bucket_limit(bucket: usize): u32 {\n  while (bucket < bucket_limit) {\n    let root = node_for_ptr(base_ptr, bucket_limit);\n    let right_child: usize;\n\n    /*\n     * If the parent isn\'t SPLIT, that means the node at the current bucket\n     * limit is UNUSED and our address space is entirely free. In that case,\n     * clear the root free list, increase the bucket limit, and add a single\n     * block with the newly-expanded address space to the new root free list.\n     */\n    if (!parent_is_split(root)) {\n      list_remove(changetype<List>(base_ptr));\n      list_init(buckets$get(--bucket_limit));\n      list_push(buckets$get(bucket_limit), changetype<List>(base_ptr));\n      continue;\n    }\n\n    /*\n     * Otherwise, the tree is currently in use. Create a parent node for the\n     * current root node in the SPLIT state with a right child on the free\n     * list. Make sure to reserve the memory for the free list entry before\n     * writing to it. Note that we do not need to flip the "is split" flag for\n     * our current parent because it\'s already on (we know because we just\n     * checked it above).\n     */\n    right_child = ptr_for_node(root + 1, bucket_limit);\n    if (!update_max_ptr(right_child + List.SIZE)) {\n      return 0;\n    }\n    list_push(buckets$get(bucket_limit), changetype<List>(right_child));\n    list_init(buckets$get(--bucket_limit));\n\n    /*\n     * Set the grandparent\'s SPLIT flag so if we need to lower the bucket limit\n     * again, we\'ll know that the new root node we just added is in use.\n     */\n    root = (root - 1) / 2;\n    if (root != 0) {\n      flip_parent_is_split(root);\n    }\n  }\n\n  return 1;\n}\n\n@global\nexport function allocate_memory(request: usize): usize {\n  var original_bucket: usize, bucket: usize;\n\n  /*\n   * Make sure it\'s possible for an allocation of this size to succeed. There\'s\n   * a hard-coded limit on the maximum allocation size because of the way this\n   * allocator works.\n   */\n  if (request + HEADER_SIZE > MAX_ALLOC) {\n    return 0;\n  }\n\n  /*\n   * Initialize our global state if this is the first call to "malloc". At the\n   * beginning, the tree has a single node that represents the smallest\n   * possible allocation size. More memory will be reserved later as needed.\n   */\n  if (base_ptr == 0) {\n    // base_ptr = max_ptr = (uint8_t *)sbrk(0);\n    base_ptr = (NODE_IS_SPLIT_END + 7) & ~7; // must be aligned\n    max_ptr = <usize>current_memory() << 16; // must grow first\n    bucket_limit = BUCKET_COUNT - 1;\n    if (!update_max_ptr(base_ptr + List.SIZE)) {\n      return 0;\n    }\n    list_init(buckets$get(BUCKET_COUNT - 1));\n    list_push(buckets$get(BUCKET_COUNT - 1), changetype<List>(base_ptr));\n  }\n\n  /*\n   * Find the smallest bucket that will fit this request. This doesn\'t check\n   * that there\'s space for the request yet.\n   */\n  bucket = bucket_for_request(request + HEADER_SIZE);\n  original_bucket = bucket;\n\n  /*\n   * Search for a bucket with a non-empty free list that\'s as large or larger\n   * than what we need. If there isn\'t an exact match, we\'ll need to split a\n   * larger one to get a match.\n   */\n  while (bucket + 1 != 0) {\n    let size: usize, bytes_needed: usize, i: usize;\n    let ptr: usize;\n\n    /*\n     * We may need to grow the tree to be able to fit an allocation of this\n     * size. Try to grow the tree and stop here if we can\'t.\n     */\n    if (!lower_bucket_limit(bucket)) {\n      return 0;\n    }\n\n    /*\n     * Try to pop a block off the free list for this bucket. If the free list\n     * is empty, we\'re going to have to split a larger block instead.\n     */\n    ptr = changetype<usize>(list_pop(buckets$get(bucket)));\n    if (!ptr) {\n      /*\n       * If we\'re not at the root of the tree or it\'s impossible to grow the\n       * tree any more, continue on to the next bucket.\n       */\n      if (bucket != bucket_limit || bucket == 0) {\n        bucket--;\n        continue;\n      }\n\n      /*\n       * Otherwise, grow the tree one more level and then pop a block off the\n       * free list again. Since we know the root of the tree is used (because\n       * the free list was empty), this will add a parent above this node in\n       * the SPLIT state and then add the new right child node to the free list\n       * for this bucket. Popping the free list will give us this right child.\n       */\n      if (!lower_bucket_limit(bucket - 1)) {\n        return 0;\n      }\n      ptr = changetype<usize>(list_pop(buckets$get(bucket)));\n    }\n\n    /*\n     * Try to expand the address space first before going any further. If we\n     * have run out of space, put this block back on the free list and fail.\n     */\n    size = 1 << (MAX_ALLOC_LOG2 - bucket);\n    bytes_needed = bucket < original_bucket ? size / 2 + List.SIZE : size;\n    if (!update_max_ptr(ptr + bytes_needed)) {\n      list_push(buckets$get(bucket), changetype<List>(ptr));\n      return 0;\n    }\n\n    /*\n     * If we got a node off the free list, change the node from UNUSED to USED.\n     * This involves flipping our parent\'s "is split" bit because that bit is\n     * the exclusive-or of the UNUSED flags of both children, and our UNUSED\n     * flag (which isn\'t ever stored explicitly) has just changed.\n     *\n     * Note that we shouldn\'t ever need to flip the "is split" bit of our\n     * grandparent because we know our buddy is USED so it\'s impossible for our\n     * grandparent to be UNUSED (if our buddy chunk was UNUSED, our parent\n     * wouldn\'t ever have been split in the first place).\n     */\n    i = node_for_ptr(ptr, bucket);\n    if (i != 0) {\n      flip_parent_is_split(i);\n    }\n\n    /*\n     * If the node we got is larger than we need, split it down to the correct\n     * size and put the new unused child nodes on the free list in the\n     * corresponding bucket. This is done by repeatedly moving to the left\n     * child, splitting the parent, and then adding the right child to the free\n     * list.\n     */\n    while (bucket < original_bucket) {\n      i = i * 2 + 1;\n      bucket++;\n      flip_parent_is_split(i);\n      list_push(\n        buckets$get(bucket),\n        changetype<List>(ptr_for_node(i + 1, bucket))\n      );\n    }\n\n    /*\n     * Now that we have a memory address, write the block header (just the size\n     * of the allocation) and return the address immediately after the header.\n     */\n    store<usize>(ptr, request);\n    return ptr + HEADER_SIZE;\n  }\n\n  return 0;\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  var bucket: usize, i: usize;\n\n  /*\n   * Ignore any attempts to free a NULL pointer.\n   */\n  if (!ptr) {\n    return;\n  }\n\n  /*\n   * We were given the address returned by "malloc" so get back to the actual\n   * address of the node by subtracting off the size of the block header. Then\n   * look up the index of the node corresponding to this address.\n   */\n  ptr = ptr - HEADER_SIZE;\n  bucket = bucket_for_request(load<usize>(ptr) + HEADER_SIZE);\n  i = node_for_ptr(ptr, bucket);\n\n  /*\n   * Traverse up to the root node, flipping USED blocks to UNUSED and merging\n   * UNUSED buddies together into a single UNUSED parent.\n   */\n  while (i != 0) {\n    /*\n     * Change this node from UNUSED to USED. This involves flipping our\n     * parent\'s "is split" bit because that bit is the exclusive-or of the\n     * UNUSED flags of both children, and our UNUSED flag (which isn\'t ever\n     * stored explicitly) has just changed.\n     */\n    flip_parent_is_split(i);\n\n    /*\n     * If the parent is now SPLIT, that means our buddy is USED, so don\'t merge\n     * with it. Instead, stop the iteration here and add ourselves to the free\n     * list for our bucket.\n     *\n     * Also stop here if we\'re at the current root node, even if that root node\n     * is now UNUSED. Root nodes don\'t have a buddy so we can\'t merge with one.\n     */\n    if (parent_is_split(i) || bucket == bucket_limit) {\n      break;\n    }\n\n    /*\n     * If we get here, we know our buddy is UNUSED. In this case we should\n     * merge with that buddy and continue traversing up to the root node. We\n     * need to remove the buddy from its free list here but we don\'t need to\n     * add the merged parent to its free list yet. That will be done once after\n     * this loop is finished.\n     */\n    list_remove(changetype<List>(ptr_for_node(((i - 1) ^ 1) + 1, bucket)));\n    i = (i - 1) / 2;\n    bucket--;\n  }\n\n  /*\n   * Add ourselves to the free list for our bucket. We add to the back of the\n   * list because "malloc" takes from the back of the list and we want a "free"\n   * followed by a "malloc" of the same size to ideally use the same address\n   * for better memory locality.\n   */\n  list_push(buckets$get(bucket), changetype<List>(ptr_for_node(i, bucket)));\n}\n\n@global\nexport function reset_memory(): void {\n  unreachable();\n}\n',"(lib)/allocator/common/alignment":"/**\n * Shared alignment constants.\n * @module std/assembly/allocator/common/alignment\n *//***/\n\n/** Number of alignment bits. */\nexport const BITS: u32 = 3;\n\n/** Number of possible alignment values. */\nexport const SIZE: usize = 1 << <usize>BITS;\n\n/** Mask to obtain just the alignment bits. */\nexport const MASK: usize = SIZE - 1;\n","(lib)/allocator/emscripten":"/**\n * Emscripten Memory Allocator.\n *\n * Uses Emscripten's exported _malloc and _free implementations, i.e., when linking with\n * Emscripten-compiled programs that already provide these. Differs from 'system' in that their\n * names are prefixed with an underscore.\n *\n * @module std/assembly/allocator/emscripten\n *//***/\n\ndeclare function _malloc(size: usize): usize;\ndeclare function _free(ptr: usize): void;\n\n@global\nexport function allocate_memory(size: usize): usize {\n  return _malloc(size);\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  _free(ptr);\n}\n\n@global\nexport function reset_memory(): void {\n  unreachable();\n}\n","(lib)/allocator/system":"/**\n * System Memory Allocator.\n *\n * Uses the environment's malloc and free implementations, i.e., when linking with other C-like\n * programs that already provide these.\n *\n * @module std/assembly/allocator/system\n *//***/\n\ndeclare function malloc(size: usize): usize;\ndeclare function free(ptr: usize): void;\n\n@global\nexport function allocate_memory(size: usize): usize {\n  return malloc(size);\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  free(ptr);\n}\n\n@global\nexport function reset_memory(): void {\n  unreachable();\n}\n","(lib)/allocator/tlsf":"/**\n * Two-Level Segregate Fit Memory Allocator.\n *\n * A general purpose dynamic memory allocator specifically designed to meet real-time requirements.\n * Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/tlsf\n *//***/\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─╫─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴─────────╨─────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\nimport {\n  BITS as AL_BITS,\n  SIZE as AL_SIZE,\n  MASK as AL_MASK\n} from \"./common/alignment\";\n\nconst SL_BITS: u32 = 5;\nconst SL_SIZE: usize = 1 << <usize>SL_BITS;\n\nconst SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\nconst SB_SIZE: usize = 1 << <usize>SB_BITS;\n\nconst FL_BITS: u32 = (sizeof<usize>() == sizeof<u32>()\n  ? 30 // ^= up to 1GB per block\n  : 32 // ^= up to 4GB per block\n) - SB_BITS;\n\n// ╒════════════════ Block structure layout (32-bit) ══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤\n// │                          size                             │L│F│ ◄─┐ info\n// ╞═══════════════════════════════════════════════════════════╧═╧═╡   │      ┐\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                ... unused free space >= 0 ...                 │   │    = 0\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤   │\n// │                        if free: jump ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ MIN SIZE ┘\n// F: FREE, L: LEFT_FREE\n\n/** Tag indicating that this block is free. */\nconst FREE: usize = 1 << 0;\n/** Tag indicating that this block's left block is free. */\nconst LEFT_FREE: usize = 1 << 1;\n/** Mask to obtain all tags. */\nconst TAGS: usize = FREE | LEFT_FREE;\n\n/** Block structure. */\n@unmanaged\nclass Block {\n\n  /** Info field holding this block's size and tags. */\n  info: usize;\n\n  /** End offset of the {@link Block#info} field. User data starts here. */\n  static readonly INFO: usize = (sizeof<usize>() + AL_MASK) & ~AL_MASK;\n\n  /** Previous free block, if any. Only valid if free. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free. */\n  next: Block | null;\n\n  /** Minimum size of a block, excluding {@link Block#info}. */\n  static readonly MIN_SIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK;// prev + next + jump\n\n  /** Maximum size of a used block, excluding {@link Block#info}. */\n  static readonly MAX_SIZE: usize = 1 << (FL_BITS + SB_BITS);\n\n  /** Gets this block's left (free) block in memory. */\n  get left(): Block {\n    assert(this.info & LEFT_FREE); // must be free to contain a jump\n    return assert(\n      load<Block>(changetype<usize>(this) - sizeof<usize>())\n    ); // can't be null\n  }\n\n  /** Gets this block's right block in memory. */\n  get right(): Block {\n    assert(this.info & ~TAGS); // can't skip beyond the tail block\n    return assert(\n      changetype<Block>(\n        changetype<usize>(this) + Block.INFO + (this.info & ~TAGS)\n      )\n    ); // can't be null\n  }\n}\n\n// ╒════════════════ Root structure layout (32-bit) ═══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                              ...                              │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[22] P                         │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[736]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                            tailRef                            │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map, P: Possibly padded if 64-bit\n\nassert((1 << SL_BITS) <= 32); // second level must fit into 32 bits\n\n/** Root structure. */\n@unmanaged\nclass Root {\n\n  /** First level bitmap. */\n  flMap: usize = 0;\n\n  /** Start offset of second level maps. */\n  private static readonly SL_START: usize = sizeof<usize>();\n\n  // Using *one* SL map per *FL bit*\n\n  /** Gets the second level map for the specified first level. */\n  getSLMap(fl: usize): u32 {\n    assert(fl < FL_BITS); // fl out of range\n    return load<u32>(changetype<usize>(this) + fl * 4, Root.SL_START);\n  }\n\n  /** Sets the second level map for the specified first level. */\n  setSLMap(fl: usize, value: u32): void {\n    assert(fl < FL_BITS); // fl out of range\n    store<u32>(changetype<usize>(this) + fl * 4, value, Root.SL_START);\n  }\n\n  /** End offset of second level maps. */\n  private static readonly SL_END: usize = Root.SL_START + FL_BITS * 4;\n\n  // Using *number bits per SL* heads per *FL bit*\n\n  /** Start offset of FL/SL heads. */\n  private static readonly HL_START: usize = (Root.SL_END + AL_MASK) & ~AL_MASK;\n\n  /** Gets the head of the specified first and second level index. */\n  getHead(fl: usize, sl: u32): Block | null {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    return changetype<Block>(load<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , Root.HL_START));\n  }\n\n  /** Sets the head of the specified first and second level index. */\n  setHead(fl: usize, sl: u32, value: Block | null): void {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    store<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , changetype<usize>(value)\n    , Root.HL_START);\n  }\n\n  /** End offset of FL/SL heads. */\n  private static readonly HL_END: usize = (\n    Root.HL_START + FL_BITS * SL_SIZE * sizeof<usize>()\n  );\n\n  get tailRef(): usize { return load<usize>(0, Root.HL_END); }\n  set tailRef(value: usize) { store<usize>(0, value, Root.HL_END); }\n\n  /** Total size of the {@link Root} structure. */\n  static readonly SIZE: usize = Root.HL_END + sizeof<usize>();\n\n  /** Inserts a previously used block back into the free list. */\n  insert(block: Block): void {\n    // check as much as possible here to prevent invalid free blocks\n    assert(block); // cannot be null\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size: usize;\n    assert(\n      (size = block.info & ~TAGS) >= Block.MIN_SIZE && size < Block.MAX_SIZE\n    ); // must be valid, not necessary to compute yet if noAssert=true\n\n    var right: Block = assert(block.right); // can't be null\n    var rightInfo = right.info;\n\n    // merge with right block if also free\n    if (rightInfo & FREE) {\n      this.remove(right);\n      block.info = (blockInfo += Block.INFO + (rightInfo & ~TAGS));\n      right = block.right;\n      rightInfo = right.info;\n      // jump is set below\n    }\n\n    // merge with left block if also free\n    if (blockInfo & LEFT_FREE) {\n      let left: Block = assert(block.left); // can't be null\n      let leftInfo = left.info;\n      assert(leftInfo & FREE); // must be free according to tags\n      this.remove(left);\n      left.info = (leftInfo += Block.INFO + (blockInfo & ~TAGS));\n      block = left;\n      blockInfo = leftInfo;\n      // jump is set below\n    }\n\n    right.info = rightInfo | LEFT_FREE;\n    this.setJump(block, right);\n    // right is no longer used now, hence rightInfo is not synced\n\n    size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // perform insertion\n    var head = this.getHead(fl, sl);\n    block.prev = null;\n    block.next = head;\n    if (head) head.prev = block;\n    this.setHead(fl, sl, block);\n\n    // update first and second level maps\n    this.flMap |= (1 << fl);\n    this.setSLMap(fl, this.getSLMap(fl) | (1 << sl));\n  }\n\n  /**\n   * Removes a free block from FL/SL maps. Does not alter left/jump because it\n   * is likely that splitting is performed afterwards, invalidating any changes\n   * again.\n   */\n  private remove(block: Block): void {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // link previous and next free block\n    var prev = block.prev;\n    var next = block.next;\n    if (prev) prev.next = next;\n    if (next) next.prev = prev;\n\n    // update head if we are removing it\n    if (block == this.getHead(fl, sl)) {\n      this.setHead(fl, sl, next);\n\n      // clear second level map if head is empty now\n      if (!next) {\n        let slMap = this.getSLMap(fl);\n        this.setSLMap(fl, slMap &= ~(1 << sl));\n\n        // clear first level map if second level is empty now\n        if (!slMap) this.flMap &= ~(1 << fl);\n      }\n    }\n  }\n\n  /** Searches for a free block of at least the specified size. */\n  search(size: usize): Block | null {\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE);\n\n    // mapping_search\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      // (*) size += (1 << (fls<usize>(size) - SL_BITS)) - 1;\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n      // (*) instead of rounding up, use next second level list for better fit\n      if (sl < SL_SIZE - 1) ++sl;\n      else ++fl, sl = 0;\n    }\n\n    // search second level\n    var slMap = this.getSLMap(fl) & (~0 << sl);\n    var head: Block | null;\n    if (!slMap) {\n      // search next larger first level\n      let flMap = this.flMap & (~0 << (fl + 1));\n      if (!flMap) {\n        head = null;\n      } else {\n        fl = ffs<usize>(flMap);\n        slMap = assert(this.getSLMap(fl)); // can't be zero if fl points here\n        head = this.getHead(fl, ffs<u32>(slMap));\n      }\n    } else {\n      head = this.getHead(fl, ffs<u32>(slMap));\n    }\n    return head;\n  }\n\n  /** Links a free left with its right block in memory. */\n  private setJump(left: Block, right: Block): void {\n    assert(left.info & FREE);       // must be free\n    assert(left.right == right);    // right block must match\n    assert(right.info & LEFT_FREE); // right block must be tagged as LEFT_FREE\n    store<Block>(\n      changetype<usize>(right) - sizeof<usize>()\n    , left); // last word in left block's (free) data region\n  }\n\n  /**\n   * Uses the specified free block, removing it from internal maps and\n   * splitting it if possible, and returns its data pointer.\n   */\n  use(block: Block, size: usize): usize {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free so we can use it\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n    assert(!(size & AL_MASK)); // size must be aligned so the new block is\n\n    this.remove(block);\n\n    // split if the block can hold another MIN_SIZE block\n    var remaining = (blockInfo & ~TAGS) - size;\n    if (remaining >= Block.INFO + Block.MIN_SIZE) {\n      block.info = size | (blockInfo & LEFT_FREE); // also discards FREE\n\n      let spare = changetype<Block>(\n        changetype<usize>(block) + Block.INFO + size\n      );\n      spare.info = (remaining - Block.INFO) | FREE; // not LEFT_FREE\n      this.insert(spare); // also sets jump\n\n    // otherwise tag block as no longer FREE and right as no longer LEFT_FREE\n    } else {\n      block.info = blockInfo & ~FREE;\n      let right: Block = assert(block.right); // can't be null (tail)\n      right.info &= ~LEFT_FREE;\n    }\n\n    return changetype<usize>(block) + Block.INFO;\n  }\n\n  /** Adds more memory to the pool. */\n  addMemory(start: usize, end: usize): bool {\n    assert(start <= end);\n    assert(!(start & AL_MASK)); // must be aligned\n    assert(!(end & AL_MASK)); // must be aligned\n\n    var tailRef = this.tailRef;\n    var tailInfo: usize = 0;\n    if (tailRef) {\n      assert(start >= tailRef + sizeof<usize>()); // starts after tail\n\n      // merge with current tail if adjacent\n      if (start - Block.INFO == tailRef) {\n        start -= Block.INFO;\n        tailInfo = changetype<Block>(tailRef).info;\n      }\n\n    } else {\n      assert(start >= changetype<usize>(this) + Root.SIZE); // starts after root\n    }\n\n    // check if size is large enough for a free block and the tail block\n    var size = end - start;\n    if (size < Block.INFO + Block.MIN_SIZE + Block.INFO) {\n      return false;\n    }\n\n    // left size is total minus its own and the zero-length tail's header\n    var leftSize = size - 2 * Block.INFO;\n    var left = changetype<Block>(start);\n    left.info = leftSize | FREE | (tailInfo & LEFT_FREE);\n    left.prev = null;\n    left.next = null;\n\n    // tail is a zero-length used block\n    var tail = changetype<Block>(start + size - Block.INFO);\n    tail.info = 0 | LEFT_FREE;\n    this.tailRef = changetype<usize>(tail);\n\n    this.insert(left); // also merges with free left before tail / sets jump\n\n    return true;\n  }\n}\n\n/** Determines the first (LSB to MSB) set bit's index of a word. */\nfunction ffs<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  return ctz<T>(word);  // differs from ffs only for 0\n}\n\n/** Determines the last (LSB to MSB) set bit's index of a word. */\nfunction fls<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  const inv: T = (sizeof<T>() << 3) - 1;\n  return inv - clz<T>(word);\n}\n\n/** Reference to the initialized {@link Root} structure, once initialized. */\nvar ROOT: Root = changetype<Root>(0);\n\n// External interface\n\n/** Allocates a chunk of memory. */\n@global\nexport function allocate_memory(size: usize): usize {\n\n  // initialize if necessary\n  var root = ROOT;\n  if (!root) {\n    let rootOffset = (HEAP_BASE + AL_MASK) & ~AL_MASK;\n    ROOT = root = changetype<Root>(rootOffset);\n    root.tailRef = 0;\n    root.flMap = 0;\n    for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n      root.setSLMap(fl, 0);\n      for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n        root.setHead(fl, sl, null);\n      }\n    }\n    root.addMemory((rootOffset + Root.SIZE + AL_MASK) & ~AL_MASK, current_memory() << 16);\n  }\n\n  // search for a suitable block\n  var data: usize = 0;\n  if (size && size < Block.MAX_SIZE) {\n    size = max<usize>((size + AL_MASK) & ~AL_MASK, Block.MIN_SIZE);\n\n    let block = root.search(size);\n    if (!block) {\n\n      // request more memory\n      let pagesBefore = current_memory();\n      let pagesNeeded = ((size + 0xffff) & ~0xffff) >>> 16;\n      let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n      if (grow_memory(pagesWanted) < 0) {\n        if (grow_memory(pagesNeeded) < 0) {\n          unreachable(); // out of memory\n        }\n      }\n      let pagesAfter = current_memory();\n      root.addMemory(<usize>pagesBefore << 16, <usize>pagesAfter << 16);\n      block = assert(root.search(size)); // must be found now\n    }\n\n    assert((block.info & ~TAGS) >= size);\n    data = root.use(block, size);\n  }\n\n  return data;\n}\n\n/** Frees the chunk of memory at the specified address. */\n@global\nexport function free_memory(data: usize): void {\n  if (data) {\n    let root = ROOT;\n    if (root) {\n      let block = changetype<Block>(data - Block.INFO);\n      let blockInfo = block.info;\n      assert(!(blockInfo & FREE)); // must be used\n      block.info = blockInfo | FREE;\n      root.insert(changetype<Block>(data - Block.INFO));\n    }\n  }\n}\n\n@global\nexport function reset_memory(): void {\n  unreachable();\n}\n","(lib)/array":'export class Array<T> {\n\n  private __memory: usize;\n  private __capacity: i32;  // capped to [0, 0x7fffffff]\n  private __length: i32;    // capped to [0, __capacity]\n\n  private __grow(newCapacity: i32): void {\n    assert(newCapacity > this.__capacity);\n    var newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\n    if (this.__memory) {\n      move_memory(newMemory, this.__memory, <usize>this.__capacity * sizeof<T>());\n      free_memory(this.__memory);\n    }\n    this.__memory = newMemory;\n    this.__capacity = newCapacity;\n  }\n\n  constructor(capacity: i32 = 0) {\n    if (capacity < 0) {\n      throw new RangeError("Invalid array length");\n    }\n    this.__memory = capacity\n      ? allocate_memory(<usize>capacity * sizeof<T>())\n      : 0;\n    this.__capacity = this.__length = capacity;\n  }\n\n  get length(): i32 {\n    return this.__length;\n  }\n\n  set length(length: i32) {\n    if (length < 0) {\n      throw new RangeError("Invalid array length");\n    }\n    if (length > this.__capacity) {\n      this.__grow(max(length, this.__capacity << 1));\n    }\n    this.__length = length;\n  }\n\n  @operator("[]")\n  private __get(index: i32): T {\n    if (<u32>index >= <u32>this.__capacity) {\n      throw new Error("Index out of bounds"); // return changetype<T>(0) ?\n    }\n    return load<T>(this.__memory + <usize>index * sizeof<T>());\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: T): void {\n    if (index < 0) {\n      throw new Error("Index out of bounds");\n    }\n    if (index >= this.__capacity) {\n      this.__grow(max(index + 1, this.__capacity << 1));\n    }\n    store<T>(this.__memory + <usize>index * sizeof<T>(), value);\n  }\n\n  includes(searchElement: T, fromIndex: i32 = 0): bool {\n    if (this.__length == 0 || fromIndex >= this.__length) {\n      return false;\n    }\n    if (fromIndex < 0) {\n      fromIndex = this.__length + fromIndex;\n      if (fromIndex < 0) {\n        fromIndex = 0;\n      }\n    }\n    while (<u32>fromIndex < <u32>this.__length) {\n      if (load<T>(this.__memory + <usize>fromIndex * sizeof<T>()) == searchElement) {\n        return true;\n      }\n      ++fromIndex;\n    }\n    return false;\n  }\n\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    if (this.__length == 0 || fromIndex >= this.__length) {\n      return -1;\n    }\n    if (fromIndex < 0) {\n      fromIndex = this.__length + fromIndex;\n      if (fromIndex < 0) {\n        fromIndex = 0;\n      }\n    }\n    while (<u32>fromIndex < <u32>this.__length) {\n      if (load<T>(this.__memory + <usize>fromIndex * sizeof<T>()) == searchElement) {\n        return fromIndex;\n      }\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchElement: T, fromIndex: i32 = this.__length): i32 {\n    if (this.__length == 0) {\n      return -1;\n    }\n    if (fromIndex < 0) {\n      fromIndex = this.__length + fromIndex;\n    } else if (fromIndex >= this.__length) {\n      fromIndex = this.__length - 1;\n    }\n    while (fromIndex >= 0) {\n      if (load<T>(this.__memory + <usize>fromIndex * sizeof<T>()) == searchElement) {\n        return fromIndex;\n      }\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(element: T): i32 {\n    if (this.__length == this.__capacity) {\n      this.__grow(this.__capacity ? this.__capacity << 1 : 1);\n    }\n    store<T>(this.__memory + <usize>this.__length * sizeof<T>(), element);\n    return ++this.__length;\n  }\n\n  pop(): T {\n    if (this.__length < 1) {\n      throw new RangeError("Array is empty"); // return changetype<T>(0) ?\n    }\n    return load<T>(this.__memory + <usize>--this.__length * sizeof<T>());\n  }\n\n  shift(): T {\n    if (this.__length < 1) {\n      throw new RangeError("Array is empty"); // return changetype<T>(0) ?\n    }\n    var element = load<T>(this.__memory);\n    move_memory(\n      this.__memory,\n      this.__memory + sizeof<T>(),\n      <usize>(this.__capacity - 1) * sizeof<T>()\n    );\n    set_memory(\n      this.__memory + <usize>(this.__capacity - 1) * sizeof<T>(),\n      0,\n      sizeof<T>()\n    );\n    --this.__length;\n    return element;\n  }\n\n  unshift(element: T): i32 {\n    var oldCapacity = this.__capacity;\n    if (this.__length == oldCapacity) {\n      // inlined __grow (avoids moving twice)\n      let newCapacity: i32 = oldCapacity ? oldCapacity << 1 : 1;\n      assert(newCapacity > this.__capacity);\n      let newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\n      if (this.__memory) {\n        move_memory(\n          newMemory + sizeof<T>(),\n          this.__memory,\n          <usize>oldCapacity * sizeof<T>()\n        );\n        free_memory(this.__memory);\n      }\n      this.__memory = newMemory;\n      this.__capacity = newCapacity;\n    } else {\n      move_memory(\n        this.__memory + sizeof<T>(),\n        this.__memory,\n        <usize>oldCapacity * sizeof<T>()\n      );\n    }\n    store<T>(this.__memory, element);\n    return ++this.__length;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (begin < 0) {\n      begin = this.__length + begin;\n      if (begin < 0) {\n        begin = 0;\n      }\n    } else if (begin > this.__length) {\n      begin = this.__length;\n    }\n    if (end < 0) {\n      end = this.__length + end;\n    } else if (end > this.__length) {\n      end = this.__length;\n    }\n    if (end < begin) {\n      end = begin;\n    }\n    var capacity = end - begin;\n    assert(capacity >= 0);\n    var sliced = new Array<T>(capacity);\n    if (capacity) {\n      move_memory(\n        sliced.__memory,\n        this.__memory + <usize>begin * sizeof<T>(),\n        <usize>capacity * sizeof<T>()\n      );\n    }\n    return sliced;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): void {\n    if (deleteCount < 1) {\n      return;\n    }\n    if (start < 0) {\n      start = this.__length + start;\n      if (start < 0) {\n        start = 0;\n      } else if (start >= this.__length) {\n        return;\n      }\n    } else if (start >= this.__length) {\n      return;\n    }\n    deleteCount = min(deleteCount, this.__length - start);\n    move_memory(\n      this.__memory + <usize>start * sizeof<T>(),\n      this.__memory + <usize>(start + deleteCount) * sizeof<T>(),\n      <usize>deleteCount * sizeof<T>()\n    );\n    this.__length -= deleteCount;\n  }\n\n  reverse(): Array<T> {\n    for (let front: usize = 0, back: usize = <usize>this.__length - 1; front < back; ++front, --back) {\n      let temp = load<T>(this.__memory + front * sizeof<T>());\n      store<T>(this.__memory + front * sizeof<T>(), load<T>(this.__memory + back * sizeof<T>()));\n      store<T>(this.__memory + back * sizeof<T>(), temp);\n    }\n    return this;\n  }\n}\n\n@unmanaged\n@sealed\nexport class CArray<T> {\n\n  private constructor() {}\n\n  @operator("[]")\n  private __get(index: i32): T {\n    if (index < 0) {\n      throw new RangeError("Index out of range");\n    }\n    return load<T>(changetype<usize>(this) + <usize>index * sizeof<T>());\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: T): void {\n    if (index < 0) {\n      throw new RangeError("Index out of range");\n    }\n    store<T>(changetype<usize>(this) + <usize>index * sizeof<T>(), value);\n  }\n}\n',"(lib)/arraybuffer":'const HEADER_SIZE: usize = sizeof<i32>();\n\n@sealed\nexport class ArrayBuffer {\n\n  readonly byteLength: i32;\n\n  constructor(length: i32) {\n    if (<u32>length > 0x7fffffff) throw new RangeError("Invalid array buffer length");\n    var buffer = allocate_memory(HEADER_SIZE + <usize>length);\n    store<i32>(buffer, length);\n    return changetype<ArrayBuffer>(buffer);\n  }\n\n  slice(begin: i32 = 0, end: i32 = 0x7fffffff): ArrayBuffer {\n    var len = this.byteLength;\n    if (begin < 0) begin = max(len + begin, 0);\n    else begin = min(begin, len);\n    if (end < 0) end = max(len + end, 0);\n    else end = min(end, len);\n    var newLen = max(end - begin, 0);\n    if (newLen) {\n      let buffer = allocate_memory(HEADER_SIZE + <usize>newLen);\n      store<i32>(buffer, newLen);\n      move_memory(buffer + HEADER_SIZE, changetype<usize>(this) + HEADER_SIZE + begin, newLen);\n      return changetype<ArrayBuffer>(buffer);\n    } else if (ArrayBuffer.EMPTY) {\n      return ArrayBuffer.EMPTY;\n    } else {\n      let buffer = allocate_memory(HEADER_SIZE);\n      store<i32>(buffer, 0);\n      ArrayBuffer.EMPTY = changetype<ArrayBuffer>(buffer);\n      return changetype<ArrayBuffer>(buffer);\n    }\n  }\n\n  /** @internal */\n  static EMPTY: ArrayBuffer | null = null;\n}\n',"(lib)/builtins":"export declare function isInteger(value: void): bool;\n\nexport declare function isFloat(value: void): bool;\n\nexport declare function isReference(value: void): bool;\n\nexport declare function isString(value: void): bool;\n\nexport declare function isArray(value: void): bool;\n\nexport declare const NaN: f64; // | f32\n\nexport declare const Infinity: f64; // | f32\n\nexport declare function isNaN<T>(value: T): bool;\n\nexport declare function isFinite<T>(value: T): bool;\n\nexport declare function clz<T>(value: T): T;\n\nexport declare function ctz<T>(value: T): T;\n\nexport declare function popcnt<T>(value: T): T;\n\nexport declare function rotl<T>(value: T, shift: T): T;\n\nexport declare function rotr<T>(value: T, shift: T): T;\n\nexport declare function abs<T>(value: T): T;\n\nexport declare function max<T>(left: T, right: T): T;\n\nexport declare function min<T>(left: T, right: T): T;\n\nexport declare function ceil<T>(value: T): T;\n\nexport declare function floor<T>(value: T): T;\n\nexport declare function copysign<T>(left: T, right: T): T;\n\nexport declare function nearest<T>(value: T): T;\n\nexport declare function reinterpret<T>(value: void): T;\n\nexport declare function sqrt<T>(value: T): T;\n\nexport declare function trunc<T>(value: T): T;\n\nexport declare function load<T>(offset: usize, constantOffset?: usize): T;\n\nexport declare function store<T>(offset: usize, value: void, constantOffset?: usize): T;\n\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\nexport declare function unreachable(): void;\n\nexport declare function current_memory(): i32;\n\nexport declare function grow_memory(pages: i32): i32;\n\n// export declare function move_memory(dest: usize, src: usize: n: usize): void;\n\n// export declare function set_memory(dest: usize, value: u32, n: usize): void;\n\nexport declare function changetype<T>(value: void): T;\n\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\nexport declare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\nexport declare function i8(value: void): i8;\nexport namespace i8 {\n  export const MIN_VALUE: i8 = -128;\n  export const MAX_VALUE: i8 = 127;\n}\n\nexport declare function i16(value: void): i16;\nexport namespace i16 {\n  export const MIN_VALUE: i16 = -32768;\n  export const MAX_VALUE: i16 = 32767;\n}\n\nexport declare function i32(value: void): i32;\nexport namespace i32 {\n  export const MIN_VALUE: i32 = -2147483648;\n  export const MAX_VALUE: i32 = 2147483647;\n}\n\nexport declare function i64(value: void): i64;\nexport namespace i64 {\n  export const MIN_VALUE: i64 = -9223372036854775808;\n  export const MAX_VALUE: i64 = 9223372036854775807;\n}\n\nexport declare function isize(value: void): isize;\nexport namespace isize {\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\nexport declare function u8(value: void): u8;\nexport namespace u8 {\n  export const MIN_VALUE: u8 = 0;\n  export const MAX_VALUE: u8 = 255;\n}\n\nexport declare function u16(value: void): u16;\nexport namespace u16 {\n  export const MIN_VALUE: u16 = 0;\n  export const MAX_VALUE: u16 = 65535;\n}\n\nexport declare function u32(value: void): u32;\nexport namespace u32 {\n  export const MIN_VALUE: u32 = 0;\n  export const MAX_VALUE: u32 = 4294967295;\n}\n\nexport declare function u64(value: void): u64;\nexport namespace u64 {\n  export const MIN_VALUE: u64 = 0;\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\nexport declare function usize(value: void): usize;\nexport namespace usize {\n  export const MIN_VALUE: usize = 0;\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\nexport declare function bool(value: void): bool;\nexport namespace bool {\n  export const MIN_VALUE: bool = false;\n  export const MAX_VALUE: bool = true;\n}\n\nexport declare function f32(value: void): f32;\nexport namespace f32 {\n  export const MIN_VALUE: f32 = -3.40282347e+38;\n  export const MAX_VALUE: f32 = 3.40282347e+38;\n  export const MIN_POSITIVE_VALUE: f32 = 1.175494351e-38;\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n  export const MAX_SAFE_INTEGER: f32 = 16777215;\n  export const EPSILON: f32 = 1.19209290e-07;\n}\n\nexport declare function f64(value: void): f64;\nexport namespace f64 {\n  export const MIN_VALUE: f64 = -1.7976931348623157e+308;\n  export const MAX_VALUE: f64 = 1.7976931348623157e+308;\n  export const MIN_POSITIVE_VALUE: f64 = 2.2250738585072014e-308;\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n  export const MAX_SAFE_INTEGER: f64 = 9007199254740991;\n  export const EPSILON: f64 = 2.2204460492503131e-16;\n}\n\nexport declare const HEAP_BASE: usize;\n\nexport declare function start(): void;\n","(lib)/collector/itcm":'/**\n * @file Incremental Tri-Color-Marking Garbage Collector\n */\n\n// TODO: Generations?\n\nimport { MASK as AL_MASK } from "../allocator/common/alignment";\n\n// ╒════════════════ Object header layout (32-bit) ════════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┤      ┐\n// │                              next                         │ C │ ◄─┐ = nextWithColor\n// ├───────────────────────────────────────────────────────────┴───┤   │ usize\n// │                              prev                             │ ◄─┘\n// ╞═══════════════════════════════════════════════════════════════╡ SIZE ┘\n// │                          ... data ...                         │\n// └───────────────────────────────────────────────────────────────┘\n// C: color\n\n@unmanaged\nclass ObjectHeader {\n\n  /** Pointer to the next object with additional tags stored in the alignment bits. */\n  taggedNext: usize;\n\n  /** Pointer to the previous object. */\n  prev: ObjectHeader;\n\n  /** Visitor function. */\n  visitFn: (obj: ObjectHeader) => void;\n\n  /** Release function. */\n  releaseFn: (obj: ObjectHeader) => void;\n\n  // NOTE that visitFn and releaseFn take 4 bytes each in memory. Storing both doesn\'t matter\n  // because alignment must be retained at 8 bytes anyway.\n\n  static readonly SIZE: usize = (2 * sizeof<usize>() + 2 * sizeof<u32>() + AL_MASK) & ~AL_MASK;\n\n  /** Gets the pointer to the next object in the list. */\n  get next(): ObjectHeader {\n    return changetype<ObjectHeader>(this.taggedNext & ~AL_MASK);\n  }\n\n  /** Sets the pointer to the next object in the list. */\n  set next(obj: ObjectHeader) {\n    this.taggedNext = changetype<usize>(obj) | (this.taggedNext & AL_MASK);\n  }\n\n  /** Inserts an object to this list. */\n  insert(obj: ObjectHeader): void {\n    var prev = this.prev;\n    obj.next = this;\n    obj.prev = prev;\n    prev.next = obj;\n    this.prev = obj;\n  }\n\n  /** Removes this object from its list. */\n  remove(): void {\n    var next = this.next;\n    var prev = this.prev;\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Tests if this object is white, this is unreachable (so far). */\n  get isWhite(): bool {\n    return (this.taggedNext & Color.MASK) == Color.WHITE;\n  }\n\n  /** Marks this object as white, that is unreachable (so far). */\n  makeWhite(): void {\n    this.taggedNext = (this.taggedNext & ~Color.MASK) | Color.WHITE;\n  }\n\n  /** Tests if this object is black, that is reachable. */\n  get isBlack(): bool {\n    return (this.taggedNext & Color.MASK) == Color.BLACK;\n  }\n\n  /** Marks this object as black, that is reachable. */\n  makeBlack(): void {\n    this.taggedNext = (this.taggedNext & ~Color.MASK) | Color.BLACK;\n  }\n\n  /** Tests if this object is gray, that is reachable with unscanned children. */\n  get isGray(): bool {\n    return (this.taggedNext & Color.MASK) == Color.GRAY;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this != iter) {\n      this.remove();\n      to.insert(this);\n    } else {\n      iter = iter.prev;\n    }\n    this.taggedNext = (this.taggedNext & ~Color.MASK) | Color.GRAY;\n  }\n}\n\n/** Object colors. */\nnamespace Color {\n  /** Object is unreachable (so far). */\n  export var WHITE = 0;\n  /** Object is reachable. */\n  export var BLACK = 1;\n  /** Object is reachable but its children have not yet been scanned. */\n  export const GRAY = 2;\n\n  /** Mask to obtain just the color bits. */\n  export const MASK = 3;\n}\n\n/** Collector states. */\nconst enum State {\n  /** Not yet initialized. */\n  INIT = 0,\n  /** Currently transitioning from SWEEP to MARK states. */\n  IDLE = 1,\n  /** Currently marking reachable objects. */\n  MARK = 2,\n  /** Currently sweeping unreachable objects. */\n  SWEEP = 3\n}\n\n/** Current collector state. */\nvar state = State.INIT;\n\n// From and to spaces\n\nvar from: ObjectHeader;\nvar to: ObjectHeader;\nvar iter: ObjectHeader;\n\n/** Performs a single step according to the current state. */\nfunction gc_step(): void {\n  var obj: ObjectHeader;\n  switch (state) {\n    case State.INIT: {\n      from = changetype<ObjectHeader>(allocate_memory(ObjectHeader.SIZE));\n      from.taggedNext = changetype<usize>(from);\n      from.prev = from;\n      to = changetype<ObjectHeader>(allocate_memory(ObjectHeader.SIZE));\n      to.taggedNext = changetype<usize>(to);\n      to.prev = to;\n      iter = to;\n      // fall-through\n    }\n    case State.IDLE: {\n      state = State.MARK;\n      break;\n    }\n    case State.MARK: {\n      obj = iter.next;\n      if (obj != to) {\n        iter = obj;\n        obj.makeBlack();\n        obj.visitFn(obj);\n      } else {\n        obj = iter.next;\n        if (obj == to) {\n          let temp = from;\n          from = to;\n          to = temp;\n          Color.WHITE ^= 1;\n          Color.BLACK ^= 1;\n          iter = from.next;\n          state = State.SWEEP;\n        }\n      }\n      break;\n    }\n    case State.SWEEP: {\n      obj = iter;\n      if (obj != to) {\n        iter = obj.next;\n        obj.releaseFn(obj);\n      } else {\n        to.taggedNext = changetype<usize>(to);\n        to.prev = to;\n        state = State.IDLE;\n      }\n      break;\n    }\n  }\n}\n\n/** Allocates a managed object. */\n@global\nfunction gc_allocate(\n  size: usize,\n  visitFn: (obj: ObjectHeader) => void,\n  releaseFn: (obj: ObjectHeader) => void\n): usize {\n  var obj = changetype<ObjectHeader>(allocate_memory(ObjectHeader.SIZE + size));\n  obj.makeWhite();\n  obj.visitFn = visitFn;\n  obj.releaseFn = releaseFn;\n  from.insert(obj);\n  return changetype<usize>(obj) + ObjectHeader.SIZE;\n}\n\n/** Visits a reachable object. Called from the visitFn functions. */\n@global\nexport function gc_visit(obj: ObjectHeader): void {\n  if (state == State.SWEEP) return;\n  if (obj.isWhite) {\n    obj.makeGray();\n  }\n}\n\n/** Registers a managed child object with its parent object. */\n@global\nexport function gc_register(parent: ObjectHeader, child: ObjectHeader): void {\n  if (parent.isBlack && child.isWhite) {\n    parent.makeGray();\n  }\n}\n\n/** Iterates the root set. Provided by the compiler according to the program. */\n@global\ndeclare function gc_roots(): void;\n\n/** Performs a full garbage collection cycle. */\n@global\nexport function gc_collect(): void {\n  // begin collecting if not yet collecting\n  switch (state) {\n    case State.INIT:\n    case State.IDLE: gc_step();\n  }\n  // finish the cycle\n  while (state != State.IDLE) {\n    gc_step();\n  }\n}\n\ndeclare function allocate_memory(size: usize): usize;\n',"(lib)/error":'export class Error {\n\n  name: string = "Error";\n  message: string;\n  stack: string = ""; // TODO\n\n  constructor(message: string = "") {\n    this.message = message;\n  }\n}\n\nexport class RangeError extends Error {\n  name: string = "RangeError";\n}\n\nexport class TypeError extends Error {\n  name: string = "TypeError";\n}\n',"(lib)/iterator":"// export abstract class Iterator<T> {\n//   abstract get done(): bool;\n//   abstract next(): T;\n// }\n","(lib)/map":"export class Map<K,V> {\n\n  private __keys: K[] = [];\n  private __values: V[] = [];\n\n  // FIXME: not a proper map implementation, just a filler\n\n  get size(): i32 {\n    return this.__keys.length;\n  }\n\n  get(key: K): V | null {\n    var keys = this.__keys;\n    for (let i = 0, k = keys.length; i < k; ++i) {\n      if (keys[i] == key) {\n        return this.__values[i];\n      }\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    var keys = this.__keys;\n    for (let i = 0, k = keys.length; i < k; ++i) {\n      if (keys[i] == key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  set(key: K, value: V): void {\n    this.__keys.push(key);\n    this.__values.push(value);\n  }\n\n  clear(): void {\n    this.__keys.length = 0;\n    this.__values.length = 0;\n  }\n}\n","(lib)/math":"export declare namespace JSMath {\n\n  export const E: f64;\n  export const LN2: f64;\n  export const LN10: f64;\n  export const LOG2E: f64;\n  export const LOG10E: f64;\n  export const PI: f64;\n  export const SQRT1_2: f64;\n  export const SQRT2: f64;\n\n  export function abs(x: f64): f64;\n  export function acos(x: f64): f64;\n  export function acosh(x: f64): f64;\n  export function asin(x: f64): f64;\n  export function asinh(x: f64): f64;\n  export function atan(x: f64): f64;\n  export function atan2(y: f64, x: f64): f64;\n  export function atanh(x: f64): f64;\n  export function cbrt(x: f64): f64;\n  export function ceil(x: f64): f64;\n  export function clz32(x: f64): i32;\n  export function cos(x: f64): f64;\n  export function cosh(x: f64): f64;\n  export function exp(x: f64): f64;\n  export function expm1(x: f64): f64;\n  export function floor(x: f64): f64;\n  export function fround(x: f64): f32;\n  export function hypot(value1: f64, value2: f64): f64; // hypot(...values: f64[]): f64;\n  export function imul(a: f64, b: f64): i32;\n  export function log(x: f64): f64;\n  export function log10(x: f64): f64;\n  export function log1p(x: f64): f64;\n  export function log2(x: f64): f64;\n  export function max(value1: f64, value2: f64): f64; // max(...values: f64[]): f64;\n  export function min(value1: f64, value2: f64): f64; // min(...values: f64[]): f64;\n  export function pow(base: f64, exponent: f64): f64;\n  export function random(): f64;\n  export function round(x: f64): f64;\n  export function sign(x: f64): f64;\n  export function sin(x: f64): f64;\n  export function sinh(x: f64): f64;\n  export function sqrt(x: f64): f64;\n  export function tan(x: f64): f64;\n  export function tanh(x: f64): f64;\n  export function trunc(x: f64): f64;\n}\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  nearest as builtin_nearest,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\nexport namespace Math {\n\n  export const E = 2.7182818284590452354;\n  export const LN2 = 0.69314718055994530942;\n  export const LN10 = 2.30258509299404568402;\n  export const LOG2E = 1.4426950408889634074;\n  export const LOG10E = 0.43429448190325182765;\n  export const PI = 3.14159265358979323846;\n  export const SQRT1_2 = 0.70710678118654752440;\n  export const SQRT2 = 1.41421356237309504880;\n\n  export function abs(x: f64): f64 {\n    return builtin_abs(x);\n  }\n\n  export function ceil(x: f64): f64 {\n    return builtin_ceil(x);\n  }\n\n  export function clz32(x: f64): i32 {\n    return builtin_clz(<i32>x);\n  }\n\n  export function floor(x: f64): f64 {\n    return builtin_floor(x);\n  }\n\n  export function fround(x: f64): f32 {\n    return <f32>x;\n  }\n\n  export function imul(x: f64, y: f64): i32 {\n    return <i32>x * <i32>y;\n  }\n\n  export function log(x: f64): f64 {\n    // based on musl's implementation of log:\n    //   Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n    //   Developed at SunPro, a Sun Microsystems, Inc. business.\n    //   Permission to use, copy, modify, and distribute this\n    //   software is freely granted, provided that this notice\n    //   is preserved.\n    const\n      ln2_hi = 6.93147180369123816490e-01, // 3fe62e42 fee00000\n      ln2_lo = 1.90821492927058770002e-10, // 3dea39ef 35793c76\n      Lg1 = 6.666666666666735130e-01,      // 3FE55555 55555593\n      Lg2 = 3.999999999940941908e-01,      // 3FD99999 9997FA04\n      Lg3 = 2.857142874366239149e-01,      // 3FD24924 94229359\n      Lg4 = 2.222219843214978396e-01,      // 3FCC71C5 1D8E78AF\n      Lg5 = 1.818357216161805012e-01,      // 3FC74664 96CB03DE\n      Lg6 = 1.531383769920937332e-01,      // 3FC39A09 D078C69F\n      Lg7 = 1.479819860511658591e-01;      // 3FC2F112 DF3E5244\n\n    var u = reinterpret<u64>(x);\n    var hfsq: f64, f: f64, s: f64, z: f64, R: f64, w: f64, t1: f64, t2: f64, dk: f64;\n\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx>>31)) {\n      if (u<<1 == 0) {\n        return -1/(x*x);  // log(+-0)=-inf\n      }\n      if (hx>>31) {\n        return (x-x)/0.0; // log(-#) = NaN\n      }\n      // subnormal number, scale x up\n      k -= 54;\n      x *= 1.8014398509481984e16; // 0x1p54\n      u = reinterpret<u64>(x);\n      hx = <u32>(u>>32);\n    } else if (hx >= 0x7ff00000) {\n      return x;\n    } else if (hx == 0x3ff00000 && u<<32 == 0) {\n      return 0;\n    }\n\n    // reduce x into [sqrt(2)/2, sqrt(2)]\n    hx += 0x3ff00000 - 0x3fe6a09e;\n    k += (<i32>hx>>20) - 0x3ff;\n    hx = (hx&0x000fffff) + 0x3fe6a09e;\n    u = <u64>hx<<32 | (u&0xffffffff);\n    x = reinterpret<f64>(u);\n\n    f = x - 1.0;\n    hfsq = 0.5*f*f;\n    s = f/(2.0+f);\n    z = s*s;\n    w = z*z;\n    t1 = w*(Lg2+w*(Lg4+w*Lg6));\n    t2 = z*(Lg1+w*(Lg3+w*(Lg5+w*Lg7)));\n    R = t2 + t1;\n    dk = k;\n    return s*(hfsq+R) + dk*ln2_lo - hfsq + f + dk*ln2_hi;\n  }\n\n  // export function log2(x: f64): f64 {\n  //   return log(x) / LN2;\n  // }\n\n  // export function log10(x: f64): f64 {\n  //   return log(x) / LN10;\n  // }\n\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max(value1, value2);\n  }\n\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min(value1, value2);\n  }\n\n  export function round(x: f64): f64 {\n    return builtin_nearest(x);\n  }\n\n  export function sign(x: f64): f64 {\n    return x > 0 ? 1 : x < 0 ? -1 : x;\n  }\n\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt(x);\n  }\n\n  export function trunc(x: f64): f64 {\n    return builtin_trunc(x);\n  }\n}\n\nexport namespace Mathf {\n\n  export const E = <f32>Math.E;\n  export const LN2 = <f32>Math.LN2;\n  export const LN10 = <f32>Math.LN10;\n  export const LOG2E = <f32>Math.LOG2E;\n  export const LOG10E = <f32>Math.LOG10E;\n  export const PI = <f32>Math.PI;\n  export const SQRT1_2 = <f32>Math.SQRT1_2;\n  export const SQRT2 = <f32>Math.SQRT2;\n\n  export function abs(x: f32): f32 {\n    return builtin_abs(x);\n  }\n\n  export function ceil(x: f32): f32 {\n    return builtin_ceil(x);\n  }\n\n  export function clz32(x: f32): i32 {\n    return builtin_clz(<i32>x);\n  }\n\n  export function floor(x: f32): f32 {\n    return builtin_floor(x);\n  }\n\n  export function imul(x: f32, y: f32): i32 {\n    return <i32>x * <i32>y;\n  }\n\n  export function log(x: f32): f32 {\n    // based on musl's implementaion of logf:\n    //   Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n    //   Developed at SunPro, a Sun Microsystems, Inc. business.\n    //   Permission to use, copy, modify, and distribute this\n    //   software is freely granted, provided that this notice\n    //   is preserved.\n    const\n      ln2_hi: f32 = 6.9313812256e-01, // 0x3f317180\n      ln2_lo: f32 = 9.0580006145e-06, // 0x3717f7d1\n      Lg1: f32 = 0.66666662693,       // 0xaaaaaa.0p-24\n      Lg2: f32 = 0.40000972152,       // 0xccce13.0p-25\n      Lg3: f32 = 0.28498786688,       // 0x91e9ee.0p-25\n      Lg4: f32 = 0.24279078841;       // 0xf89e26.0p-26\n\n    var u = reinterpret<u32>(x);\n    var hfsq: f32, f: f32, s: f32, z: f32, R: f32, w: f32, t1: f32, t2: f32, dk: f32;\n\n    var ix = u;\n    var k = 0;\n    if (ix < 0x00800000 || <bool>(ix>>31)) { // x < 2**-126\n      if (ix<<1 == 0) {\n        return -1/(x*x);     // log(+-0)=-inf\n      }\n      if (ix>>31) {\n        return (x-x)/<f32>0; // log(-#) = NaN\n      }\n      // subnormal number, scale up x\n      k -= 25;\n      x *= 3.3554432; // 0x1p25f;\n      u = reinterpret<u32>(x);\n      ix = u;\n    } else if (ix >= 0x7f800000) {\n      return x;\n    } else if (ix == 0x3f800000) {\n      return 0;\n    }\n\n    // reduce x into [sqrt(2)/2, sqrt(2)]\n    ix += 0x3f800000 - 0x3f3504f3;\n    k += <u32>(<i32>ix>>23) - 0x7f;\n    ix = (ix&0x007fffff) + 0x3f3504f3;\n    x = reinterpret<f32>(ix);\n\n    f = x - 1.0;\n    s = f/(2.0 + f);\n    z = s*s;\n    w = z*z;\n    t1= w*(Lg2+w*Lg4);\n    t2= z*(Lg1+w*Lg3);\n    R = t2 + t1;\n    hfsq = 0.5*f*f;\n    dk = <f32>k;\n    return s*(hfsq+R) + dk*ln2_lo - hfsq + f + dk*ln2_hi;\n  }\n\n  // export function log2(x: f32): f32 {\n  //   return log(x) / LN2;\n  // }\n\n  // export function log10(x: f32): f32 {\n  //   return log(x) / LN10;\n  // }\n\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max(value1, value2);\n  }\n\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min(value1, value2);\n  }\n\n  export function round(x: f32): f32 {\n    return builtin_nearest(x);\n  }\n\n  export function sign(x: f32): f32 {\n    return x > 0 ? 1 : x < 0 ? -1 : x;\n  }\n\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt(x);\n  }\n\n  export function trunc(x: f32): f32 {\n    return builtin_trunc(x);\n  }\n}\n","(lib)/memory":"function copy_memory(dest: usize, src: usize, n: usize): void {\n  // based on musl's implementation of memcpy\n  // not a future instruction and sufficiently covered by the upcoming move_memory intrinsic\n\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\nexport function move_memory(dest: usize, src: usize, n: usize): void {\n  // based on musl's implementation of memmove\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\n\n  if (dest == src) return;\n  if (src + n <= dest || dest + n <= src) {\n    copy_memory(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\nexport function set_memory(dest: usize, c: u8, n: usize): void {\n  // based on musl's implementation of memset\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\n\n  // fill head and tail with minimal branching\n  if (!n) return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2) return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6) return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8) return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = <u32>-1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8) return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24) return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nexport function compare_memory(vl: usize, vr: usize, n: usize): i32 {\n  // based on musl's implementation of memcmp\n  // provided because there's no proposed alternative\n  if (vl == vr) return 0;\n  while (n && load<u8>(vl) == load<u8>(vr)) {\n    n--;\n    vl++;\n    vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n","(lib)/polyfills":"export function bswap<T>(value: T): T {\n  assert(sizeof<T>() == 1 || sizeof<T>() == 2 || sizeof<T>() == 4 || sizeof<T>() == 8);\n\n  if (sizeof<T>() == 2) {\n    return bswap16<T>(value);\n  } else if (sizeof<T>() == 4) {\n    return <T>(\n      rotl<u32>(<u32>value & 0xFF00FF00, 8) |\n      rotr<u32>(<u32>value & 0x00FF00FF, 8)\n    );\n  } else if (sizeof<T>() == 8) {\n    let a: u64 = (<u64>value >> 8) & 0x00FF00FF00FF00FF;\n    let b: u64 = (<u64>value & 0x00FF00FF00FF00FF) << 8;\n    let v: u64 = a | b;\n\n    a = (v >> 16) & 0x0000FFFF0000FFFF;\n    b = (v & 0x0000FFFF0000FFFF) << 16;\n\n    return <T>rotr<u64>(a | b, 32);\n  }\n  return value;\n}\n\nexport function bswap16<T>(value: T): T {\n  assert(sizeof<T>() == 1 || sizeof<T>() == 2 || sizeof<T>() == 4);\n\n  if (sizeof<T>() == 2 || sizeof<T>() == 4) {\n    return <T>(((value << 8) & <T>0xFF00) | ((value >> 8) & <T>0x00FF) | (value & <T>0xFFFF0000));\n  }\n  return value;\n}\n","(lib)/regexp":'export class RegExp {\n\n  // @binding(CALL_NEW, [ STRING, STRING], OBJECT_HANDLE)\n  constructor(pattern: string, flags: string = "") { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [ STRING ], PASS_THRU)\n  test(search: string): bool { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [], STRING)\n  toString(): string { throw new Error("unreachable"); }\n\n}\n',"(lib)/set":'// const prime1: u32 = 73;\n// const prime2: u32 = 5009;\n\nexport class Set<T> {\n\n  private __memory: usize;\n  private __capacity: u32;\n  private __size: u32;\n\n  constructor() {\n    this.__memory = 0;\n    this.__capacity = this.__size = 0;\n  }\n\n  get size(): i32 {\n    return <i32>this.__size;\n  }\n\n  // FIXME: not a proper set implementation, just a filler\n\n  has(value: T): bool {\n    assert(this != null);\n\n    for (let index: usize = 0, limit: usize = this.__size; index < limit; ++index) {\n      if (load<T>(this.__memory + index * sizeof<T>()) == value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  add(value: T): Set<T> {\n    assert(this != null);\n\n    if (this.__size >= this.__capacity) {\n      let newCapacity = max(this.__capacity << 1, 8);\n      let newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\n      if (this.__memory) {\n        move_memory(newMemory, this.__memory, <usize>this.__capacity * sizeof<T>());\n        free_memory(this.__memory);\n      }\n      this.__capacity = newCapacity;\n      this.__memory = newMemory;\n    }\n    store<T>(this.__memory + <usize>this.__size * sizeof<T>(), value);\n    ++this.__size;\n    return this;\n  }\n\n  delete(value: T): bool {\n    assert(this != null);\n\n    for (let index: usize = 0, limit: usize = this.__size; index < limit; ++index) {\n      if (load<T>(this.__memory + index * sizeof<T>()) == value) {\n        if (index + 1 < limit) {\n          move_memory(\n            this.__memory + index * sizeof<T>(),\n            this.__memory + (index + 1) * sizeof<T>(),\n            limit - index - 1\n          );\n        }\n        --this.__size;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  clear(): void {\n    assert(this != null);\n\n    this.__size = 0;\n  }\n\n  // TODO: think about iterators\n}\n\n// class SetIterator<T> extends Iterator<T> {\n\n//   get done(): bool {\n//     throw new Error("not implemented");\n//   }\n\n//   next(): T {\n//     throw new Error("not implemented");\n//   }\n// }\n',"(lib)/string":'// singleton empty string\nconst EMPTY: String = changetype<String>("");\n\n// number of bytes preceeding string data\nconst HEADER_SIZE: usize = 4;\n\nfunction allocate(length: i32): String {\n  assert(length > 0); // 0 -> EMPTY\n  var ptr = allocate_memory(HEADER_SIZE + (<usize>length << 1));\n  store<i32>(ptr, length);\n  return changetype<String>(ptr);\n}\n\n@sealed\nexport class String {\n\n  readonly length: i32; // capped to [0, 0x7fffffff]\n\n  @operator("[]")\n  charAt(pos: i32): String {\n    assert(this != null);\n\n    if (<u32>pos >= <u32>this.length) {\n      return EMPTY;\n    }\n\n    var out = allocate(1);\n    store<u16>(\n      changetype<usize>(out),\n      load<u16>(\n        changetype<usize>(this) + (<usize>pos << 1),\n        HEADER_SIZE\n      ),\n      HEADER_SIZE\n    );\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    assert(this != null);\n    if (<u32>pos >= <u32>this.length) {\n      return -1; // (NaN)\n    }\n    return load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n  }\n\n  codePointAt(pos: i32): i32 {\n    assert(this != null);\n    if (<u32>pos >= <u32>this.length) {\n      return -1; // (undefined)\n    }\n    var first = <i32>load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) {\n      return first;\n    }\n    var second = <i32>load<u16>(\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\n      HEADER_SIZE\n    );\n    if (second < 0xDC00 || second > 0xDFFF) {\n      return first;\n    }\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator("+")\n  private static __concat(left: String, right: String): String {\n    if (!changetype<usize>(left)) left = changetype<String>("null");\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    assert(this != null);\n    if (other == null) other = changetype<String>("null");\n    var thisLen: isize = this.length;\n    var otherLen: isize = other.length;\n    var outLen: usize = thisLen + otherLen;\n    if (outLen == 0) return EMPTY;\n    var out = allocate(outLen);\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE,\n      thisLen << 1\n    );\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE + (thisLen << 1),\n      changetype<usize>(other) + HEADER_SIZE,\n      otherLen << 1\n    );\n    return out;\n  }\n\n  endsWith(searchString: String, endPosition: i32 = 0x7fffffff): bool {\n    assert(this != null);\n    if (searchString == null) {\n      return false;\n    }\n    var end: isize = <isize>min(max(endPosition, 0), this.length);\n    var searchLength: isize = searchString.length;\n    var start: isize = end - searchLength;\n    if (start < 0) {\n      return false;\n    }\n    return !compare_memory(\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\n      changetype<usize>(searchString) + HEADER_SIZE,\n      searchLength << 1\n    );\n  }\n\n  @operator("==")\n  private static __eq(left: String, right: String): bool {\n    if (!changetype<usize>(left)) return !changetype<usize>(right);\n    else if (!changetype<usize>(right)) return false;\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n    return !compare_memory(\n      changetype<usize>(left) + HEADER_SIZE,\n      changetype<usize>(right) + HEADER_SIZE,\n      (<usize>leftLength << 1)\n    );\n  }\n\n  includes(searchString: String, position: i32 = 0): bool {\n    return this.indexOf(searchString, position) != -1;\n  }\n\n  indexOf(searchString: String, position: i32 = 0): i32 {\n    assert(this != null);\n    if (searchString == null) {\n      searchString = changetype<String>("null");\n    }\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start: isize = min<isize>(max<isize>(pos, 0), len);\n    var searchLen: isize = <isize>searchString.length;\n\n    // TODO: two-way, multiple char codes\n    for (let k: usize = start; <isize>k + searchLen <= len; ++k) {\n      if (!compare_memory(\n        changetype<usize>(this) + HEADER_SIZE + (k << 1),\n        changetype<usize>(searchString) + HEADER_SIZE,\n        searchLen << 1)\n      ) {\n        return <i32>k;\n      }\n    }\n    return -1;\n  }\n\n  startsWith(searchString: String, position: i32 = 0): bool {\n    assert(this != null);\n    if (searchString == null) {\n      searchString = changetype<String>("null");\n    }\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start: isize = min<isize>(max<isize>(pos, 0), len);\n    var searchLength: isize = <isize>searchString.length;\n    if (searchLength + start > len) {\n      return false;\n    }\n    return !compare_memory(\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\n      changetype<usize>(searchString) + HEADER_SIZE,\n      searchLength << 1\n    );\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\n    assert(this != null);\n    var intStart: isize = start;\n    var end: isize = length;\n    var size: isize = this.length;\n    if (intStart < 0) {\n      intStart = max<isize>(size + intStart, 0);\n    }\n    var resultLength: isize = min<isize>(max<isize>(end, 0), size - intStart);\n    if (resultLength <= 0) {\n      return EMPTY;\n    }\n    var out = allocate(resultLength);\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + (intStart << 1),\n      <usize>resultLength << 1\n    );\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    assert(this != null);\n    var len = this.length;\n    var finalStart = min<i32>(max<i32>(start, 0), len);\n    var finalEnd = min<i32>(max<i32>(end, 0), len);\n    var from = min<i32>(finalStart, finalEnd);\n    var to = max<i32>(finalStart, finalEnd);\n    len = to - from;\n    if (!len) {\n      return EMPTY;\n    }\n    if (!from && to == this.length) {\n      return this;\n    }\n    var out = allocate(len);\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + (from << 1),\n      len << 1\n    );\n    return out;\n  }\n\n  trim(): String {\n    assert(this != null);\n    var length: usize = this.length;\n    while (\n      length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (length << 1), HEADER_SIZE)\n      )\n    ) {\n      --length;\n    }\n    var start: usize = 0;\n    while (\n      start < length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start, --length;\n    }\n    if (!length) {\n      return EMPTY;\n    }\n    if (!start && length == this.length) {\n      return this;\n    }\n    var out = allocate(length);\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\n      length << 1\n    );\n    return out;\n  }\n\n  trimLeft(): String {\n    assert(this != null);\n    var start: isize = 0;\n    var len: isize = this.length;\n    while (\n      start < len &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start;\n    }\n    if (!start) {\n      return this;\n    }\n    var outLen = len - start;\n    if (!outLen) {\n      return EMPTY;\n    }\n    var out = allocate(outLen);\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\n      outLen << 1\n    );\n    return out;\n  }\n\n  trimRight(): String {\n    assert(this != null);\n    var len: isize = this.length;\n    while (\n      len > 0 &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (len << 1), HEADER_SIZE)\n      )\n    ) {\n      --len;\n    }\n    if (len <= 0) {\n      return EMPTY;\n    }\n    if (<i32>len == this.length) {\n      return this;\n    }\n    var out = allocate(len);\n    move_memory(\n      changetype<usize>(out) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE,\n      len << 1\n    );\n    return out;\n  }\n}\n\nfunction isWhiteSpaceOrLineTerminator(c: u16): bool {\n  switch (c) {\n    case 10:      // <LF>\n    case 13:      // <CR>\n    case 8232:    // <LS>\n    case 8233:    // <PS>\n    case 9:       // <TAB>\n    case 11:      // <VT>\n    case 12:      // <FF>\n    case 32:      // <SP>\n    case 160:     // <NBSP>\n    case 65279: { // <ZWNBSP>\n      return true;\n    }\n    default: return false;\n  }\n}\n\nconst enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function parseInt(str: String, radix: i32 = 0): f64 {\n  return parse<f64>(str, radix);\n}\n\nexport function parseI32(str: String, radix: i32 = 0): i32 {\n  return parse<i32>(str, radix);\n}\n\nexport function parseI64(str: String, radix: i32 = 0): i64 {\n  return parse<i64>(str, radix);\n}\n\nfunction parse<T>(str: String, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len) {\n    return <T>NaN;\n  }\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: T;\n  if (code == CharCode.MINUS) {\n    if (!--len) {\n      return <T>NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) {\n      return <T>NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\n        case CharCode.B:\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.O:\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.X:\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: {\n          radix = 10;\n        }\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    return <T>NaN;\n  }\n\n  // calculate value\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else {\n      break;\n    }\n    if (code >= radix) {\n      break;\n    }\n    num = (num * radix) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n\nexport function parseFloat(str: String): f64 {\n  var len: i32 = str.length;\n  if (!len) {\n    return NaN;\n  }\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: f64;\n  if (code == CharCode.MINUS) {\n    if (!--len) {\n      return NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) {\n      return NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // calculate value\n  var num: f64 = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code == CharCode.DOT) {\n      ptr += 2;\n      let fac: f64 = 0.1; // precision :(\n      while (len--) {\n        code = <i32>load<u16>(ptr, HEADER_SIZE);\n        if (code == CharCode.E || code == CharCode.e) {\n          assert(false); // TODO\n        }\n        code -= CharCode._0;\n        if (<u32>code > 9) {\n          break;\n        }\n        num += <f64>code * fac;\n        fac *= 0.1;\n        ptr += 2;\n      }\n      break;\n    }\n    code -= CharCode._0;\n    if (<u32>code >= 10) {\n      break;\n    }\n    num = (num * 10) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n',"(lib)/typedarray":'class TypedArray<T> {\n\n  readonly buffer: ArrayBuffer;\n  readonly byteOffset: i32;\n  readonly byteLength: i32;\n  get length(): i32 { return this.byteLength / sizeof<T>(); }\n\n  constructor(length: i32) {\n    var byteLength = length * sizeof<T>();\n    this.buffer = new ArrayBuffer(byteLength);\n    this.byteOffset = 0;\n    this.byteLength = byteLength;\n  }\n\n  @operator("[]")\n  private __get(index: i32): T {\n    var offset = this.byteOffset;\n    assert(<u32>index < <u32>this.byteLength / sizeof<T>());\n    return load<T>(changetype<usize>(this.buffer) + (offset + index) * sizeof<T>(), 4);\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: T): void {\n    var offset = this.byteOffset;\n    assert(<u32>index < <u32>(this.byteLength / sizeof<T>()));\n    store<T>(changetype<usize>(this.buffer) + (offset + index) * sizeof<T>(), value, 4);\n  }\n}\n\n// export class Int8Array extends TypedArray<i8> {\n//   static readonly BYTES_PER_ELEMENT: usize = sizeof<i8>();\n//   static readonly name: string = "Int8Array";\n// }\n\n// export class Uint8Array extends TypedArray<u8> {\n//   static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n//   static readonly name: string = "Uint8Array";\n// }\n\n// export class Int16Array extends TypedArray<i16> {\n//   static readonly BYTES_PER_ELEMENT: usize = sizeof<i16>();\n//   static readonly name: string = "Int16Array";\n// }\n\n// export class Uint16Array extends TypedArray<u16> {\n//   static readonly BYTES_PER_ELEMENT: usize = sizeof<u16>();\n//   static readonly name: string = "Uint16Array";\n// }\n\n// export class Int32Array extends TypedArray<i32> {\n//   static readonly BYTES_PER_ELEMENT: usize = sizeof<i32>();\n//   static readonly name: string = "Int32Array";\n// }\n\n// export class Uint32Array extends TypedArray<u32> {\n//   static readonly BYTES_PER_ELEMENT: usize = sizeof<u32>();\n//   static readonly name: string = "Uint32Array";\n// }\n\n// export class Int64Array extends TypedArray<i64> {\n//   static readonly BYTES_PER_ELEMENT: usize = sizeof<i64>();\n//   static readonly name: string = "Int64Array";\n// }\n\n// export class Uint64Array extends TypedArray<u64> {\n//   static readonly BYTES_PER_ELEMENT: usize = sizeof<u64>();\n//   static readonly name: string = "Uint64Array";\n// }\n\n// export class Float32Array extends TypedArray<f32> {\n//   static readonly BYTES_PER_ELEMENT: usize = sizeof<f32>();\n//   static readonly name: string = "Float32Array";\n// }\n\n// export class Float64Array extends TypedArray<f64> {\n//   static readonly BYTES_PER_ELEMENT: usize = sizeof<f64>();\n//   static readonly name: string = "Float64Array";\n// }\n'}):{},exports.definitionFiles=exports.isBundle?Object({assembly:"/**\n * Environment definitions for compiling AssemblyScript to WebAssembly using asc.\n * @module std/assembly\n *//***/\n\n// Types\n\n/** An 8-bit signed integer. */\ndeclare type i8 = number;\n/** A 16-bit signed integer. */\ndeclare type i16 = number;\n/** A 32-bit signed integer. */\ndeclare type i32 = number;\n/** A 64-bit signed integer. */\ndeclare type i64 = number;\n/** A 32-bit signed integer when targeting 32-bit WebAssembly or a 64-bit signed integer when targeting 64-bit WebAssembly. */\ndeclare type isize = number;\n/** An 8-bit unsigned integer. */\ndeclare type u8 = number;\n/** A 16-bit unsigned integer. */\ndeclare type u16 = number;\n/** A 32-bit unsigned integer. */\ndeclare type u32 = number;\n/** A 64-bit unsigned integer. */\ndeclare type u64 = number;\n/** A 32-bit unsigned integer when targeting 32-bit WebAssembly or a 64-bit unsigned integer when targeting 64-bit WebAssembly. */\ndeclare type usize = number;\n/** A 1-bit unsigned integer. */\ndeclare type bool = any; // sic\n/** A 32-bit float. */\ndeclare type f32 = number;\n/** A 64-bit float. */\ndeclare type f64 = number;\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace i8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i8;\n  /** Largest representable value. */\n  export const MAX_VALUE: i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace i16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i16;\n  /** Largest representable value. */\n  export const MAX_VALUE: i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i32;\ndeclare namespace i32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i32;\n  /** Largest representable value. */\n  export const MAX_VALUE: i32;\n}\n/** Converts any other numeric value to a 64-bit signed integer. */\ndeclare function i64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i64;\ndeclare namespace i64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i64;\n  /** Largest representable value. */\n  export const MAX_VALUE: i64;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare function isize(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): isize;\ndeclare namespace isize {\n  /** Smallest representable value. */\n  export const MIN_VALUE: isize;\n  /** Largest representable value. */\n  export const MAX_VALUE: isize;\n}\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace u8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u8;\n  /** Largest representable value. */\n  export const MAX_VALUE: u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace u16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u16;\n  /** Largest representable value. */\n  export const MAX_VALUE: u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i32;\ndeclare namespace u32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u32;\n  /** Largest representable value. */\n  export const MAX_VALUE: u32;\n}\n/** Converts any other numeric value to a 64-bit unsigned integer. */\ndeclare function u64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i64;\ndeclare namespace u64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u64;\n  /** Largest representable value. */\n  export const MAX_VALUE: u64;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare function usize(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): isize;\ndeclare namespace usize {\n  /** Smallest representable value. */\n  export const MIN_VALUE: usize;\n  /** Largesst representable value. */\n  export const MAX_VALUE: usize;\n}\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): bool;\ndeclare namespace bool {\n  /** Smallest representable value. */\n  export const MIN_VALUE: bool;\n  /** Largest representable value. */\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): f32;\ndeclare namespace f32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f32;\n  /** Largest representable value. */\n  export const MAX_VALUE: f32;\n  /** Smallest normalized positive value. */\n  export const MIN_POSITIVE_VALUE: f32;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): f64;\ndeclare namespace f64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f64;\n  /** Largest representable value. */\n  export const MAX_VALUE: f64;\n  /** Smallest normalized positive value. */\n  export const MIN_POSITIVE_VALUE: f64;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n}\n\n// Built-ins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered trailing if the value is zero. */\ndeclare function ctz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit or 64-bit integer. */\ndeclare function popcnt<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic rotate left operation on a 32-bit or 64-bit integer. */\ndeclare function rotl<T = i32 | i64>(value: T, shift: T): T;\n/** Performs the sign-agnostic rotate right operation on a 32-bit or 64-bit integer. */\ndeclare function rotr<T = i32 | i64>(value: T, shift: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | i64 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\ndeclare function copysign<T = f32 | f64>(x: T, y: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\ndeclare function nearest<T = f32 | f64>(value: T): T;\n/** Reinterprets the bits of the specified value as type `T`. Valid reinterpretations are u32/i32 to/from f32 and u64/i64 to/from f64. */\ndeclare function reinterpret<T = i32 | i64 | f32 | f64>(value: number): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Loads a value of the specified type from memory. Equivalent to dereferncing a pointer in other languages. */\ndeclare function load<T>(ptr: usize, constantOffset?: usize): T;\n/** Stores a value of the specified type to memory. Equivalent to dereferencing a pointer in other languages when assigning a value. */\ndeclare function store<T>(ptr: usize, value: any, constantOffset?: usize): void;\n/** Returns the current memory size in units of pages. One page is 64kb. */\ndeclare function current_memory(): i32;\n/** Grows linear memory by a given unsigned delta of pages. One page is 64kb. Returns the previous memory size in units of pages or `-1` on failure. */\ndeclare function grow_memory(value: i32): i32;\n/** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\ndeclare function move_memory(destination: usize, source: usize, n: usize): void;\n/** Sets n bytes beginning at the specified destination in memory to the specified byte value. */\ndeclare function set_memory(destination: usize, value: u8, count: usize): void;\n/** Compares two chunks of memory. Returns `0` if equal, otherwise the difference of the first differing bytes. */\ndeclare function compare_memory(vl: usize, vr: usize, n: usize): i32;\n/** Allocates a chunk of memory of the specified size and returns a pointer to it. */\ndeclare function allocate_memory(size: usize): usize;\n/** Disposes a chunk of memory by its pointer. */\ndeclare function free_memory(ptr: usize): void;\n/** Emits an unreachable operation that results in a runtime error when executed. Both a statement and an expression of any type. */\ndeclare function unreachable(): any; // sic\n\n/** [Polyfill] Performs the sign-agnostic reverse bytes **/\ndeclare function bswap<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | isize | usize>(value: T): T;\n/** [Polyfill] Performs the sign-agnostic reverse bytes only for last 16-bit **/\ndeclare function bswap16<T = i8 | u8 | i16 | u16 | i32 | u32>(value: T): T;\n\n/** NaN (not a number) as a 32-bit or 64-bit float depending on context. */\ndeclare const NaN: f32 | f64;\n/** Positive infinity as a 32-bit or 64-bit float depending on context. */\ndeclare const Infinity: f32 | f64;\n/** Heap base offset. */\ndeclare const HEAP_BASE: usize;\n/** Determines the byte size of the specified core or class type. Compiles to a constant. */\ndeclare function sizeof<T>(): usize;\n/** Determines the offset of the specified field within the given class type. Returns the class type's end offset if field name has been omitted. Compiles to a constant. */\ndeclare function offsetof<T>(fieldName?: string): usize;\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Tests if a 32-bit or 64-bit float is `NaN`. */\ndeclare function isNaN<T = f32 | f64>(value: T): bool;\n/** Tests if a 32-bit or 64-bit float is finite, that is not `NaN` or +/-`Infinity`. */\ndeclare function isFinite<T = f32 | f64>(value: T): bool;\n/** Tests if the specified expression is of an integer type and not a reference. Compiles to a constant. */\ndeclare function isInteger(value: any): value is number;\n/** Tests if the specified expression is of a float type. Compiles to a constant. */\ndeclare function isFloat(value: any): value is number;\n/** Tests if the specified expression is of a reference type. Compiles to a constant. */\ndeclare function isReference(value: any): value is object | string;\n/** Tests if the specified expression can be used ass a string. Compiles to a constant. */\ndeclare function isString(value: any): value is string | String;\n/** Tests if the specified expression can be used as an array. Compiles to a constant. */\ndeclare function isArray(value: any): value is Array<any>;\n/** Traps if the specified value is not true-ish, otherwise returns the (non-nullable) value. */\ndeclare function assert<T>(isTrueish: T, message?: string): T & object; // any better way to model `: T != null`?\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses an integer string to a 32-bit integer. */\ndeclare function parseI32(str: string, radix?: i32): i32;\n/** Parses an integer string to a 64-bit integer. */\ndeclare function parseI64(str: string, radix?: i32): i64;\n/** Parses a string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n\n// Standard library\n\n/** Class representing a generic, fixed-length raw binary data buffer. */\ndeclare class ArrayBuffer {\n  /** The size, in bytes, of the array. */\n  readonly byteLength: i32;\n  /** Constructs a new array buffer of the given length in bytes. */\n  constructor(length: i32);\n  /** Returns a copy of this array buffer's bytes from begin, inclusive, up to end, exclusive. */\n  slice(begin?: i32, end?: i32): ArrayBuffer;\n}\n\n/** Class representing a sequence of values of type `T`. */\ndeclare class Array<T> {\n  [key: number]: T;\n  /** Current length of the array. */\n  length: i32;\n  /** Constructs a new array. */\n  constructor(capacity?: i32);\n  includes(searchElement: T, fromIndex?: i32): bool;\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  push(element: T): void;\n  pop(): T;\n  shift(): T;\n  unshift(element: T): i32;\n  slice(from: i32, to?: i32): T[];\n  splice(start: i32, deleteCount?: i32): void;\n  reverse(): T[];\n}\n\n/** Class representing a C-like array of values of type `T` with limited capabilities. */\ndeclare class CArray<T> {\n  [key: number]: T;\n  private constructor();\n}\n\n/** Class representing a sequence of characters. */\ndeclare class String {\n\n  static fromCharCode(ls: i32, hs?: i32): string;\n  static fromCharCodes(arr: u16[]): string;\n  static fromCodePoint(cp: i32): string;\n  static fromCodePoints(arr: i32[]): string;\n\n  readonly length: u32;\n\n  charAt(index: u32): string;\n  charCodeAt(index: u32): u16;\n  concat(other: string): string;\n  endsWith(other: string): bool;\n  indexOf(other: string): u32;\n  includes(other: string): bool;\n  startsWith(other: string): bool;\n  substr(start: u32, length?: u32): string;\n  substring(start: u32, end?: u32): string;\n  trim(): string;\n  trimLeft(): string;\n  trimRight(): string;\n}\n\n/** Class for representing a runtime error. Base class of all errors. */\ndeclare class Error {\n\n  /** Error name. */\n  name: string;\n\n  /** Message provided on construction. */\n  message: string;\n\n  /** Stack trace. */\n  stack: string;\n\n  /** Constructs a new error, optionally with a message. */\n  constructor(message?: string);\n}\n\n/** Class for indicating an error when a value is not in the set or range of allowed values. */\ndeclare class RangeError extends Error { }\n\ninterface Boolean {}\ninterface Function {}\ninterface IArguments {}\ninterface Number {}\ninterface Object {}\ninterface RegExp {}\n\ndeclare class Set<T> {\n  readonly size: i32;\n  has(value: T): bool;\n  add(value: T): void;\n  delete(value: T): bool;\n  clear(): void;\n}\n\ndeclare namespace JSMath {\n  export const E: f64;\n  export const LN2: f64;\n  export const LN10: f64;\n  export const LOG2E: f64;\n  export const LOG10E: f64;\n  export const PI: f64;\n  export const SQRT1_2: f64;\n  export const SQRT2: f64;\n  export function abs(x: f64): f64;\n  export function acos(x: f64): f64;\n  export function acosh(x: f64): f64;\n  export function asin(x: f64): f64;\n  export function asinh(x: f64): f64;\n  export function atan(x: f64): f64;\n  export function atan2(y: f64, x: f64): f64;\n  export function atanh(x: f64): f64;\n  export function cbrt(x: f64): f64;\n  export function ceil(x: f64): f64;\n  export function clz32(x: f64): i32;\n  export function cos(x: f64): f64;\n  export function cosh(x: f64): f64;\n  export function exp(x: f64): f64;\n  export function expm1(x: f64): f64;\n  export function floor(x: f64): f64;\n  export function fround(x: f64): f32;\n  export function hypot(value1: f64, value2: f64): f64; // TODO: see std/math\n  export function imul(a: f64, b: f64): i32;\n  export function log(x: f64): f64;\n  export function log10(x: f64): f64;\n  export function log1p(x: f64): f64;\n  export function log2(x: f64): f64;\n  export function max(value1: f64, value2: f64): f64; // TODO: see std/math\n  export function min(value1: f64, value2: f64): f64; // TODO: see std/math\n  export function pow(base: f64, exponent: f64): f64;\n  export function random(): f64;\n  export function round(x: f64): f64;\n  export function sign(x: f64): f64;\n  export function sin(x: f64): f64;\n  export function sinh(x: f64): f64;\n  export function sqrt(x: f64): f64;\n  export function tan(x: f64): f64;\n  export function tanh(x: f64): f64;\n  export function trunc(x: f64): f64;\n}\n\ndeclare namespace Math {\n  export const E: f64;\n  export const LN2: f64;\n  export const LN10: f64;\n  export const LOG2E: f64;\n  export const LOG10E: f64;\n  export const PI: f64;\n  export const SQRT1_2: f64;\n  export const SQRT2: f64;\n  export function abs(x: f64): f64;\n  export function ceil(x: f64): f64;\n  export function clz32(x: f64): i32;\n  export function floor(x: f64): f64;\n  export function fround(x: f64): f32;\n  export function imul(a: f64, b: f64): i32;\n  export function log(x: f64): f64;\n  export function max(value1: f64, value2: f64): f64; // TODO: see std/math\n  export function min(value1: f64, value2: f64): f64; // TODO: see std/math\n  export function round(x: f64): f64;\n  export function sign(x: f64): f64;\n  export function sqrt(x: f64): f64;\n  export function trunc(x: f64): f64;\n}\n\ndeclare namespace Mathf {\n  export const E: f32;\n  export const LN2: f32;\n  export const LN10: f32;\n  export const LOG2E: f32;\n  export const LOG10E: f32;\n  export const PI: f32;\n  export const SQRT1_2: f32;\n  export const SQRT2: f32;\n  export function abs(x: f32): f32;\n  export function ceil(x: f32): f32;\n  export function clz32(x: f32): i32;\n  export function floor(x: f32): f32;\n  export function imul(a: f32, b: f32): i32;\n  export function log(x: f32): f32;\n  export function max(value1: f32, value2: f32): f32; // TODO: see std/math\n  export function min(value1: f32, value2: f32): f32; // TODO: see std/math\n  export function round(x: f32): f32;\n  export function sign(x: f32): f32;\n  export function sqrt(x: f32): f32;\n  export function trunc(x: f32): f32;\n}\n\n// Internal decorators\n\n/** Annotates an element as a program global. */\ndeclare function global(target: Function, propertyKey: string, descriptor: any): void;\n\n/** Annotates a method as an operator overload. */\ndeclare function operator(token: string): (target: any, propertyKey: string, descriptor: any) => void;\n\n/** Annotates a class as being unmanaged with limited capabilities. */\ndeclare function unmanaged(target: Function): any;\n\n/** Annotates a class as being sealed / non-derivable. */\ndeclare function sealed(target: Function): any;\n\n/** Annotates a class field with an explicit offset. */\ndeclare function offset(offset: usize): any;\n",portable:"/**\n * Environment definitions for compiling AssemblyScript to JavaScript using tsc.\n *\n * Note that semantic differences require additional explicit conversions for full compatibility.\n * For example, when casting an i32 to an u8, doing `<u8>(someI32 & 0xff)` will yield the same\n * result when compiling to WebAssembly or JS while `<u8>someI32` alone does nothing in JS.\n *\n * Note that i64's are not portable (JS numbers are IEEE754 doubles with a maximum safe integer\n * value of 2^53-1) and instead require a compatibility layer to work in JS as well, as for example\n * {@link glue/js/i64} respectively {@link glue/wasm/i64}.\n *\n * @module std/portable\n *//***/\n\n// Portable types\n\ndeclare type i8 = number;\ndeclare type i16 = number;\ndeclare type i32 = number;\ndeclare type isize = number;\ndeclare type u8 = number;\ndeclare type u16 = number;\ndeclare type u32 = number;\ndeclare type bool = boolean;\ndeclare type usize = number;\ndeclare type f32 = number;\ndeclare type f64 = number;\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace i8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i8;\n  /** Largest representable value. */\n  export const MAX_VALUE: i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace i16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i16;\n  /** Largest representable value. */\n  export const MAX_VALUE: i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i32;\ndeclare namespace i32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: i32;\n  /** Largest representable value. */\n  export const MAX_VALUE: i32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare function isize(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): isize;\ndeclare namespace isize {\n  /** Smallest representable value. */\n  export const MIN_VALUE: isize;\n  /** Largest representable value. */\n  export const MAX_VALUE: isize;\n}\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace u8 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u8;\n  /** Largest representable value. */\n  export const MAX_VALUE: u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace u16 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u16;\n  /** Largest representable value. */\n  export const MAX_VALUE: u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i32;\ndeclare namespace u32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: u32;\n  /** Largest representable value. */\n  export const MAX_VALUE: u32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare function usize(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): isize;\ndeclare namespace usize {\n  /** Smallest representable value. */\n  export const MIN_VALUE: usize;\n  /** Largest representable value. */\n  export const MAX_VALUE: usize;\n}\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): bool;\ndeclare namespace bool {\n  /** Smallest representable value. */\n  export const MIN_VALUE: bool;\n  /** Largest representable value. */\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): f32;\ndeclare namespace f32 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f32;\n  /** Largest representable value. */\n  export const MAX_VALUE: f32;\n  /** Smallest normalized positive value. */\n  export const MIN_POSITIVE_VALUE: f32;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): f64;\ndeclare namespace f64 {\n  /** Smallest representable value. */\n  export const MIN_VALUE: f64;\n  /** Largest representable value. */\n  export const MAX_VALUE: f64;\n  /** Smallest normalized positive value. */\n  export const MIN_POSITIVE_VALUE: f64;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n}\n\n// Portable built-ins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32>(value: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Allocates a chunk of memory of the specified size and returns a pointer to it. */\ndeclare function allocate_memory(size: usize): usize;\n/** Disposes a chunk of memory by its pointer. */\ndeclare function free_memory(ptr: usize): void;\n/** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\ndeclare function move_memory(destination: usize, source: usize, n: usize): void;\n/** Loads a value of the specified type from memory. Type must be `u8`. */\ndeclare function load<T = u8>(ptr: usize, constantOffset?: usize): T;\n/** Stores a value of the specified type to memory. Type must be `u8`. */\ndeclare function store<T = u8>(ptr: usize, value: T, constantOffset?: usize): void;\n/** Emits an unreachable operation that results in a runtime error when executed. */\ndeclare function unreachable(): any; // sic\n\n/** [Polyfill] Performs the sign-agnostic reverse bytes **/\ndeclare function bswap<T = i32 | u32 | isize | usize>(value: T): T;\n/** [Polyfill] Performs the sign-agnostic reverse bytes only for last 16-bit **/\ndeclare function bswap16<T = i16 | u16 | i32 | u32>(value: T): T;\n\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Tests if a 32-bit or 64-bit float is `NaN`. */\ndeclare function isNaN<T = f32 | f64>(value: T): bool;\n/** Tests if a 32-bit or 64-bit float is finite, that is not `NaN` or +/-`Infinity`. */\ndeclare function isFinite<T = f32 | f64>(value: T): bool;\n/** Tests if the specified value is a valid integer. Can't distinguish an integer from an integral float. */\ndeclare function isInteger(value: any): value is number;\n/** Tests if the specified value is a valid float. Can't distinguish a float from an integer. */\ndeclare function isFloat(value: any): value is number;\n/** Tests if the specified value is of a reference type. */\ndeclare function isReference(value: any): value is object | string;\n/** Tests if the specified value can be used as a string. */\ndeclare function isString(value: any): value is string | String;\n/** Tests if the specified value can be used as an array. */\ndeclare function isArray(value: any): value is Array<any>;\n/** Traps if the specified value is not true-ish, otherwise returns the value. */\ndeclare function assert<T>(isTrueish: T | null, message?: string): T;\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses an integer string to a 32-bit integer. */\ndeclare function parseI32(str: string, radix?: i32): i32;\n/** Parses a floating point string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n\n// Portable standard library\n// Everything marked @deprecated is a temporary filler. Do not use.\n\ndeclare const NaN: f32 | f64;\ndeclare const Infinity: f32 | f64;\n\n/** Class representing a generic, fixed-length raw binary data buffer. */\ndeclare class ArrayBuffer {\n  /** The size, in bytes, of the array. */\n  readonly byteLength: i32;\n  /** Constructs a new array buffer of the given length in bytes. */\n  constructor(length: i32);\n  /** Returns a copy of this array buffer's bytes from begin, inclusive, up to end, exclusive. */\n  slice(begin?: i32, end?: i32): ArrayBuffer;\n}\n\ndeclare class Array<T> {\n  [key: number]: T;\n  length: i32;\n  constructor(capacity?: i32);\n  includes(searchElement: T, fromIndex?: i32): bool;\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  push(element: T): void;\n  pop(): T;\n  shift(): T;\n  unshift(element: T): i32;\n  slice(from: i32, to?: i32): T[];\n  splice(start: i32, deleteCount?: i32): void;\n  reverse(): T[];\n\n  join(delim: string): string;\n}\n\ndeclare class Uint8Array extends Array<u8> {}\ndeclare class Uint16Array extends Array<u16> {}\ndeclare class Uint32Array extends Array<u32> {}\ndeclare class Int8Array extends Array<i8> {}\ndeclare class Int16Array extends Array<i16> {}\ndeclare class Int32Array extends Array<i32> {}\ndeclare class Float32Array extends Array<f32> {}\ndeclare class Float64Array extends Array<f64> {}\n\ndeclare class String {\n  static fromCharCode(ls: i32, hs?: i32): string;\n  static fromCharCodes(arr: u16[]): string;\n  static fromCodePoint(cp: i32): string;\n  static fromCodePoints(arr: i32[]): string;\n  readonly length: i32;\n  private constructor();\n  indexOf(subject: string, position?: i32): i32;\n  includes(other: string): bool;\n  lastIndexOf(subject: string, position?: i32): i32;\n  charAt(index: i32): string;\n  charCodeAt(index: i32): i32;\n  substring(from: i32, to?: i32): string;\n  startsWith(subject: string): bool;\n  endsWith(subject: string): bool;\n  replace(search: string, replacement: string): string;\n  toString(): string;\n}\n\ninterface Boolean {}\n\ndeclare class Number {\n  private constructor();\n  toString(radix?: i32): string;\n}\n\ninterface Object {}\n\ninterface Function {}\n\ninterface RegExp {}\n\ninterface IArguments {}\n\ndeclare class Error {\n  constructor(message: string);\n  message: string;\n  stack: string | null;\n}\n\ndeclare class Symbol {\n  private constructor();\n  static readonly iterator: symbol;\n}\n\ndeclare class Set<T> {\n  constructor(entries?: T[]);\n  has(value: T): bool;\n  add(value: T): void;\n  delete(value: T): bool;\n  clear(): void;\n  [Symbol.iterator](): Iterator<T>;\n}\n\ndeclare class Map<K,V> {\n  constructor(entries?: [K, V][]);\n  readonly size: i32;\n  set(key: K, value: V): void;\n  has(key: K): bool;\n  get(key: K): V | null;\n  clear(): void;\n  entries(): Iterable<[K, V]>;\n  keys(): Iterable<K>;\n  values(): Iterable<V>;\n  [Symbol.iterator](): Iterator<[K,V]>;\n}\n\ninterface Iterable<T> {\n  [Symbol.iterator](): Iterator<T>;\n}\n\ninterface Iterator<T> {}\n\ndeclare namespace Math {\n  export const E: f64;\n  export const LN2: f64;\n  export const LN10: f64;\n  export const LOG2E: f64;\n  export const LOG10E: f64;\n  export const PI: f64;\n  export const SQRT1_2: f64;\n  export const SQRT2: f64;\n  export function abs(x: f64): f64;\n  export function acos(x: f64): f64;\n  export function acosh(x: f64): f64;\n  export function asin(x: f64): f64;\n  export function asinh(x: f64): f64;\n  export function atan(x: f64): f64;\n  export function atan2(y: f64, x: f64): f64;\n  export function atanh(x: f64): f64;\n  export function cbrt(x: f64): f64;\n  export function ceil(x: f64): f64;\n  export function clz32(x: f64): i32;\n  export function cos(x: f64): f64;\n  export function cosh(x: f64): f64;\n  export function exp(x: f64): f64;\n  export function expm1(x: f64): f64;\n  export function floor(x: f64): f64;\n  export function fround(x: f64): f32;\n  export function hypot(value1: f64, value2: f64): f64; // TODO: see std/math\n  export function imul(a: f64, b: f64): i32;\n  export function log(x: f64): f64;\n  export function log10(x: f64): f64;\n  export function log1p(x: f64): f64;\n  export function log2(x: f64): f64;\n  export function max(value1: f64, value2: f64): f64; // TODO: see std/math\n  export function min(value1: f64, value2: f64): f64; // TODO: see std/math\n  export function pow(base: f64, exponent: f64): f64;\n  export function random(): f64;\n  export function round(x: f64): f64;\n  export function sign(x: f64): f64;\n  export function sin(x: f64): f64;\n  export function sinh(x: f64): f64;\n  export function sqrt(x: f64): f64;\n  export function tan(x: f64): f64;\n  export function tanh(x: f64): f64;\n  export function trunc(x: f64): f64;\n}\n\ndeclare namespace console {\n  /** @deprecated */\n  function log(message: string): void;\n}\n"}):{},exports.compileString=((e,n={})=>new Promise((t,r)=>{const i={},o={};"string"==typeof e&&(i["input.ts"]=e),Object.keys(i).forEach(e=>{i[`/${e}`]=i[e],delete i[e]});const s={stdout:createMemoryStream(),stderr:createMemoryStream(),readFile:e=>i[e],writeFile:(e,n)=>o[e.replace(/^\//,"")]=n,listFiles:Function.prototype};if(!exports.isBundle){const e=path.join(".","../std","assembly");__webpack_require__(!function(){var e=new Error('Cannot find module "glob"');throw e.code="MODULE_NOT_FOUND",e}()).sync("**/*.ts",{cwd:e}).forEach(n=>exports.libraryFiles["(lib)/"+n.replace(/\.ts$/,"")]=readFileNode(path.join(e,n),{encoding:"utf8"}))}const a=["--baseDir=/","--binaryFile=wasm","--textFile=wast",...Object.keys(n).map(e=>`--${e}=${n[e]}`),...Object.keys(i)];exports.main(a,s,e=>{e?r({err:e,stdout:s.stdout.toString(),stderr:s.stderr.toString()}):t(Object.assign(o,{stdout:s.stdout.toString(),stderr:s.stderr.toString()}))})})),exports.main=function(e,n,t){"function"==typeof n?(t=n,n={}):n||(n={});const r=n.stdout||process.stdout,i=n.stderr||process.stderr,o=n.readFile||E,s=n.writeFile||T,a=n.listFiles||z,l=n.stats||createStats();if(!r)throw Error("'options.stdout' must be specified");if(!i)throw Error("'options.stderr' must be specified");if(!fs.readFileSync){if(o===E)throw Error("'options.readFile' must be specified");if(s===T)throw Error("'options.writeFile' must be specified");if(a===z)throw Error("'options.listFiles' must be specified")}const u=parseArguments(e);if(t||(t=function(e){var n=0;return e&&(i.write(e.stack+os.EOL),n=1),n}),u.version)return r.write("Version "+exports.version+(isDev?"-dev":"")+os.EOL),t(null);if(u.help||u._.length<1){const e=[];return Object.keys(exports.options).forEach(n=>{var t=exports.options[n],r=" ";for(r+="--"+n,t.aliases&&1===t.aliases[0].length&&(r+=", -"+t.aliases[0]);r.length<24;)r+=" ";Array.isArray(t.desc)?e.push(r+t.desc[0]+t.desc.slice(1).map(e=>{for(let n=0;n<24;++n)e=" "+e;return os.EOL+e}).join("")):e.push(r+t.desc)}),(u.help?r:i).write(["Version "+exports.version+(isDev?"-dev":""),"Syntax:   asc [entryFile ...] [options]","","Examples: asc hello.ts","          asc hello.ts -b hello.wasm -t hello.wat","          asc hello1.ts hello2.ts -b -O > hello.wasm","","Options:"].concat(e).join(os.EOL)+os.EOL),t(null)}const f=u.baseDir?path.resolve(u.baseDir):process.cwd(),c=path.join(".","..","std","assembly"),p=u.noLib?[]:[c];u.lib&&("string"==typeof u.lib&&(u.lib=u.lib.split(",")),Array.prototype.push.apply(p,u.lib.map(e=>e.trim())));var h=null;for(let e=0,n=u._.length;e<n;++e){let n=u._[e].replace(/\\/g,"/").replace(/(\.ts|\/)$/,""),r=o(path.join(f,n)+".ts");if(null===r){if(null===(r=o(path.join(f,n,"index.ts"))))return t(Error("Entry file '"+n+".ts' not found."));n+="/index.ts"}else n+=".ts";for(l.parseCount++,l.parseTime+=measure(()=>{h=assemblyscript.parseFile(r,n,!0,h)});null!=(n=h.nextFile());){if(n.startsWith(exports.libraryPrefix)){for(let e=0,t=p.length;e<t;++e)if(exports.libraryFiles.hasOwnProperty(n))r=exports.libraryFiles[n],n+=".ts";else if(null!==(r=o(path.join(p[e],n.substring(exports.libraryPrefix.length)+".ts")))){n+=".ts";break}}else if(null!==(r=o(path.join(f,n+".ts"))))n+=".ts";else if(null!==(r=o(path.join(f,n,"index.ts"))))n+="/index.ts";else{const e=exports.libraryPrefix+n;if(exports.libraryFiles.hasOwnProperty(e))r=exports.libraryFiles[e],n=e+".ts";else{for(let e=0,t=p.length;e<t;++e){const t=p[e];if(null!==(r=o(path.join(t,n+".ts")))){n=exports.libraryPrefix+n+".ts";break}}if(null===r)return t(Error("Import file '"+n+".ts' not found."))}}l.parseCount++,l.parseTime+=measure(()=>{assemblyscript.parseFile(r,n,!1,h)})}if(checkDiagnostics(h,i))return t(Error("Parse error"))}var d=!1;u.noLib||Object.keys(exports.libraryFiles).forEach(e=>{e.lastIndexOf("/")>=exports.libraryPrefix.length||(l.parseCount++,l.parseTime+=measure(()=>{h=assemblyscript.parseFile(exports.libraryFiles[e],e+".ts",!1,h)}),d=!0)});for(let e=0,n=p.length;e<n;++e){if(0===e&&d)continue;let n,r=p[e];r.endsWith(".ts")?(n=[path.basename(r)],r=path.dirname(r)):n=a(r);for(let e=0,i=n.length;e<i;++e){let i=n[e],s=o(path.join(r,i));if(null===s)return t(Error("Library file '"+i+"' not found."));l.parseCount++,l.parseTime+=measure(()=>{h=assemblyscript.parseFile(s,exports.libraryPrefix+i,!1,h)})}}const m=assemblyscript.finishParsing(h),g=assemblyscript.createOptions();var b;if(assemblyscript.setTarget(g,0),assemblyscript.setNoTreeShaking(g,!!u.noTreeShaking),assemblyscript.setNoAssert(g,!!u.noAssert),assemblyscript.setNoMemory(g,!!u.noMemory),assemblyscript.setImportMemory(g,!!u.importMemory),assemblyscript.setImportTable(g,!!u.importTable),assemblyscript.setMemoryBase(g,u.memoryBase>>>0),assemblyscript.setSourceMap(g,null!=u.sourceMap),l.compileCount++,(()=>{try{l.compileTime+=measure(()=>{b=assemblyscript.compileProgram(m,g)})}catch(e){return t(e)}})(),checkDiagnostics(h,i))return b&&b.dispose(),t(Error("Compile error"));if(u.validate&&(l.validateCount++,l.validateTime+=measure(()=>{if(!b.validate())return b.dispose(),t(Error("Validate error"))})),"clamp"===u.trapMode)l.optimizeCount++,l.optimizeTime+=measure(()=>{b.runPasses(["trap-mode-clamp"])});else if("js"===u.trapMode)l.optimizeCount++,l.optimizeTime+=measure(()=>{b.runPasses(["trap-mode-js"])});else if("allow"!==u.trapMode)return b.dispose(),t(Error("Unsupported trap mode"));var y=-1,x=0,_=!u.noDebug;!1!==u.optimize&&("number"==typeof u.optimize?y=u.optimize:u[0]?y=0:u[1]?y=1:u[2]?y=2:u[3]?y=3:!0===u.optimize?(y=exports.defaultOptimizeLevel,x=exports.defaultShrinkLevel):y=0),u.s?x=1:u.z&&(x=2),"number"==typeof u.optimizeLevel&&(y=u.optimizeLevel),"number"==typeof u.shrinkLevel?x=u.shrinkLevel:"s"===u.shrinkLevel?x=1:"z"===u.shrinkLevel&&(x=2),b.setOptimizeLevel(y>0?y:0),b.setShrinkLevel(x),b.setDebugInfo(_);var v=[];if(u.runPasses&&("string"==typeof u.runPasses&&(u.runPasses=u.runPasses.split(",")),u.runPasses.length&&u.runPasses.forEach(e=>{v.indexOf(e)<0&&v.push(e)})),y>=0&&(l.optimizeCount++,l.optimizeTime+=measure(()=>{b.optimize()})),v.length&&(l.optimizeCount++,l.optimizeTime+=measure(()=>{b.runPasses(v.map(e=>e.trim()))})),!u.noEmit){let e=!1,n=!1;if(null!=u.outFile&&(/\.was?t$/.test(u.outFile)&&null==u.textFile?u.textFile=u.outFile:/\.js$/.test(u.outFile)&&null==u.asmjsFile?u.asmjsFile=u.outFile:null==u.binaryFile&&(u.binaryFile=u.outFile)),null!=u.binaryFile){let r,a=null!=u.sourceMap?u.sourceMap.length?u.sourceMap:path.basename(u.binaryFile)+".map":null;if(l.emitCount++,l.emitTime+=measure(()=>{r=b.toBinary(a)}),u.binaryFile.length?s(path.join(f,u.binaryFile),r.output):(S(r.output),e=!0),n=!0,null!=r.sourceMap)if(u.binaryFile.length){let e=JSON.parse(r.sourceMap);e.sourceRoot=exports.sourceMapRoot,e.sources.forEach((n,r)=>{let i=null;if(n.startsWith(exports.libraryPrefix))for(let e=0,t=p.length;e<t&&null===(i=o(path.join(p[e],n.substring(exports.libraryPrefix.length))));++e);else i=o(path.join(f,n));if(null===i)return t(Error("Source file '"+n+"' not found."));e.sourceContents||(e.sourceContents=[]),e.sourceContents[r]=i}),s(path.join(f,path.dirname(u.binaryFile),path.basename(a)),JSON.stringify(e))}else i.write("Skipped source map (stdout already occupied)"+os.EOL)}if(null!=u.asmjsFile){let t;u.asmjsFile.length?(l.emitCount++,l.emitTime+=measure(()=>{t=b.toAsmjs()}),s(path.join(f,u.asmjsFile),t)):e||(l.emitCount++,l.emitTime+=measure(()=>{t=b.toAsmjs()}),S(t),e=!0),n=!0}if(null!=u.idlFile){let t;u.idlFile.length?(l.emitCount++,l.emitTime+=measure(()=>{t=assemblyscript.buildIDL(m)}),s(path.join(f,u.idlFile),t)):e||(l.emitCount++,l.emitTime+=measure(()=>{t=assemblyscript.buildIDL(m)}),S(t),e=!0),n=!0}if(null!=u.tsdFile){let t;u.tsdFile.length?(l.emitCount++,l.emitTime+=measure(()=>{t=assemblyscript.buildTSD(m)}),s(path.join(f,u.tsdFile),t)):e||(l.emitCount++,l.emitTime+=measure(()=>{t=assemblyscript.buildTSD(m)}),S(t),e=!0),n=!0}if(null!=u.textFile||!n){let n;u.textFile&&u.textFile.length?(l.emitCount++,l.emitTime+=measure(()=>{n=b.toText()}),s(path.join(f,u.textFile),n)):e||(l.emitCount++,l.emitTime+=measure(()=>{n=b.toText()}),S(n))}}return b.dispose(),u.measure&&printStats(l,i),t(null);function E(e){try{let n;return l.readCount++,l.readTime+=measure(()=>{n=fs.readFileSync(e,{encoding:"utf8"})}),n}catch(e){return null}}function T(e,n){try{return l.writeCount++,l.writeTime+=measure(()=>{"string"==typeof n?fs.writeFileSync(e,n,{encoding:"utf8"}):fs.writeFileSync(e,n)}),!0}catch(e){return!1}}function z(e){var n;try{return l.readTime+=measure(()=>{n=__webpack_require__(!function(){var e=new Error('Cannot find module "glob"');throw e.code="MODULE_NOT_FOUND",e}()).sync("*.ts",{cwd:e})}),n}catch(e){return[]}}function S(e){S.used||(l.writeCount++,S.used=!0),l.writeTime+=measure(()=>{"string"==typeof e?r.write(e,{encoding:"utf8"}):r.write(e)})}},exports.parseArguments=parseArguments,exports.checkDiagnostics=checkDiagnostics,exports.createStats=createStats,process.hrtime||(process.hrtime=__webpack_require__(3)),exports.measure=measure,exports.printStats=printStats,exports.createMemoryStream=createMemoryStream,exports.tscOptions={alwaysStrict:!0,noImplicitAny:!0,noImplicitReturns:!0,noImplicitThis:!0,noEmitOnError:!0,strictNullChecks:!0,experimentalDecorators:!0,target:"esnext",module:"commonjs",noLib:!0,types:[],allowJs:!1}}).call(this,__webpack_require__(0),__webpack_require__(12).Buffer)},function(e,n,t){e.exports=t(13)}])});
//# sourceMappingURL=asc.js.map