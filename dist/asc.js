(function(e,t){'object'==typeof exports&&'object'==typeof module?module.exports=t(function(){try{return require('assemblyscript')}catch(t){}}(),require('./assemblyscript')):'function'==typeof define&&define.amd?define(['assemblyscript'],t):'object'==typeof exports?exports.asc=t(function(){try{return require('assemblyscript')}catch(t){}}(),require('./assemblyscript')):e.asc=t(e._,e[void 0])})('undefined'==typeof self?this:self,function(t,e){var r=Math.floor,n=Math.pow,s=Math.min;return function(e){function t(r){if(i[r])return i[r].exports;var s=i[r]={i:r,l:!1,exports:{}};return e[r].call(s.exports,s,s.exports,t),s.l=!0,s.exports}var i={};return t.m=e,t.c=i,t.d=function(e,i,r){t.o(e,i)||Object.defineProperty(e,i,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var i=e&&e.__esModule?function(){return e['default']}:function(){return e};return t.d(i,'a',i),i},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p='',t(t.s=3)}([function(e,t,i){t.nextTick=function(e){setTimeout(e,0)},t.platform=t.arch=t.execPath=t.title='browser',t.pid=1,t.browser=!0,t.env={},t.argv=[],t.binding=function(){throw new Error('No such module. (Possibly not yet loaded)')},function(){var e,r='/';t.cwd=function(){return r},t.chdir=function(t){e||(e=i(1)),r=e.resolve(t,r)}}(),t.exit=t.kill=t.umask=t.dlopen=t.uptime=t.memoryUsage=t.uvCounters=function(){},t.features={}},function(e,t,i){(function(e){function r(e,t){for(var r,s=0,n=e.length-1;0<=n;n--)r=e[n],'.'===r?e.splice(n,1):'..'===r?(e.splice(n,1),s++):s&&(e.splice(n,1),s--);if(t)for(;s--;s)e.unshift('..');return e}function n(e,t){if(e.filter)return e.filter(t);for(var r=[],s=0;s<e.length;s++)t(e[s],s,e)&&r.push(e[s]);return r}var i=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,o=function(e){return i.exec(e).slice(1)};t.resolve=function(){for(var t,s='',o=!1,a=arguments.length-1;-1<=a&&!o;a--){if(t=0<=a?arguments[a]:e.cwd(),'string'!=typeof t)throw new TypeError('Arguments to path.resolve must be strings');else if(!t)continue;s=t+'/'+s,o='/'===t.charAt(0)}return s=r(n(s.split('/'),function(e){return!!e}),!o).join('/'),(o?'/':'')+s||'.'},t.normalize=function(e){var i=t.isAbsolute(e),s='/'===a(e,-1);return e=r(n(e.split('/'),function(e){return!!e}),!i).join('/'),e||i||(e='.'),e&&s&&(e+='/'),(i?'/':'')+e},t.isAbsolute=function(e){return'/'===e.charAt(0)},t.join=function(){var e=Array.prototype.slice.call(arguments,0);return t.normalize(n(e,function(e){if('string'!=typeof e)throw new TypeError('Arguments to path.join must be strings');return e}).join('/'))},t.relative=function(e,r){function n(e){for(var t=0;t<e.length&&''===e[t];t++);for(var i=e.length-1;0<=i&&''===e[i];i--);return t>i?[]:e.slice(t,i-t+1)}e=t.resolve(e).substr(1),r=t.resolve(r).substr(1);for(var o=n(e.split('/')),a=n(r.split('/')),l=s(o.length,a.length),u=l,d=0;d<l;d++)if(o[d]!==a[d]){u=d;break}for(var i=[],d=u;d<o.length;d++)i.push('..');return i=i.concat(a.slice(u)),i.join('/')},t.sep='/',t.delimiter=':',t.dirname=function(e){var t=o(e),i=t[0],r=t[1];return i||r?(r&&(r=r.substr(0,r.length-1)),i+r):'.'},t.basename=function(e,t){var i=o(e)[2];return t&&i.substr(-1*t.length)===t&&(i=i.substr(0,i.length-t.length)),i},t.extname=function(e){return o(e)[3]};var a=function(e,t,i){return e.substr(t,i)}}).call(t,i(0))},function(e){var t=function(){return this}();try{t=t||Function('return this')()||(1,eval)('this')}catch(i){'object'==typeof window&&(t=window)}e.exports=t},function(e,t,i){e.exports=i(4)},function(e,t,i){(function(e,r){function s(t,r,s){function h(e){try{var t;return k.readCount++,k.readTime+=l(()=>{t=c.readFileSync(e,{encoding:'utf8'})}),t}catch(t){return null}}function v(e,t){try{return k.writeCount++,k.writeTime+=l(()=>c.writeFileSync(e,t,'string'==typeof t?{encoding:'utf8'}:void 0)),!0}catch(t){return!1}}function z(e){var t;try{return k.readTime+=l(()=>{t=i(!function(){var t=new Error('Cannot find module "glob"');throw t.code='MODULE_NOT_FOUND',t}()).sync('*.ts',{cwd:e})}),t}catch(t){return[]}}function E(e){E.used||(k.writeCount++,E.used=!0),k.writeTime+=l(()=>A.write(e,'string'==typeof e?{encoding:'utf8'}:void 0))}'function'==typeof r?(s=r,r={}):!r&&(r={});const A=r.stdout||e.stdout,w=r.stderr||e.stderr,S=r.readFile||h,L=r.writeFile||v,C=r.listFiles||z,k=r.stats||a();if(!A)throw Error('\'options.stdout\' must be specified');if(!w)throw Error('\'options.stderr\' must be specified');if(!c.readFileSync){if(S===h)throw Error('\'options.readFile\' must be specified');if(L===v)throw Error('\'options.writeFile\' must be specified');if(C===z)throw Error('\'options.listFiles\' must be specified')}const I=n(t),P=24;if(s||(s=function(e){var t=0;return e&&(w.write(e.stack+p.EOL),t=1),t}),I.version)return A.write('Version '+m+p.EOL),s(null);if(I.help||1>I._.length){const e=[];return Object.keys(g).forEach((t)=>{var i=g[t],r=' ';for(r+='--'+t,i.aliases&&1===i.aliases[0].length&&(r+=', -'+i.aliases[0]);r.length<P;)r+=' ';Array.isArray(i.desc)?e.push(r+i.desc[0]+i.desc.slice(1).map((e)=>{for(let t=0;t<P;++t)e=' '+e;return p.EOL+e}).join('')):e.push(r+i.desc)}),(I.help?A:w).write(['Version '+m,'Syntax:   asc [entryFile ...] [options]','','Examples: asc hello.ts','          asc hello.ts -b hello.wasm -t hello.wast','          asc hello1.ts hello2.ts -b -O > hello.wasm','','Options:'].concat(e).join(p.EOL)+p.EOL),s(null)}const O=null==I.baseDir?e.cwd():d.resolve(I.baseDir),D=d.join('.','..','std','assembly'),F=I.noLib?[]:[D];I.lib&&('string'==typeof I.lib&&(I.lib=I.lib.split(',')),Array.prototype.push.apply(F,I.lib.map(trim)));var U=null;for(let e=0,i=I._.length;e<i;++e){const t=I._[e];let r=t.replace(/\\/g,'/').replace(/(\.ts|\/)$/,''),n=S(d.join(O,r)+'.ts');if(null===n){if(n=S(d.join(O,r,'index.ts')),null===n)return s(Error('Entry file \''+r+'.ts\' not found.'));r+='/index.ts'}else r+='.ts';for(k.parseCount++,k.parseTime+=l(()=>U=f.parseFile(n,r,U,!0));null!=(r=U.nextFile());){if(r.startsWith(_)){for(let e=0,t=F.length;e<t;++e)if(T.hasOwnProperty(r))n=T[r];else if(n=S(d.join(F[e],r.substring(_.length)+'.ts')),null!==n){r+='.ts';break}}else if(n=S(d.join(O,r+'.ts')),null!==n)r+='.ts';else if(n=S(d.join(O,r,'index.ts')),null===n){for(let e=0,t=F.length;e<t;++e)if(T.hasOwnProperty(_+r))n=T[_+r];else if(n=S(d.join(F[e],r+'.ts')),null!==n){r=_+r+'.ts';break}if(null===n)return s(Error('Import file \''+r+'.ts\' not found.'))}else r+='/index.ts';k.parseCount++,k.parseTime+=l(()=>f.parseFile(n,r,U))}if(o(U,w))return s(Error('Parse error'))}var R=!1;I.noLib||Object.keys(T).forEach((e)=>{e.lastIndexOf('/')>=_.length||(k.parseCount++,k.parseTime+=l(()=>{U=f.parseFile(T[e],e+'.ts',U,!1)}),R=!0)});for(let e=0,i=F.length;e<i;++e){if(0===e&&R)continue;let t=F[e],i=C(t);for(let e=0,r=i.length;e<r;++e){let r=i[e],n=S(d.join(t,r));if(null===n)return s(Error('Library file \''+r+'\' could not be read.'));k.parseCount++,k.parseTime+=l(()=>{U=f.parseFile(n,_+r,U,!1)})}}const N=f.createOptions();f.setTarget(N,0),f.setNoTreeShaking(N,!!I.noTreeShaking),f.setNoAssert(N,!!I.noAssert),f.setNoMemory(N,!!I.noMemory),f.setSourceMap(N,null!=I.sourceMap);var M;k.compileCount++;try{k.compileTime+=l(()=>M=f.compile(U,N))}catch(t){return s(t)}if(o(U,w))return M&&M.dispose(),s(Error('Compile error'));if(I.validate&&(k.validateCount++,k.validateTime+=l(()=>{if(!M.validate())return M.dispose(),s(Error('Validate error'))})),'clamp'===I.trapMode)k.optimizeCount++,k.optimizeTime+=l(()=>M.runPasses(['trap-mode-clamp']));else if('js'===I.trapMode)k.optimizeCount++,k.optimizeTime+=l(()=>M.runPasses(['trap-mode-js']));else if('allow'!==I.trapMode)return M.dispose(),s(Error('Unsupported trap mode'));var B=-1,j=0,H=!I.noDebug;!1!==I.optimize&&('number'==typeof I.optimize?B=I.optimize:I[0]?B=0:I[1]?B=1:I[2]?B=2:I[3]?B=3:!0===I.optimize?(B=b,j=x):B=0),I.s?j=1:I.z&&(j=2),'number'==typeof I.optimizeLevel&&(B=I.optimizeLevel),'number'==typeof I.shrinkLevel?j=I.shrinkLevel:'s'===I.shrinkLevel?j=1:'z'===I.shrinkLevel&&(j=2),M.setOptimizeLevel(B),M.setShrinkLevel(j),M.setDebugInfo(H);var Y=[];if(I.runPasses&&('string'==typeof I.runPasses&&(I.runPasses=I.runPasses.split(',')),I.runPasses.length&&I.runPasses.forEach((e)=>{0>Y.indexOf(e)&&Y.push(e)})),0<=B&&(k.optimizeCount++,k.optimizeTime+=l(()=>M.optimize())),Y.length&&(k.optimizeCount++,k.optimizeTime+=l(()=>M.runPasses(Y.map((e)=>e.trim())))),!I.noEmit){let e=!1;if(null!=I.outFile&&(/\.wast$/.test(I.outFile)&&null==I.textFile?I.textFile=I.outFile:/\.js$/.test(I.outFile)&&null==I.asmjsFile?I.asmjsFile=I.outFile:null==I.binaryFile&&(I.binaryFile=I.outFile)),null!=I.binaryFile){let t,i=null==I.sourceMap?null:I.sourceMap.length?I.sourceMap:d.basename(I.binaryFile)+'.map';if(k.emitCount++,k.emitTime+=l(()=>t=M.toBinary(i)),I.binaryFile.length?L(d.join(O,I.binaryFile),t.output):(E(t.output),e=!0),null!=t.sourceMap)if(I.binaryFile.length){let e=JSON.parse(t.sourceMap);e.sourceRoot=y,e.sources.forEach((t,i)=>{let r=null;if(t.startsWith(_))for(let e=0,i=F.length;e<i&&(r=S(d.join(F[e],t.substring(_.length))),null===r);++e);else r=S(d.join(O,t));return null===r?s(Error('Source file \''+t+'\' not found.')):void((e.sourceContents||(e.sourceContents=[]))[i]=r)}),L(d.join(O,d.dirname(I.binaryFile),d.basename(i)),JSON.stringify(e))}else w.write('Cannot write source map because binary already occupies stdout.'+p.EOL)}if(null!=I.textFile||null==I.binaryFile&&null==I.asmjsFile){let t;I.textFile&&I.textFile.length?(k.emitCount++,k.emitTime+=l(()=>t=M.toText()),L(d.join(O,I.textFile),t)):!e&&(k.emitCount++,k.emitTime+=l(()=>t=M.toText()),E(t),e=!0)}if(null!=I.asmjsFile&&I.asmjsFile.length){let t;I.asmjsFile.length?(k.emitCount++,k.emitTime+=l(()=>t=M.toAsmjs()),L(d.join(O,I.asmjsFile),t)):!e&&(k.emitCount++,k.emitTime+=l(()=>t=M.toAsmjs()),E(t),e=!0)}}return M.dispose(),I.measure&&u(k,w),s(null)}function n(e){const t={};return Object.keys(g).forEach((e)=>{const i=g[e];i.aliases&&((t.alias||(t.alias={}))[e]=i.aliases),void 0!==i.default&&((t.default||(t.default={}))[e]=i.default),'string'===i.type?(t.string||(t.string=[])).push(e):'boolean'===i.type&&(t.boolean||(t.boolean=[])).push(e)}),i(14)(e,t)}function o(e,t){for(var i,r=!1;null!=(i=f.nextDiagnostic(e));)t.write(f.formatDiagnostic(i,t.isTTY,!0)+p.EOL+p.EOL),f.isError(i)&&(r=!0);return r}function a(){return{readTime:0,readCount:0,writeTime:0,writeCount:0,parseTime:0,parseCount:0,compileTime:0,compileCount:0,emitTime:0,emitCount:0,validateTime:0,validateCount:0,optimizeTime:0,optimizeCount:0}}function l(t){const i=e.hrtime();t();const r=e.hrtime(i);return 1e9*r[0]+r[1]}function u(t,i){(i||e.stdout).write(['I/O Read  : '+(t.readTime?(t.readTime/1e6).toFixed(3)+' ms ('+t.readCount+' files)':'N/A'),'I/O Write : '+(t.writeTime?(t.writeTime/1e6).toFixed(3)+' ms ('+t.writeCount+' files)':'N/A'),'Parse     : '+(t.parseTime?(t.parseTime/1e6).toFixed(3)+' ms ('+t.parseCount+' times)':'N/A'),'Compile   : '+(t.compileTime?(t.compileTime/1e6).toFixed(3)+' ms ('+t.compileCount+' times)':'N/A'),'Emit      : '+(t.emitTime?(t.emitTime/1e6).toFixed(3)+' ms ('+t.emitCount+' times)':'N/A'),'Validate  : '+(t.validateTime?(t.validateTime/1e6).toFixed(3)+' ms ('+t.validateCount+' times)':'N/A'),'Optimize  : '+(t.optimizeTime?(t.optimizeTime/1e6).toFixed(3)+' ms ('+t.optimizeCount+' times)':'N/A')].join(p.EOL)+p.EOL)}const d=i(1),c=i(9),p=i(10);var f,h;try{f=i(11),h=!1;try{i(!function(){var t=new Error('Cannot find module "source-map-support"');throw t.code='MODULE_NOT_FOUND',t}()).install()}catch(t){}}catch(t){try{i(!function(){var t=new Error('Cannot find module "ts-node"');throw t.code='MODULE_NOT_FOUND',t}()).register({project:i(1).join('.','..','src')}),i(!function(){var t=new Error('Cannot find module "../src/glue/js"');throw t.code='MODULE_NOT_FOUND',t}()),f=i(!function(){var t=new Error('Cannot find module "../src"');throw t.code='MODULE_NOT_FOUND',t}()),h=!0}catch(t){f=i(12),h=!1}}const m='0.5.0',g=i(13),y='assemblyscript:///',_=f.LIBRARY_PREFIX,b=2,x=1,T={"(lib)/allocator/arena":'/////////////// A simple yet effective Arena Memory Allocator /////////////////\r\n\r\n// Provides a `reset_memory` function to reset the heap to its initial state. A\r\n// user has to make sure that there are no more references to cleared memory\r\n// afterwards. Always aligns to 8 bytes.\r\n\r\nconst ALIGN_LOG2: usize = 3;\r\nconst ALIGN_SIZE: usize = 1 << ALIGN_LOG2;\r\nconst ALIGN_MASK: usize = ALIGN_SIZE - 1;\r\n\r\nvar HEAP_OFFSET: usize = HEAP_BASE;\r\n\r\nexport function allocate_memory(size: usize): usize {\r\n  if (!size) return 0;\r\n  var ptr = HEAP_OFFSET;\r\n  var off = (ptr + size + ALIGN_MASK) & ~ALIGN_MASK;\r\n  var avail = <usize>current_memory() << 16;\r\n  if (off > avail && grow_memory(\r\n    max(\r\n      (((off + 0xffff) & ~0xffff) - avail) >> 16, // minimum required pages\r\n      avail                                >> 16  // at least double memory\r\n    )\r\n  ) < 0) unreachable(); // out of memory\r\n  HEAP_OFFSET = off;\r\n  return ptr;\r\n}\r\n\r\nexport function free_memory(ptr: usize): void {\r\n  // nop\r\n}\r\n\r\nexport function reset_memory(): void {\r\n  HEAP_OFFSET = HEAP_BASE;\r\n}\r\n',"(lib)/allocator/emscripten":'///////////////////////// Emscripten Memory Allocator //////////////////////////\r\n\r\n// Uses Emscripten\'s exported _malloc and _free implementations, i.e., when\r\n// linking with Emscripten-compiled programs that already provide these.\r\n// Differs from \'system\' in that their names are prefixed with an underscore.\r\n\r\ndeclare function _malloc(size: usize): usize;\r\ndeclare function _free(ptr: usize): void;\r\n\r\nexport function allocate_memory(size: usize): usize {\r\n  return _malloc(size);\r\n}\r\n\r\nexport function free_memory(ptr: usize): void {\r\n  _free(ptr);\r\n}\r\n\r\nexport function reset_memory(): void {\r\n  throw new Error("not supported");\r\n}\r\n',"(lib)/allocator/system":'/////////////////////////// System Memory Allocator ////////////////////////////\r\n\r\n// Uses the environment\'s malloc and free implementations, i.e., when linking\r\n// with other C-like programs that already provide these.\r\n\r\ndeclare function malloc(size: usize): usize;\r\ndeclare function free(ptr: usize): void;\r\n\r\nexport function allocate_memory(size: usize): usize {\r\n  return malloc(size);\r\n}\r\n\r\nexport function free_memory(ptr: usize): void {\r\n  free(ptr);\r\n}\r\n\r\nexport function reset_memory(): void {\r\n  throw new Error("not supported");\r\n}\r\n',"(lib)/allocator/tlsf":'////////////// TLSF (Two-Level Segregate Fit) Memory Allocator ////////////////\r\n\r\n// Re-export for now, so there\'s just one source file being worked on\r\n\r\nexport {\r\n  allocate_memory,\r\n  free_memory\r\n} from "../../../examples/tlsf/assembly/tlsf";\r\n\r\nexport function reset_memory(): void {\r\n  throw new Error("not supported");\r\n}\r\n',"(lib)/array":'export class Array<T> {\r\n\r\n  private __memory: usize;\r\n  private __capacity: i32;  // capped to [0, 0x7fffffff]\r\n  private __length: i32;    // capped to [0, __capacity]\r\n\r\n  private __grow(newCapacity: i32): void {\r\n    assert(newCapacity > this.__capacity);\r\n    var newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\r\n    if (this.__memory) {\r\n      move_memory(newMemory, this.__memory, this.__capacity * sizeof<T>());\r\n      free_memory(this.__memory);\r\n    }\r\n    this.__memory = newMemory;\r\n    this.__capacity = newCapacity;\r\n  }\r\n\r\n  constructor(capacity: i32 = 0) {\r\n    if (capacity < 0)\r\n      throw new RangeError("Invalid array length");\r\n    this.__memory = capacity ? allocate_memory(<usize>capacity * sizeof<T>()) : 0;\r\n    this.__capacity = this.__length = capacity;\r\n  }\r\n\r\n  get length(): i32 {\r\n    return this.__length;\r\n  }\r\n\r\n  set length(length: i32) {\r\n    if (length < 0)\r\n      throw new RangeError("Invalid array length");\r\n    if (length > this.__capacity)\r\n      this.__grow(max(length, this.__capacity << 1));\r\n    this.__length = length;\r\n  }\r\n\r\n  @operator("[]")\r\n  private __get(index: i32): T {\r\n    if (<u32>index >= this.__capacity)\r\n      throw new Error("Index out of bounds"); // return changetype<T>(0) ?\r\n    return load<T>(this.__memory + <usize>index * sizeof<T>());\r\n  }\r\n\r\n  @operator("[]=")\r\n  private __set(index: i32, value: T): void {\r\n    if (index < 0)\r\n      throw new Error("Index out of bounds");\r\n    if (index >= this.__capacity)\r\n      this.__grow(max(index + 1, this.__capacity << 1));\r\n    store<T>(this.__memory + <usize>index * sizeof<T>(), value);\r\n  }\r\n\r\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\r\n    if (fromIndex < 0)\r\n      fromIndex = this.__length + fromIndex;\r\n    while (<u32>fromIndex < this.__length) {\r\n      if (load<T>(this.__memory + fromIndex * sizeof<T>()) == searchElement)\r\n        return fromIndex;\r\n      ++fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  lastIndexOf(searchElement: T, fromIndex: i32 = 0): i32 {\r\n    if (fromIndex < 0)\r\n      fromIndex = this.__length + fromIndex;\r\n    else if (fromIndex >= this.__length)\r\n      fromIndex = this.__length - 1;\r\n    while (fromIndex >= 0) {\r\n      if (load<T>(this.__memory + fromIndex * sizeof<T>()) == searchElement)\r\n        return fromIndex;\r\n      --fromIndex;\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  push(element: T): i32 {\r\n    if (this.__length == this.__capacity)\r\n      this.__grow(this.__capacity ? this.__capacity << 1 : 1);\r\n    store<T>(this.__memory + this.__length * sizeof<T>(), element);\r\n    return ++this.__length;\r\n  }\r\n\r\n  pop(): T {\r\n    if (this.__length < 1)\r\n      throw new RangeError("Array is empty"); // return changetype<T>(0) ?\r\n    return load<T>(this.__memory + --this.__length * sizeof<T>());\r\n  }\r\n\r\n  shift(): T {\r\n    if (this.__length < 1)\r\n      throw new RangeError("Array is empty"); // return changetype<T>(0) ?\r\n    var element = load<T>(this.__memory);\r\n    move_memory(this.__memory, this.__memory + sizeof<T>(), (this.__capacity - 1) * sizeof<T>());\r\n    set_memory(this.__memory + (this.__capacity - 1) * sizeof<T>(), 0, sizeof<T>());\r\n    --this.__length;\r\n    return element;\r\n  }\r\n\r\n  unshift(element: T): i32 {\r\n    var oldCapacity = this.__capacity;\r\n    if (this.__length == oldCapacity) {\r\n      // inlined __grow (avoids moving twice)\r\n      var newCapacity: i32 = oldCapacity ? oldCapacity << 1 : 1;\r\n      assert(newCapacity > this.__capacity);\r\n      var newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\r\n      if (this.__memory) {\r\n        move_memory(newMemory + sizeof<T>(), this.__memory, oldCapacity * sizeof<T>());\r\n        free_memory(this.__memory);\r\n      }\r\n      this.__memory = newMemory;\r\n      this.__capacity = newCapacity;\r\n    } else\r\n      move_memory(this.__memory + sizeof<T>(), this.__memory, oldCapacity * sizeof<T>());\r\n    store<T>(this.__memory, element);\r\n    return ++this.__length;\r\n  }\r\n\r\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\r\n    if (begin < 0) {\r\n      begin = this.__length + begin;\r\n      if (begin < 0)\r\n        begin = 0;\r\n    } else if (begin > this.__length)\r\n      begin = this.__length;\r\n    if (end < 0)\r\n      end = this.__length + end;\r\n    else if (end > this.__length)\r\n      end = this.__length;\r\n    if (end < begin)\r\n      end = begin;\r\n    var capacity = end - begin;\r\n    assert(capacity >= 0);\r\n    var sliced = new Array<T>(capacity);\r\n    if (capacity)\r\n      move_memory(sliced.__memory, this.__memory + <usize>begin * sizeof<T>(), <usize>capacity * sizeof<T>());\r\n    return sliced;\r\n  }\r\n\r\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): void {\r\n    if (deleteCount < 1)\r\n      return;\r\n    if (start < 0) {\r\n      start = this.__length + start;\r\n      if (start < 0)\r\n        start = 0;\r\n      else if (start >= this.__length)\r\n        return;\r\n    } else if (start >= this.__length)\r\n      return;\r\n    deleteCount = min(deleteCount, this.__length - start);\r\n    move_memory(this.__memory + <usize>start * sizeof<T>(), this.__memory + <usize>(start + deleteCount) * sizeof<T>(), deleteCount * sizeof<T>());\r\n    this.__length -= deleteCount;\r\n  }\r\n\r\n  reverse(): Array<T> {\r\n    for (var front: usize = 0, back: usize = <usize>this.__length - 1; front < back; ++front, --back) {\r\n      var temp = load<T>(this.__memory + front * sizeof<T>());\r\n      store<T>(this.__memory + front * sizeof<T>(), load<T>(this.__memory + back * sizeof<T>()));\r\n      store<T>(this.__memory + back * sizeof<T>(), temp);\r\n    }\r\n    return this;\r\n  }\r\n}\r\n\r\n@unmanaged\r\nexport class CArray<T> {\r\n\r\n  private constructor() {}\r\n\r\n  @operator("[]")\r\n  private __get(index: i32): T {\r\n    if (index < 0)\r\n      throw new RangeError("Index out of range");\r\n    return load<T>(changetype<usize>(this) + <usize>index * sizeof<T>());\r\n  }\r\n\r\n  @operator("[]=")\r\n  private __set(index: i32, value: T): void {\r\n    if (index < 0)\r\n      throw new RangeError("Index out of range");\r\n    store<T>(changetype<usize>(this) + <usize>index * sizeof<T>(), value);\r\n  }\r\n}\r\n',"(lib)/builtins":'@builtin\r\nexport declare const NaN: f64; // | f32\r\n\r\n@builtin\r\nexport declare const Infinity: f64; // | f32\r\n\r\n@builtin\r\nexport declare function isNaN<T>(value: T): bool;\r\n\r\n@builtin\r\nexport declare function isFinite<T>(value: T): bool;\r\n\r\n@builtin\r\nexport declare function clz<T>(value: T): T;\r\n\r\n@builtin\r\nexport declare function ctz<T>(value: T): T;\r\n\r\n@builtin\r\nexport declare function popcnt<T>(value: T): T;\r\n\r\n@builtin\r\nexport declare function rotl<T>(value: T, shift: T): T;\r\n\r\n@builtin\r\nexport declare function rotr<T>(value: T, shift: T): T;\r\n\r\n@builtin\r\nexport declare function abs<T>(value: T): T;\r\n\r\n@builtin\r\nexport declare function max<T>(left: T, right: T): T;\r\n\r\n@builtin\r\nexport declare function min<T>(left: T, right: T): T;\r\n\r\n@builtin\r\nexport declare function ceil<T>(value: T): T;\r\n\r\n@builtin\r\nexport declare function floor<T>(value: T): T;\r\n\r\n@builtin\r\nexport declare function copysign<T>(left: T, right: T): T;\r\n\r\n@builtin\r\nexport declare function nearest<T>(left: T, right: T): T;\r\n\r\n@builtin\r\nexport declare function reinterpret<T>(value: void): T;\r\n\r\n@builtin\r\nexport declare function sqrt<T>(value: T): T;\r\n\r\n@builtin\r\nexport declare function trunc<T>(value: T): T;\r\n\r\n@builtin\r\nexport declare function load<T>(offset: usize, constantOffset?: usize): T;\r\n\r\n@builtin\r\nexport declare function store<T>(offset: usize, value: void, constantOffset?: usize): T;\r\n\r\n@builtin\r\nexport declare function sizeof<T>(): usize;\r\n\r\n@builtin\r\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\r\n\r\n@builtin\r\nexport declare function unreachable(): void;\r\n\r\n@builtin\r\nexport declare function current_memory(): i32;\r\n\r\n@builtin\r\nexport declare function grow_memory(pages: i32): i32;\r\n\r\n// @builtin\r\n// export declare function move_memory(dest: usize, src: usize: n: usize): void;\r\n\r\n// @builtin\r\n// export declare function set_memory(dest: usize, value: u32, n: usize): void;\r\n\r\n@builtin\r\nexport declare function changetype<T>(value: void): T;\r\n\r\n@builtin\r\nexport declare function assert<T>(isTrueish: T, message?: string): T;\r\n\r\n@builtin\r\nexport declare function abort(message?: string | null, fileName?: string | null, lineNumber?: u32, columnNumber?: u32): void;\r\n\r\n@builtin\r\ndeclare function i8(value: void): i8;\r\nnamespace i8 {\r\n  export const MIN_VALUE: i8 = -128;\r\n  export const MAX_VALUE: i8 = 127;\r\n}\r\nexport { i8 };\r\n\r\n@builtin\r\ndeclare function i16(value: void): i16;\r\nnamespace i16 {\r\n  export const MIN_VALUE: i16 = -32768;\r\n  export const MAX_VALUE: i16 = 32767;\r\n}\r\nexport { i16 };\r\n\r\n@builtin\r\ndeclare function i32(value: void): i32;\r\nnamespace i32 {\r\n  export const MIN_VALUE: i32 = -2147483648;\r\n  export const MAX_VALUE: i32 = 2147483647;\r\n}\r\nexport { i32 };\r\n\r\n@builtin\r\ndeclare function i64(value: void): i64;\r\nnamespace i64 {\r\n  export const MIN_VALUE: i64 = -9223372036854775808;\r\n  export const MAX_VALUE: i64 = 9223372036854775807;\r\n}\r\nexport { i64 };\r\n\r\n@builtin\r\ndeclare function isize(value: void): isize;\r\nnamespace isize {\r\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>() ? -2147483648 : <usize>-9223372036854775808;\r\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>() ? 2147483647 : <usize>9223372036854775807;\r\n}\r\nexport { isize };\r\n\r\n@builtin\r\ndeclare function u8(value: void): u8;\r\nnamespace u8 {\r\n  export const MIN_VALUE: u8 = 0;\r\n  export const MAX_VALUE: u8 = 255;\r\n}\r\nexport { u8 };\r\n\r\n@builtin\r\ndeclare function u16(value: void): u16;\r\nnamespace u16 {\r\n  export const MIN_VALUE: u16 = 0;\r\n  export const MAX_VALUE: u16 = 65535;\r\n}\r\nexport { u16 };\r\n\r\n@builtin\r\ndeclare function u32(value: void): u32;\r\nnamespace u32 {\r\n  export const MIN_VALUE: u32 = 0;\r\n  export const MAX_VALUE: u32 = 4294967295;\r\n}\r\nexport { u32 };\r\n\r\n@builtin\r\ndeclare function u64(value: void): u64;\r\nnamespace u64 {\r\n  export const MIN_VALUE: u64 = 0;\r\n  export const MAX_VALUE: u64 = 18446744073709551615;\r\n}\r\nexport { u64 };\r\n\r\n@builtin\r\ndeclare function usize(value: void): usize;\r\nnamespace usize {\r\n  export const MIN_VALUE: usize = 0;\r\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>() ? 4294967295 : <usize>18446744073709551615;\r\n}\r\nexport { usize };\r\n\r\n@builtin\r\ndeclare function bool(value: void): bool;\r\nnamespace bool {\r\n  export const MIN_VALUE: bool = 0;\r\n  export const MAX_VALUE: bool = 1;\r\n}\r\nexport { bool };\r\n\r\n@builtin\r\ndeclare function f32(value: void): f32;\r\nnamespace f32 {\r\n  export const MIN_VALUE: f32 = -3.40282347e+38;\r\n  export const MAX_VALUE: f32 = 3.40282347e+38;\r\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\r\n  export const MAX_SAFE_INTEGER: f32 = 16777215;\r\n  export const EPSILON: f32 = 1.19209290e-07;\r\n}\r\nexport { f32 };\r\n\r\n@builtin\r\ndeclare function f64(value: void): f64;\r\nnamespace f64 {\r\n  export const MIN_VALUE: f64 = -1.7976931348623157e+308;\r\n  export const MAX_VALUE: f64 = 1.7976931348623157e+308;\r\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\r\n  export const MAX_SAFE_INTEGER: f64 = 9007199254740991;\r\n  export const EPSILON: f64 = 2.2204460492503131e-16;\r\n}\r\nexport{ f64 };\r\n\r\n@builtin\r\nexport declare const HEAP_BASE: usize;\r\n\r\n@builtin\r\nexport declare function start(): void;\r\n',"(lib)/error":'export class Error {\r\n\r\n  name: string = "Error";\r\n  message: string;\r\n  stack: string = ""; // TODO\r\n\r\n  constructor(message: string = "") {\r\n    this.message = message;\r\n  }\r\n}\r\n\r\nexport class RangeError extends Error {\r\n  name: string = "RangeError";\r\n}\r\n',"(lib)/iterator":'// export abstract class Iterator<T> {\r\n//   abstract get done(): bool;\r\n//   abstract next(): T;\r\n// }\r\n',"(lib)/map":'export class Map<K,V> {\r\n\r\n  private __keys: K[] = [];\r\n  private __values: V[] = [];\r\n\r\n  // FIXME: not a proper map implementation, just a filler\r\n\r\n  get size(): i32 {\r\n    return this.__keys.length;\r\n  }\r\n\r\n  get(key: K): V | null {\r\n    var keys = this.__keys;\r\n    for (var i = 0, k = keys.length; i < k; ++i)\r\n      if (keys[i] == key)\r\n        return this.__values[i];\r\n    return null;\r\n  }\r\n\r\n  has(key: K): bool {\r\n    var keys = this.__keys;\r\n    for (var i = 0, k = keys.length; i < k; ++i)\r\n      if (keys[i] == key)\r\n        return true;\r\n    return false;\r\n  }\r\n\r\n  set(key: K, value: V): void {\r\n    this.__keys.push(key);\r\n    this.__values.push(value);\r\n  }\r\n\r\n  clear(): void {\r\n    this.__keys.length = 0;\r\n    this.__values.length = 0;\r\n  }\r\n}\r\n',"(lib)/memory":'function copy_memory(dest: usize, src: usize, n: usize): void {\r\n  // based on musl\'s implementation of memcpy\r\n  // not a future instruction and sufficiently covered by the upcoming move_memory intrinsic\r\n\r\n  var w: u32, x: u32;\r\n\r\n  // copy 1 byte each until src is aligned to 4 bytes\r\n  while (n && src % 4) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    n--;\r\n  }\r\n\r\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\r\n  if (dest % 4 == 0) {\r\n    while (n >= 16) {\r\n      store<u32>(dest     , load<u32>(src     ));\r\n      store<u32>(dest +  4, load<u32>(src +  4));\r\n      store<u32>(dest +  8, load<u32>(src +  8));\r\n      store<u32>(dest + 12, load<u32>(src + 12));\r\n      src += 16; dest += 16; n -= 16;\r\n    }\r\n    if (n & 8) {\r\n      store<u32>(dest    , load<u32>(src    ));\r\n      store<u32>(dest + 4, load<u32>(src + 4));\r\n      dest += 8; src += 8;\r\n    }\r\n    if (n & 4) {\r\n      store<u32>(dest, load<u32>(src));\r\n      dest += 4; src += 4;\r\n    }\r\n    if (n & 2) { // drop to 2 bytes each\r\n      store<u16>(dest, load<u16>(src));\r\n      dest += 2; src += 2;\r\n    }\r\n    if (n & 1) { // drop to 1 byte\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    return;\r\n  }\r\n\r\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\r\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\r\n  if (n >= 32) {\r\n    switch (dest % 4) {\r\n      // known to be != 0\r\n      case 1:\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 3;\r\n        while (n >= 17) {\r\n          x = load<u32>(src + 1);\r\n          store<u32>(dest, w >> 24 | x << 8);\r\n          w = load<u32>(src + 5);\r\n          store<u32>(dest + 4, x >> 24 | w << 8);\r\n          x = load<u32>(src + 9);\r\n          store<u32>(dest + 8, w >> 24 | x << 8);\r\n          w = load<u32>(src + 13);\r\n          store<u32>(dest + 12, x >> 24 | w << 8);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      case 2:\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 2;\r\n        while (n >= 18) {\r\n          x = load<u32>(src + 2);\r\n          store<u32>(dest, w >> 16 | x << 16);\r\n          w = load<u32>(src + 6);\r\n          store<u32>(dest + 4, x >> 16 | w << 16);\r\n          x = load<u32>(src + 10);\r\n          store<u32>(dest + 8, w >> 16 | x << 16);\r\n          w = load<u32>(src + 14);\r\n          store<u32>(dest + 12, x >> 16 | w << 16);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      case 3:\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 1;\r\n        while (n >= 19) {\r\n          x = load<u32>(src + 3);\r\n          store<u32>(dest, w >> 8 | x << 24);\r\n          w = load<u32>(src + 7);\r\n          store<u32>(dest + 4, x >> 8 | w << 24);\r\n          x = load<u32>(src + 11);\r\n          store<u32>(dest + 8, w >> 8 | x << 24);\r\n          w = load<u32>(src + 15);\r\n          store<u32>(dest + 12, x >> 8 | w << 24);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  // copy remaining bytes one by one\r\n  if (n & 16) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 8) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 4) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 2) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 1) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n}\r\n\r\nexport function move_memory(dest: usize, src: usize, n: usize): void {\r\n  // based on musl\'s implementation of memmove\r\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\r\n\r\n  if (dest == src)\r\n    return;\r\n  if (src + n <= dest || dest + n <= src) {\r\n    copy_memory(dest, src, n);\r\n    return;\r\n  }\r\n  if (dest < src) {\r\n    if (src % 8 == dest % 8) {\r\n      while (dest % 8) {\r\n        if (!n)\r\n          return;\r\n        --n;\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      while (n >= 8) {\r\n        store<u64>(dest, load<u64>(src));\r\n        n -= 8;\r\n        dest += 8;\r\n        src += 8;\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    if (src % 8 == dest % 8) {\r\n      while ((dest + n) % 8) {\r\n        if (!n)\r\n          return;\r\n        store<u8>(dest + --n, load<u8>(src + n));\r\n      }\r\n      while (n >= 8) {\r\n        n -= 8;\r\n        store<u64>(dest + n, load<u64>(src + n));\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest + --n, load<u8>(src + n));\r\n    }\r\n  }\r\n}\r\n\r\nexport function set_memory(dest: usize, c: u8, n: usize): void {\r\n  // based on musl\'s implementation of memset\r\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\r\n\r\n  // fill head and tail with minimal branching\r\n  if (!n)\r\n    return;\r\n  store<u8>(dest, c);\r\n  store<u8>(dest + n - 1, c);\r\n  if (n <= 2)\r\n    return;\r\n\r\n  store<u8>(dest + 1, c);\r\n  store<u8>(dest + 2, c);\r\n  store<u8>(dest + n - 2, c);\r\n  store<u8>(dest + n - 3, c);\r\n  if (n <= 6)\r\n    return;\r\n  store<u8>(dest + 3, c);\r\n  store<u8>(dest + n - 4, c);\r\n  if (n <= 8)\r\n    return;\r\n\r\n  // advance pointer to align it at 4-byte boundary\r\n  var k: usize = -dest & 3;\r\n  dest += k;\r\n  n -= k;\r\n  n &= -4;\r\n\r\n  var c32: u32 = -1 / 255 * c;\r\n\r\n  // fill head/tail up to 28 bytes each in preparation\r\n  store<u32>(dest, c32);\r\n  store<u32>(dest + n - 4, c32);\r\n  if (n <= 8)\r\n    return;\r\n  store<u32>(dest + 4, c32);\r\n  store<u32>(dest + 8, c32);\r\n  store<u32>(dest + n - 12, c32);\r\n  store<u32>(dest + n - 8, c32);\r\n  if (n <= 24)\r\n    return;\r\n  store<u32>(dest + 12, c32);\r\n  store<u32>(dest + 16, c32);\r\n  store<u32>(dest + 20, c32);\r\n  store<u32>(dest + 24, c32);\r\n  store<u32>(dest + n - 28, c32);\r\n  store<u32>(dest + n - 24, c32);\r\n  store<u32>(dest + n - 20, c32);\r\n  store<u32>(dest + n - 16, c32);\r\n\r\n  // align to a multiple of 8\r\n  k = 24 + (dest & 4);\r\n  dest += k;\r\n  n -= k;\r\n\r\n  // copy 32 bytes each\r\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\r\n  while (n >= 32) {\r\n    store<u64>(dest, c64);\r\n    store<u64>(dest + 8, c64);\r\n    store<u64>(dest + 16, c64);\r\n    store<u64>(dest + 24, c64);\r\n    n -= 32;\r\n    dest += 32;\r\n  }\r\n}\r\n\r\nexport function compare_memory(vl: usize, vr: usize, n: usize): i32 {\r\n  // based on musl\'s implementation of memcmp\r\n  // provided because there\'s no proposed alternative\r\n  if (vl == vr)\r\n    return 0;\r\n  while (n && load<u8>(vl) == load<u8>(vr)) {\r\n    n--;\r\n    vl++;\r\n    vr++;\r\n  }\r\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\r\n}\r\n',"(lib)/regexp":'export class RegExp {\r\n\r\n  // @binding(CALL_NEW, [ STRING, STRING], OBJECT_HANDLE)\r\n  constructor(pattern: string, flags: string = "") { throw new Error("unreachable"); }\r\n\r\n  // @binding(CALL_THIS, [ STRING ], PASS_THRU)\r\n  test(search: string): bool { throw new Error("unreachable"); }\r\n\r\n  // @binding(CALL_THIS, [], STRING)\r\n  toString(): string { throw new Error("unreachable"); }\r\n\r\n}\r\n',"(lib)/set":'// const prime1: u32 = 73;\r\n// const prime2: u32 = 5009;\r\n\r\nexport class Set<T> {\r\n\r\n  private __memory: usize;\r\n  private __capacity: u32;\r\n  private __size: u32;\r\n\r\n  constructor() {\r\n    this.__memory = 0;\r\n    this.__capacity = this.__size = 0;\r\n  }\r\n\r\n  get size(): i32 {\r\n    return this.__size;\r\n  }\r\n\r\n  // FIXME: not a proper set implementation, just a filler\r\n\r\n  has(value: T): bool {\r\n    assert(this != null);\r\n\r\n    for (var index: usize = 0, limit: usize = this.__size; index < limit; ++index)\r\n      if (load<T>(this.__memory + index * sizeof<T>()) == value)\r\n        return true;\r\n    return false;\r\n  }\r\n\r\n  add(value: T): Set<T> {\r\n    assert(this != null);\r\n\r\n    if (this.__size >= this.__capacity) {\r\n      var newCapacity = max(this.__capacity << 1, 8);\r\n      var newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\r\n      if (this.__memory) {\r\n        move_memory(newMemory, this.__memory, <usize>this.__capacity * sizeof<T>());\r\n        free_memory(this.__memory);\r\n      }\r\n      this.__capacity = newCapacity;\r\n      this.__memory = newMemory;\r\n    }\r\n    store<T>(this.__memory + <usize>this.__size * sizeof<T>(), value);\r\n    ++this.__size;\r\n    return this;\r\n  }\r\n\r\n  delete(value: T): bool {\r\n    assert(this != null);\r\n\r\n    for (var index: usize = 0, limit: usize = this.__size; index < limit; ++index)\r\n      if (load<T>(this.__memory + index * sizeof<T>()) == value) {\r\n        if (index + 1 < this.__size)\r\n          move_memory(this.__memory + index * sizeof<T>(), this.__memory + (index + 1) * sizeof<T>(), this.__size - index - 1);\r\n        --this.__size;\r\n        return true;\r\n      }\r\n    return false;\r\n  }\r\n\r\n  clear(): void {\r\n    assert(this != null);\r\n\r\n    this.__size = 0;\r\n  }\r\n\r\n  // TODO: think about iterators\r\n}\r\n\r\n// class SetIterator<T> extends Iterator<T> {\r\n\r\n//   get done(): bool {\r\n//     throw new Error("not implemented");\r\n//   }\r\n\r\n//   next(): T {\r\n//     throw new Error("not implemented");\r\n//   }\r\n// }\r\n',"(lib)/string":'// singleton empty string\r\nconst EMPTY: String = changetype<String>("");\r\n\r\n// number of bytes preceeding string data\r\nconst HEAD: usize = 4;\r\n\r\nfunction allocate(length: i32): String {\r\n  assert(length > 0); // 0 -> EMPTY\r\n  var ptr = allocate_memory(HEAD + (<usize>length << 1));\r\n  store<i32>(ptr, length);\r\n  return changetype<String>(ptr);\r\n}\r\n\r\nexport class String {\r\n\r\n  readonly length: i32;\r\n\r\n  @operator("[]")\r\n  charAt(pos: i32): String {\r\n    assert(this != null);\r\n\r\n    if (<u32>pos >= this.length)\r\n      return EMPTY;\r\n\r\n    var out = allocate(1);\r\n    store<u16>(\r\n      changetype<usize>(out),\r\n      load<u16>(\r\n        changetype<usize>(this) + (<usize>pos << 1),\r\n        HEAD\r\n      ),\r\n      HEAD\r\n    );\r\n    return out;\r\n  }\r\n\r\n  charCodeAt(pos: i32): i32 {\r\n    assert(this != null);\r\n\r\n    if (<u32>pos >= this.length)\r\n      return -1; // (NaN)\r\n\r\n    return load<u16>(\r\n      changetype<usize>(this) + (<usize>pos << 1),\r\n      HEAD\r\n    );\r\n  }\r\n\r\n  codePointAt(pos: i32): i32 {\r\n    assert(this != null);\r\n\r\n    if (<u32>pos >= this.length)\r\n      return -1; // (undefined)\r\n    var first = <i32>load<u16>(\r\n      changetype<usize>(this) + (<usize>pos << 1),\r\n      HEAD\r\n    );\r\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length)\r\n      return first;\r\n    var second = <i32>load<u16>(\r\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\r\n      HEAD\r\n    );\r\n    if (second < 0xDC00 || second > 0xDFFF)\r\n      return first;\r\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\r\n  }\r\n\r\n  @operator("+")\r\n  private static __concat(left: String, right: String): String {\r\n    if (left == null)\r\n      left = changetype<String>("null");\r\n    return left.concat(right);\r\n  }\r\n\r\n  concat(other: String): String {\r\n    assert(this != null);\r\n\r\n    if (other == null)\r\n      other = changetype<String>("null");\r\n\r\n    var thisLen: isize = this.length;\r\n    var otherLen: isize = other.length;\r\n    var outLen: usize = thisLen + otherLen;\r\n    if (outLen == 0)\r\n      return EMPTY;\r\n\r\n    var out = allocate(outLen);\r\n    move_memory(\r\n      changetype<usize>(out) + HEAD,\r\n      changetype<usize>(this) + HEAD,\r\n      thisLen << 1\r\n    );\r\n    move_memory(\r\n      changetype<usize>(out) + HEAD + (thisLen << 1),\r\n      changetype<usize>(other) + HEAD,\r\n      otherLen << 1\r\n    );\r\n    return out;\r\n  }\r\n\r\n  endsWith(searchString: String, endPosition: i32 = 0x7fffffff): bool {\r\n    assert(this != null);\r\n\r\n    if (searchString == null)\r\n      return false;\r\n\r\n    var end: isize = <isize>min(max(endPosition, 0), this.length);\r\n    var searchLength: isize = searchString.length;\r\n    var start: isize = end - searchLength;\r\n    if (start < 0)\r\n      return false;\r\n\r\n    return !compare_memory(\r\n      changetype<usize>(this) + HEAD + (start << 1),\r\n      changetype<usize>(searchString) + HEAD,\r\n      searchLength << 1\r\n    );\r\n  }\r\n\r\n  @operator("==")\r\n  private static __eq(left: String, right: String): bool {\r\n    if (left == null)\r\n      return right == null;\r\n    else if (right == null)\r\n      return false;\r\n\r\n    var leftLength = left.length;\r\n    if (leftLength != right.length)\r\n      return false;\r\n\r\n    return !compare_memory(\r\n      changetype<usize>(left) + HEAD,\r\n      changetype<usize>(right) + HEAD,\r\n      (<usize>leftLength << 1)\r\n    );\r\n  }\r\n\r\n  includes(searchString: String, position: i32 = 0): bool {\r\n    return this.indexOf(searchString, position) != -1;\r\n  }\r\n\r\n  indexOf(searchString: String, position: i32 = 0): i32 {\r\n    assert(this != null);\r\n\r\n    if (searchString == null)\r\n      searchString = changetype<String>("null");\r\n\r\n    var pos: isize = position;\r\n    var len: isize = this.length;\r\n    var start: isize = min<isize>(max<isize>(pos, 0), len);\r\n    var searchLen: isize = <isize>searchString.length;\r\n\r\n    // TODO: two-way, multiple char codes\r\n    for (var k: usize = start; <isize>k + searchLen <= len; ++k)\r\n      if (!compare_memory(\r\n        changetype<usize>(this) + HEAD + (k << 1),\r\n        changetype<usize>(searchString) + HEAD,\r\n        searchLen << 1)\r\n      )\r\n        return <i32>k;\r\n    return -1;\r\n  }\r\n\r\n  startsWith(searchString: String, position: i32 = 0): bool {\r\n    assert(this != null);\r\n\r\n    if (searchString == null)\r\n      searchString = changetype<String>("null");\r\n\r\n    var pos: isize = position;\r\n    var len: isize = this.length;\r\n    var start: isize = min<isize>(max<isize>(position, 0), len);\r\n    var searchLength: isize = <isize>searchString.length;\r\n    if (searchLength + start > len)\r\n      return false;\r\n\r\n    return !compare_memory(\r\n      changetype<usize>(this) + HEAD + (start << 1),\r\n      changetype<usize>(searchString) + HEAD,\r\n      searchLength << 1\r\n    );\r\n  }\r\n\r\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\r\n    assert(this != null);\r\n\r\n    var intStart: isize = start;\r\n    var end: isize = length;\r\n    var size: isize = this.length;\r\n    if (intStart < 0)\r\n      intStart = max<isize>(size + intStart, 0);\r\n\r\n    var resultLength: isize = min<isize>(max<isize>(end, 0), size - intStart);\r\n    if (resultLength <= 0)\r\n      return EMPTY;\r\n\r\n    var out = allocate(resultLength);\r\n    move_memory(\r\n      changetype<usize>(out) + HEAD,\r\n      changetype<usize>(this) + HEAD + (intStart << 1),\r\n      <usize>resultLength << 1\r\n    );\r\n    return out;\r\n  }\r\n\r\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\r\n    assert(this != null);\r\n\r\n    var len = this.length;\r\n    var finalStart = min<i32>(max<i32>(start, 0), len);\r\n    var finalEnd = min<i32>(max<i32>(end, 0), len);\r\n    var from = min<i32>(finalStart, finalEnd);\r\n    var to = max<i32>(finalStart, finalEnd);\r\n    len = to - from;\r\n    if (!len)\r\n      return EMPTY;\r\n\r\n    if (!from && to == this.length)\r\n      return this;\r\n\r\n    var out = allocate(len);\r\n    move_memory(\r\n      changetype<usize>(out) + HEAD,\r\n      changetype<usize>(this) + HEAD + (from << 1),\r\n      len << 1\r\n    );\r\n    return out;\r\n  }\r\n\r\n  trim(): String {\r\n    assert(this != null);\r\n\r\n    var length: usize = this.length;\r\n    while (length && isWhiteSpaceOrLineTerminator(load<u16>(changetype<usize>(this) + (length << 1), HEAD)))\r\n      --length;\r\n\r\n    var start: usize = 0;\r\n    while (start < length && isWhiteSpaceOrLineTerminator(load<u16>(changetype<usize>(this) + (start << 1), HEAD)))\r\n      ++start, --length;\r\n\r\n    if (!length)\r\n      return EMPTY;\r\n\r\n    if (!start && length == this.length)\r\n      return this;\r\n\r\n    var out = allocate(length);\r\n    move_memory(\r\n      changetype<usize>(out) + HEAD,\r\n      changetype<usize>(this) + HEAD + (start << 1),\r\n      length << 1\r\n    );\r\n    return out;\r\n  }\r\n\r\n  trimLeft(): String {\r\n    assert(this != null);\r\n\r\n    var start: isize = 0;\r\n    var len: isize = this.length;\r\n    while (start < len && isWhiteSpaceOrLineTerminator(load<u16>(changetype<usize>(this) + (start << 1), HEAD)))\r\n      ++start;\r\n\r\n    if (!start)\r\n      return this;\r\n\r\n    var outLen = len - start;\r\n    if (!outLen)\r\n      return EMPTY;\r\n\r\n    var out = allocate(outLen);\r\n    move_memory(\r\n      changetype<usize>(out) + HEAD,\r\n      changetype<usize>(this) + HEAD + (start << 1),\r\n      outLen << 1\r\n    );\r\n    return out;\r\n  }\r\n\r\n  trimRight(): String {\r\n    assert(this != null);\r\n\r\n    var len: isize = this.length;\r\n    while (len > 0 && isWhiteSpaceOrLineTerminator(load<u16>(changetype<usize>(this) + (len << 1), HEAD)))\r\n      --len;\r\n\r\n    if (len <= 0)\r\n      return EMPTY;\r\n\r\n    if (<i32>len == this.length)\r\n      return this;\r\n\r\n    var out = allocate(len);\r\n    move_memory(\r\n      changetype<usize>(out) + HEAD,\r\n      changetype<usize>(this) + HEAD,\r\n      len << 1\r\n    );\r\n    return out;\r\n  }\r\n}\r\n\r\nfunction isWhiteSpaceOrLineTerminator(c: u16): bool {\r\n  switch (c) {\r\n\r\n    case 10:    // <LF>\r\n    case 13:    // <CR>\r\n    case 8232:  // <LS>\r\n    case 8233:  // <PS>\r\n\r\n    case 9:     // <TAB>\r\n    case 11:    // <VT>\r\n    case 12:    // <FF>\r\n    case 32:    // <SP>\r\n    case 160:   // <NBSP>\r\n    case 65279: // <ZWNBSP>\r\n\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\nconst enum CharCode {\r\n  PLUS = 0x2B,\r\n  MINUS = 0x2D,\r\n  DOT = 0x2E,\r\n  _0 = 0x30,\r\n  _1 = 0x31,\r\n  _2 = 0x32,\r\n  _3 = 0x33,\r\n  _4 = 0x34,\r\n  _5 = 0x35,\r\n  _6 = 0x36,\r\n  _7 = 0x37,\r\n  _8 = 0x38,\r\n  _9 = 0x39,\r\n  A = 0x41,\r\n  B = 0x42,\r\n  E = 0x45,\r\n  O = 0x4F,\r\n  X = 0x58,\r\n  Z = 0x5a,\r\n  a = 0x61,\r\n  b = 0x62,\r\n  e = 0x65,\r\n  o = 0x6F,\r\n  x = 0x78,\r\n  z = 0x7A\r\n}\r\n\r\nexport function parseInt(str: String, radix: i32 = 0): f64 {\r\n  return parse<f64>(str, radix);\r\n}\r\n\r\nexport function parseI32(str: String, radix: i32 = 0): i32 {\r\n  return parse<i32>(str, radix);\r\n}\r\n\r\nexport function parseI64(str: String, radix: i32 = 0): i64 {\r\n  return parse<i64>(str, radix);\r\n}\r\n\r\nfunction parse<T>(str: String, radix: i32 = 0): T {\r\n  var len: i32 = str.length;\r\n  if (!len)\r\n    return <T>NaN;\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <i32>load<u16>(ptr, HEAD);\r\n\r\n  // determine sign\r\n  var sign: T;\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len)\r\n      return <T>NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEAD);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len)\r\n      return <T>NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEAD);\r\n    sign = 1;\r\n  } else\r\n    sign = 1;\r\n\r\n  // determine radix\r\n  if (!radix) {\r\n    if (code == CharCode._0 && len > 2) {\r\n      switch (<i32>load<u16>(ptr + 2, HEAD)) {\r\n\r\n        case CharCode.B:\r\n        case CharCode.b:\r\n          ptr += 4; len -= 2;\r\n          radix = 2;\r\n          break;\r\n\r\n        case CharCode.O:\r\n        case CharCode.o:\r\n          ptr += 4; len -= 2;\r\n          radix = 8;\r\n          break;\r\n\r\n        case CharCode.X:\r\n        case CharCode.x:\r\n          ptr += 4; len -= 2;\r\n          radix = 16;\r\n          break;\r\n\r\n        default:\r\n          radix = 10;\r\n      }\r\n    } else radix = 10;\r\n  } else if (radix < 2 || radix > 36)\r\n    return <T>NaN;\r\n\r\n  // calculate value\r\n  var num: T = 0;\r\n  while (len--) {\r\n    code = <i32>load<u16>(ptr, HEAD);\r\n    if (code >= CharCode._0 && code <= CharCode._9)\r\n      code -= CharCode._0;\r\n    else if (code >= CharCode.A && code <= CharCode.Z)\r\n      code -= CharCode.A - 10;\r\n    else if (code >= CharCode.a && code <= CharCode.z)\r\n      code -= CharCode.a - 10;\r\n    else\r\n      break;\r\n    if (code >= radix)\r\n      break;\r\n    num = (num * radix) + code;\r\n    ptr += 2;\r\n  }\r\n  return sign * num;\r\n}\r\n\r\nexport function parseFloat(str: String): f64 {\r\n  var len: i32 = str.length;\r\n  if (!len)\r\n    return NaN;\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <i32>load<u16>(ptr, HEAD);\r\n\r\n  // determine sign\r\n  var sign: f64;\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len)\r\n      return NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEAD);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len)\r\n      return NaN;\r\n    code = <i32>load<u16>(ptr += 2, HEAD);\r\n    sign = 1;\r\n  } else\r\n    sign = 1;\r\n\r\n  // calculate value\r\n  var num: f64 = 0;\r\n  while (len--) {\r\n    code = <i32>load<u16>(ptr, HEAD);\r\n    if (code == CharCode.DOT) {\r\n      ptr += 2;\r\n      var fac: f64 = 0.1; // precision :(\r\n      while (len--) {\r\n        code = <i32>load<u16>(ptr, HEAD);\r\n        if (code == CharCode.E || code == CharCode.e)\r\n          assert(false); // TODO\r\n        code -= CharCode._0;\r\n        if (<u32>code > 9)\r\n          break;\r\n        num += <f64>code * fac;\r\n        fac *= 0.1;\r\n        ptr += 2;\r\n      }\r\n      break;\r\n    }\r\n    code -= CharCode._0;\r\n    if (<u32>code >= 10)\r\n      break;\r\n    num = (num * 10) + code;\r\n    ptr += 2;\r\n  }\r\n  return sign * num;\r\n}\r\n'};t.VERSION=m,t.main=s,t.parseArguments=n,t.checkDiagnostics=o,t.createStats=a,e.hrtime||(e.hrtime=i(15)),t.measure=l,t.printStats=u,t.createMemoryStream=function(e){var t=[];return t.write=function(t){'string'==typeof t?this.push(r.from(t,'utf8')):this.push(t),e&&e(t)},t.toBuffer=function(){return r.concat(this)},t.toString=function(){return this.toBuffer().toString('utf8')},t}}).call(t,i(0),i(5).Buffer)},function(e,t,i){'use strict';(function(e){function o(){return l.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(e,t){if(o()<t)throw new RangeError('Invalid typed array length');return l.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t),e.__proto__=l.prototype):(null===e&&(e=new l(t)),e.length=t),e}function l(e,t,i){if(!l.TYPED_ARRAY_SUPPORT&&!(this instanceof l))return new l(e,t,i);if('number'==typeof e){if('string'==typeof t)throw new Error('If encoding is specified then the first argument must be a string');return p(this,e)}return u(this,e,t,i)}function u(e,t,i,r){if('number'==typeof t)throw new TypeError('"value" argument must not be a number');return'undefined'!=typeof ArrayBuffer&&t instanceof ArrayBuffer?m(e,t,i,r):'string'==typeof t?f(e,t,i):g(e,t)}function d(e){if('number'!=typeof e)throw new TypeError('"size" argument must be a number');else if(0>e)throw new RangeError('"size" argument must not be negative')}function c(e,t,i,r){return d(t),0>=t?a(e,t):void 0===i?a(e,t):'string'==typeof r?a(e,t).fill(i,r):a(e,t).fill(i)}function p(e,t){if(d(t),e=a(e,0>t?0:0|y(t)),!l.TYPED_ARRAY_SUPPORT)for(var r=0;r<t;++r)e[r]=0;return e}function f(e,t,i){if(('string'!=typeof i||''===i)&&(i='utf8'),!l.isEncoding(i))throw new TypeError('"encoding" must be a valid string encoding');var r=0|_(t,i);e=a(e,r);var s=e.write(t,i);return s!==r&&(e=e.slice(0,s)),e}function h(e,t){var r=0>t.length?0:0|y(t.length);e=a(e,r);for(var s=0;s<r;s+=1)e[s]=255&t[s];return e}function m(e,t,i,r){if(t.byteLength,0>i||t.byteLength<i)throw new RangeError('\'offset\' is out of bounds');if(t.byteLength<i+(r||0))throw new RangeError('\'length\' is out of bounds');return t=void 0===i&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,i):new Uint8Array(t,i,r),l.TYPED_ARRAY_SUPPORT?(e=t,e.__proto__=l.prototype):e=h(e,t),e}function g(e,t){if(l.isBuffer(t)){var i=0|y(t.length);return(e=a(e,i),0===e.length)?e:(t.copy(e,0,0,i),e)}if(t){if('undefined'!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||'length'in t)return'number'!=typeof t.length||J(t.length)?a(e,0):h(e,t);if('Buffer'===t.type&&te(t.data))return h(e,t.data)}throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')}function y(e){if(e>=o())throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x'+o().toString(16)+' bytes');return 0|e}function _(e,t){if(l.isBuffer(e))return e.length;if('undefined'!=typeof ArrayBuffer&&'function'==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;'string'!=typeof e&&(e=''+e);var i=e.length;if(0===i)return 0;for(var r=!1;;)switch(t){case'ascii':case'latin1':case'binary':return i;case'utf8':case'utf-8':case void 0:return G(e).length;case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return 2*i;case'hex':return i>>>1;case'base64':return K(e).length;default:if(r)return G(e).length;t=(''+t).toLowerCase(),r=!0;}}function b(e,t,i){var r=!1;if((void 0===t||0>t)&&(t=0),t>this.length)return'';if((void 0===i||i>this.length)&&(i=this.length),0>=i)return'';if(i>>>=0,t>>>=0,i<=t)return'';for(e||(e='utf8');;)switch(e){case'hex':return D(this,t,i);case'utf8':case'utf-8':return k(this,t,i);case'ascii':return P(this,t,i);case'latin1':case'binary':return O(this,t,i);case'base64':return C(this,t,i);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return F(this,t,i);default:if(r)throw new TypeError('Unknown encoding: '+e);e=(e+'').toLowerCase(),r=!0;}}function x(e,t,r){var s=e[t];e[t]=e[r],e[r]=s}function T(e,t,i,r,s){if(0===e.length)return-1;if('string'==typeof i?(r=i,i=0):2147483647<i?i=2147483647:-2147483648>i&&(i=-2147483648),i=+i,isNaN(i)&&(i=s?0:e.length-1),0>i&&(i=e.length+i),i>=e.length){if(s)return-1;i=e.length-1}else if(0>i)if(s)i=0;else return-1;if('string'==typeof t&&(t=l.from(t,r)),l.isBuffer(t))return 0===t.length?-1:v(e,t,i,r,s);if('number'==typeof t)return t&=255,l.TYPED_ARRAY_SUPPORT&&'function'==typeof Uint8Array.prototype.indexOf?s?Uint8Array.prototype.indexOf.call(e,t,i):Uint8Array.prototype.lastIndexOf.call(e,t,i):v(e,[t],i,r,s);throw new TypeError('val must be string, number or Buffer')}function v(e,t,r,s,n){function o(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}var a=1,l=e.length,u=t.length;if(void 0!==s&&(s=(s+'').toLowerCase(),'ucs2'===s||'ucs-2'===s||'utf16le'===s||'utf-16le'===s)){if(2>e.length||2>t.length)return-1;a=2,l/=2,u/=2,r/=2}var d;if(n){var i=-1;for(d=r;d<l;d++)if(o(e,d)!==o(t,-1==i?0:d-i))-1!=i&&(d-=d-i),i=-1;else if(-1==i&&(i=d),d-i+1===u)return i*a}else for(r+u>l&&(r=l-u),d=r;0<=d;d--){for(var c=!0,p=0;p<u;p++)if(o(e,d+p)!==o(t,p)){c=!1;break}if(c)return d}return-1}function z(e,t,r,s){r=+r||0;var n=e.length-r;s?(s=+s,s>n&&(s=n)):s=n;var o=t.length;if(0!=o%2)throw new TypeError('Invalid hex string');s>o/2&&(s=o/2);for(var a,l=0;l<s;++l){if(a=parseInt(t.substr(2*l,2),16),isNaN(a))return l;e[r+l]=a}return l}function E(e,t,i,r){return Z(G(t,e.length-i),e,i,r)}function A(e,t,i,r){return Z(W(t),e,i,r)}function w(e,t,i,r){return A(e,t,i,r)}function S(e,t,i,r){return Z(K(t),e,i,r)}function L(e,t,i,r){return Z(q(t,e.length-i),e,i,r)}function C(e,t,i){return 0===t&&i===e.length?$.fromByteArray(e):$.fromByteArray(e.slice(t,i))}function k(e,t,r){r=s(e.length,r);for(var n=[],o=t;o<r;){var i=e[o],a=null,l=239<i?4:223<i?3:191<i?2:1;if(o+l<=r){var u,d,c,p;1==l?128>i&&(a=i):2==l?(u=e[o+1],128==(192&u)&&(p=(31&i)<<6|63&u,127<p&&(a=p))):3==l?(u=e[o+1],d=e[o+2],128==(192&u)&&128==(192&d)&&(p=(15&i)<<12|(63&u)<<6|63&d,2047<p&&(55296>p||57343<p)&&(a=p))):4==l?(u=e[o+1],d=e[o+2],c=e[o+3],128==(192&u)&&128==(192&d)&&128==(192&c)&&(p=(15&i)<<18|(63&u)<<12|(63&d)<<6|63&c,65535<p&&1114112>p&&(a=p))):void 0}null===a?(a=65533,l=1):65535<a&&(a-=65536,n.push(55296|1023&a>>>10),a=56320|1023&a),n.push(a),o+=l}return I(n)}function I(e){var t=e.length;if(t<=ie)return Q.apply(String,e);for(var r='',s=0;s<t;)r+=Q.apply(String,e.slice(s,s+=ie));return r}function P(e,t,r){var n='';r=s(e.length,r);for(var o=t;o<r;++o)n+=Q(127&e[o]);return n}function O(e,t,r){var n='';r=s(e.length,r);for(var o=t;o<r;++o)n+=Q(e[o]);return n}function D(e,t,r){var s=e.length;(!t||0>t)&&(t=0),(!r||0>r||r>s)&&(r=s);for(var n='',o=t;o<r;++o)n+=X(e[o]);return n}function F(e,t,r){for(var s=e.slice(t,r),n='',o=0;o<s.length;o+=2)n+=Q(s[o]+256*s[o+1]);return n}function U(e,t,i){if(0!=e%1||0>e)throw new RangeError('offset is not uint');if(e+t>i)throw new RangeError('Trying to access beyond buffer length')}function R(e,t,i,r,s,n){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>s||t<n)throw new RangeError('"value" argument is out of bounds');if(i+r>e.length)throw new RangeError('Index out of range')}function N(e,t,r,n){0>t&&(t=65535+t+1);for(var o=0,i=s(e.length-r,2);o<i;++o)e[r+o]=(t&255<<8*(n?o:1-o))>>>8*(n?o:1-o)}function M(e,t,r,n){0>t&&(t=4294967295+t+1);for(var o=0,i=s(e.length-r,4);o<i;++o)e[r+o]=255&t>>>8*(n?o:3-o)}function B(e,t,i,r){if(i+r>e.length)throw new RangeError('Index out of range');if(0>i)throw new RangeError('Index out of range')}function j(e,t,i,r,s){return s||B(e,t,i,4,34028234663852886e22,-34028234663852886e22),ee.write(e,t,i,r,23,4),i+4}function H(e,t,i,r,s){return s||B(e,t,i,8,17976931348623157e292,-17976931348623157e292),ee.write(e,t,i,r,52,8),i+8}function Y(e){if(e=V(e).replace(re,''),2>e.length)return'';for(;0!=e.length%4;)e+='=';return e}function V(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,'')}function X(e){return 16>e?'0'+e.toString(16):e.toString(16)}function G(e,t){t=t||Infinity;for(var r,s=e.length,n=null,o=[],a=0;a<s;++a){if(r=e.charCodeAt(a),55295<r&&57344>r){if(!n){if(56319<r){-1<(t-=3)&&o.push(239,191,189);continue}else if(a+1===s){-1<(t-=3)&&o.push(239,191,189);continue}n=r;continue}if(56320>r){-1<(t-=3)&&o.push(239,191,189),n=r;continue}r=(n-55296<<10|r-56320)+65536}else n&&-1<(t-=3)&&o.push(239,191,189);if(n=null,128>r){if(0>(t-=1))break;o.push(r)}else if(2048>r){if(0>(t-=2))break;o.push(192|r>>6,128|63&r)}else if(65536>r){if(0>(t-=3))break;o.push(224|r>>12,128|63&r>>6,128|63&r)}else if(1114112>r){if(0>(t-=4))break;o.push(240|r>>18,128|63&r>>12,128|63&r>>6,128|63&r)}else throw new Error('Invalid code point')}return o}function W(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}function q(e,t){for(var r,s,n,o=[],a=0;a<e.length&&!(0>(t-=2));++a)r=e.charCodeAt(a),s=r>>8,n=r%256,o.push(n),o.push(s);return o}function K(e){return $.toByteArray(Y(e))}function Z(e,t,r,s){for(var n=0;n<s&&!(n+r>=t.length||n>=e.length);++n)t[n+r]=e[n];return n}function J(e){return e!==e}var Q=String.fromCharCode,$=i(6),ee=i(7),te=i(8);/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */t.Buffer=l,t.SlowBuffer=function(e){return+e!=e&&(e=0),l.alloc(+e)},t.INSPECT_MAX_BYTES=50,l.TYPED_ARRAY_SUPPORT=e.TYPED_ARRAY_SUPPORT===void 0?function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&'function'==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(t){return!1}}():e.TYPED_ARRAY_SUPPORT,t.kMaxLength=o(),l.poolSize=8192,l._augment=function(e){return e.__proto__=l.prototype,e},l.from=function(e,t,i){return u(null,e,t,i)},l.TYPED_ARRAY_SUPPORT&&(l.prototype.__proto__=Uint8Array.prototype,l.__proto__=Uint8Array,'undefined'!=typeof Symbol&&Symbol.species&&l[Symbol.species]===l&&Object.defineProperty(l,Symbol.species,{value:null,configurable:!0})),l.alloc=function(e,t,i){return c(null,e,t,i)},l.allocUnsafe=function(e){return p(null,e)},l.allocUnsafeSlow=function(e){return p(null,e)},l.isBuffer=function(e){return!!(null!=e&&e._isBuffer)},l.compare=function(e,t){if(!l.isBuffer(e)||!l.isBuffer(t))throw new TypeError('Arguments must be Buffers');if(e===t)return 0;for(var r=e.length,n=t.length,o=0,i=s(r,n);o<i;++o)if(e[o]!==t[o]){r=e[o],n=t[o];break}return r<n?-1:n<r?1:0},l.isEncoding=function(e){switch((e+'').toLowerCase()){case'hex':case'utf8':case'utf-8':case'ascii':case'latin1':case'binary':case'base64':case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return!0;default:return!1;}},l.concat=function(e,t){if(!te(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);var r;if(t===void 0)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var i=l.allocUnsafe(t),s=0;for(r=0;r<e.length;++r){var n=e[r];if(!l.isBuffer(n))throw new TypeError('"list" argument must be an Array of Buffers');n.copy(i,s),s+=n.length}return i},l.byteLength=_,l.prototype._isBuffer=!0,l.prototype.swap16=function(){var e=this.length;if(0!=e%2)throw new RangeError('Buffer size must be a multiple of 16-bits');for(var t=0;t<e;t+=2)x(this,t,t+1);return this},l.prototype.swap32=function(){var e=this.length;if(0!=e%4)throw new RangeError('Buffer size must be a multiple of 32-bits');for(var t=0;t<e;t+=4)x(this,t,t+3),x(this,t+1,t+2);return this},l.prototype.swap64=function(){var e=this.length;if(0!=e%8)throw new RangeError('Buffer size must be a multiple of 64-bits');for(var t=0;t<e;t+=8)x(this,t,t+7),x(this,t+1,t+6),x(this,t+2,t+5),x(this,t+3,t+4);return this},l.prototype.toString=function(){var e=0|this.length;return 0==e?'':0===arguments.length?k(this,0,e):b.apply(this,arguments)},l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError('Argument must be a Buffer');return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){var e='',i=t.INSPECT_MAX_BYTES;return 0<this.length&&(e=this.toString('hex',0,i).match(/.{2}/g).join(' '),this.length>i&&(e+=' ... ')),'<Buffer '+e+'>'},l.prototype.compare=function(e,t,r,n,o){if(!l.isBuffer(e))throw new TypeError('Argument must be a Buffer');if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===o&&(o=this.length),0>t||r>e.length||0>n||o>this.length)throw new RangeError('out of range index');if(n>=o&&t>=r)return 0;if(n>=o)return-1;if(t>=r)return 1;if(t>>>=0,r>>>=0,n>>>=0,o>>>=0,this===e)return 0;for(var a=o-n,u=r-t,d=s(a,u),c=this.slice(n,o),p=e.slice(t,r),f=0;f<d;++f)if(c[f]!==p[f]){a=c[f],u=p[f];break}return a<u?-1:u<a?1:0},l.prototype.includes=function(e,t,i){return-1!==this.indexOf(e,t,i)},l.prototype.indexOf=function(e,t,i){return T(this,e,t,i,!0)},l.prototype.lastIndexOf=function(e,t,i){return T(this,e,t,i,!1)},l.prototype.write=function(e,t,i,r){if(void 0===t)r='utf8',i=this.length,t=0;else if(void 0===i&&'string'==typeof t)r=t,i=this.length,t=0;else if(isFinite(t))t|=0,isFinite(i)?(i|=0,void 0===r&&(r='utf8')):(r=i,i=void 0);else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');var s=this.length-t;if((void 0===i||i>s)&&(i=s),0<e.length&&(0>i||0>t)||t>this.length)throw new RangeError('Attempt to write outside buffer bounds');r||(r='utf8');for(var n=!1;;)switch(r){case'hex':return z(this,e,t,i);case'utf8':case'utf-8':return E(this,e,t,i);case'ascii':return A(this,e,t,i);case'latin1':case'binary':return w(this,e,t,i);case'base64':return S(this,e,t,i);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return L(this,e,t,i);default:if(n)throw new TypeError('Unknown encoding: '+r);r=(''+r).toLowerCase(),n=!0;}},l.prototype.toJSON=function(){return{type:'Buffer',data:Array.prototype.slice.call(this._arr||this,0)}};var ie=4096;l.prototype.slice=function(e,t){var r=this.length;e=~~e,t=t===void 0?r:~~t,0>e?(e+=r,0>e&&(e=0)):e>r&&(e=r),0>t?(t+=r,0>t&&(t=0)):t>r&&(t=r),t<e&&(t=e);var s;if(l.TYPED_ARRAY_SUPPORT)s=this.subarray(e,t),s.__proto__=l.prototype;else{var n=t-e;s=new l(n,void 0);for(var o=0;o<n;++o)s[o]=this[o+e]}return s},l.prototype.readUIntLE=function(e,t,r){e|=0,t|=0,r||U(e,t,this.length);for(var s=this[e],n=1,o=0;++o<t&&(n*=256);)s+=this[e+o]*n;return s},l.prototype.readUIntBE=function(e,t,i){e|=0,t|=0,i||U(e,t,this.length);for(var r=this[e+--t],s=1;0<t&&(s*=256);)r+=this[e+--t]*s;return r},l.prototype.readUInt8=function(e,t){return t||U(e,1,this.length),this[e]},l.prototype.readUInt16LE=function(e,t){return t||U(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUInt16BE=function(e,t){return t||U(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUInt32LE=function(e,t){return t||U(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUInt32BE=function(e,t){return t||U(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readIntLE=function(e,t,r){e|=0,t|=0,r||U(e,t,this.length);for(var s=this[e],o=1,a=0;++a<t&&(o*=256);)s+=this[e+a]*o;return o*=128,s>=o&&(s-=n(2,8*t)),s},l.prototype.readIntBE=function(e,t,r){e|=0,t|=0,r||U(e,t,this.length);for(var s=t,i=1,o=this[e+--s];0<s&&(i*=256);)o+=this[e+--s]*i;return i*=128,o>=i&&(o-=n(2,8*t)),o},l.prototype.readInt8=function(e,t){return t||U(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,t){t||U(e,2,this.length);var i=this[e]|this[e+1]<<8;return 32768&i?4294901760|i:i},l.prototype.readInt16BE=function(e,t){t||U(e,2,this.length);var i=this[e+1]|this[e]<<8;return 32768&i?4294901760|i:i},l.prototype.readInt32LE=function(e,t){return t||U(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,t){return t||U(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readFloatLE=function(e,t){return t||U(e,4,this.length),ee.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,t){return t||U(e,4,this.length),ee.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,t){return t||U(e,8,this.length),ee.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,t){return t||U(e,8,this.length),ee.read(this,e,!1,52,8)},l.prototype.writeUIntLE=function(e,t,r,s){if(e=+e,t|=0,r|=0,!s){var o=n(2,8*r)-1;R(this,e,t,r,o,0)}var a=1,l=0;for(this[t]=255&e;++l<r&&(a*=256);)this[t+l]=255&e/a;return t+r},l.prototype.writeUIntBE=function(e,t,r,s){if(e=+e,t|=0,r|=0,!s){var o=n(2,8*r)-1;R(this,e,t,r,o,0)}var a=r-1,i=1;for(this[t+a]=255&e;0<=--a&&(i*=256);)this[t+a]=255&e/i;return t+r},l.prototype.writeUInt8=function(e,t,i){return e=+e,t|=0,i||R(this,e,t,1,255,0),l.TYPED_ARRAY_SUPPORT||(e=r(e)),this[t]=255&e,t+1},l.prototype.writeUInt16LE=function(e,t,i){return e=+e,t|=0,i||R(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):N(this,e,t,!0),t+2},l.prototype.writeUInt16BE=function(e,t,i){return e=+e,t|=0,i||R(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):N(this,e,t,!1),t+2},l.prototype.writeUInt32LE=function(e,t,i){return e=+e,t|=0,i||R(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):M(this,e,t,!0),t+4},l.prototype.writeUInt32BE=function(e,t,i){return e=+e,t|=0,i||R(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):M(this,e,t,!1),t+4},l.prototype.writeIntLE=function(e,t,r,s){if(e=+e,t|=0,!s){var o=n(2,8*r-1);R(this,e,t,r,o-1,-o)}var a=0,i=1,l=0;for(this[t]=255&e;++a<r&&(i*=256);)0>e&&0==l&&0!==this[t+a-1]&&(l=1),this[t+a]=255&(e/i>>0)-l;return t+r},l.prototype.writeIntBE=function(e,t,r,s){if(e=+e,t|=0,!s){var o=n(2,8*r-1);R(this,e,t,r,o-1,-o)}var a=r-1,i=1,l=0;for(this[t+a]=255&e;0<=--a&&(i*=256);)0>e&&0==l&&0!==this[t+a+1]&&(l=1),this[t+a]=255&(e/i>>0)-l;return t+r},l.prototype.writeInt8=function(e,t,i){return e=+e,t|=0,i||R(this,e,t,1,127,-128),l.TYPED_ARRAY_SUPPORT||(e=r(e)),0>e&&(e=255+e+1),this[t]=255&e,t+1},l.prototype.writeInt16LE=function(e,t,i){return e=+e,t|=0,i||R(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):N(this,e,t,!0),t+2},l.prototype.writeInt16BE=function(e,t,i){return e=+e,t|=0,i||R(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):N(this,e,t,!1),t+2},l.prototype.writeInt32LE=function(e,t,i){return e=+e,t|=0,i||R(this,e,t,4,2147483647,-2147483648),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):M(this,e,t,!0),t+4},l.prototype.writeInt32BE=function(e,t,i){return e=+e,t|=0,i||R(this,e,t,4,2147483647,-2147483648),0>e&&(e=4294967295+e+1),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):M(this,e,t,!1),t+4},l.prototype.writeFloatLE=function(e,t,i){return j(this,e,t,!0,i)},l.prototype.writeFloatBE=function(e,t,i){return j(this,e,t,!1,i)},l.prototype.writeDoubleLE=function(e,t,i){return H(this,e,t,!0,i)},l.prototype.writeDoubleBE=function(e,t,i){return H(this,e,t,!1,i)},l.prototype.copy=function(e,t,r,s){if(r||(r=0),s||0===s||(s=this.length),t>=e.length&&(t=e.length),t||(t=0),0<s&&s<r&&(s=r),s===r)return 0;if(0===e.length||0===this.length)return 0;if(0>t)throw new RangeError('targetStart out of bounds');if(0>r||r>=this.length)throw new RangeError('sourceStart out of bounds');if(0>s)throw new RangeError('sourceEnd out of bounds');s>this.length&&(s=this.length),e.length-t<s-r&&(s=e.length-t+r);var n,i=s-r;if(this===e&&r<t&&t<s)for(n=i-1;0<=n;--n)e[n+t]=this[n+r];else if(1e3>i||!l.TYPED_ARRAY_SUPPORT)for(n=0;n<i;++n)e[n+t]=this[n+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+i),t);return i},l.prototype.fill=function(e,t,r,s){if('string'==typeof e){if('string'==typeof t?(s=t,t=0,r=this.length):'string'==typeof r&&(s=r,r=this.length),1===e.length){var n=e.charCodeAt(0);256>n&&(e=n)}if(void 0!==s&&'string'!=typeof s)throw new TypeError('encoding must be a string');if('string'==typeof s&&!l.isEncoding(s))throw new TypeError('Unknown encoding: '+s)}else'number'==typeof e&&(e&=255);if(0>t||this.length<t||this.length<r)throw new RangeError('Out of range index');if(r<=t)return this;t>>>=0,r=r===void 0?this.length:r>>>0,e||(e=0);var o;if('number'==typeof e)for(o=t;o<r;++o)this[o]=e;else{var i=l.isBuffer(e)?e:G(new l(e,s).toString()),a=i.length;for(o=0;o<r-t;++o)this[o+t]=i[o%a]}return this};var re=/[^+\/0-9A-Za-z-_]/g}).call(t,i(2))},function(e,t){'use strict';function r(e){var t=e.length;if(0<t%4)throw new Error('Invalid string. Length must be a multiple of 4');return'='===e[t-2]?2:'='===e[t-1]?1:0}function s(e){var t,i,s,n,o,a=e.length;n=r(e),o=new d(3*a/4-n),i=0<n?a-4:a;var l=0;for(t=0;t<i;t+=4)s=u[e.charCodeAt(t)]<<18|u[e.charCodeAt(t+1)]<<12|u[e.charCodeAt(t+2)]<<6|u[e.charCodeAt(t+3)],o[l++]=255&s>>16,o[l++]=255&s>>8,o[l++]=255&s;return 2===n?(s=u[e.charCodeAt(t)]<<2|u[e.charCodeAt(t+1)]>>4,o[l++]=255&s):1===n&&(s=u[e.charCodeAt(t)]<<10|u[e.charCodeAt(t+1)]<<4|u[e.charCodeAt(t+2)]>>2,o[l++]=255&s>>8,o[l++]=255&s),o}function n(e){return l[63&e>>18]+l[63&e>>12]+l[63&e>>6]+l[63&e]}function o(e,t,r){for(var s,o=[],a=t;a<r;a+=3)s=(e[a]<<16)+(e[a+1]<<8)+e[a+2],o.push(n(s));return o.join('')}function a(e){for(var t,r=e.length,s=r%3,n='',a=[],u=16383,d=0,i=r-s;d<i;d+=u)a.push(o(e,d,d+u>i?i:d+u));return 1==s?(t=e[r-1],n+=l[t>>2],n+=l[63&t<<4],n+='=='):2==s&&(t=(e[r-2]<<8)+e[r-1],n+=l[t>>10],n+=l[63&t>>4],n+=l[63&t<<2],n+='='),a.push(n),a.join('')}t.byteLength=function(e){return 3*e.length/4-r(e)},t.toByteArray=s,t.fromByteArray=a;for(var l=[],u=[],d='undefined'==typeof Uint8Array?Array:Uint8Array,c='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',p=0,i=c.length;p<i;++p)l[p]=c[p],u[c.charCodeAt(p)]=p;u[45]=62,u[95]=63},function(e,t){t.read=function(t,r,o,a,l){var u,e,c=8*l-a-1,p=(1<<c)-1,f=p>>1,h=-7,m=o?l-1:0,i=o?-1:1,d=t[r+m];for(m+=i,u=d&(1<<-h)-1,d>>=-h,h+=c;0<h;u=256*u+t[r+m],m+=i,h-=8);for(e=u&(1<<-h)-1,u>>=-h,h+=a;0<h;e=256*e+t[r+m],m+=i,h-=8);if(0===u)u=1-f;else{if(u===p)return e?NaN:(d?-1:1)*Infinity;e+=n(2,a),u-=f}return(d?-1:1)*e*n(2,u-a)},t.write=function(t,o,a,l,u,p){var f,h,m,c=8*p-u-1,g=(1<<c)-1,y=g>>1,_=23===u?5.960464477539063e-8-6.617444900424222e-24:0,b=l?0:p-1,i=l?1:-1,d=0>o||0===o&&0>1/o?1:0;for(o=Math.abs(o),isNaN(o)||o===Infinity?(h=isNaN(o)?1:0,f=g):(f=r(Math.log(o)/Math.LN2),1>o*(m=n(2,-f))&&(f--,m*=2),o+=1<=f+y?_/m:_*n(2,1-y),2<=o*m&&(f++,m/=2),f+y>=g?(h=0,f=g):1<=f+y?(h=(o*m-1)*n(2,u),f+=y):(h=o*n(2,y-1)*n(2,u),f=0));8<=u;t[a+b]=255&h,b+=i,h/=256,u-=8);for(f=f<<u|h,c+=u;0<c;t[a+b]=255&f,b+=i,f/=256,c-=8);t[a+b-i]|=128*d}},function(e){var t={}.toString;e.exports=Array.isArray||function(e){return'[object Array]'==t.call(e)}},function(){},function(e,t){var i=Number.MAX_VALUE;t.endianness=function(){return'LE'},t.hostname=function(){return'undefined'==typeof location?'':location.hostname},t.loadavg=function(){return[]},t.uptime=function(){return 0},t.freemem=function(){return i},t.totalmem=function(){return i},t.cpus=function(){return[]},t.type=function(){return'Browser'},t.release=function(){return'undefined'==typeof navigator?'':navigator.appVersion},t.networkInterfaces=t.getNetworkInterfaces=function(){return{}},t.arch=function(){return'javascript'},t.platform=function(){return'browser'},t.tmpdir=t.tmpDir=function(){return'/tmp'},t.EOL='\n',t.homedir=function(){return'/'}},function(i){if('undefined'==typeof t){var r=new Error('Cannot find module "undefined"');throw r.code='MODULE_NOT_FOUND',r}i.exports=t},function(t){t.exports=e},function(e){e.exports={version:{desc:'Prints just the compiler\'s version and exits.',type:'boolean',aliases:['v']},help:{desc:'Prints this message and exits.',type:'boolean',aliases:['h']},optimize:{desc:['Optimizes the module. Also accepts the optimize level:','',' -O     Uses defaults. Equivalent to -O2s',' -O0    Equivalent to --optimizeLevel 0',' -O1    Equivalent to --optimizeLevel 1',' -O2    Equivalent to --optimizeLevel 2',' -O3    Equivalent to --optimizeLevel 3',' -Oz    Equivalent to -O but with --shrinkLevel 2',' -O3s   Equivalent to -O3 with --shrinkLevel 1 etc.',''],type:'boolean',aliases:['O']},optimizeLevel:{desc:'How much to focus on optimizing code. [0-3]',type:'number'},shrinkLevel:{desc:'How much to focus on shrinking code size. [0-2, s=1, z=2]',type:'number'},validate:{desc:'Validates the module using Binaryen. Exits if invalid.',type:'boolean',aliases:['c','check']},baseDir:{desc:'Specifies the base directory of input and output files.',type:'string'},outFile:{desc:'Specifies the output file. File extension indicates format.',type:'string',aliases:['o']},binaryFile:{desc:'Specifies the binary output file (.wasm).',type:'string',aliases:['b']},textFile:{desc:'Specifies the text output file (.wast).',type:'string',aliases:['t']},asmjsFile:{desc:'Specifies the asm.js output file (.js).',type:'string',aliases:['a']},sourceMap:{desc:['Enables source map generation. Optionally takes the URL','used to reference the source map from the binary file.'],type:'string'},noTreeShaking:{desc:'Disables compiler-level tree-shaking, compiling everything.',type:'boolean'},noDebug:{desc:'Disables maintaining of debug information in binaries.',type:'boolean'},noAssert:{desc:'Replaces assertions with just their value without trapping.',type:'boolean'},noEmit:{desc:'Performs compilation as usual but does not emit code.',type:'boolean'},noMemory:{desc:'Does not set up a memory. Useful for low-level WebAssembly.',type:'boolean'},noLib:{desc:'Does not include the shipped standard library.',type:'boolean'},lib:{desc:['Adds one or multiple paths to custom library components and','uses exports of all top-level files at this path as globals.'],type:'string'},trapMode:{desc:['Sets the trap mode to use.','',' allow  Allow trapping operations. This is the default.',' clamp  Replace trapping operations with clamping semantics.',' js     Replace trapping operations with JS semantics.',''],type:'string',default:'allow'},runPasses:{desc:['Specifies additional Binaryen passes to run after other','optimizations, if any. See: Binaryen/src/passes/pass.cpp'],type:'string'},measure:{desc:'Prints measuring information on I/O and compile times.',type:'boolean'}}},function(e){function t(e,t){var i=e;t.slice(0,-1).forEach(function(e){i=i[e]||{}});var r=t[t.length-1];return r in i}function r(e){return!('number'!=typeof e)||!!/^0x[0-9a-f]+$/i.test(e)||/^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(e)}e.exports=function(e,s){function n(e,t){return u.allBools&&/^--[^=]+$/.test(t)||u.strings[e]||u.bools[e]||d[e]}function o(e,t,i){if(!(i&&u.unknownFn&&!n(e,i)&&!1===u.unknownFn(i))){var s=!u.strings[e]&&r(t)?+t:t;a(p,e.split('.'),s),(d[e]||[]).forEach(function(e){a(p,e.split('.'),s)})}}function a(e,t,i){var r=e;t.slice(0,-1).forEach(function(e){void 0===r[e]&&(r[e]={}),r=r[e]});var s=t[t.length-1];void 0===r[s]||u.bools[s]||'boolean'==typeof r[s]?r[s]=i:Array.isArray(r[s])?r[s].push(i):r[s]=[r[s],i]}function l(e){return d[e].some(function(e){return u.bools[e]})}s||(s={});var u={bools:{},strings:{},unknownFn:null};'function'==typeof s.unknown&&(u.unknownFn=s.unknown),'boolean'==typeof s.boolean&&s.boolean?u.allBools=!0:[].concat(s.boolean).filter(Boolean).forEach(function(e){u.bools[e]=!0});var d={};Object.keys(s.alias||{}).forEach(function(e){d[e]=[].concat(s.alias[e]),d[e].forEach(function(t){d[t]=[e].concat(d[e].filter(function(e){return t!==e}))})}),[].concat(s.string).filter(Boolean).forEach(function(e){u.strings[e]=!0,d[e]&&(u.strings[d[e]]=!0)});var c=s['default']||{},p={_:[]};Object.keys(u.bools).forEach(function(e){o(e,void 0!==c[e]&&c[e])});var f=[];-1!==e.indexOf('--')&&(f=e.slice(e.indexOf('--')+1),e=e.slice(0,e.indexOf('--')));for(var h,g=0;g<e.length;g++)if(h=e[g],/^--.+=/.test(h)){var i=h.match(/^--([^=]+)=([\s\S]*)$/),m=i[1],y=i[2];u.bools[m]&&(y='false'!==y),o(m,y,h)}else if(/^--no-.+/.test(h)){var m=h.match(/^--no-(.+)/)[1];o(m,!1,h)}else if(/^--.+/.test(h)){var m=h.match(/^--(.+)/)[1],_=e[g+1];void 0===_||/^-/.test(_)||u.bools[m]||u.allBools||!!d[m]&&!!l(m)?/^(true|false)$/.test(_)?(o(m,'true'===_,h),g++):o(m,!u.strings[m]||'',h):(o(m,_,h),g++)}else if(/^-[^-]+/.test(h)){for(var _,b=h.slice(1,-1).split(''),x=!1,T=0;T<b.length;T++){if(_=h.slice(T+2),'-'===_){o(b[T],_,h);continue}if(/[A-Za-z]/.test(b[T])&&/=/.test(_)){o(b[T],_.split('=')[1],h),x=!0;break}if(/[A-Za-z]/.test(b[T])&&/-?\d+(\.\d*)?(e-?\d+)?$/.test(_)){o(b[T],_,h),x=!0;break}if(b[T+1]&&b[T+1].match(/\W/)){o(b[T],h.slice(T+2),h),x=!0;break}else o(b[T],!u.strings[b[T]]||'',h)}var m=h.slice(-1)[0];x||'-'===m||(!e[g+1]||/^(-|--)[^-]/.test(e[g+1])||u.bools[m]||d[m]&&l(m)?e[g+1]&&/true|false/.test(e[g+1])?(o(m,'true'===e[g+1],h),g++):o(m,!u.strings[m]||'',h):(o(m,e[g+1],h),g++))}else if(u.unknownFn&&!1===u.unknownFn(h)||p._.push(u.strings._||!r(h)?h:+h),s.stopEarly){p._.push.apply(p._,e.slice(g+1));break}return Object.keys(c).forEach(function(e){t(p,e.split('.'))||(a(p,e.split('.'),c[e]),(d[e]||[]).forEach(function(t){a(p,t.split('.'),c[e])}))}),s['--']?(p['--']=[],f.forEach(function(e){p['--'].push(e)})):f.forEach(function(e){p._.push(e)}),p}},function(e,t,i){(function(t,i){e.exports=t.hrtime||function(e){var t=1e-3*n.call(s),i=r(t),o=r(1e9*(t%1));return e&&(i-=e[0],o-=e[1],0>o&&(i--,o+=1e9)),[i,o]};var s=i.performance||{},n=s.now||s.mozNow||s.msNow||s.oNow||s.webkitNow||function(){return new Date().getTime()}}).call(t,i(0),i(2))}])});