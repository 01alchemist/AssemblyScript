(function(e,t){'object'==typeof exports&&'object'==typeof module?module.exports=t(function(){try{return require('assemblyscript')}catch(t){}}(),require('./assemblyscript')):'function'==typeof define&&define.amd?define(['assemblyscript'],t):'object'==typeof exports?exports.asc=t(function(){try{return require('assemblyscript')}catch(t){}}(),require('./assemblyscript')):e.asc=t(e._,e[void 0])})('undefined'==typeof self?this:self,function(t,e){var r=Math.floor,n=Math.pow,s=Math.min;return function(e){function t(r){if(i[r])return i[r].exports;var n=i[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,t),n.l=!0,n.exports}var i={};return t.m=e,t.c=i,t.d=function(e,i,r){t.o(e,i)||Object.defineProperty(e,i,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var i=e&&e.__esModule?function(){return e['default']}:function(){return e};return t.d(i,'a',i),i},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p='',t(t.s=3)}([function(e,t,i){t.nextTick=function(e){setTimeout(e,0)},t.platform=t.arch=t.execPath=t.title='browser',t.pid=1,t.browser=!0,t.env={},t.argv=[],t.binding=function(){throw new Error('No such module. (Possibly not yet loaded)')},function(){var e,r='/';t.cwd=function(){return r},t.chdir=function(t){e||(e=i(1)),r=e.resolve(t,r)}}(),t.exit=t.kill=t.umask=t.dlopen=t.uptime=t.memoryUsage=t.uvCounters=function(){},t.features={}},function(e,t,i){(function(e){function r(e,t){for(var r,n=0,s=e.length-1;0<=s;s--)r=e[s],'.'===r?e.splice(s,1):'..'===r?(e.splice(s,1),n++):n&&(e.splice(s,1),n--);if(t)for(;n--;n)e.unshift('..');return e}function n(e,t){if(e.filter)return e.filter(t);for(var r=[],n=0;n<e.length;n++)t(e[n],n,e)&&r.push(e[n]);return r}var i=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,o=function(e){return i.exec(e).slice(1)};t.resolve=function(){for(var t,s='',o=!1,a=arguments.length-1;-1<=a&&!o;a--){if(t=0<=a?arguments[a]:e.cwd(),'string'!=typeof t)throw new TypeError('Arguments to path.resolve must be strings');else if(!t)continue;s=t+'/'+s,o='/'===t.charAt(0)}return s=r(n(s.split('/'),function(e){return!!e}),!o).join('/'),(o?'/':'')+s||'.'},t.normalize=function(e){var i=t.isAbsolute(e),s='/'===a(e,-1);return e=r(n(e.split('/'),function(e){return!!e}),!i).join('/'),e||i||(e='.'),e&&s&&(e+='/'),(i?'/':'')+e},t.isAbsolute=function(e){return'/'===e.charAt(0)},t.join=function(){var e=Array.prototype.slice.call(arguments,0);return t.normalize(n(e,function(e){if('string'!=typeof e)throw new TypeError('Arguments to path.join must be strings');return e}).join('/'))},t.relative=function(e,r){function n(e){for(var t=0;t<e.length&&''===e[t];t++);for(var i=e.length-1;0<=i&&''===e[i];i--);return t>i?[]:e.slice(t,i-t+1)}e=t.resolve(e).substr(1),r=t.resolve(r).substr(1);for(var o=n(e.split('/')),a=n(r.split('/')),l=s(o.length,a.length),u=l,c=0;c<l;c++)if(o[c]!==a[c]){u=c;break}for(var i=[],c=u;c<o.length;c++)i.push('..');return i=i.concat(a.slice(u)),i.join('/')},t.sep='/',t.delimiter=':',t.dirname=function(e){var t=o(e),i=t[0],r=t[1];return i||r?(r&&(r=r.substr(0,r.length-1)),i+r):'.'},t.basename=function(e,t){var i=o(e)[2];return t&&i.substr(-1*t.length)===t&&(i=i.substr(0,i.length-t.length)),i},t.extname=function(e){return o(e)[3]};var a=function(e,t,i){return e.substr(t,i)}}).call(t,i(0))},function(e){var t=function(){return this}();try{t=t||Function('return this')()||(1,eval)('this')}catch(i){'object'==typeof window&&(t=window)}e.exports=t},function(e,t,i){e.exports=i(4)},function(e,t,i){(function(e,r){function n(t,r,n){function m(e){try{var t;return I.readCount++,I.readTime+=l(()=>{t=d.readFileSync(e,{encoding:'utf8'})}),t}catch(t){return null}}function h(e,t){try{return I.writeCount++,I.writeTime+=l(()=>d.writeFileSync(e,t,'string'==typeof t?{encoding:'utf8'}:void 0)),!0}catch(t){return!1}}function z(e){var t;try{return I.readTime+=l(()=>{t=i(!function(){var t=new Error('Cannot find module "glob"');throw t.code='MODULE_NOT_FOUND',t}()).sync('*.ts',{cwd:e})}),t}catch(t){return[]}}function A(e){A.used||(I.writeCount++,A.used=!0),I.writeTime+=l(()=>E.write(e,'string'==typeof e?{encoding:'utf8'}:void 0))}'function'==typeof r?(n=r,r={}):!r&&(r={});const E=r.stdout||e.stdout,w=r.stderr||e.stderr,L=r.readFile||m,S=r.writeFile||h,C=r.listFiles||z,I=r.stats||a();if(!E)throw Error('\'options.stdout\' must be specified');if(!w)throw Error('\'options.stderr\' must be specified');if(!d.readFileSync){if(L===m)throw Error('\'options.readFile\' must be specified');if(S===h)throw Error('\'options.writeFile\' must be specified');if(C===z)throw Error('\'options.listFiles\' must be specified')}const N=s(t),k=24;if(n||(n=function(e){var t=0;return e&&(w.write(e.stack+f.EOL),t=1),t}),N.version)return E.write('Version '+g+f.EOL),n(null);if(N.help||1>N._.length){const e=[];return Object.keys(y).forEach((t)=>{var i=y[t],r=' ';for(r+='--'+t,i.aliases&&1===i.aliases[0].length&&(r+=', -'+i.aliases[0]);r.length<k;)r+=' ';Array.isArray(i.desc)?e.push(r+i.desc[0]+i.desc.slice(1).map((e)=>{for(let t=0;t<k;++t)e=' '+e;return f.EOL+e}).join('')):e.push(r+i.desc)}),(N.help?E:w).write(['Version '+g,'Syntax:   asc [entryFile ...] [options]','','Examples: asc hello.ts','          asc hello.ts -b hello.wasm -t hello.wast','          asc hello1.ts hello2.ts -b -O > hello.wasm','','Options:'].concat(e).join(f.EOL)+f.EOL),n(null)}const P=null==N.baseDir?e.cwd():c.resolve(N.baseDir),M=c.join('.','..','std','assembly'),U=N.noLib?[]:[M];N.lib&&('string'==typeof N.lib&&(N.lib=N.lib.split(',')),Array.prototype.push.apply(U,N.lib.map(trim)));var O=null;for(let e=0,i=N._.length;e<i;++e){const t=N._[e];let r=t.replace(/\\/g,'/').replace(/(\.ts|\/)$/,''),s=L(c.join(P,r)+'.ts');if(null===s){if(s=L(c.join(P,r,'index.ts')),null===s)return n(Error('Entry file \''+r+'.ts\' not found.'));r+='/index.ts'}else r+='.ts';for(I.parseCount++,I.parseTime+=l(()=>O=p.parseFile(s,r,O,!0));null!=(r=O.nextFile());){if(r.startsWith(_)){for(let e=0,t=U.length;e<t;++e)if(x.hasOwnProperty(r))s=x[r];else if(s=L(c.join(U[e],r.substring(_.length)+'.ts')),null!==s){r+='.ts';break}}else if(s=L(c.join(P,r+'.ts')),null!==s)r+='.ts';else if(s=L(c.join(P,r,'index.ts')),null===s){for(let e=0,t=U.length;e<t;++e)if(x.hasOwnProperty(_+r))s=x[_+r];else if(s=L(c.join(U[e],r+'.ts')),null!==s){r=_+r+'.ts';break}if(null===s)return n(Error('Import file \''+r+'.ts\' not found.'))}else r+='/index.ts';I.parseCount++,I.parseTime+=l(()=>p.parseFile(s,r,O))}if(o(O,w))return n(Error('Parse error'))}var D=!1;N.noLib||Object.keys(x).forEach((e)=>{e.lastIndexOf('/')>=_.length||(I.parseCount++,I.parseTime+=l(()=>{O=p.parseFile(x[e],e+'.ts',O,!1)}),D=!0)});for(let e=0,i=U.length;e<i;++e){if(0===e&&D)continue;let t=U[e],i=C(t);for(let e=0,r=i.length;e<r;++e){let r=i[e],s=L(c.join(t,r));if(null===s)return n(Error('Library file \''+r+'\' could not be read.'));I.parseCount++,I.parseTime+=l(()=>{O=p.parseFile(s,_+r,O,!1)})}}const F=p.createOptions();p.setTarget(F,0),p.setNoTreeShaking(F,!!N.noTreeShaking),p.setNoAssert(F,!!N.noAssert),p.setNoMemory(F,!!N.noMemory),p.setSourceMap(F,null!=N.sourceMap);var R;I.compileCount++;try{I.compileTime+=l(()=>R=p.compile(O,F))}catch(t){return n(t)}if(o(O,w))return R&&R.dispose(),n(Error('Compile error'));if(N.validate&&(I.validateCount++,I.validateTime+=l(()=>{if(!R.validate())return R.dispose(),n(Error('Validate error'))})),'clamp'===N.trapMode)I.optimizeCount++,I.optimizeTime+=l(()=>R.runPasses(['trap-mode-clamp']));else if('js'===N.trapMode)I.optimizeCount++,I.optimizeTime+=l(()=>R.runPasses(['trap-mode-js']));else if('allow'!==N.trapMode)return R.dispose(),n(Error('Unsupported trap mode'));var V=-1,B=0,j=!N.noDebug;!1!==N.optimize&&('number'==typeof N.optimize?V=N.optimize:N[0]?V=0:N[1]?V=1:N[2]?V=2:N[3]?V=3:!0===N.optimize?(V=v,B=T):V=0),N.s?B=1:N.z&&(B=2),'number'==typeof N.optimizeLevel&&(V=N.optimizeLevel),'number'==typeof N.shrinkLevel?B=N.shrinkLevel:'s'===N.shrinkLevel?B=1:'z'===N.shrinkLevel&&(B=2),R.setOptimizeLevel(V),R.setShrinkLevel(B),R.setDebugInfo(j);var H=[];if(N.runPasses&&('string'==typeof N.runPasses&&(N.runPasses=N.runPasses.split(',')),N.runPasses.length&&N.runPasses.forEach((e)=>{0>H.indexOf(e)&&H.push(e)})),0<=V&&(I.optimizeCount++,I.optimizeTime+=l(()=>R.optimize())),H.length&&(I.optimizeCount++,I.optimizeTime+=l(()=>R.runPasses(H.map((e)=>e.trim())))),!N.noEmit){let e=!1;if(null!=N.outFile&&(/\.wast$/.test(N.outFile)&&null==N.textFile?N.textFile=N.outFile:/\.js$/.test(N.outFile)&&null==N.asmjsFile?N.asmjsFile=N.outFile:null==N.binaryFile&&(N.binaryFile=N.outFile)),null!=N.binaryFile){let t,i=null==N.sourceMap?null:N.sourceMap.length?N.sourceMap:c.basename(N.binaryFile)+'.map';if(I.emitCount++,I.emitTime+=l(()=>t=R.toBinary(i)),N.binaryFile.length?S(c.join(P,N.binaryFile),t.output):(A(t.output),e=!0),null!=t.sourceMap)if(N.binaryFile.length){let e=JSON.parse(t.sourceMap);e.sourceRoot=b,e.sources.forEach((t,i)=>{let r=null;if(t.startsWith(_))for(let e=0,i=U.length;e<i&&(r=L(c.join(U[e],t.substring(_.length))),null===r);++e);else r=L(c.join(P,t));return null===r?n(Error('Source file \''+t+'\' not found.')):void((e.sourceContents||(e.sourceContents=[]))[i]=r)}),S(c.join(P,c.dirname(N.binaryFile),c.basename(i)),JSON.stringify(e))}else w.write('Cannot write source map because binary already occupies stdout.'+f.EOL)}if(null!=N.textFile||null==N.binaryFile&&null==N.asmjsFile){let t;N.textFile&&N.textFile.length?(I.emitCount++,I.emitTime+=l(()=>t=R.toText()),S(c.join(P,N.textFile),t)):!e&&(I.emitCount++,I.emitTime+=l(()=>t=R.toText()),A(t),e=!0)}if(null!=N.asmjsFile&&N.asmjsFile.length){let t;N.asmjsFile.length?(I.emitCount++,I.emitTime+=l(()=>t=R.toAsmjs()),S(c.join(P,N.asmjsFile),t)):!e&&(I.emitCount++,I.emitTime+=l(()=>t=R.toAsmjs()),A(t),e=!0)}}return R.dispose(),N.measure&&u(I,w),n(null)}function s(e){const t={};return Object.keys(y).forEach((e)=>{const i=y[e];i.aliases&&((t.alias||(t.alias={}))[e]=i.aliases),void 0!==i.default&&((t.default||(t.default={}))[e]=i.default),'string'===i.type?(t.string||(t.string=[])).push(e):'boolean'===i.type&&(t.boolean||(t.boolean=[])).push(e)}),i(14)(e,t)}function o(e,t){for(var i,r=!1;null!=(i=p.nextDiagnostic(e));)t.write(p.formatDiagnostic(i,t.isTTY,!0)+f.EOL+f.EOL),p.isError(i)&&(r=!0);return r}function a(){return{readTime:0,readCount:0,writeTime:0,writeCount:0,parseTime:0,parseCount:0,compileTime:0,compileCount:0,emitTime:0,emitCount:0,validateTime:0,validateCount:0,optimizeTime:0,optimizeCount:0}}function l(t){const i=e.hrtime();t();const r=e.hrtime(i);return 1e9*r[0]+r[1]}function u(t,i){(i||e.stdout).write(['I/O Read  : '+(t.readTime?(t.readTime/1e6).toFixed(3)+' ms ('+t.readCount+' files)':'N/A'),'I/O Write : '+(t.writeTime?(t.writeTime/1e6).toFixed(3)+' ms ('+t.writeCount+' files)':'N/A'),'Parse     : '+(t.parseTime?(t.parseTime/1e6).toFixed(3)+' ms ('+t.parseCount+' times)':'N/A'),'Compile   : '+(t.compileTime?(t.compileTime/1e6).toFixed(3)+' ms ('+t.compileCount+' times)':'N/A'),'Emit      : '+(t.emitTime?(t.emitTime/1e6).toFixed(3)+' ms ('+t.emitCount+' times)':'N/A'),'Validate  : '+(t.validateTime?(t.validateTime/1e6).toFixed(3)+' ms ('+t.validateCount+' times)':'N/A'),'Optimize  : '+(t.optimizeTime?(t.optimizeTime/1e6).toFixed(3)+' ms ('+t.optimizeCount+' times)':'N/A')].join(f.EOL)+f.EOL)}const c=i(1),d=i(9),f=i(10);var p,m;try{p=i(11),m=!1;try{i(!function(){var t=new Error('Cannot find module "source-map-support"');throw t.code='MODULE_NOT_FOUND',t}()).install()}catch(t){}}catch(t){try{i(!function(){var t=new Error('Cannot find module "ts-node"');throw t.code='MODULE_NOT_FOUND',t}()).register({project:i(1).join('.','..','src')}),i(!function(){var t=new Error('Cannot find module "../src/glue/js"');throw t.code='MODULE_NOT_FOUND',t}()),p=i(!function(){var t=new Error('Cannot find module "../src"');throw t.code='MODULE_NOT_FOUND',t}()),m=!0}catch(t){p=i(12),m=!1}}const h=!0,g=t.version='0.5.0',y=t.options=i(13),b='assemblyscript:///',_=p.LIBRARY_PREFIX,v=t.defaultOptimizeLevel=2,T=t.defaultShrinkLevel=1,x=t.libraryFiles={"(lib)/allocator/arena":'/////////////// A simple yet effective Arena Memory Allocator /////////////////\n\n// Provides a `reset_memory` function to reset the heap to its initial state. A\n// user has to make sure that there are no more references to cleared memory\n// afterwards. Always aligns to 8 bytes.\n\nconst ALIGN_LOG2: usize = 3;\nconst ALIGN_SIZE: usize = 1 << ALIGN_LOG2;\nconst ALIGN_MASK: usize = ALIGN_SIZE - 1;\n\nvar HEAP_OFFSET: usize = HEAP_BASE;\n\nexport function allocate_memory(size: usize): usize {\n  if (!size) return 0;\n  var ptr = HEAP_OFFSET;\n  var off = (ptr + size + ALIGN_MASK) & ~ALIGN_MASK;\n  var avail = <usize>current_memory() << 16;\n  if (off > avail && grow_memory(\n    max(\n      (((off + 0xffff) & ~0xffff) - avail) >> 16, // minimum required pages\n      avail                                >> 16  // at least double memory\n    )\n  ) < 0) unreachable(); // out of memory\n  HEAP_OFFSET = off;\n  return ptr;\n}\n\nexport function free_memory(ptr: usize): void {\n  // nop\n}\n\nexport function reset_memory(): void {\n  HEAP_OFFSET = HEAP_BASE;\n}\n',"(lib)/allocator/emscripten":'///////////////////////// Emscripten Memory Allocator //////////////////////////\n\n// Uses Emscripten\'s exported _malloc and _free implementations, i.e., when\n// linking with Emscripten-compiled programs that already provide these.\n// Differs from \'system\' in that their names are prefixed with an underscore.\n\ndeclare function _malloc(size: usize): usize;\ndeclare function _free(ptr: usize): void;\n\nexport function allocate_memory(size: usize): usize {\n  return _malloc(size);\n}\n\nexport function free_memory(ptr: usize): void {\n  _free(ptr);\n}\n\nexport function reset_memory(): void {\n  throw new Error("not supported");\n}\n',"(lib)/allocator/system":'/////////////////////////// System Memory Allocator ////////////////////////////\n\n// Uses the environment\'s malloc and free implementations, i.e., when linking\n// with other C-like programs that already provide these.\n\ndeclare function malloc(size: usize): usize;\ndeclare function free(ptr: usize): void;\n\nexport function allocate_memory(size: usize): usize {\n  return malloc(size);\n}\n\nexport function free_memory(ptr: usize): void {\n  free(ptr);\n}\n\nexport function reset_memory(): void {\n  throw new Error("not supported");\n}\n',"(lib)/allocator/tlsf":'////////////// TLSF (Two-Level Segregate Fit) Memory Allocator ////////////////\n\n// Re-export for now, so there\'s just one source file being worked on\n\nexport {\n  allocate_memory,\n  free_memory\n} from "../../../examples/tlsf/assembly/tlsf";\n\nexport function reset_memory(): void {\n  throw new Error("not supported");\n}\n',"(lib)/array":'export class Array<T> {\n\n  private __memory: usize;\n  private __capacity: i32;  // capped to [0, 0x7fffffff]\n  private __length: i32;    // capped to [0, __capacity]\n\n  private __grow(newCapacity: i32): void {\n    assert(newCapacity > this.__capacity);\n    var newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\n    if (this.__memory) {\n      move_memory(newMemory, this.__memory, this.__capacity * sizeof<T>());\n      free_memory(this.__memory);\n    }\n    this.__memory = newMemory;\n    this.__capacity = newCapacity;\n  }\n\n  constructor(capacity: i32 = 0) {\n    if (capacity < 0)\n      throw new RangeError("Invalid array length");\n    this.__memory = capacity ? allocate_memory(<usize>capacity * sizeof<T>()) : 0;\n    this.__capacity = this.__length = capacity;\n  }\n\n  get length(): i32 {\n    return this.__length;\n  }\n\n  set length(length: i32) {\n    if (length < 0)\n      throw new RangeError("Invalid array length");\n    if (length > this.__capacity)\n      this.__grow(max(length, this.__capacity << 1));\n    this.__length = length;\n  }\n\n  @operator("[]")\n  private __get(index: i32): T {\n    if (<u32>index >= this.__capacity)\n      throw new Error("Index out of bounds"); // return changetype<T>(0) ?\n    return load<T>(this.__memory + <usize>index * sizeof<T>());\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: T): void {\n    if (index < 0)\n      throw new Error("Index out of bounds");\n    if (index >= this.__capacity)\n      this.__grow(max(index + 1, this.__capacity << 1));\n    store<T>(this.__memory + <usize>index * sizeof<T>(), value);\n  }\n\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    if (fromIndex < 0)\n      fromIndex = this.__length + fromIndex;\n    while (<u32>fromIndex < this.__length) {\n      if (load<T>(this.__memory + fromIndex * sizeof<T>()) == searchElement)\n        return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    if (fromIndex < 0)\n      fromIndex = this.__length + fromIndex;\n    else if (fromIndex >= this.__length)\n      fromIndex = this.__length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(this.__memory + fromIndex * sizeof<T>()) == searchElement)\n        return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(element: T): i32 {\n    if (this.__length == this.__capacity)\n      this.__grow(this.__capacity ? this.__capacity << 1 : 1);\n    store<T>(this.__memory + this.__length * sizeof<T>(), element);\n    return ++this.__length;\n  }\n\n  pop(): T {\n    if (this.__length < 1)\n      throw new RangeError("Array is empty"); // return changetype<T>(0) ?\n    return load<T>(this.__memory + --this.__length * sizeof<T>());\n  }\n\n  shift(): T {\n    if (this.__length < 1)\n      throw new RangeError("Array is empty"); // return changetype<T>(0) ?\n    var element = load<T>(this.__memory);\n    move_memory(this.__memory, this.__memory + sizeof<T>(), (this.__capacity - 1) * sizeof<T>());\n    set_memory(this.__memory + (this.__capacity - 1) * sizeof<T>(), 0, sizeof<T>());\n    --this.__length;\n    return element;\n  }\n\n  unshift(element: T): i32 {\n    var oldCapacity = this.__capacity;\n    if (this.__length == oldCapacity) {\n      // inlined __grow (avoids moving twice)\n      var newCapacity: i32 = oldCapacity ? oldCapacity << 1 : 1;\n      assert(newCapacity > this.__capacity);\n      var newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\n      if (this.__memory) {\n        move_memory(newMemory + sizeof<T>(), this.__memory, oldCapacity * sizeof<T>());\n        free_memory(this.__memory);\n      }\n      this.__memory = newMemory;\n      this.__capacity = newCapacity;\n    } else\n      move_memory(this.__memory + sizeof<T>(), this.__memory, oldCapacity * sizeof<T>());\n    store<T>(this.__memory, element);\n    return ++this.__length;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (begin < 0) {\n      begin = this.__length + begin;\n      if (begin < 0)\n        begin = 0;\n    } else if (begin > this.__length)\n      begin = this.__length;\n    if (end < 0)\n      end = this.__length + end;\n    else if (end > this.__length)\n      end = this.__length;\n    if (end < begin)\n      end = begin;\n    var capacity = end - begin;\n    assert(capacity >= 0);\n    var sliced = new Array<T>(capacity);\n    if (capacity)\n      move_memory(sliced.__memory, this.__memory + <usize>begin * sizeof<T>(), <usize>capacity * sizeof<T>());\n    return sliced;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): void {\n    if (deleteCount < 1)\n      return;\n    if (start < 0) {\n      start = this.__length + start;\n      if (start < 0)\n        start = 0;\n      else if (start >= this.__length)\n        return;\n    } else if (start >= this.__length)\n      return;\n    deleteCount = min(deleteCount, this.__length - start);\n    move_memory(this.__memory + <usize>start * sizeof<T>(), this.__memory + <usize>(start + deleteCount) * sizeof<T>(), deleteCount * sizeof<T>());\n    this.__length -= deleteCount;\n  }\n\n  reverse(): Array<T> {\n    for (var front: usize = 0, back: usize = <usize>this.__length - 1; front < back; ++front, --back) {\n      var temp = load<T>(this.__memory + front * sizeof<T>());\n      store<T>(this.__memory + front * sizeof<T>(), load<T>(this.__memory + back * sizeof<T>()));\n      store<T>(this.__memory + back * sizeof<T>(), temp);\n    }\n    return this;\n  }\n}\n\n@unmanaged\nexport class CArray<T> {\n\n  private constructor() {}\n\n  @operator("[]")\n  private __get(index: i32): T {\n    if (index < 0)\n      throw new RangeError("Index out of range");\n    return load<T>(changetype<usize>(this) + <usize>index * sizeof<T>());\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: T): void {\n    if (index < 0)\n      throw new RangeError("Index out of range");\n    store<T>(changetype<usize>(this) + <usize>index * sizeof<T>(), value);\n  }\n}\n',"(lib)/builtins":'@builtin\nexport declare const NaN: f64; // | f32\n\n@builtin\nexport declare const Infinity: f64; // | f32\n\n@builtin\nexport declare function isNaN<T>(value: T): bool;\n\n@builtin\nexport declare function isFinite<T>(value: T): bool;\n\n@builtin\nexport declare function clz<T>(value: T): T;\n\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n@builtin\nexport declare function abs<T>(value: T): T;\n\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n@builtin\nexport declare function floor<T>(value: T): T;\n\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n@builtin\nexport declare function nearest<T>(left: T, right: T): T;\n\n@builtin\nexport declare function reinterpret<T>(value: void): T;\n\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n@builtin\nexport declare function load<T>(offset: usize, constantOffset?: usize): T;\n\n@builtin\nexport declare function store<T>(offset: usize, value: void, constantOffset?: usize): T;\n\n@builtin\nexport declare function sizeof<T>(): usize;\n\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n@builtin\nexport declare function unreachable(): void;\n\n@builtin\nexport declare function current_memory(): i32;\n\n@builtin\nexport declare function grow_memory(pages: i32): i32;\n\n// @builtin\n// export declare function move_memory(dest: usize, src: usize: n: usize): void;\n\n// @builtin\n// export declare function set_memory(dest: usize, value: u32, n: usize): void;\n\n@builtin\nexport declare function changetype<T>(value: void): T;\n\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n@builtin\nexport declare function abort(message?: string | null, fileName?: string | null, lineNumber?: u32, columnNumber?: u32): void;\n\n@builtin\ndeclare function i8(value: void): i8;\nnamespace i8 {\n  export const MIN_VALUE: i8 = -128;\n  export const MAX_VALUE: i8 = 127;\n}\nexport { i8 };\n\n@builtin\ndeclare function i16(value: void): i16;\nnamespace i16 {\n  export const MIN_VALUE: i16 = -32768;\n  export const MAX_VALUE: i16 = 32767;\n}\nexport { i16 };\n\n@builtin\ndeclare function i32(value: void): i32;\nnamespace i32 {\n  export const MIN_VALUE: i32 = -2147483648;\n  export const MAX_VALUE: i32 = 2147483647;\n}\nexport { i32 };\n\n@builtin\ndeclare function i64(value: void): i64;\nnamespace i64 {\n  export const MIN_VALUE: i64 = -9223372036854775808;\n  export const MAX_VALUE: i64 = 9223372036854775807;\n}\nexport { i64 };\n\n@builtin\ndeclare function isize(value: void): isize;\nnamespace isize {\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>() ? -2147483648 : <usize>-9223372036854775808;\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>() ? 2147483647 : <usize>9223372036854775807;\n}\nexport { isize };\n\n@builtin\ndeclare function u8(value: void): u8;\nnamespace u8 {\n  export const MIN_VALUE: u8 = 0;\n  export const MAX_VALUE: u8 = 255;\n}\nexport { u8 };\n\n@builtin\ndeclare function u16(value: void): u16;\nnamespace u16 {\n  export const MIN_VALUE: u16 = 0;\n  export const MAX_VALUE: u16 = 65535;\n}\nexport { u16 };\n\n@builtin\ndeclare function u32(value: void): u32;\nnamespace u32 {\n  export const MIN_VALUE: u32 = 0;\n  export const MAX_VALUE: u32 = 4294967295;\n}\nexport { u32 };\n\n@builtin\ndeclare function u64(value: void): u64;\nnamespace u64 {\n  export const MIN_VALUE: u64 = 0;\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\nexport { u64 };\n\n@builtin\ndeclare function usize(value: void): usize;\nnamespace usize {\n  export const MIN_VALUE: usize = 0;\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>() ? 4294967295 : <usize>18446744073709551615;\n}\nexport { usize };\n\n@builtin\ndeclare function bool(value: void): bool;\nnamespace bool {\n  export const MIN_VALUE: bool = 0;\n  export const MAX_VALUE: bool = 1;\n}\nexport { bool };\n\n@builtin\ndeclare function f32(value: void): f32;\nnamespace f32 {\n  export const MIN_VALUE: f32 = -3.40282347e+38;\n  export const MAX_VALUE: f32 = 3.40282347e+38;\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n  export const MAX_SAFE_INTEGER: f32 = 16777215;\n  export const EPSILON: f32 = 1.19209290e-07;\n}\nexport { f32 };\n\n@builtin\ndeclare function f64(value: void): f64;\nnamespace f64 {\n  export const MIN_VALUE: f64 = -1.7976931348623157e+308;\n  export const MAX_VALUE: f64 = 1.7976931348623157e+308;\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n  export const MAX_SAFE_INTEGER: f64 = 9007199254740991;\n  export const EPSILON: f64 = 2.2204460492503131e-16;\n}\nexport{ f64 };\n\n@builtin\nexport declare const HEAP_BASE: usize;\n\n@builtin\nexport declare function start(): void;\n',"(lib)/error":'export class Error {\n\n  name: string = "Error";\n  message: string;\n  stack: string = ""; // TODO\n\n  constructor(message: string = "") {\n    this.message = message;\n  }\n}\n\nexport class RangeError extends Error {\n  name: string = "RangeError";\n}\n',"(lib)/iterator":'// export abstract class Iterator<T> {\n//   abstract get done(): bool;\n//   abstract next(): T;\n// }\n',"(lib)/map":'export class Map<K,V> {\n\n  private __keys: K[] = [];\n  private __values: V[] = [];\n\n  // FIXME: not a proper map implementation, just a filler\n\n  get size(): i32 {\n    return this.__keys.length;\n  }\n\n  get(key: K): V | null {\n    var keys = this.__keys;\n    for (var i = 0, k = keys.length; i < k; ++i)\n      if (keys[i] == key)\n        return this.__values[i];\n    return null;\n  }\n\n  has(key: K): bool {\n    var keys = this.__keys;\n    for (var i = 0, k = keys.length; i < k; ++i)\n      if (keys[i] == key)\n        return true;\n    return false;\n  }\n\n  set(key: K, value: V): void {\n    this.__keys.push(key);\n    this.__values.push(value);\n  }\n\n  clear(): void {\n    this.__keys.length = 0;\n    this.__values.length = 0;\n  }\n}\n',"(lib)/memory":'function copy_memory(dest: usize, src: usize, n: usize): void {\n  // based on musl\'s implementation of memcpy\n  // not a future instruction and sufficiently covered by the upcoming move_memory intrinsic\n\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && src % 4) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if (dest % 4 == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest % 4) {\n      // known to be != 0\n      case 1:\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      case 2:\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      case 3:\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\nexport function move_memory(dest: usize, src: usize, n: usize): void {\n  // based on musl\'s implementation of memmove\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\n\n  if (dest == src)\n    return;\n  if (src + n <= dest || dest + n <= src) {\n    copy_memory(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if (src % 8 == dest % 8) {\n      while (dest % 8) {\n        if (!n)\n          return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n -= 8;\n        dest += 8;\n        src += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (src % 8 == dest % 8) {\n      while ((dest + n) % 8) {\n        if (!n)\n          return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\nexport function set_memory(dest: usize, c: u8, n: usize): void {\n  // based on musl\'s implementation of memset\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\n\n  // fill head and tail with minimal branching\n  if (!n)\n    return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2)\n    return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6)\n    return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8)\n    return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = -1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8)\n    return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24)\n    return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nexport function compare_memory(vl: usize, vr: usize, n: usize): i32 {\n  // based on musl\'s implementation of memcmp\n  // provided because there\'s no proposed alternative\n  if (vl == vr)\n    return 0;\n  while (n && load<u8>(vl) == load<u8>(vr)) {\n    n--;\n    vl++;\n    vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n',"(lib)/regexp":'export class RegExp {\n\n  // @binding(CALL_NEW, [ STRING, STRING], OBJECT_HANDLE)\n  constructor(pattern: string, flags: string = "") { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [ STRING ], PASS_THRU)\n  test(search: string): bool { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [], STRING)\n  toString(): string { throw new Error("unreachable"); }\n\n}\n',"(lib)/set":'// const prime1: u32 = 73;\n// const prime2: u32 = 5009;\n\nexport class Set<T> {\n\n  private __memory: usize;\n  private __capacity: u32;\n  private __size: u32;\n\n  constructor() {\n    this.__memory = 0;\n    this.__capacity = this.__size = 0;\n  }\n\n  get size(): i32 {\n    return this.__size;\n  }\n\n  // FIXME: not a proper set implementation, just a filler\n\n  has(value: T): bool {\n    assert(this != null);\n\n    for (var index: usize = 0, limit: usize = this.__size; index < limit; ++index)\n      if (load<T>(this.__memory + index * sizeof<T>()) == value)\n        return true;\n    return false;\n  }\n\n  add(value: T): Set<T> {\n    assert(this != null);\n\n    if (this.__size >= this.__capacity) {\n      var newCapacity = max(this.__capacity << 1, 8);\n      var newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\n      if (this.__memory) {\n        move_memory(newMemory, this.__memory, <usize>this.__capacity * sizeof<T>());\n        free_memory(this.__memory);\n      }\n      this.__capacity = newCapacity;\n      this.__memory = newMemory;\n    }\n    store<T>(this.__memory + <usize>this.__size * sizeof<T>(), value);\n    ++this.__size;\n    return this;\n  }\n\n  delete(value: T): bool {\n    assert(this != null);\n\n    for (var index: usize = 0, limit: usize = this.__size; index < limit; ++index)\n      if (load<T>(this.__memory + index * sizeof<T>()) == value) {\n        if (index + 1 < this.__size)\n          move_memory(this.__memory + index * sizeof<T>(), this.__memory + (index + 1) * sizeof<T>(), this.__size - index - 1);\n        --this.__size;\n        return true;\n      }\n    return false;\n  }\n\n  clear(): void {\n    assert(this != null);\n\n    this.__size = 0;\n  }\n\n  // TODO: think about iterators\n}\n\n// class SetIterator<T> extends Iterator<T> {\n\n//   get done(): bool {\n//     throw new Error("not implemented");\n//   }\n\n//   next(): T {\n//     throw new Error("not implemented");\n//   }\n// }\n',"(lib)/string":'// singleton empty string\nconst EMPTY: String = changetype<String>("");\n\n// number of bytes preceeding string data\nconst HEAD: usize = 4;\n\nfunction allocate(length: i32): String {\n  assert(length > 0); // 0 -> EMPTY\n  var ptr = allocate_memory(HEAD + (<usize>length << 1));\n  store<i32>(ptr, length);\n  return changetype<String>(ptr);\n}\n\nexport class String {\n\n  readonly length: i32;\n\n  @operator("[]")\n  charAt(pos: i32): String {\n    assert(this != null);\n\n    if (<u32>pos >= this.length)\n      return EMPTY;\n\n    var out = allocate(1);\n    store<u16>(\n      changetype<usize>(out),\n      load<u16>(\n        changetype<usize>(this) + (<usize>pos << 1),\n        HEAD\n      ),\n      HEAD\n    );\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    assert(this != null);\n\n    if (<u32>pos >= this.length)\n      return -1; // (NaN)\n\n    return load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEAD\n    );\n  }\n\n  codePointAt(pos: i32): i32 {\n    assert(this != null);\n\n    if (<u32>pos >= this.length)\n      return -1; // (undefined)\n    var first = <i32>load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEAD\n    );\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length)\n      return first;\n    var second = <i32>load<u16>(\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\n      HEAD\n    );\n    if (second < 0xDC00 || second > 0xDFFF)\n      return first;\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator("+")\n  private static __concat(left: String, right: String): String {\n    if (left == null)\n      left = changetype<String>("null");\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    assert(this != null);\n\n    if (other == null)\n      other = changetype<String>("null");\n\n    var thisLen: isize = this.length;\n    var otherLen: isize = other.length;\n    var outLen: usize = thisLen + otherLen;\n    if (outLen == 0)\n      return EMPTY;\n\n    var out = allocate(outLen);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD,\n      thisLen << 1\n    );\n    move_memory(\n      changetype<usize>(out) + HEAD + (thisLen << 1),\n      changetype<usize>(other) + HEAD,\n      otherLen << 1\n    );\n    return out;\n  }\n\n  endsWith(searchString: String, endPosition: i32 = 0x7fffffff): bool {\n    assert(this != null);\n\n    if (searchString == null)\n      return false;\n\n    var end: isize = <isize>min(max(endPosition, 0), this.length);\n    var searchLength: isize = searchString.length;\n    var start: isize = end - searchLength;\n    if (start < 0)\n      return false;\n\n    return !compare_memory(\n      changetype<usize>(this) + HEAD + (start << 1),\n      changetype<usize>(searchString) + HEAD,\n      searchLength << 1\n    );\n  }\n\n  @operator("==")\n  private static __eq(left: String, right: String): bool {\n    if (left == null)\n      return right == null;\n    else if (right == null)\n      return false;\n\n    var leftLength = left.length;\n    if (leftLength != right.length)\n      return false;\n\n    return !compare_memory(\n      changetype<usize>(left) + HEAD,\n      changetype<usize>(right) + HEAD,\n      (<usize>leftLength << 1)\n    );\n  }\n\n  includes(searchString: String, position: i32 = 0): bool {\n    return this.indexOf(searchString, position) != -1;\n  }\n\n  indexOf(searchString: String, position: i32 = 0): i32 {\n    assert(this != null);\n\n    if (searchString == null)\n      searchString = changetype<String>("null");\n\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start: isize = min<isize>(max<isize>(pos, 0), len);\n    var searchLen: isize = <isize>searchString.length;\n\n    // TODO: two-way, multiple char codes\n    for (var k: usize = start; <isize>k + searchLen <= len; ++k)\n      if (!compare_memory(\n        changetype<usize>(this) + HEAD + (k << 1),\n        changetype<usize>(searchString) + HEAD,\n        searchLen << 1)\n      )\n        return <i32>k;\n    return -1;\n  }\n\n  startsWith(searchString: String, position: i32 = 0): bool {\n    assert(this != null);\n\n    if (searchString == null)\n      searchString = changetype<String>("null");\n\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start: isize = min<isize>(max<isize>(position, 0), len);\n    var searchLength: isize = <isize>searchString.length;\n    if (searchLength + start > len)\n      return false;\n\n    return !compare_memory(\n      changetype<usize>(this) + HEAD + (start << 1),\n      changetype<usize>(searchString) + HEAD,\n      searchLength << 1\n    );\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\n    assert(this != null);\n\n    var intStart: isize = start;\n    var end: isize = length;\n    var size: isize = this.length;\n    if (intStart < 0)\n      intStart = max<isize>(size + intStart, 0);\n\n    var resultLength: isize = min<isize>(max<isize>(end, 0), size - intStart);\n    if (resultLength <= 0)\n      return EMPTY;\n\n    var out = allocate(resultLength);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD + (intStart << 1),\n      <usize>resultLength << 1\n    );\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    assert(this != null);\n\n    var len = this.length;\n    var finalStart = min<i32>(max<i32>(start, 0), len);\n    var finalEnd = min<i32>(max<i32>(end, 0), len);\n    var from = min<i32>(finalStart, finalEnd);\n    var to = max<i32>(finalStart, finalEnd);\n    len = to - from;\n    if (!len)\n      return EMPTY;\n\n    if (!from && to == this.length)\n      return this;\n\n    var out = allocate(len);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD + (from << 1),\n      len << 1\n    );\n    return out;\n  }\n\n  trim(): String {\n    assert(this != null);\n\n    var length: usize = this.length;\n    while (length && isWhiteSpaceOrLineTerminator(load<u16>(changetype<usize>(this) + (length << 1), HEAD)))\n      --length;\n\n    var start: usize = 0;\n    while (start < length && isWhiteSpaceOrLineTerminator(load<u16>(changetype<usize>(this) + (start << 1), HEAD)))\n      ++start, --length;\n\n    if (!length)\n      return EMPTY;\n\n    if (!start && length == this.length)\n      return this;\n\n    var out = allocate(length);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD + (start << 1),\n      length << 1\n    );\n    return out;\n  }\n\n  trimLeft(): String {\n    assert(this != null);\n\n    var start: isize = 0;\n    var len: isize = this.length;\n    while (start < len && isWhiteSpaceOrLineTerminator(load<u16>(changetype<usize>(this) + (start << 1), HEAD)))\n      ++start;\n\n    if (!start)\n      return this;\n\n    var outLen = len - start;\n    if (!outLen)\n      return EMPTY;\n\n    var out = allocate(outLen);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD + (start << 1),\n      outLen << 1\n    );\n    return out;\n  }\n\n  trimRight(): String {\n    assert(this != null);\n\n    var len: isize = this.length;\n    while (len > 0 && isWhiteSpaceOrLineTerminator(load<u16>(changetype<usize>(this) + (len << 1), HEAD)))\n      --len;\n\n    if (len <= 0)\n      return EMPTY;\n\n    if (<i32>len == this.length)\n      return this;\n\n    var out = allocate(len);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD,\n      len << 1\n    );\n    return out;\n  }\n}\n\nfunction isWhiteSpaceOrLineTerminator(c: u16): bool {\n  switch (c) {\n\n    case 10:    // <LF>\n    case 13:    // <CR>\n    case 8232:  // <LS>\n    case 8233:  // <PS>\n\n    case 9:     // <TAB>\n    case 11:    // <VT>\n    case 12:    // <FF>\n    case 32:    // <SP>\n    case 160:   // <NBSP>\n    case 65279: // <ZWNBSP>\n\n      return true;\n    default:\n      return false;\n  }\n}\n\nconst enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function parseInt(str: String, radix: i32 = 0): f64 {\n  return parse<f64>(str, radix);\n}\n\nexport function parseI32(str: String, radix: i32 = 0): i32 {\n  return parse<i32>(str, radix);\n}\n\nexport function parseI64(str: String, radix: i32 = 0): i64 {\n  return parse<i64>(str, radix);\n}\n\nfunction parse<T>(str: String, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len)\n    return <T>NaN;\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEAD);\n\n  // determine sign\n  var sign: T;\n  if (code == CharCode.MINUS) {\n    if (!--len)\n      return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEAD);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len)\n      return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEAD);\n    sign = 1;\n  } else\n    sign = 1;\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2, HEAD)) {\n\n        case CharCode.B:\n        case CharCode.b:\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n\n        case CharCode.O:\n        case CharCode.o:\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n\n        case CharCode.X:\n        case CharCode.x:\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n\n        default:\n          radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36)\n    return <T>NaN;\n\n  // calculate value\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEAD);\n    if (code >= CharCode._0 && code <= CharCode._9)\n      code -= CharCode._0;\n    else if (code >= CharCode.A && code <= CharCode.Z)\n      code -= CharCode.A - 10;\n    else if (code >= CharCode.a && code <= CharCode.z)\n      code -= CharCode.a - 10;\n    else\n      break;\n    if (code >= radix)\n      break;\n    num = (num * radix) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n\nexport function parseFloat(str: String): f64 {\n  var len: i32 = str.length;\n  if (!len)\n    return NaN;\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEAD);\n\n  // determine sign\n  var sign: f64;\n  if (code == CharCode.MINUS) {\n    if (!--len)\n      return NaN;\n    code = <i32>load<u16>(ptr += 2, HEAD);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len)\n      return NaN;\n    code = <i32>load<u16>(ptr += 2, HEAD);\n    sign = 1;\n  } else\n    sign = 1;\n\n  // calculate value\n  var num: f64 = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEAD);\n    if (code == CharCode.DOT) {\n      ptr += 2;\n      var fac: f64 = 0.1; // precision :(\n      while (len--) {\n        code = <i32>load<u16>(ptr, HEAD);\n        if (code == CharCode.E || code == CharCode.e)\n          assert(false); // TODO\n        code -= CharCode._0;\n        if (<u32>code > 9)\n          break;\n        num += <f64>code * fac;\n        fac *= 0.1;\n        ptr += 2;\n      }\n      break;\n    }\n    code -= CharCode._0;\n    if (<u32>code >= 10)\n      break;\n    num = (num * 10) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n'},z=t.definitionFiles={assembly:'// Definitions for the "AssemblyScript" subset.\n\n// Types\n\n/** An 8-bit signed integer. */\ndeclare type i8 = number;\n/** A 16-bit signed integer. */\ndeclare type i16 = number;\n/** A 32-bit signed integer. */\ndeclare type i32 = number;\n/** A 64-bit signed integer. */\ndeclare type i64 = number;\n/** A 32-bit signed integer when targeting 32-bit WebAssembly or a 64-bit signed integer when targeting 64-bit WebAssembly. */\ndeclare type isize = number;\n/** An 8-bit unsigned integer. */\ndeclare type u8 = number;\n/** A 16-bit unsigned integer. */\ndeclare type u16 = number;\n/** A 32-bit unsigned integer. */\ndeclare type u32 = number;\n/** A 64-bit unsigned integer. */\ndeclare type u64 = number;\n/** A 32-bit unsigned integer when targeting 32-bit WebAssembly or a 64-bit unsigned integer when targeting 64-bit WebAssembly. */\ndeclare type usize = number;\n/** A 1-bit unsigned integer. */\ndeclare type bool = any; // sic\n/** A 32-bit float. */\ndeclare type f32 = number;\n/** A 64-bit float. */\ndeclare type f64 = number;\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace i8 {\n  export const MIN_VALUE: i8;\n  export const MAX_VALUE: i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace i16 {\n  export const MIN_VALUE: i16;\n  export const MAX_VALUE: i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i32;\ndeclare namespace i32 {\n  export const MIN_VALUE: i32;\n  export const MAX_VALUE: i32;\n}\n/** Converts any other numeric value to a 64-bit signed integer. */\ndeclare function i64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i64;\ndeclare namespace i64 {\n  export const MIN_VALUE: i64;\n  export const MAX_VALUE: i64;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare function isize(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): isize;\ndeclare namespace isize {\n  export const MIN_VALUE: isize;\n  export const MAX_VALUE: isize;\n}\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace u8 {\n  export const MIN_VALUE: u8;\n  export const MAX_VALUE: u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace u16 {\n  export const MIN_VALUE: u16;\n  export const MAX_VALUE: u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i32;\ndeclare namespace u32 {\n  export const MIN_VALUE: u32;\n  export const MAX_VALUE: u32;\n}\n/** Converts any other numeric value to a 64-bit unsigned integer. */\ndeclare function u64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i64;\ndeclare namespace u64 {\n  export const MIN_VALUE: u64;\n  export const MAX_VALUE: u64;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare function usize(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): isize;\ndeclare namespace usize {\n  export const MIN_VALUE: usize;\n  export const MAX_VALUE: usize;\n}\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): bool;\ndeclare namespace bool {\n  export const MIN_VALUE: bool;\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): f32;\ndeclare namespace f32 {\n  export const MIN_VALUE: f32;\n  export const MAX_VALUE: f32;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): f64;\ndeclare namespace f64 {\n  export const MIN_VALUE: f64;\n  export const MAX_VALUE: f64;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n}\n\n// Built-ins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered trailing if the value is zero. */\ndeclare function ctz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit or 64-bit integer. */\ndeclare function popcnt<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic rotate left operation on a 32-bit or 64-bit integer. */\ndeclare function rotl<T = i32 | i64>(value: T, shift: T): T;\n/** Performs the sign-agnostic rotate right operation on a 32-bit or 64-bit integer. */\ndeclare function rotr<T = i32 | i64>(value: T, shift: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | i64 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\ndeclare function copysign<T = f32 | f64>(x: T, y: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\ndeclare function nearest<T = f32 | f64>(value: T): T;\n/** Reinterprets the bits of the specified value as type `T`. Valid reinterpretations are u32/i32 to/from f32 and u64/i64 to/from f64. */\ndeclare function reinterpret<T = i32 | i64 | f32 | f64>(value: number): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Loads a value of the specified type from memory. Equivalent to dereferncing a pointer in other languages. */\ndeclare function load<T>(ptr: usize, constantOffset?: usize): any;\n/** Stores a value of the specified type to memory. Equivalent to dereferencing a pointer in other languages when assigning a value. */\ndeclare function store<T>(ptr: usize, value: any, constantOffset?: usize): void;\n/** Returns the current memory size in units of pages. One page is 64kb. */\ndeclare function current_memory(): i32;\n/** Grows linear memory by a given unsigned delta of pages. One page is 64kb. Returns the previous memory size in units of pages or `-1` on failure. */\ndeclare function grow_memory(value: i32): i32;\n/** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\ndeclare function move_memory(destination: usize, source: usize, n: usize): void;\n/** Sets n bytes beginning at the specified destination in memory to the specified byte value. */\ndeclare function set_memory(destination: usize, value: u8, count: usize): void;\n/** Compares two chunks of memory. Returns `0` if equal, otherwise the difference of the first differing bytes. */\ndeclare function compare_memory(vl: usize, vr: usize, n: usize): i32;\n/** Allocates a chunk of memory of the specified size and returns a pointer to it. */\ndeclare function allocate_memory(size: usize): usize;\n/** Disposes a chunk of memory by its pointer. */\ndeclare function free_memory(ptr: usize): void;\n/** Emits an unreachable operation that results in a runtime error when executed. Both a statement and an expression of any type. */\ndeclare function unreachable(): any; // sic\n\n/** NaN (not a number) as a 32-bit or 64-bit float depending on context. */\ndeclare const NaN: f32 | f64;\n/** Positive infinity as a 32-bit or 64-bit float depending on context. */\ndeclare const Infinity: f32 | f64;\n/** Heap base offset. */\ndeclare const HEAP_BASE: usize;\n/** Determines the byte size of the specified core or class type. Compiles to a constant. */\ndeclare function sizeof<T>(): usize;\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Tests if a 32-bit or 64-bit float is `NaN`. */\ndeclare function isNaN<T = f32 | f64>(value: T): bool;\n/** Tests if a 32-bit or 64-bit float is finite, that is not `NaN` or +/-`Infinity`. */\ndeclare function isFinite<T = f32 | f64>(value: T): bool;\n/** Traps if the specified value is not true-ish, otherwise returns the (non-nullable) value. */\ndeclare function assert<T>(isTrueish: T, message?: string): T & object; // any better way to model `: T != null`?\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses an integer string to a 32-bit integer. */\ndeclare function parseI32(str: string, radix?: i32): i32;\n/** Parses an integer string to a 64-bit integer. */\ndeclare function parseI64(str: string, radix?: i32): i64;\n/** Parses a string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n\n// Standard library (not yet implemented)\n\n/** Class representing a sequence of values of type `T`. */\ndeclare class Array<T> {\n  [key: number]: T;\n  /** Current length of the array. */\n  length: i32;\n  /** Constructs a new array. */\n  constructor(capacity?: i32);\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  push(element: T): void;\n  pop(): T;\n  shift(): T;\n  unshift(element: T): i32;\n  slice(from: i32, to?: i32): T[];\n  splice(start: i32, deleteCount?: i32): void;\n  reverse(): T[];\n}\n\n/** Class representing a C-like array of values of type `T` with limited capabilities. */\ndeclare class CArray<T> {\n  [key: number]: T;\n  private constructor();\n}\n\n/** Class representing a sequence of characters. */\ndeclare class String {\n\n  static fromCharCode(ls: i32, hs?: i32): string;\n  static fromCharCodes(arr: u16[]): string;\n  static fromCodePoint(cp: i32): string;\n  static fromCodePoints(arr: i32[]): string;\n\n  readonly length: u32;\n\n  charAt(index: u32): string;\n  charCodeAt(index: u32): u16;\n  concat(other: string): string;\n  endsWith(other: string): bool;\n  indexOf(other: string): u32;\n  includes(other: string): bool;\n  startsWith(other: string): bool;\n  substr(start: u32, length?: u32): string;\n  substring(start: u32, end?: u32): string;\n  trim(): string;\n  trimLeft(): string;\n  trimRight(): string;\n}\n\n/** Class for representing a runtime error. Base class of all errors. */\ndeclare class Error {\n\n  /** Error name. */\n  name: string;\n\n  /** Message provided on construction. */\n  message: string;\n\n  /** Stack trace. */\n  stack: string;\n\n  /** Constructs a new error, optionally with a message. */\n  constructor(message?: string);\n}\n\n/** Class for indicating an error when a value is not in the set or range of allowed values. */\ndeclare class RangeError extends Error { }\n\ninterface Boolean {}\ninterface Function {}\ninterface IArguments {}\ninterface Number {}\ninterface Object {}\ninterface RegExp {}\n\ndeclare class Set<T> {\n  readonly size: i32;\n  has(value: T): bool;\n  add(value: T): void;\n  delete(value: T): bool;\n  clear(): void;\n}\n\n// Internal decorators\n\n/** Annotates an element as a program global. */\ndeclare function global(target: Function): any;\n\n/** Annotates a method as an operator overload. */\ndeclare function operator(token: string): any;\n\n/** Annotates a class as being unmanaged with limited capabilities. */\ndeclare function unmanaged(target: Function): any;\n\n/** Annotates a class field with an explicit offset. */\ndeclare function offset(offset: usize): any;\n\n/** Annotates an element as begin built-in. */\ndeclare function builtin(target: Function): any;\n',portable:'// Definitions for the "portable AssemblyScript" subset.\n\n// Portable types\n\n// Note that semantic differences require additional explicit conversions for full compatibility.\n// For example, when casting an i32 to an u8, doing `<u8>(someI32 & 0xff)` will yield the same\n// result when compiling to WebAssembly or JS while `<u8>someI32` alone does nothing in JS.\n\n// Note that i64\'s are not portable (JS numbers are IEEE754 doubles with a maximum safe integer value\n// of 2^53-1) and instead require a compatibility layer to work in JS as well. See: src/util/i64.ts\n\ndeclare type i8 = number;\ndeclare type i16 = number;\ndeclare type i32 = number;\ndeclare type isize = number;\ndeclare type u8 = number;\ndeclare type u16 = number;\ndeclare type u32 = number;\ndeclare type bool = boolean;\ndeclare type usize = number;\ndeclare type f32 = number;\ndeclare type f64 = number;\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace i8 {\n  export const MIN_VALUE: i8;\n  export const MAX_VALUE: i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace i16 {\n  export const MIN_VALUE: i16;\n  export const MAX_VALUE: i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i32;\ndeclare namespace i32 {\n  export const MIN_VALUE: i32;\n  export const MAX_VALUE: i32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare function isize(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): isize;\ndeclare namespace isize {\n  export const MIN_VALUE: isize;\n  export const MAX_VALUE: isize;\n}\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace u8 {\n  export const MIN_VALUE: u8;\n  export const MAX_VALUE: u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace u16 {\n  export const MIN_VALUE: u16;\n  export const MAX_VALUE: u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i32;\ndeclare namespace u32 {\n  export const MIN_VALUE: u32;\n  export const MAX_VALUE: u32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare function usize(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): isize;\ndeclare namespace usize {\n  export const MIN_VALUE: usize;\n  export const MAX_VALUE: usize;\n}\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): bool;\ndeclare namespace bool {\n  export const MIN_VALUE: bool;\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): f32;\ndeclare namespace f32 {\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): f64;\ndeclare namespace f64 {\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n}\n\n// Portable built-ins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32>(value: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Allocates a chunk of memory of the specified size and returns a pointer to it. */\ndeclare function allocate_memory(size: usize): usize;\n/** Disposes a chunk of memory by its pointer. */\ndeclare function free_memory(ptr: usize): void;\n/** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\ndeclare function move_memory(destination: usize, source: usize, n: usize): void;\n/** Loads a value of the specified type from memory. Type must be `u8`. */\ndeclare function load<T = u8>(ptr: usize, constantOffset?: usize): T;\n/** Stores a value of the specified type to memory. Type must be `u8`. */\ndeclare function store<T = u8>(ptr: usize, value: T, constantOffset?: usize): void;\n/** Emits an unreachable operation that results in a runtime error when executed. */\ndeclare function unreachable(): any; // sic\n\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Traps if the specified value is not true-ish, otherwise returns the value. */\ndeclare function assert<T>(isTrueish: T, message?: string): T & object; // any better way to model `: T != null`?\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses an integer string to a 32-bit integer. */\ndeclare function parseI32(str: string, radix?: i32): i32;\n/** Parses a floating point string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n\n// Portable standard library\n// Everything marked @deprecated is a temporary filler. Do not use.\n\ndeclare const NaN: f32 | f64;\ndeclare const Infinity: f32 | f64;\n\ndeclare class Array<T> {\n  [key: number]: T;\n  length: i32;\n  constructor(capacity?: i32);\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  push(element: T): void;\n  pop(): T;\n  shift(): T;\n  unshift(element: T): i32;\n  slice(from: i32, to?: i32): T[];\n  splice(start: i32, deleteCount?: i32): void;\n  reverse(): T[];\n\n  join(delim: string): string;\n}\n\ndeclare class Uint8Array extends Array<u8> {}\ndeclare class Uint16Array extends Array<u16> {}\ndeclare class Uint32Array extends Array<u32> {}\ndeclare class Int8Array extends Array<i8> {}\ndeclare class Int16Array extends Array<i16> {}\ndeclare class Int32Array extends Array<i32> {}\ndeclare class Float32Array extends Array<f32> {}\ndeclare class Float64Array extends Array<f64> {}\n\ndeclare class String {\n  static fromCharCode(ls: i32, hs?: i32): string;\n  static fromCharCodes(arr: u16[]): string;\n  static fromCodePoint(cp: i32): string;\n  static fromCodePoints(arr: i32[]): string;\n  readonly length: i32;\n  private constructor();\n  indexOf(subject: string): i32;\n  includes(other: string): bool;\n  lastIndexOf(subject: string): i32;\n  charAt(index: i32): string;\n  charCodeAt(index: i32): i32;\n  substring(from: i32, to?: i32): string;\n  startsWith(subject: string): bool;\n  endsWith(subject: string): bool;\n  replace(search: string, replacement: string): string;\n  toString(): string;\n}\n\ninterface Boolean {}\n\ndeclare class Number {\n  private constructor();\n  toString(radix?: i32): string;\n}\n\ninterface Object {}\n\ninterface Function {}\n\ninterface RegExp {}\n\ninterface IArguments {}\n\ndeclare class Error {\n  constructor(message: string);\n  message: string;\n  stack: string | null;\n}\n\ndeclare class Symbol {\n  private constructor();\n  static readonly iterator: symbol;\n}\n\ndeclare class Set<T> {\n  constructor(entries?: T[]);\n  has(value: T): bool;\n  add(value: T): void;\n  delete(value: T): bool;\n  clear(): void;\n  [Symbol.iterator](): Iterator<T>;\n}\n\ndeclare class Map<K,V> {\n  constructor(entries?: [K, V][]);\n  readonly size: i32;\n  set(key: K, value: V): void;\n  has(key: K): bool;\n  get(key: K): V | null;\n  clear(): void;\n  entries(): Iterable<[K, V]>;\n  keys(): Iterable<K>;\n  values(): Iterable<V>;\n  [Symbol.iterator](): Iterator<[K,V]>;\n}\n\ninterface Iterable<T> {\n  [Symbol.iterator](): Iterator<T>;\n}\n\ninterface Iterator<T> {}\n\ndeclare namespace console {\n  /** @deprecated */\n  function log(message: string): void;\n}\n'};t.main=n,t.parseArguments=s,t.checkDiagnostics=o,t.createStats=a,e.hrtime||(e.hrtime=i(15)),t.measure=l,t.printStats=u,t.createMemoryStream=function(e){var t=[];return t.write=function(t){'string'==typeof t?this.push(r.from(t,'utf8')):this.push(t),e&&e(t)},t.toBuffer=function(){return r.concat(this)},t.toString=function(){return this.toBuffer().toString('utf8')},t},t.tscOptions={alwaysStrict:!0,noImplicitAny:!0,noImplicitReturns:!0,noImplicitThis:!0,noEmitOnError:!0,strictNullChecks:!0,experimentalDecorators:!0,target:'esnext',module:'commonjs',noLib:!0,types:[],allowJs:!1}}).call(t,i(0),i(5).Buffer)},function(e,t,i){'use strict';(function(e){function o(){return l.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(e,t){if(o()<t)throw new RangeError('Invalid typed array length');return l.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t),e.__proto__=l.prototype):(null===e&&(e=new l(t)),e.length=t),e}function l(e,t,i){if(!l.TYPED_ARRAY_SUPPORT&&!(this instanceof l))return new l(e,t,i);if('number'==typeof e){if('string'==typeof t)throw new Error('If encoding is specified then the first argument must be a string');return f(this,e)}return u(this,e,t,i)}function u(e,t,i,r){if('number'==typeof t)throw new TypeError('"value" argument must not be a number');return'undefined'!=typeof ArrayBuffer&&t instanceof ArrayBuffer?h(e,t,i,r):'string'==typeof t?p(e,t,i):g(e,t)}function c(e){if('number'!=typeof e)throw new TypeError('"size" argument must be a number');else if(0>e)throw new RangeError('"size" argument must not be negative')}function d(e,t,i,r){return c(t),0>=t?a(e,t):void 0===i?a(e,t):'string'==typeof r?a(e,t).fill(i,r):a(e,t).fill(i)}function f(e,t){if(c(t),e=a(e,0>t?0:0|y(t)),!l.TYPED_ARRAY_SUPPORT)for(var r=0;r<t;++r)e[r]=0;return e}function p(e,t,i){if(('string'!=typeof i||''===i)&&(i='utf8'),!l.isEncoding(i))throw new TypeError('"encoding" must be a valid string encoding');var r=0|b(t,i);e=a(e,r);var n=e.write(t,i);return n!==r&&(e=e.slice(0,n)),e}function m(e,t){var r=0>t.length?0:0|y(t.length);e=a(e,r);for(var n=0;n<r;n+=1)e[n]=255&t[n];return e}function h(e,t,i,r){if(t.byteLength,0>i||t.byteLength<i)throw new RangeError('\'offset\' is out of bounds');if(t.byteLength<i+(r||0))throw new RangeError('\'length\' is out of bounds');return t=void 0===i&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,i):new Uint8Array(t,i,r),l.TYPED_ARRAY_SUPPORT?(e=t,e.__proto__=l.prototype):e=m(e,t),e}function g(e,t){if(l.isBuffer(t)){var i=0|y(t.length);return(e=a(e,i),0===e.length)?e:(t.copy(e,0,0,i),e)}if(t){if('undefined'!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||'length'in t)return'number'!=typeof t.length||Z(t.length)?a(e,0):m(e,t);if('Buffer'===t.type&&te(t.data))return m(e,t.data)}throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')}function y(e){if(e>=o())throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x'+o().toString(16)+' bytes');return 0|e}function b(e,t){if(l.isBuffer(e))return e.length;if('undefined'!=typeof ArrayBuffer&&'function'==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;'string'!=typeof e&&(e=''+e);var i=e.length;if(0===i)return 0;for(var r=!1;;)switch(t){case'ascii':case'latin1':case'binary':return i;case'utf8':case'utf-8':case void 0:return W(e).length;case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return 2*i;case'hex':return i>>>1;case'base64':return K(e).length;default:if(r)return W(e).length;t=(''+t).toLowerCase(),r=!0;}}function _(e,t,i){var r=!1;if((void 0===t||0>t)&&(t=0),t>this.length)return'';if((void 0===i||i>this.length)&&(i=this.length),0>=i)return'';if(i>>>=0,t>>>=0,i<=t)return'';for(e||(e='utf8');;)switch(e){case'hex':return M(this,t,i);case'utf8':case'utf-8':return I(this,t,i);case'ascii':return N(this,t,i);case'latin1':case'binary':return P(this,t,i);case'base64':return C(this,t,i);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return U(this,t,i);default:if(r)throw new TypeError('Unknown encoding: '+e);e=(e+'').toLowerCase(),r=!0;}}function v(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function T(e,t,i,r,n){if(0===e.length)return-1;if('string'==typeof i?(r=i,i=0):2147483647<i?i=2147483647:-2147483648>i&&(i=-2147483648),i=+i,isNaN(i)&&(i=n?0:e.length-1),0>i&&(i=e.length+i),i>=e.length){if(n)return-1;i=e.length-1}else if(0>i)if(n)i=0;else return-1;if('string'==typeof t&&(t=l.from(t,r)),l.isBuffer(t))return 0===t.length?-1:x(e,t,i,r,n);if('number'==typeof t)return t&=255,l.TYPED_ARRAY_SUPPORT&&'function'==typeof Uint8Array.prototype.indexOf?n?Uint8Array.prototype.indexOf.call(e,t,i):Uint8Array.prototype.lastIndexOf.call(e,t,i):x(e,[t],i,r,n);throw new TypeError('val must be string, number or Buffer')}function x(e,t,r,n,s){function o(e,t){return 1===a?e[t]:e.readUInt16BE(t*a)}var a=1,l=e.length,u=t.length;if(void 0!==n&&(n=(n+'').toLowerCase(),'ucs2'===n||'ucs-2'===n||'utf16le'===n||'utf-16le'===n)){if(2>e.length||2>t.length)return-1;a=2,l/=2,u/=2,r/=2}var c;if(s){var i=-1;for(c=r;c<l;c++)if(o(e,c)!==o(t,-1==i?0:c-i))-1!=i&&(c-=c-i),i=-1;else if(-1==i&&(i=c),c-i+1===u)return i*a}else for(r+u>l&&(r=l-u),c=r;0<=c;c--){for(var d=!0,f=0;f<u;f++)if(o(e,c+f)!==o(t,f)){d=!1;break}if(d)return c}return-1}function z(e,t,r,n){r=+r||0;var s=e.length-r;n?(n=+n,n>s&&(n=s)):n=s;var o=t.length;if(0!=o%2)throw new TypeError('Invalid hex string');n>o/2&&(n=o/2);for(var a,l=0;l<n;++l){if(a=parseInt(t.substr(2*l,2),16),isNaN(a))return l;e[r+l]=a}return l}function A(e,t,i,r){return J(W(t,e.length-i),e,i,r)}function E(e,t,i,r){return J(G(t),e,i,r)}function w(e,t,i,r){return E(e,t,i,r)}function L(e,t,i,r){return J(K(t),e,i,r)}function S(e,t,i,r){return J(q(t,e.length-i),e,i,r)}function C(e,t,i){return 0===t&&i===e.length?$.fromByteArray(e):$.fromByteArray(e.slice(t,i))}function I(e,t,r){r=s(e.length,r);for(var n=[],o=t;o<r;){var i=e[o],a=null,l=239<i?4:223<i?3:191<i?2:1;if(o+l<=r){var u,c,d,f;1==l?128>i&&(a=i):2==l?(u=e[o+1],128==(192&u)&&(f=(31&i)<<6|63&u,127<f&&(a=f))):3==l?(u=e[o+1],c=e[o+2],128==(192&u)&&128==(192&c)&&(f=(15&i)<<12|(63&u)<<6|63&c,2047<f&&(55296>f||57343<f)&&(a=f))):4==l?(u=e[o+1],c=e[o+2],d=e[o+3],128==(192&u)&&128==(192&c)&&128==(192&d)&&(f=(15&i)<<18|(63&u)<<12|(63&c)<<6|63&d,65535<f&&1114112>f&&(a=f))):void 0}null===a?(a=65533,l=1):65535<a&&(a-=65536,n.push(55296|1023&a>>>10),a=56320|1023&a),n.push(a),o+=l}return k(n)}function k(e){var t=e.length;if(t<=ie)return Q.apply(String,e);for(var r='',n=0;n<t;)r+=Q.apply(String,e.slice(n,n+=ie));return r}function N(e,t,r){var n='';r=s(e.length,r);for(var o=t;o<r;++o)n+=Q(127&e[o]);return n}function P(e,t,r){var n='';r=s(e.length,r);for(var o=t;o<r;++o)n+=Q(e[o]);return n}function M(e,t,r){var n=e.length;(!t||0>t)&&(t=0),(!r||0>r||r>n)&&(r=n);for(var s='',o=t;o<r;++o)s+=X(e[o]);return s}function U(e,t,r){for(var n=e.slice(t,r),s='',o=0;o<n.length;o+=2)s+=Q(n[o]+256*n[o+1]);return s}function O(e,t,i){if(0!=e%1||0>e)throw new RangeError('offset is not uint');if(e+t>i)throw new RangeError('Trying to access beyond buffer length')}function D(e,t,i,r,n,s){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>n||t<s)throw new RangeError('"value" argument is out of bounds');if(i+r>e.length)throw new RangeError('Index out of range')}function F(e,t,r,n){0>t&&(t=65535+t+1);for(var o=0,i=s(e.length-r,2);o<i;++o)e[r+o]=(t&255<<8*(n?o:1-o))>>>8*(n?o:1-o)}function R(e,t,r,n){0>t&&(t=4294967295+t+1);for(var o=0,i=s(e.length-r,4);o<i;++o)e[r+o]=255&t>>>8*(n?o:3-o)}function V(e,t,i,r){if(i+r>e.length)throw new RangeError('Index out of range');if(0>i)throw new RangeError('Index out of range')}function B(e,t,i,r,n){return n||V(e,t,i,4,34028234663852886e22,-34028234663852886e22),ee.write(e,t,i,r,23,4),i+4}function j(e,t,i,r,n){return n||V(e,t,i,8,17976931348623157e292,-17976931348623157e292),ee.write(e,t,i,r,52,8),i+8}function H(e){if(e=Y(e).replace(re,''),2>e.length)return'';for(;0!=e.length%4;)e+='=';return e}function Y(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,'')}function X(e){return 16>e?'0'+e.toString(16):e.toString(16)}function W(e,t){t=t||Infinity;for(var r,n=e.length,s=null,o=[],a=0;a<n;++a){if(r=e.charCodeAt(a),55295<r&&57344>r){if(!s){if(56319<r){-1<(t-=3)&&o.push(239,191,189);continue}else if(a+1===n){-1<(t-=3)&&o.push(239,191,189);continue}s=r;continue}if(56320>r){-1<(t-=3)&&o.push(239,191,189),s=r;continue}r=(s-55296<<10|r-56320)+65536}else s&&-1<(t-=3)&&o.push(239,191,189);if(s=null,128>r){if(0>(t-=1))break;o.push(r)}else if(2048>r){if(0>(t-=2))break;o.push(192|r>>6,128|63&r)}else if(65536>r){if(0>(t-=3))break;o.push(224|r>>12,128|63&r>>6,128|63&r)}else if(1114112>r){if(0>(t-=4))break;o.push(240|r>>18,128|63&r>>12,128|63&r>>6,128|63&r)}else throw new Error('Invalid code point')}return o}function G(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}function q(e,t){for(var r,n,s,o=[],a=0;a<e.length&&!(0>(t-=2));++a)r=e.charCodeAt(a),n=r>>8,s=r%256,o.push(s),o.push(n);return o}function K(e){return $.toByteArray(H(e))}function J(e,t,r,n){for(var s=0;s<n&&!(s+r>=t.length||s>=e.length);++s)t[s+r]=e[s];return s}function Z(e){return e!==e}var Q=String.fromCharCode,$=i(6),ee=i(7),te=i(8);/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */t.Buffer=l,t.SlowBuffer=function(e){return+e!=e&&(e=0),l.alloc(+e)},t.INSPECT_MAX_BYTES=50,l.TYPED_ARRAY_SUPPORT=e.TYPED_ARRAY_SUPPORT===void 0?function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&'function'==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(t){return!1}}():e.TYPED_ARRAY_SUPPORT,t.kMaxLength=o(),l.poolSize=8192,l._augment=function(e){return e.__proto__=l.prototype,e},l.from=function(e,t,i){return u(null,e,t,i)},l.TYPED_ARRAY_SUPPORT&&(l.prototype.__proto__=Uint8Array.prototype,l.__proto__=Uint8Array,'undefined'!=typeof Symbol&&Symbol.species&&l[Symbol.species]===l&&Object.defineProperty(l,Symbol.species,{value:null,configurable:!0})),l.alloc=function(e,t,i){return d(null,e,t,i)},l.allocUnsafe=function(e){return f(null,e)},l.allocUnsafeSlow=function(e){return f(null,e)},l.isBuffer=function(e){return!!(null!=e&&e._isBuffer)},l.compare=function(e,t){if(!l.isBuffer(e)||!l.isBuffer(t))throw new TypeError('Arguments must be Buffers');if(e===t)return 0;for(var r=e.length,n=t.length,o=0,i=s(r,n);o<i;++o)if(e[o]!==t[o]){r=e[o],n=t[o];break}return r<n?-1:n<r?1:0},l.isEncoding=function(e){switch((e+'').toLowerCase()){case'hex':case'utf8':case'utf-8':case'ascii':case'latin1':case'binary':case'base64':case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return!0;default:return!1;}},l.concat=function(e,t){if(!te(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);var r;if(t===void 0)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var i=l.allocUnsafe(t),n=0;for(r=0;r<e.length;++r){var s=e[r];if(!l.isBuffer(s))throw new TypeError('"list" argument must be an Array of Buffers');s.copy(i,n),n+=s.length}return i},l.byteLength=b,l.prototype._isBuffer=!0,l.prototype.swap16=function(){var e=this.length;if(0!=e%2)throw new RangeError('Buffer size must be a multiple of 16-bits');for(var t=0;t<e;t+=2)v(this,t,t+1);return this},l.prototype.swap32=function(){var e=this.length;if(0!=e%4)throw new RangeError('Buffer size must be a multiple of 32-bits');for(var t=0;t<e;t+=4)v(this,t,t+3),v(this,t+1,t+2);return this},l.prototype.swap64=function(){var e=this.length;if(0!=e%8)throw new RangeError('Buffer size must be a multiple of 64-bits');for(var t=0;t<e;t+=8)v(this,t,t+7),v(this,t+1,t+6),v(this,t+2,t+5),v(this,t+3,t+4);return this},l.prototype.toString=function(){var e=0|this.length;return 0==e?'':0===arguments.length?I(this,0,e):_.apply(this,arguments)},l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError('Argument must be a Buffer');return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){var e='',i=t.INSPECT_MAX_BYTES;return 0<this.length&&(e=this.toString('hex',0,i).match(/.{2}/g).join(' '),this.length>i&&(e+=' ... ')),'<Buffer '+e+'>'},l.prototype.compare=function(e,t,r,n,o){if(!l.isBuffer(e))throw new TypeError('Argument must be a Buffer');if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===o&&(o=this.length),0>t||r>e.length||0>n||o>this.length)throw new RangeError('out of range index');if(n>=o&&t>=r)return 0;if(n>=o)return-1;if(t>=r)return 1;if(t>>>=0,r>>>=0,n>>>=0,o>>>=0,this===e)return 0;for(var a=o-n,u=r-t,c=s(a,u),d=this.slice(n,o),f=e.slice(t,r),p=0;p<c;++p)if(d[p]!==f[p]){a=d[p],u=f[p];break}return a<u?-1:u<a?1:0},l.prototype.includes=function(e,t,i){return-1!==this.indexOf(e,t,i)},l.prototype.indexOf=function(e,t,i){return T(this,e,t,i,!0)},l.prototype.lastIndexOf=function(e,t,i){return T(this,e,t,i,!1)},l.prototype.write=function(e,t,i,r){if(void 0===t)r='utf8',i=this.length,t=0;else if(void 0===i&&'string'==typeof t)r=t,i=this.length,t=0;else if(isFinite(t))t|=0,isFinite(i)?(i|=0,void 0===r&&(r='utf8')):(r=i,i=void 0);else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');var n=this.length-t;if((void 0===i||i>n)&&(i=n),0<e.length&&(0>i||0>t)||t>this.length)throw new RangeError('Attempt to write outside buffer bounds');r||(r='utf8');for(var s=!1;;)switch(r){case'hex':return z(this,e,t,i);case'utf8':case'utf-8':return A(this,e,t,i);case'ascii':return E(this,e,t,i);case'latin1':case'binary':return w(this,e,t,i);case'base64':return L(this,e,t,i);case'ucs2':case'ucs-2':case'utf16le':case'utf-16le':return S(this,e,t,i);default:if(s)throw new TypeError('Unknown encoding: '+r);r=(''+r).toLowerCase(),s=!0;}},l.prototype.toJSON=function(){return{type:'Buffer',data:Array.prototype.slice.call(this._arr||this,0)}};var ie=4096;l.prototype.slice=function(e,t){var r=this.length;e=~~e,t=t===void 0?r:~~t,0>e?(e+=r,0>e&&(e=0)):e>r&&(e=r),0>t?(t+=r,0>t&&(t=0)):t>r&&(t=r),t<e&&(t=e);var n;if(l.TYPED_ARRAY_SUPPORT)n=this.subarray(e,t),n.__proto__=l.prototype;else{var s=t-e;n=new l(s,void 0);for(var o=0;o<s;++o)n[o]=this[o+e]}return n},l.prototype.readUIntLE=function(e,t,r){e|=0,t|=0,r||O(e,t,this.length);for(var n=this[e],s=1,o=0;++o<t&&(s*=256);)n+=this[e+o]*s;return n},l.prototype.readUIntBE=function(e,t,i){e|=0,t|=0,i||O(e,t,this.length);for(var r=this[e+--t],n=1;0<t&&(n*=256);)r+=this[e+--t]*n;return r},l.prototype.readUInt8=function(e,t){return t||O(e,1,this.length),this[e]},l.prototype.readUInt16LE=function(e,t){return t||O(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUInt16BE=function(e,t){return t||O(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUInt32LE=function(e,t){return t||O(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUInt32BE=function(e,t){return t||O(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readIntLE=function(e,t,r){e|=0,t|=0,r||O(e,t,this.length);for(var s=this[e],o=1,a=0;++a<t&&(o*=256);)s+=this[e+a]*o;return o*=128,s>=o&&(s-=n(2,8*t)),s},l.prototype.readIntBE=function(e,t,r){e|=0,t|=0,r||O(e,t,this.length);for(var s=t,i=1,o=this[e+--s];0<s&&(i*=256);)o+=this[e+--s]*i;return i*=128,o>=i&&(o-=n(2,8*t)),o},l.prototype.readInt8=function(e,t){return t||O(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,t){t||O(e,2,this.length);var i=this[e]|this[e+1]<<8;return 32768&i?4294901760|i:i},l.prototype.readInt16BE=function(e,t){t||O(e,2,this.length);var i=this[e+1]|this[e]<<8;return 32768&i?4294901760|i:i},l.prototype.readInt32LE=function(e,t){return t||O(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,t){return t||O(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readFloatLE=function(e,t){return t||O(e,4,this.length),ee.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,t){return t||O(e,4,this.length),ee.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,t){return t||O(e,8,this.length),ee.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,t){return t||O(e,8,this.length),ee.read(this,e,!1,52,8)},l.prototype.writeUIntLE=function(e,t,r,s){if(e=+e,t|=0,r|=0,!s){var o=n(2,8*r)-1;D(this,e,t,r,o,0)}var a=1,l=0;for(this[t]=255&e;++l<r&&(a*=256);)this[t+l]=255&e/a;return t+r},l.prototype.writeUIntBE=function(e,t,r,s){if(e=+e,t|=0,r|=0,!s){var o=n(2,8*r)-1;D(this,e,t,r,o,0)}var a=r-1,i=1;for(this[t+a]=255&e;0<=--a&&(i*=256);)this[t+a]=255&e/i;return t+r},l.prototype.writeUInt8=function(e,t,i){return e=+e,t|=0,i||D(this,e,t,1,255,0),l.TYPED_ARRAY_SUPPORT||(e=r(e)),this[t]=255&e,t+1},l.prototype.writeUInt16LE=function(e,t,i){return e=+e,t|=0,i||D(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):F(this,e,t,!0),t+2},l.prototype.writeUInt16BE=function(e,t,i){return e=+e,t|=0,i||D(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):F(this,e,t,!1),t+2},l.prototype.writeUInt32LE=function(e,t,i){return e=+e,t|=0,i||D(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):R(this,e,t,!0),t+4},l.prototype.writeUInt32BE=function(e,t,i){return e=+e,t|=0,i||D(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):R(this,e,t,!1),t+4},l.prototype.writeIntLE=function(e,t,r,s){if(e=+e,t|=0,!s){var o=n(2,8*r-1);D(this,e,t,r,o-1,-o)}var a=0,i=1,l=0;for(this[t]=255&e;++a<r&&(i*=256);)0>e&&0==l&&0!==this[t+a-1]&&(l=1),this[t+a]=255&(e/i>>0)-l;return t+r},l.prototype.writeIntBE=function(e,t,r,s){if(e=+e,t|=0,!s){var o=n(2,8*r-1);D(this,e,t,r,o-1,-o)}var a=r-1,i=1,l=0;for(this[t+a]=255&e;0<=--a&&(i*=256);)0>e&&0==l&&0!==this[t+a+1]&&(l=1),this[t+a]=255&(e/i>>0)-l;return t+r},l.prototype.writeInt8=function(e,t,i){return e=+e,t|=0,i||D(this,e,t,1,127,-128),l.TYPED_ARRAY_SUPPORT||(e=r(e)),0>e&&(e=255+e+1),this[t]=255&e,t+1},l.prototype.writeInt16LE=function(e,t,i){return e=+e,t|=0,i||D(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):F(this,e,t,!0),t+2},l.prototype.writeInt16BE=function(e,t,i){return e=+e,t|=0,i||D(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):F(this,e,t,!1),t+2},l.prototype.writeInt32LE=function(e,t,i){return e=+e,t|=0,i||D(this,e,t,4,2147483647,-2147483648),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):R(this,e,t,!0),t+4},l.prototype.writeInt32BE=function(e,t,i){return e=+e,t|=0,i||D(this,e,t,4,2147483647,-2147483648),0>e&&(e=4294967295+e+1),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):R(this,e,t,!1),t+4},l.prototype.writeFloatLE=function(e,t,i){return B(this,e,t,!0,i)},l.prototype.writeFloatBE=function(e,t,i){return B(this,e,t,!1,i)},l.prototype.writeDoubleLE=function(e,t,i){return j(this,e,t,!0,i)},l.prototype.writeDoubleBE=function(e,t,i){return j(this,e,t,!1,i)},l.prototype.copy=function(e,t,r,n){if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),0<n&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(0>t)throw new RangeError('targetStart out of bounds');if(0>r||r>=this.length)throw new RangeError('sourceStart out of bounds');if(0>n)throw new RangeError('sourceEnd out of bounds');n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var s,i=n-r;if(this===e&&r<t&&t<n)for(s=i-1;0<=s;--s)e[s+t]=this[s+r];else if(1e3>i||!l.TYPED_ARRAY_SUPPORT)for(s=0;s<i;++s)e[s+t]=this[s+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+i),t);return i},l.prototype.fill=function(e,t,r,n){if('string'==typeof e){if('string'==typeof t?(n=t,t=0,r=this.length):'string'==typeof r&&(n=r,r=this.length),1===e.length){var s=e.charCodeAt(0);256>s&&(e=s)}if(void 0!==n&&'string'!=typeof n)throw new TypeError('encoding must be a string');if('string'==typeof n&&!l.isEncoding(n))throw new TypeError('Unknown encoding: '+n)}else'number'==typeof e&&(e&=255);if(0>t||this.length<t||this.length<r)throw new RangeError('Out of range index');if(r<=t)return this;t>>>=0,r=r===void 0?this.length:r>>>0,e||(e=0);var o;if('number'==typeof e)for(o=t;o<r;++o)this[o]=e;else{var i=l.isBuffer(e)?e:W(new l(e,n).toString()),a=i.length;for(o=0;o<r-t;++o)this[o+t]=i[o%a]}return this};var re=/[^+\/0-9A-Za-z-_]/g}).call(t,i(2))},function(e,t){'use strict';function r(e){var t=e.length;if(0<t%4)throw new Error('Invalid string. Length must be a multiple of 4');return'='===e[t-2]?2:'='===e[t-1]?1:0}function n(e){var t,i,n,s,o,a=e.length;s=r(e),o=new c(3*a/4-s),i=0<s?a-4:a;var l=0;for(t=0;t<i;t+=4)n=u[e.charCodeAt(t)]<<18|u[e.charCodeAt(t+1)]<<12|u[e.charCodeAt(t+2)]<<6|u[e.charCodeAt(t+3)],o[l++]=255&n>>16,o[l++]=255&n>>8,o[l++]=255&n;return 2===s?(n=u[e.charCodeAt(t)]<<2|u[e.charCodeAt(t+1)]>>4,o[l++]=255&n):1===s&&(n=u[e.charCodeAt(t)]<<10|u[e.charCodeAt(t+1)]<<4|u[e.charCodeAt(t+2)]>>2,o[l++]=255&n>>8,o[l++]=255&n),o}function s(e){return l[63&e>>18]+l[63&e>>12]+l[63&e>>6]+l[63&e]}function o(e,t,r){for(var n,o=[],a=t;a<r;a+=3)n=(e[a]<<16)+(e[a+1]<<8)+e[a+2],o.push(s(n));return o.join('')}function a(e){for(var t,r=e.length,n=r%3,s='',a=[],u=16383,c=0,i=r-n;c<i;c+=u)a.push(o(e,c,c+u>i?i:c+u));return 1==n?(t=e[r-1],s+=l[t>>2],s+=l[63&t<<4],s+='=='):2==n&&(t=(e[r-2]<<8)+e[r-1],s+=l[t>>10],s+=l[63&t>>4],s+=l[63&t<<2],s+='='),a.push(s),a.join('')}t.byteLength=function(e){return 3*e.length/4-r(e)},t.toByteArray=n,t.fromByteArray=a;for(var l=[],u=[],c='undefined'==typeof Uint8Array?Array:Uint8Array,d='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',f=0,i=d.length;f<i;++f)l[f]=d[f],u[d.charCodeAt(f)]=f;u[45]=62,u[95]=63},function(e,t){t.read=function(t,r,o,a,l){var u,e,c=8*l-a-1,f=(1<<c)-1,p=f>>1,m=-7,h=o?l-1:0,i=o?-1:1,d=t[r+h];for(h+=i,u=d&(1<<-m)-1,d>>=-m,m+=c;0<m;u=256*u+t[r+h],h+=i,m-=8);for(e=u&(1<<-m)-1,u>>=-m,m+=a;0<m;e=256*e+t[r+h],h+=i,m-=8);if(0===u)u=1-p;else{if(u===f)return e?NaN:(d?-1:1)*Infinity;e+=n(2,a),u-=p}return(d?-1:1)*e*n(2,u-a)},t.write=function(t,o,a,l,u,f){var p,h,m,c=8*f-u-1,g=(1<<c)-1,y=g>>1,b=23===u?5.960464477539063e-8-6.617444900424222e-24:0,_=l?0:f-1,i=l?1:-1,d=0>o||0===o&&0>1/o?1:0;for(o=Math.abs(o),isNaN(o)||o===Infinity?(h=isNaN(o)?1:0,p=g):(p=r(Math.log(o)/Math.LN2),1>o*(m=n(2,-p))&&(p--,m*=2),o+=1<=p+y?b/m:b*n(2,1-y),2<=o*m&&(p++,m/=2),p+y>=g?(h=0,p=g):1<=p+y?(h=(o*m-1)*n(2,u),p+=y):(h=o*n(2,y-1)*n(2,u),p=0));8<=u;t[a+_]=255&h,_+=i,h/=256,u-=8);for(p=p<<u|h,c+=u;0<c;t[a+_]=255&p,_+=i,p/=256,c-=8);t[a+_-i]|=128*d}},function(e){var t={}.toString;e.exports=Array.isArray||function(e){return'[object Array]'==t.call(e)}},function(){},function(e,t){var i=Number.MAX_VALUE;t.endianness=function(){return'LE'},t.hostname=function(){return'undefined'==typeof location?'':location.hostname},t.loadavg=function(){return[]},t.uptime=function(){return 0},t.freemem=function(){return i},t.totalmem=function(){return i},t.cpus=function(){return[]},t.type=function(){return'Browser'},t.release=function(){return'undefined'==typeof navigator?'':navigator.appVersion},t.networkInterfaces=t.getNetworkInterfaces=function(){return{}},t.arch=function(){return'javascript'},t.platform=function(){return'browser'},t.tmpdir=t.tmpDir=function(){return'/tmp'},t.EOL='\n',t.homedir=function(){return'/'}},function(i){if('undefined'==typeof t){var r=new Error('Cannot find module "undefined"');throw r.code='MODULE_NOT_FOUND',r}i.exports=t},function(t){t.exports=e},function(e){e.exports={version:{desc:'Prints just the compiler\'s version and exits.',type:'boolean',aliases:['v']},help:{desc:'Prints this message and exits.',type:'boolean',aliases:['h']},optimize:{desc:['Optimizes the module. Also accepts the optimize level:','',' -O     Uses defaults. Equivalent to -O2s',' -O0    Equivalent to --optimizeLevel 0',' -O1    Equivalent to --optimizeLevel 1',' -O2    Equivalent to --optimizeLevel 2',' -O3    Equivalent to --optimizeLevel 3',' -Oz    Equivalent to -O but with --shrinkLevel 2',' -O3s   Equivalent to -O3 with --shrinkLevel 1 etc.',''],type:'boolean',aliases:['O']},optimizeLevel:{desc:'How much to focus on optimizing code. [0-3]',type:'number'},shrinkLevel:{desc:'How much to focus on shrinking code size. [0-2, s=1, z=2]',type:'number'},validate:{desc:'Validates the module using Binaryen. Exits if invalid.',type:'boolean',aliases:['c','check']},baseDir:{desc:'Specifies the base directory of input and output files.',type:'string'},outFile:{desc:'Specifies the output file. File extension indicates format.',type:'string',aliases:['o']},binaryFile:{desc:'Specifies the binary output file (.wasm).',type:'string',aliases:['b']},textFile:{desc:'Specifies the text output file (.wast).',type:'string',aliases:['t']},asmjsFile:{desc:'Specifies the asm.js output file (.js).',type:'string',aliases:['a']},sourceMap:{desc:['Enables source map generation. Optionally takes the URL','used to reference the source map from the binary file.'],type:'string'},noTreeShaking:{desc:'Disables compiler-level tree-shaking, compiling everything.',type:'boolean'},noDebug:{desc:'Disables maintaining of debug information in binaries.',type:'boolean'},noAssert:{desc:'Replaces assertions with just their value without trapping.',type:'boolean'},noEmit:{desc:'Performs compilation as usual but does not emit code.',type:'boolean'},noMemory:{desc:'Does not set up a memory. Useful for low-level WebAssembly.',type:'boolean'},noLib:{desc:'Does not include the shipped standard library.',type:'boolean'},lib:{desc:['Adds one or multiple paths to custom library components and','uses exports of all top-level files at this path as globals.'],type:'string'},trapMode:{desc:['Sets the trap mode to use.','',' allow  Allow trapping operations. This is the default.',' clamp  Replace trapping operations with clamping semantics.',' js     Replace trapping operations with JS semantics.',''],type:'string',default:'allow'},runPasses:{desc:['Specifies additional Binaryen passes to run after other','optimizations, if any. See: Binaryen/src/passes/pass.cpp'],type:'string'},measure:{desc:'Prints measuring information on I/O and compile times.',type:'boolean'}}},function(e){function t(e,t){var i=e;t.slice(0,-1).forEach(function(e){i=i[e]||{}});var r=t[t.length-1];return r in i}function r(e){return!('number'!=typeof e)||!!/^0x[0-9a-f]+$/i.test(e)||/^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(e)}e.exports=function(e,n){function s(e,t){return u.allBools&&/^--[^=]+$/.test(t)||u.strings[e]||u.bools[e]||c[e]}function o(e,t,i){if(!(i&&u.unknownFn&&!s(e,i)&&!1===u.unknownFn(i))){var n=!u.strings[e]&&r(t)?+t:t;a(f,e.split('.'),n),(c[e]||[]).forEach(function(e){a(f,e.split('.'),n)})}}function a(e,t,i){var r=e;t.slice(0,-1).forEach(function(e){void 0===r[e]&&(r[e]={}),r=r[e]});var n=t[t.length-1];void 0===r[n]||u.bools[n]||'boolean'==typeof r[n]?r[n]=i:Array.isArray(r[n])?r[n].push(i):r[n]=[r[n],i]}function l(e){return c[e].some(function(e){return u.bools[e]})}n||(n={});var u={bools:{},strings:{},unknownFn:null};'function'==typeof n.unknown&&(u.unknownFn=n.unknown),'boolean'==typeof n.boolean&&n.boolean?u.allBools=!0:[].concat(n.boolean).filter(Boolean).forEach(function(e){u.bools[e]=!0});var c={};Object.keys(n.alias||{}).forEach(function(e){c[e]=[].concat(n.alias[e]),c[e].forEach(function(t){c[t]=[e].concat(c[e].filter(function(e){return t!==e}))})}),[].concat(n.string).filter(Boolean).forEach(function(e){u.strings[e]=!0,c[e]&&(u.strings[c[e]]=!0)});var d=n['default']||{},f={_:[]};Object.keys(u.bools).forEach(function(e){o(e,void 0!==d[e]&&d[e])});var p=[];-1!==e.indexOf('--')&&(p=e.slice(e.indexOf('--')+1),e=e.slice(0,e.indexOf('--')));for(var h,g=0;g<e.length;g++)if(h=e[g],/^--.+=/.test(h)){var i=h.match(/^--([^=]+)=([\s\S]*)$/),m=i[1],y=i[2];u.bools[m]&&(y='false'!==y),o(m,y,h)}else if(/^--no-.+/.test(h)){var m=h.match(/^--no-(.+)/)[1];o(m,!1,h)}else if(/^--.+/.test(h)){var m=h.match(/^--(.+)/)[1],b=e[g+1];void 0===b||/^-/.test(b)||u.bools[m]||u.allBools||!!c[m]&&!!l(m)?/^(true|false)$/.test(b)?(o(m,'true'===b,h),g++):o(m,!u.strings[m]||'',h):(o(m,b,h),g++)}else if(/^-[^-]+/.test(h)){for(var b,_=h.slice(1,-1).split(''),v=!1,T=0;T<_.length;T++){if(b=h.slice(T+2),'-'===b){o(_[T],b,h);continue}if(/[A-Za-z]/.test(_[T])&&/=/.test(b)){o(_[T],b.split('=')[1],h),v=!0;break}if(/[A-Za-z]/.test(_[T])&&/-?\d+(\.\d*)?(e-?\d+)?$/.test(b)){o(_[T],b,h),v=!0;break}if(_[T+1]&&_[T+1].match(/\W/)){o(_[T],h.slice(T+2),h),v=!0;break}else o(_[T],!u.strings[_[T]]||'',h)}var m=h.slice(-1)[0];v||'-'===m||(!e[g+1]||/^(-|--)[^-]/.test(e[g+1])||u.bools[m]||c[m]&&l(m)?e[g+1]&&/true|false/.test(e[g+1])?(o(m,'true'===e[g+1],h),g++):o(m,!u.strings[m]||'',h):(o(m,e[g+1],h),g++))}else if(u.unknownFn&&!1===u.unknownFn(h)||f._.push(u.strings._||!r(h)?h:+h),n.stopEarly){f._.push.apply(f._,e.slice(g+1));break}return Object.keys(d).forEach(function(e){t(f,e.split('.'))||(a(f,e.split('.'),d[e]),(c[e]||[]).forEach(function(t){a(f,t.split('.'),d[e])}))}),n['--']?(f['--']=[],p.forEach(function(e){f['--'].push(e)})):p.forEach(function(e){f._.push(e)}),f}},function(e,t,i){(function(t,i){e.exports=t.hrtime||function(e){var t=1e-3*s.call(n),i=r(t),o=r(1e9*(t%1));return e&&(i-=e[0],o-=e[1],0>o&&(i--,o+=1e9)),[i,o]};var n=i.performance||{},s=n.now||n.mozNow||n.msNow||n.oNow||n.webkitNow||function(){return new Date().getTime()}}).call(t,i(0),i(2))}])});