!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n(function(){try{return require("assemblyscript")}catch(e){}}()):"function"==typeof define&&define.amd?define(["assemblyscript"],n):"object"==typeof exports?exports.asc=n(function(){try{return require("assemblyscript")}catch(e){}}()):e.asc=n(e._)}(window,function(e){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=14)}([function(e,n,t){var r,i;n.nextTick=function(e){setTimeout(e,0)},n.platform=n.arch=n.execPath=n.title="browser",n.pid=1,n.browser=!0,n.env={},n.argv=[],n.binding=function(e){throw new Error("No such module. (Possibly not yet loaded)")},i="/",n.cwd=function(){return i},n.chdir=function(e){r||(r=t(2)),i=r.resolve(e,i)},n.exit=n.kill=n.umask=n.dlopen=n.uptime=n.memoryUsage=n.uvCounters=function(){},n.features={}},function(e,n){var t;t=function(){return this}();try{t=t||Function("return this")()||(0,eval)("this")}catch(e){"object"==typeof window&&(t=window)}e.exports=t},function(e,n,t){(function(e){function t(e,n){for(var t=0,r=e.length-1;r>=0;r--){var i=e[r];"."===i?e.splice(r,1):".."===i?(e.splice(r,1),t++):t&&(e.splice(r,1),t--)}if(n)for(;t--;t)e.unshift("..");return e}var r=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,i=function(e){return r.exec(e).slice(1)};function o(e,n){if(e.filter)return e.filter(n);for(var t=[],r=0;r<e.length;r++)n(e[r],r,e)&&t.push(e[r]);return t}n.resolve=function(){for(var n="",r=!1,i=arguments.length-1;i>=-1&&!r;i--){var s=i>=0?arguments[i]:e.cwd();if("string"!=typeof s)throw new TypeError("Arguments to path.resolve must be strings");s&&(n=s+"/"+n,r="/"===s.charAt(0))}return n=t(o(n.split("/"),function(e){return!!e}),!r).join("/"),(r?"/":"")+n||"."},n.normalize=function(e){var r=n.isAbsolute(e),i="/"===s(e,-1);return(e=t(o(e.split("/"),function(e){return!!e}),!r).join("/"))||r||(e="."),e&&i&&(e+="/"),(r?"/":"")+e},n.isAbsolute=function(e){return"/"===e.charAt(0)},n.join=function(){var e=Array.prototype.slice.call(arguments,0);return n.normalize(o(e,function(e,n){if("string"!=typeof e)throw new TypeError("Arguments to path.join must be strings");return e}).join("/"))},n.relative=function(e,t){function r(e){for(var n=0;n<e.length&&""===e[n];n++);for(var t=e.length-1;t>=0&&""===e[t];t--);return n>t?[]:e.slice(n,t-n+1)}e=n.resolve(e).substr(1),t=n.resolve(t).substr(1);for(var i=r(e.split("/")),o=r(t.split("/")),s=Math.min(i.length,o.length),a=s,l=0;l<s;l++)if(i[l]!==o[l]){a=l;break}var u=[];for(l=a;l<i.length;l++)u.push("..");return(u=u.concat(o.slice(a))).join("/")},n.sep="/",n.delimiter=":",n.dirname=function(e){var n=i(e),t=n[0],r=n[1];return t||r?(r&&(r=r.substr(0,r.length-1)),t+r):"."},n.basename=function(e,n){var t=i(e)[2];return n&&t.substr(-1*n.length)===n&&(t=t.substr(0,t.length-n.length)),t},n.extname=function(e){return i(e)[3]};var s="b"==="ab".substr(-1)?function(e,n,t){return e.substr(n,t)}:function(e,n,t){return n<0&&(n=e.length+n),e.substr(n,t)}}).call(this,t(0))},function(e,n,t){(function(n,t){e.exports=n.hrtime||function(e){var n=.001*i.call(r),t=Math.floor(n),o=Math.floor(n%1*1e9);e&&(t-=e[0],(o-=e[1])<0&&(t--,o+=1e9));return[t,o]};var r=t.performance||{},i=r.now||r.mozNow||r.msNow||r.oNow||r.webkitNow||function(){return(new Date).getTime()}}).call(this,t(0),t(1))},function(e,n){function t(e){return"number"==typeof e||(!!/^0x[0-9a-f]+$/i.test(e)||/^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(e))}e.exports=function(e,n){n||(n={});var r={bools:{},strings:{},unknownFn:null};"function"==typeof n.unknown&&(r.unknownFn=n.unknown),"boolean"==typeof n.boolean&&n.boolean?r.allBools=!0:[].concat(n.boolean).filter(Boolean).forEach(function(e){r.bools[e]=!0});var i={};Object.keys(n.alias||{}).forEach(function(e){i[e]=[].concat(n.alias[e]),i[e].forEach(function(n){i[n]=[e].concat(i[e].filter(function(e){return n!==e}))})}),[].concat(n.string).filter(Boolean).forEach(function(e){r.strings[e]=!0,i[e]&&(r.strings[i[e]]=!0)});var o=n.default||{},s={_:[]};Object.keys(r.bools).forEach(function(e){l(e,void 0!==o[e]&&o[e])});var a=[];function l(e,n,o){if(!o||!r.unknownFn||function(e,n){return r.allBools&&/^--[^=]+$/.test(n)||r.strings[e]||r.bools[e]||i[e]}(e,o)||!1!==r.unknownFn(o)){var a=!r.strings[e]&&t(n)?Number(n):n;u(s,e.split("."),a),(i[e]||[]).forEach(function(e){u(s,e.split("."),a)})}}function u(e,n,t){var i=e;n.slice(0,-1).forEach(function(e){void 0===i[e]&&(i[e]={}),i=i[e]});var o=n[n.length-1];void 0===i[o]||r.bools[o]||"boolean"==typeof i[o]?i[o]=t:Array.isArray(i[o])?i[o].push(t):i[o]=[i[o],t]}function c(e){return i[e].some(function(e){return r.bools[e]})}-1!==e.indexOf("--")&&(a=e.slice(e.indexOf("--")+1),e=e.slice(0,e.indexOf("--")));for(var f=0;f<e.length;f++){var h=e[f];if(/^--.+=/.test(h)){var d=h.match(/^--([^=]+)=([\s\S]*)$/),p=d[1],m=d[2];r.bools[p]&&(m="false"!==m),l(p,m,h)}else if(/^--no-.+/.test(h)){l(p=h.match(/^--no-(.+)/)[1],!1,h)}else if(/^--.+/.test(h)){p=h.match(/^--(.+)/)[1];void 0===(v=e[f+1])||/^-/.test(v)||r.bools[p]||r.allBools||i[p]&&c(p)?/^(true|false)$/.test(v)?(l(p,"true"===v,h),f++):l(p,!r.strings[p]||"",h):(l(p,v,h),f++)}else if(/^-[^-]+/.test(h)){for(var g=h.slice(1,-1).split(""),y=!1,b=0;b<g.length;b++){var v;if("-"!==(v=h.slice(b+2))){if(/[A-Za-z]/.test(g[b])&&/=/.test(v)){l(g[b],v.split("=")[1],h),y=!0;break}if(/[A-Za-z]/.test(g[b])&&/-?\d+(\.\d*)?(e-?\d+)?$/.test(v)){l(g[b],v,h),y=!0;break}if(g[b+1]&&g[b+1].match(/\W/)){l(g[b],h.slice(b+2),h),y=!0;break}l(g[b],!r.strings[g[b]]||"",h)}else l(g[b],v,h)}p=h.slice(-1)[0];y||"-"===p||(!e[f+1]||/^(-|--)[^-]/.test(e[f+1])||r.bools[p]||i[p]&&c(p)?e[f+1]&&/true|false/.test(e[f+1])?(l(p,"true"===e[f+1],h),f++):l(p,!r.strings[p]||"",h):(l(p,e[f+1],h),f++))}else if(r.unknownFn&&!1===r.unknownFn(h)||s._.push(r.strings._||!t(h)?h:Number(h)),n.stopEarly){s._.push.apply(s._,e.slice(f+1));break}}return Object.keys(o).forEach(function(e){var n,t,r;n=s,t=e.split("."),r=n,t.slice(0,-1).forEach(function(e){r=r[e]||{}}),t[t.length-1]in r||(u(s,e.split("."),o[e]),(i[e]||[]).forEach(function(n){u(s,n.split("."),o[e])}))}),n["--"]?(s["--"]=new Array,a.forEach(function(e){s["--"].push(e)})):a.forEach(function(e){s._.push(e)}),s}},function(e){e.exports={version:{desc:"Prints just the compiler's version and exits.",type:"boolean",aliases:["v"]},help:{desc:"Prints this message and exits.",type:"boolean",aliases:["h"]},optimize:{desc:["Optimizes the module. Also accepts the optimize level:",""," -O     Uses defaults. Equivalent to -O2s"," -O0    Equivalent to --optimizeLevel 0"," -O1    Equivalent to --optimizeLevel 1"," -O2    Equivalent to --optimizeLevel 2"," -O3    Equivalent to --optimizeLevel 3"," -Oz    Equivalent to -O but with --shrinkLevel 2"," -O3s   Equivalent to -O3 with --shrinkLevel 1 etc.",""],type:"boolean",aliases:["O"]},optimizeLevel:{desc:"How much to focus on optimizing code. [0-3]",type:"number"},shrinkLevel:{desc:"How much to focus on shrinking code size. [0-2, s=1, z=2]",type:"number"},validate:{desc:"Validates the module using Binaryen. Exits if invalid.",type:"boolean",aliases:["c","check"]},baseDir:{desc:"Specifies the base directory of input and output files.",type:"string"},outFile:{desc:"Specifies the output file. File extension indicates format.",type:"string",aliases:["o"]},binaryFile:{desc:"Specifies the binary output file (.wasm).",type:"string",aliases:["b"]},textFile:{desc:"Specifies the text output file (.wat).",type:"string",aliases:["t"]},asmjsFile:{desc:"Specifies the asm.js output file (.js).",type:"string",aliases:["a"]},sourceMap:{desc:["Enables source map generation. Optionally takes the URL","used to reference the source map from the binary file."],type:"string"},noTreeShaking:{desc:"Disables compiler-level tree-shaking, compiling everything.",type:"boolean"},noDebug:{desc:"Disables maintaining of debug information in binaries.",type:"boolean"},noAssert:{desc:"Replaces assertions with just their value without trapping.",type:"boolean"},noEmit:{desc:"Performs compilation as usual but does not emit code.",type:"boolean"},noMemory:{desc:"Does not set up a memory. Useful for low-level WebAssembly.",type:"boolean"},importMemory:{desc:"Imports the memory instance provided by the embedder.",type:"boolean"},memoryBase:{desc:"Sets the start offset of compiler-generated static memory.",type:"number"},noLib:{desc:"Does not include the shipped standard library.",type:"boolean"},lib:{desc:["Adds one or multiple paths to custom library components and","uses exports of all top-level files at this path as globals."],type:"string"},trapMode:{desc:["Sets the trap mode to use.",""," allow  Allow trapping operations. This is the default."," clamp  Replace trapping operations with clamping semantics."," js     Replace trapping operations with JS semantics.",""],type:"string",default:"allow"},runPasses:{desc:["Specifies additional Binaryen passes to run after other","optimizations, if any. See: Binaryen/src/passes/pass.cpp"],type:"string"},measure:{desc:"Prints measuring information on I/O and compile times.",type:"boolean"}}},function(n,t){if(void 0===e){var r=new Error('Cannot find module "undefined"');throw r.code="MODULE_NOT_FOUND",r}n.exports=e},function(e,n){n.endianness=function(){return"LE"},n.hostname=function(){return"undefined"!=typeof location?location.hostname:""},n.loadavg=function(){return[]},n.uptime=function(){return 0},n.freemem=function(){return Number.MAX_VALUE},n.totalmem=function(){return Number.MAX_VALUE},n.cpus=function(){return[]},n.type=function(){return"Browser"},n.release=function(){return"undefined"!=typeof navigator?navigator.appVersion:""},n.networkInterfaces=n.getNetworkInterfaces=function(){return{}},n.arch=function(){return"javascript"},n.platform=function(){return"browser"},n.tmpdir=n.tmpDir=function(){return"/tmp"},n.EOL="\n",n.homedir=function(){return"/"}},function(e,n){},function(e,n){var t={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==t.call(e)}},function(e,n){n.read=function(e,n,t,r,i){var o,s,a=8*i-r-1,l=(1<<a)-1,u=l>>1,c=-7,f=t?i-1:0,h=t?-1:1,d=e[n+f];for(f+=h,o=d&(1<<-c)-1,d>>=-c,c+=a;c>0;o=256*o+e[n+f],f+=h,c-=8);for(s=o&(1<<-c)-1,o>>=-c,c+=r;c>0;s=256*s+e[n+f],f+=h,c-=8);if(0===o)o=1-u;else{if(o===l)return s?NaN:1/0*(d?-1:1);s+=Math.pow(2,r),o-=u}return(d?-1:1)*s*Math.pow(2,o-r)},n.write=function(e,n,t,r,i,o){var s,a,l,u=8*o-i-1,c=(1<<u)-1,f=c>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=r?0:o-1,p=r?1:-1,m=n<0||0===n&&1/n<0?1:0;for(n=Math.abs(n),isNaN(n)||n===1/0?(a=isNaN(n)?1:0,s=c):(s=Math.floor(Math.log(n)/Math.LN2),n*(l=Math.pow(2,-s))<1&&(s--,l*=2),(n+=s+f>=1?h/l:h*Math.pow(2,1-f))*l>=2&&(s++,l/=2),s+f>=c?(a=0,s=c):s+f>=1?(a=(n*l-1)*Math.pow(2,i),s+=f):(a=n*Math.pow(2,f-1)*Math.pow(2,i),s=0));i>=8;e[t+d]=255&a,d+=p,a/=256,i-=8);for(s=s<<i|a,u+=i;u>0;e[t+d]=255&s,d+=p,s/=256,u-=8);e[t+d-p]|=128*m}},function(e,n,t){"use strict";n.byteLength=function(e){return 3*e.length/4-u(e)},n.toByteArray=function(e){var n,t,r,s,a,l=e.length;s=u(e),a=new o(3*l/4-s),t=s>0?l-4:l;var c=0;for(n=0;n<t;n+=4)r=i[e.charCodeAt(n)]<<18|i[e.charCodeAt(n+1)]<<12|i[e.charCodeAt(n+2)]<<6|i[e.charCodeAt(n+3)],a[c++]=r>>16&255,a[c++]=r>>8&255,a[c++]=255&r;2===s?(r=i[e.charCodeAt(n)]<<2|i[e.charCodeAt(n+1)]>>4,a[c++]=255&r):1===s&&(r=i[e.charCodeAt(n)]<<10|i[e.charCodeAt(n+1)]<<4|i[e.charCodeAt(n+2)]>>2,a[c++]=r>>8&255,a[c++]=255&r);return a},n.fromByteArray=function(e){for(var n,t=e.length,i=t%3,o="",s=[],a=0,l=t-i;a<l;a+=16383)s.push(c(e,a,a+16383>l?l:a+16383));1===i?(n=e[t-1],o+=r[n>>2],o+=r[n<<4&63],o+="=="):2===i&&(n=(e[t-2]<<8)+e[t-1],o+=r[n>>10],o+=r[n>>4&63],o+=r[n<<2&63],o+="=");return s.push(o),s.join("")};for(var r=[],i=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0,l=s.length;a<l;++a)r[a]=s[a],i[s.charCodeAt(a)]=a;function u(e){var n=e.length;if(n%4>0)throw new Error("Invalid string. Length must be a multiple of 4");return"="===e[n-2]?2:"="===e[n-1]?1:0}function c(e,n,t){for(var i,o,s=[],a=n;a<t;a+=3)i=(e[a]<<16&16711680)+(e[a+1]<<8&65280)+(255&e[a+2]),s.push(r[(o=i)>>18&63]+r[o>>12&63]+r[o>>6&63]+r[63&o]);return s.join("")}i["-".charCodeAt(0)]=62,i["_".charCodeAt(0)]=63},function(e,n,t){"use strict";(function(e){var r=t(11),i=t(10),o=t(9);function s(){return l.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(e,n){if(s()<n)throw new RangeError("Invalid typed array length");return l.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(n)).__proto__=l.prototype:(null===e&&(e=new l(n)),e.length=n),e}function l(e,n,t){if(!(l.TYPED_ARRAY_SUPPORT||this instanceof l))return new l(e,n,t);if("number"==typeof e){if("string"==typeof n)throw new Error("If encoding is specified then the first argument must be a string");return f(this,e)}return u(this,e,n,t)}function u(e,n,t,r){if("number"==typeof n)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&n instanceof ArrayBuffer?function(e,n,t,r){if(n.byteLength,t<0||n.byteLength<t)throw new RangeError("'offset' is out of bounds");if(n.byteLength<t+(r||0))throw new RangeError("'length' is out of bounds");n=void 0===t&&void 0===r?new Uint8Array(n):void 0===r?new Uint8Array(n,t):new Uint8Array(n,t,r);l.TYPED_ARRAY_SUPPORT?(e=n).__proto__=l.prototype:e=h(e,n);return e}(e,n,t,r):"string"==typeof n?function(e,n,t){"string"==typeof t&&""!==t||(t="utf8");if(!l.isEncoding(t))throw new TypeError('"encoding" must be a valid string encoding');var r=0|p(n,t),i=(e=a(e,r)).write(n,t);i!==r&&(e=e.slice(0,i));return e}(e,n,t):function(e,n){if(l.isBuffer(n)){var t=0|d(n.length);return 0===(e=a(e,t)).length?e:(n.copy(e,0,0,t),e)}if(n){if("undefined"!=typeof ArrayBuffer&&n.buffer instanceof ArrayBuffer||"length"in n)return"number"!=typeof n.length||(r=n.length)!=r?a(e,0):h(e,n);if("Buffer"===n.type&&o(n.data))return h(e,n.data)}var r;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,n)}function c(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function f(e,n){if(c(n),e=a(e,n<0?0:0|d(n)),!l.TYPED_ARRAY_SUPPORT)for(var t=0;t<n;++t)e[t]=0;return e}function h(e,n){var t=n.length<0?0:0|d(n.length);e=a(e,t);for(var r=0;r<t;r+=1)e[r]=255&n[r];return e}function d(e){if(e>=s())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+s().toString(16)+" bytes");return 0|e}function p(e,n){if(l.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var t=e.length;if(0===t)return 0;for(var r=!1;;)switch(n){case"ascii":case"latin1":case"binary":return t;case"utf8":case"utf-8":case void 0:return D(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*t;case"hex":return t>>>1;case"base64":return V(e).length;default:if(r)return D(e).length;n=(""+n).toLowerCase(),r=!0}}function m(e,n,t){var r=e[n];e[n]=e[t],e[t]=r}function g(e,n,t,r,i){if(0===e.length)return-1;if("string"==typeof t?(r=t,t=0):t>2147483647?t=2147483647:t<-2147483648&&(t=-2147483648),t=+t,isNaN(t)&&(t=i?0:e.length-1),t<0&&(t=e.length+t),t>=e.length){if(i)return-1;t=e.length-1}else if(t<0){if(!i)return-1;t=0}if("string"==typeof n&&(n=l.from(n,r)),l.isBuffer(n))return 0===n.length?-1:y(e,n,t,r,i);if("number"==typeof n)return n&=255,l.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,n,t):Uint8Array.prototype.lastIndexOf.call(e,n,t):y(e,[n],t,r,i);throw new TypeError("val must be string, number or Buffer")}function y(e,n,t,r,i){var o,s=1,a=e.length,l=n.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||n.length<2)return-1;s=2,a/=2,l/=2,t/=2}function u(e,n){return 1===s?e[n]:e.readUInt16BE(n*s)}if(i){var c=-1;for(o=t;o<a;o++)if(u(e,o)===u(n,-1===c?0:o-c)){if(-1===c&&(c=o),o-c+1===l)return c*s}else-1!==c&&(o-=o-c),c=-1}else for(t+l>a&&(t=a-l),o=t;o>=0;o--){for(var f=!0,h=0;h<l;h++)if(u(e,o+h)!==u(n,h)){f=!1;break}if(f)return o}return-1}function b(e,n,t,r){t=Number(t)||0;var i=e.length-t;r?(r=Number(r))>i&&(r=i):r=i;var o=n.length;if(o%2!=0)throw new TypeError("Invalid hex string");r>o/2&&(r=o/2);for(var s=0;s<r;++s){var a=parseInt(n.substr(2*s,2),16);if(isNaN(a))return s;e[t+s]=a}return s}function v(e,n,t,r){return j(D(n,e.length-t),e,t,r)}function _(e,n,t,r){return j(function(e){for(var n=[],t=0;t<e.length;++t)n.push(255&e.charCodeAt(t));return n}(n),e,t,r)}function T(e,n,t,r){return _(e,n,t,r)}function z(e,n,t,r){return j(V(n),e,t,r)}function E(e,n,t,r){return j(function(e,n){for(var t,r,i,o=[],s=0;s<e.length&&!((n-=2)<0);++s)t=e.charCodeAt(s),r=t>>8,i=t%256,o.push(i),o.push(r);return o}(n,e.length-t),e,t,r)}function A(e,n,t){return 0===n&&t===e.length?r.fromByteArray(e):r.fromByteArray(e.slice(n,t))}function x(e,n,t){t=Math.min(e.length,t);for(var r=[],i=n;i<t;){var o,s,a,l,u=e[i],c=null,f=u>239?4:u>223?3:u>191?2:1;if(i+f<=t)switch(f){case 1:u<128&&(c=u);break;case 2:128==(192&(o=e[i+1]))&&(l=(31&u)<<6|63&o)>127&&(c=l);break;case 3:o=e[i+1],s=e[i+2],128==(192&o)&&128==(192&s)&&(l=(15&u)<<12|(63&o)<<6|63&s)>2047&&(l<55296||l>57343)&&(c=l);break;case 4:o=e[i+1],s=e[i+2],a=e[i+3],128==(192&o)&&128==(192&s)&&128==(192&a)&&(l=(15&u)<<18|(63&o)<<12|(63&s)<<6|63&a)>65535&&l<1114112&&(c=l)}null===c?(c=65533,f=1):c>65535&&(c-=65536,r.push(c>>>10&1023|55296),c=56320|1023&c),r.push(c),i+=f}return function(e){var n=e.length;if(n<=w)return String.fromCharCode.apply(String,e);var t="",r=0;for(;r<n;)t+=String.fromCharCode.apply(String,e.slice(r,r+=w));return t}(r)}n.Buffer=l,n.SlowBuffer=function(e){+e!=e&&(e=0);return l.alloc(+e)},n.INSPECT_MAX_BYTES=50,l.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),n.kMaxLength=s(),l.poolSize=8192,l._augment=function(e){return e.__proto__=l.prototype,e},l.from=function(e,n,t){return u(null,e,n,t)},l.TYPED_ARRAY_SUPPORT&&(l.prototype.__proto__=Uint8Array.prototype,l.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&l[Symbol.species]===l&&Object.defineProperty(l,Symbol.species,{value:null,configurable:!0})),l.alloc=function(e,n,t){return function(e,n,t,r){return c(n),n<=0?a(e,n):void 0!==t?"string"==typeof r?a(e,n).fill(t,r):a(e,n).fill(t):a(e,n)}(null,e,n,t)},l.allocUnsafe=function(e){return f(null,e)},l.allocUnsafeSlow=function(e){return f(null,e)},l.isBuffer=function(e){return!(null==e||!e._isBuffer)},l.compare=function(e,n){if(!l.isBuffer(e)||!l.isBuffer(n))throw new TypeError("Arguments must be Buffers");if(e===n)return 0;for(var t=e.length,r=n.length,i=0,o=Math.min(t,r);i<o;++i)if(e[i]!==n[i]){t=e[i],r=n[i];break}return t<r?-1:r<t?1:0},l.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(e,n){if(!o(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);var t;if(void 0===n)for(n=0,t=0;t<e.length;++t)n+=e[t].length;var r=l.allocUnsafe(n),i=0;for(t=0;t<e.length;++t){var s=e[t];if(!l.isBuffer(s))throw new TypeError('"list" argument must be an Array of Buffers');s.copy(r,i),i+=s.length}return r},l.byteLength=p,l.prototype._isBuffer=!0,l.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var n=0;n<e;n+=2)m(this,n,n+1);return this},l.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var n=0;n<e;n+=4)m(this,n,n+3),m(this,n+1,n+2);return this},l.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var n=0;n<e;n+=8)m(this,n,n+7),m(this,n+1,n+6),m(this,n+2,n+5),m(this,n+3,n+4);return this},l.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?x(this,0,e):function(e,n,t){var r=!1;if((void 0===n||n<0)&&(n=0),n>this.length)return"";if((void 0===t||t>this.length)&&(t=this.length),t<=0)return"";if((t>>>=0)<=(n>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return L(this,n,t);case"utf8":case"utf-8":return x(this,n,t);case"ascii":return S(this,n,t);case"latin1":case"binary":return I(this,n,t);case"base64":return A(this,n,t);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return k(this,n,t);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0}}.apply(this,arguments)},l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){var e="",t=n.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,t).match(/.{2}/g).join(" "),this.length>t&&(e+=" ... ")),"<Buffer "+e+">"},l.prototype.compare=function(e,n,t,r,i){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===n&&(n=0),void 0===t&&(t=e?e.length:0),void 0===r&&(r=0),void 0===i&&(i=this.length),n<0||t>e.length||r<0||i>this.length)throw new RangeError("out of range index");if(r>=i&&n>=t)return 0;if(r>=i)return-1;if(n>=t)return 1;if(n>>>=0,t>>>=0,r>>>=0,i>>>=0,this===e)return 0;for(var o=i-r,s=t-n,a=Math.min(o,s),u=this.slice(r,i),c=e.slice(n,t),f=0;f<a;++f)if(u[f]!==c[f]){o=u[f],s=c[f];break}return o<s?-1:s<o?1:0},l.prototype.includes=function(e,n,t){return-1!==this.indexOf(e,n,t)},l.prototype.indexOf=function(e,n,t){return g(this,e,n,t,!0)},l.prototype.lastIndexOf=function(e,n,t){return g(this,e,n,t,!1)},l.prototype.write=function(e,n,t,r){if(void 0===n)r="utf8",t=this.length,n=0;else if(void 0===t&&"string"==typeof n)r=n,t=this.length,n=0;else{if(!isFinite(n))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");n|=0,isFinite(t)?(t|=0,void 0===r&&(r="utf8")):(r=t,t=void 0)}var i=this.length-n;if((void 0===t||t>i)&&(t=i),e.length>0&&(t<0||n<0)||n>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");for(var o=!1;;)switch(r){case"hex":return b(this,e,n,t);case"utf8":case"utf-8":return v(this,e,n,t);case"ascii":return _(this,e,n,t);case"latin1":case"binary":return T(this,e,n,t);case"base64":return z(this,e,n,t);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return E(this,e,n,t);default:if(o)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),o=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var w=4096;function S(e,n,t){var r="";t=Math.min(e.length,t);for(var i=n;i<t;++i)r+=String.fromCharCode(127&e[i]);return r}function I(e,n,t){var r="";t=Math.min(e.length,t);for(var i=n;i<t;++i)r+=String.fromCharCode(e[i]);return r}function L(e,n,t){var r=e.length;(!n||n<0)&&(n=0),(!t||t<0||t>r)&&(t=r);for(var i="",o=n;o<t;++o)i+=U(e[o]);return i}function k(e,n,t){for(var r=e.slice(n,t),i="",o=0;o<r.length;o+=2)i+=String.fromCharCode(r[o]+256*r[o+1]);return i}function M(e,n,t){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+n>t)throw new RangeError("Trying to access beyond buffer length")}function F(e,n,t,r,i,o){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(n>i||n<o)throw new RangeError('"value" argument is out of bounds');if(t+r>e.length)throw new RangeError("Index out of range")}function C(e,n,t,r){n<0&&(n=65535+n+1);for(var i=0,o=Math.min(e.length-t,2);i<o;++i)e[t+i]=(n&255<<8*(r?i:1-i))>>>8*(r?i:1-i)}function B(e,n,t,r){n<0&&(n=4294967295+n+1);for(var i=0,o=Math.min(e.length-t,4);i<o;++i)e[t+i]=n>>>8*(r?i:3-i)&255}function N(e,n,t,r,i,o){if(t+r>e.length)throw new RangeError("Index out of range");if(t<0)throw new RangeError("Index out of range")}function R(e,n,t,r,o){return o||N(e,0,t,4),i.write(e,n,t,r,23,4),t+4}function O(e,n,t,r,o){return o||N(e,0,t,8),i.write(e,n,t,r,52,8),t+8}l.prototype.slice=function(e,n){var t,r=this.length;if(e=~~e,n=void 0===n?r:~~n,e<0?(e+=r)<0&&(e=0):e>r&&(e=r),n<0?(n+=r)<0&&(n=0):n>r&&(n=r),n<e&&(n=e),l.TYPED_ARRAY_SUPPORT)(t=this.subarray(e,n)).__proto__=l.prototype;else{var i=n-e;t=new l(i,void 0);for(var o=0;o<i;++o)t[o]=this[o+e]}return t},l.prototype.readUIntLE=function(e,n,t){e|=0,n|=0,t||M(e,n,this.length);for(var r=this[e],i=1,o=0;++o<n&&(i*=256);)r+=this[e+o]*i;return r},l.prototype.readUIntBE=function(e,n,t){e|=0,n|=0,t||M(e,n,this.length);for(var r=this[e+--n],i=1;n>0&&(i*=256);)r+=this[e+--n]*i;return r},l.prototype.readUInt8=function(e,n){return n||M(e,1,this.length),this[e]},l.prototype.readUInt16LE=function(e,n){return n||M(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUInt16BE=function(e,n){return n||M(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUInt32LE=function(e,n){return n||M(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUInt32BE=function(e,n){return n||M(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readIntLE=function(e,n,t){e|=0,n|=0,t||M(e,n,this.length);for(var r=this[e],i=1,o=0;++o<n&&(i*=256);)r+=this[e+o]*i;return r>=(i*=128)&&(r-=Math.pow(2,8*n)),r},l.prototype.readIntBE=function(e,n,t){e|=0,n|=0,t||M(e,n,this.length);for(var r=n,i=1,o=this[e+--r];r>0&&(i*=256);)o+=this[e+--r]*i;return o>=(i*=128)&&(o-=Math.pow(2,8*n)),o},l.prototype.readInt8=function(e,n){return n||M(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,n){n||M(e,2,this.length);var t=this[e]|this[e+1]<<8;return 32768&t?4294901760|t:t},l.prototype.readInt16BE=function(e,n){n||M(e,2,this.length);var t=this[e+1]|this[e]<<8;return 32768&t?4294901760|t:t},l.prototype.readInt32LE=function(e,n){return n||M(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,n){return n||M(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readFloatLE=function(e,n){return n||M(e,4,this.length),i.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,n){return n||M(e,4,this.length),i.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,n){return n||M(e,8,this.length),i.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,n){return n||M(e,8,this.length),i.read(this,e,!1,52,8)},l.prototype.writeUIntLE=function(e,n,t,r){(e=+e,n|=0,t|=0,r)||F(this,e,n,t,Math.pow(2,8*t)-1,0);var i=1,o=0;for(this[n]=255&e;++o<t&&(i*=256);)this[n+o]=e/i&255;return n+t},l.prototype.writeUIntBE=function(e,n,t,r){(e=+e,n|=0,t|=0,r)||F(this,e,n,t,Math.pow(2,8*t)-1,0);var i=t-1,o=1;for(this[n+i]=255&e;--i>=0&&(o*=256);)this[n+i]=e/o&255;return n+t},l.prototype.writeUInt8=function(e,n,t){return e=+e,n|=0,t||F(this,e,n,1,255,0),l.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[n]=255&e,n+1},l.prototype.writeUInt16LE=function(e,n,t){return e=+e,n|=0,t||F(this,e,n,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[n]=255&e,this[n+1]=e>>>8):C(this,e,n,!0),n+2},l.prototype.writeUInt16BE=function(e,n,t){return e=+e,n|=0,t||F(this,e,n,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[n]=e>>>8,this[n+1]=255&e):C(this,e,n,!1),n+2},l.prototype.writeUInt32LE=function(e,n,t){return e=+e,n|=0,t||F(this,e,n,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[n+3]=e>>>24,this[n+2]=e>>>16,this[n+1]=e>>>8,this[n]=255&e):B(this,e,n,!0),n+4},l.prototype.writeUInt32BE=function(e,n,t){return e=+e,n|=0,t||F(this,e,n,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[n]=e>>>24,this[n+1]=e>>>16,this[n+2]=e>>>8,this[n+3]=255&e):B(this,e,n,!1),n+4},l.prototype.writeIntLE=function(e,n,t,r){if(e=+e,n|=0,!r){var i=Math.pow(2,8*t-1);F(this,e,n,t,i-1,-i)}var o=0,s=1,a=0;for(this[n]=255&e;++o<t&&(s*=256);)e<0&&0===a&&0!==this[n+o-1]&&(a=1),this[n+o]=(e/s>>0)-a&255;return n+t},l.prototype.writeIntBE=function(e,n,t,r){if(e=+e,n|=0,!r){var i=Math.pow(2,8*t-1);F(this,e,n,t,i-1,-i)}var o=t-1,s=1,a=0;for(this[n+o]=255&e;--o>=0&&(s*=256);)e<0&&0===a&&0!==this[n+o+1]&&(a=1),this[n+o]=(e/s>>0)-a&255;return n+t},l.prototype.writeInt8=function(e,n,t){return e=+e,n|=0,t||F(this,e,n,1,127,-128),l.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[n]=255&e,n+1},l.prototype.writeInt16LE=function(e,n,t){return e=+e,n|=0,t||F(this,e,n,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[n]=255&e,this[n+1]=e>>>8):C(this,e,n,!0),n+2},l.prototype.writeInt16BE=function(e,n,t){return e=+e,n|=0,t||F(this,e,n,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[n]=e>>>8,this[n+1]=255&e):C(this,e,n,!1),n+2},l.prototype.writeInt32LE=function(e,n,t){return e=+e,n|=0,t||F(this,e,n,4,2147483647,-2147483648),l.TYPED_ARRAY_SUPPORT?(this[n]=255&e,this[n+1]=e>>>8,this[n+2]=e>>>16,this[n+3]=e>>>24):B(this,e,n,!0),n+4},l.prototype.writeInt32BE=function(e,n,t){return e=+e,n|=0,t||F(this,e,n,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),l.TYPED_ARRAY_SUPPORT?(this[n]=e>>>24,this[n+1]=e>>>16,this[n+2]=e>>>8,this[n+3]=255&e):B(this,e,n,!1),n+4},l.prototype.writeFloatLE=function(e,n,t){return R(this,e,n,!0,t)},l.prototype.writeFloatBE=function(e,n,t){return R(this,e,n,!1,t)},l.prototype.writeDoubleLE=function(e,n,t){return O(this,e,n,!0,t)},l.prototype.writeDoubleBE=function(e,n,t){return O(this,e,n,!1,t)},l.prototype.copy=function(e,n,t,r){if(t||(t=0),r||0===r||(r=this.length),n>=e.length&&(n=e.length),n||(n=0),r>0&&r<t&&(r=t),r===t)return 0;if(0===e.length||0===this.length)return 0;if(n<0)throw new RangeError("targetStart out of bounds");if(t<0||t>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-n<r-t&&(r=e.length-n+t);var i,o=r-t;if(this===e&&t<n&&n<r)for(i=o-1;i>=0;--i)e[i+n]=this[i+t];else if(o<1e3||!l.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)e[i+n]=this[i+t];else Uint8Array.prototype.set.call(e,this.subarray(t,t+o),n);return o},l.prototype.fill=function(e,n,t,r){if("string"==typeof e){if("string"==typeof n?(r=n,n=0,t=this.length):"string"==typeof t&&(r=t,t=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!l.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof e&&(e&=255);if(n<0||this.length<n||this.length<t)throw new RangeError("Out of range index");if(t<=n)return this;var o;if(n>>>=0,t=void 0===t?this.length:t>>>0,e||(e=0),"number"==typeof e)for(o=n;o<t;++o)this[o]=e;else{var s=l.isBuffer(e)?e:D(new l(e,r).toString()),a=s.length;for(o=0;o<t-n;++o)this[o+n]=s[o%a]}return this};var P=/[^+\/0-9A-Za-z-_]/g;function U(e){return e<16?"0"+e.toString(16):e.toString(16)}function D(e,n){var t;n=n||1/0;for(var r=e.length,i=null,o=[],s=0;s<r;++s){if((t=e.charCodeAt(s))>55295&&t<57344){if(!i){if(t>56319){(n-=3)>-1&&o.push(239,191,189);continue}if(s+1===r){(n-=3)>-1&&o.push(239,191,189);continue}i=t;continue}if(t<56320){(n-=3)>-1&&o.push(239,191,189),i=t;continue}t=65536+(i-55296<<10|t-56320)}else i&&(n-=3)>-1&&o.push(239,191,189);if(i=null,t<128){if((n-=1)<0)break;o.push(t)}else if(t<2048){if((n-=2)<0)break;o.push(t>>6|192,63&t|128)}else if(t<65536){if((n-=3)<0)break;o.push(t>>12|224,t>>6&63|128,63&t|128)}else{if(!(t<1114112))throw new Error("Invalid code point");if((n-=4)<0)break;o.push(t>>18|240,t>>12&63|128,t>>6&63|128,63&t|128)}}return o}function V(e){return r.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(P,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function j(e,n,t,r){for(var i=0;i<r&&!(i+t>=n.length||i>=e.length);++i)n[i+t]=e[i];return i}}).call(this,t(1))},function(e,n,t){(function(e,r){const i=t(8),o=t(2),s=t(7);var a,l;try{a=t(6),l=!1;try{t(!function(){var e=new Error('Cannot find module "source-map-support"');throw e.code="MODULE_NOT_FOUND",e}()).install()}catch(e){}}catch(e){try{t(!function(){var e=new Error('Cannot find module "ts-node"');throw e.code="MODULE_NOT_FOUND",e}()).register({project:o.join(".","..","src","tsconfig.json")}),t(!function(){var e=new Error('Cannot find module "../src/glue/js"');throw e.code="MODULE_NOT_FOUND",e}()),a=t(!function(){var e=new Error('Cannot find module "../src"');throw e.code="MODULE_NOT_FOUND",e}()),l=!0}catch(e){a=t(!function(){var e=new Error('Cannot find module "./assemblyscript"');throw e.code="MODULE_NOT_FOUND",e}()),l=!1}}function u(e){const r={};return Object.keys(n.options).forEach(e=>{const t=n.options[e];t.aliases&&((r.alias||(r.alias={}))[e]=t.aliases),void 0!==t.default&&((r.default||(r.default={}))[e]=t.default),"string"===t.type?(r.string||(r.string=[])).push(e):"boolean"===t.type&&(r.boolean||(r.boolean=[])).push(e)}),t(4)(e,r)}function c(e,n){for(var t,r=!1;null!=(t=a.nextDiagnostic(e));)n.write(a.formatDiagnostic(t,n.isTTY,!0)+s.EOL+s.EOL),a.isError(t)&&(r=!0);return r}function f(){return{readTime:0,readCount:0,writeTime:0,writeCount:0,parseTime:0,parseCount:0,compileTime:0,compileCount:0,emitTime:0,emitCount:0,validateTime:0,validateCount:0,optimizeTime:0,optimizeCount:0}}function h(n){const t=e.hrtime();n();const r=e.hrtime(t);return 1e9*r[0]+r[1]}function d(n,t){function r(e,n){return e?(e/1e6).toFixed(3)+" ms":"N/A"}(t||e.stdout).write(["I/O Read  : "+r(n.readTime,n.readCount),"I/O Write : "+r(n.writeTime,n.writeCount),"Parse     : "+r(n.parseTime,n.parseCount),"Compile   : "+r(n.compileTime,n.compileCount),"Emit      : "+r(n.emitTime,n.emitCount),"Validate  : "+r(n.validateTime,n.validateCount),"Optimize  : "+r(n.optimizeTime,n.optimizeCount)].join(s.EOL)+s.EOL)}n.isBundle=!0,n.isDev=l,n.version=n.isBundle?"0.5.0":t(!function(){var e=new Error('Cannot find module "../package.json"');throw e.code="MODULE_NOT_FOUND",e}()).version,n.options=t(5),n.sourceMapRoot="assemblyscript:///",n.libraryPrefix=a.LIBRARY_PREFIX,n.defaultOptimizeLevel=2,n.defaultShrinkLevel=1,n.libraryFiles=n.isBundle?Object({"(lib)/allocator/arena":"/////////////// A simple yet effective Arena Memory Allocator /////////////////\n\n// Provides a `reset_memory` function to reset the heap to its initial state. A\n// user has to make sure that there are no more references to cleared memory\n// afterwards. Always aligns to 8 bytes.\n\nconst ALIGN_LOG2: usize = 3;\nconst ALIGN_SIZE: usize = 1 << ALIGN_LOG2;\nconst ALIGN_MASK: usize = ALIGN_SIZE - 1;\n\nvar HEAP_OFFSET: usize = HEAP_BASE;\n\n@global\nexport function allocate_memory(size: usize): usize {\n  if (!size) return 0;\n  var ptr = HEAP_OFFSET;\n  var off = (ptr + size + ALIGN_MASK) & ~ALIGN_MASK;\n  var avail = <usize>current_memory() << 16;\n  if (off > avail && grow_memory(\n    <i32>max(\n      (((off + 0xffff) & ~0xffff) - avail) >> 16, // minimum required pages\n      avail                                >> 16  // at least double memory\n    )\n  ) < 0) unreachable(); // out of memory\n  HEAP_OFFSET = off;\n  return ptr;\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  // nop\n}\n\n@global\nexport function reset_memory(): void {\n  HEAP_OFFSET = HEAP_BASE;\n}\n","(lib)/allocator/emscripten":"///////////////////////// Emscripten Memory Allocator //////////////////////////\n\n// Uses Emscripten's exported _malloc and _free implementations, i.e., when\n// linking with Emscripten-compiled programs that already provide these.\n// Differs from 'system' in that their names are prefixed with an underscore.\n\ndeclare function _malloc(size: usize): usize;\ndeclare function _free(ptr: usize): void;\n\n@global\nexport function allocate_memory(size: usize): usize {\n  return _malloc(size);\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  _free(ptr);\n}\n\n@global\nexport { reset_memory } from \"./none\";\n","(lib)/allocator/none":'export function allocate_memory(size: usize): usize {\n  throw new Error("not supported");\n}\n\nexport function free_memory(ptr: usize): void {\n  throw new Error("not supported");\n}\n\nexport function reset_memory(): void {\n  throw new Error("not supported");\n}\n',"(lib)/allocator/system":'/////////////////////////// System Memory Allocator ////////////////////////////\n\n// Uses the environment\'s malloc and free implementations, i.e., when linking\n// with other C-like programs that already provide these.\n\ndeclare function malloc(size: usize): usize;\ndeclare function free(ptr: usize): void;\n\n@global\nexport function allocate_memory(size: usize): usize {\n  return malloc(size);\n}\n\n@global\nexport function free_memory(ptr: usize): void {\n  free(ptr);\n}\n\n@global\nexport { reset_memory } from "./none";\n',"(lib)/allocator/tlsf":"////////////// TLSF (Two-Level Segregate Fit) Memory Allocator ////////////////\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─╫─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴─────────╨─────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\nconst AL_BITS: u32 = sizeof<usize>() == sizeof<u32>() ? 2 : 3;\nconst AL_SIZE: usize = 1 << <usize>AL_BITS;\nconst AL_MASK: usize = AL_SIZE - 1;\n\nconst SL_BITS: u32 = 5;\nconst SL_SIZE: usize = 1 << <usize>SL_BITS;\n\nconst SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\nconst SB_SIZE: usize = 1 << <usize>SB_BITS;\n\nconst FL_BITS: u32 = (sizeof<usize>() == sizeof<u32>()\n  ? 30 // ^= up to 1GB per block\n  : 32 // ^= up to 4GB per block\n) - SB_BITS;\n\n// ╒════════════════ Block structure layout (32-bit) ══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤\n// │                          size                             │L│F│ ◄─┐\n// ╞═══════════════════════════════════════════════════════════╧═╧═╡   │      ┐\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                ... unused free space >= 0 ...                 │   │    = 0\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤   │\n// │                        if free: jump ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ MIN SIZE ┘\n// F: FREE, L: LEFT_FREE\n\n/** Tag indicating that this block is free. */\nconst FREE: usize = 1 << 0;\n/** Tag indicating that this block's left block is free. */\nconst LEFT_FREE: usize = 1 << 1;\n/** Mask to obtain all tags. */\nconst TAGS: usize = FREE | LEFT_FREE;\n\nassert(AL_BITS >= 2); // alignment must be large enough to store all tags\n\n/** Block structure. */\n@unmanaged\nclass Block {\n\n  /** Info field holding this block's size and tags. */\n  info: usize;\n\n  /** End offset of the {@link Block#info} field. User data starts here. */\n  static readonly INFO: usize = sizeof<usize>();\n\n  /** Previous free block, if any. Only valid if free. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free. */\n  next: Block | null;\n\n  /** Minimum size of a block, excluding {@link Block#info}. */\n  static readonly MIN_SIZE: usize = 3 * sizeof<usize>(); // prev + next + jump\n\n  /** Maximum size of a used block, excluding {@link Block#info}. */\n  static readonly MAX_SIZE: usize = 1 << (FL_BITS + SB_BITS);\n\n  /** Gets this block's left (free) block in memory. */\n  get left(): Block {\n    assert(this.info & LEFT_FREE); // must be free to contain a jump\n    return assert(\n      load<Block>(changetype<usize>(this) - sizeof<usize>())\n    ); // can't be null\n  }\n\n  /** Gets this block's right block in memory. */\n  get right(): Block {\n    assert(this.info & ~TAGS); // can't skip beyond the tail block\n    return assert(\n      changetype<Block>(\n        changetype<usize>(this) + Block.INFO + (this.info & ~TAGS)\n      )\n    ); // can't be null\n  }\n}\n\n// ╒════════════════ Root structure layout (32-bit) ═══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                              ...                              │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[22] P                         │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[736]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                            tailRef                            │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map, P: Possibly padded if 64-bit\n\nassert((1 << SL_BITS) <= 32); // second level must fit into 32 bits\n\n/** Root structure. */\n@unmanaged\nclass Root {\n\n  /** First level bitmap. */\n  flMap: usize = 0;\n\n  /** Start offset of second level maps. */\n  private static readonly SL_START: usize = sizeof<usize>();\n\n  // Using *one* SL map per *FL bit*\n\n  /** Gets the second level map for the specified first level. */\n  getSLMap(fl: usize): u32 {\n    assert(fl < FL_BITS); // fl out of range\n    return load<u32>(changetype<usize>(this) + fl * 4, Root.SL_START);\n  }\n\n  /** Sets the second level map for the specified first level. */\n  setSLMap(fl: usize, value: u32): void {\n    assert(fl < FL_BITS); // fl out of range\n    store<u32>(changetype<usize>(this) + fl * 4, value, Root.SL_START);\n  }\n\n  /** End offset of second level maps. */\n  private static readonly SL_END: usize = Root.SL_START + FL_BITS * 4;\n\n  // Using *number bits per SL* heads per *FL bit*\n\n  /** Start offset of FL/SL heads. */\n  private static readonly HL_START: usize = (Root.SL_END + AL_MASK) & ~AL_MASK;\n\n  /** Gets the head of the specified first and second level index. */\n  getHead(fl: usize, sl: u32): Block | null {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    return changetype<Block>(load<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , Root.HL_START));\n  }\n\n  /** Sets the head of the specified first and second level index. */\n  setHead(fl: usize, sl: u32, value: Block | null): void {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    store<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , changetype<usize>(value)\n    , Root.HL_START);\n  }\n\n  /** End offset of FL/SL heads. */\n  private static readonly HL_END: usize = (\n    Root.HL_START + FL_BITS * SL_SIZE * sizeof<usize>()\n  );\n\n  get tailRef(): usize { return load<usize>(0, Root.HL_END); }\n  set tailRef(value: usize) { store<usize>(0, value, Root.HL_END); }\n\n  /** Total size of the {@link Root} structure. */\n  static readonly SIZE: usize = Root.HL_END + sizeof<usize>();\n\n  /** Inserts a previously used block back into the free list. */\n  insert(block: Block): void {\n    // check as much as possible here to prevent invalid free blocks\n    assert(block); // cannot be null\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size: usize;\n    assert(\n      (size = block.info & ~TAGS) >= Block.MIN_SIZE && size < Block.MAX_SIZE\n    ); // must be valid, not necessary to compute yet if noAssert=true\n\n    var right: Block = assert(block.right); // can't be null\n    var rightInfo = right.info;\n\n    // merge with right block if also free\n    if (rightInfo & FREE) {\n      this.remove(right);\n      block.info = (blockInfo += Block.INFO + (rightInfo & ~TAGS));\n      right = block.right;\n      rightInfo = right.info;\n      // jump is set below\n    }\n\n    // merge with left block if also free\n    if (blockInfo & LEFT_FREE) {\n      var left: Block = assert(block.left); // can't be null\n      var leftInfo = left.info;\n      assert(leftInfo & FREE); // must be free according to tags\n      this.remove(left);\n      left.info = (leftInfo += Block.INFO + (blockInfo & ~TAGS));\n      block = left;\n      blockInfo = leftInfo;\n      // jump is set below\n    }\n\n    right.info = rightInfo | LEFT_FREE;\n    this.setJump(block, right);\n    // right is no longer used now, hence rightInfo is not synced\n\n    size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // perform insertion\n    var head = this.getHead(fl, sl);\n    block.prev = null;\n    block.next = head;\n    if (head) head.prev = block;\n    this.setHead(fl, sl, block);\n\n    // update first and second level maps\n    this.flMap |= (1 << fl);\n    this.setSLMap(fl, this.getSLMap(fl) | (1 << sl));\n  }\n\n  /**\n   * Removes a free block from FL/SL maps. Does not alter left/jump because it\n   * is likely that splitting is performed afterwards, invalidating any changes\n   * again.\n   */\n  private remove(block: Block): void {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // link previous and next free block\n    var prev = block.prev;\n    var next = block.next;\n    if (prev) prev.next = next;\n    if (next) next.prev = prev;\n\n    // update head if we are removing it\n    if (block == this.getHead(fl, sl)) {\n      this.setHead(fl, sl, next);\n\n      // clear second level map if head is empty now\n      if (!next) {\n        var slMap = this.getSLMap(fl);\n        this.setSLMap(fl, slMap &= ~(1 << sl));\n\n        // clear first level map if second level is empty now\n        if (!slMap) this.flMap &= ~(1 << fl);\n      }\n    }\n  }\n\n  /** Searches for a free block of at least the specified size. */\n  search(size: usize): Block | null {\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE);\n\n    // mapping_search\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      // (*) size += (1 << (fls<usize>(size) - SL_BITS)) - 1;\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n      // (*) instead of rounding up, use next second level list for better fit\n      if (sl < SL_SIZE - 1) ++sl;\n      else ++fl, sl = 0;\n    }\n\n    // search second level\n    var slMap = this.getSLMap(fl) & (~0 << sl);\n    var head: Block | null;\n    if (!slMap) {\n      // search next larger first level\n      var flMap = this.flMap & (~0 << (fl + 1));\n      if (!flMap) {\n        head = null;\n      } else {\n        fl = ffs<usize>(flMap);\n        slMap = assert(this.getSLMap(fl)); // can't be zero if fl points here\n        head = this.getHead(fl, ffs<u32>(slMap));\n      }\n    } else {\n      head = this.getHead(fl, ffs<u32>(slMap));\n    }\n    return head;\n  }\n\n  /** Links a free left with its right block in memory. */\n  private setJump(left: Block, right: Block): void {\n    assert(left.info & FREE);       // must be free\n    assert(left.right == right);    // right block must match\n    assert(right.info & LEFT_FREE); // right block must be tagged as LEFT_FREE\n    store<Block>(\n      changetype<usize>(right) - sizeof<usize>()\n    , left); // last word in left block's (free) data region\n  }\n\n  /**\n   * Uses the specified free block, removing it from internal maps and\n   * splitting it if possible, and returns its data pointer.\n   */\n  use(block: Block, size: usize): usize {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free so we can use it\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n    assert(!(size & AL_MASK)); // size must be aligned so the new block is\n\n    this.remove(block);\n\n    // split if the block can hold another MIN_SIZE block\n    var remaining = (blockInfo & ~TAGS) - size;\n    if (remaining >= Block.INFO + Block.MIN_SIZE) {\n      block.info = size | (blockInfo & LEFT_FREE); // also discards FREE\n\n      var spare = changetype<Block>(\n        changetype<usize>(block) + Block.INFO + size\n      );\n      spare.info = (remaining - Block.INFO) | FREE; // not LEFT_FREE\n      this.insert(spare); // also sets jump\n\n    // otherwise tag block as no longer FREE and right as no longer LEFT_FREE\n    } else {\n      block.info = blockInfo & ~FREE;\n      var right: Block = assert(block.right); // can't be null (tail)\n      right.info &= ~LEFT_FREE;\n    }\n\n    return changetype<usize>(block) + Block.INFO;\n  }\n\n  /** Adds more memory to the pool. */\n  addMemory(start: usize, end: usize): bool {\n    assert(start <= end);\n    assert(!(start & AL_MASK)); // must be aligned\n    assert(!(end & AL_MASK)); // must be aligned\n\n    var tailRef = this.tailRef;\n    var tailInfo: usize = 0;\n    if (tailRef) {\n      assert(start >= tailRef + sizeof<usize>()); // starts after tail\n\n      // merge with current tail if adjacent\n      if (start - Block.INFO == tailRef) {\n        start -= Block.INFO;\n        tailInfo = changetype<Block>(tailRef).info;\n      }\n\n    } else {\n      assert(start >= changetype<usize>(this) + Root.SIZE); // starts after root\n    }\n\n    // check if size is large enough for a free block and the tail block\n    var size = end - start;\n    if (size < Block.INFO + Block.MIN_SIZE + Block.INFO) {\n      return false;\n    }\n\n    // left size is total minus its own and the zero-length tail's header\n    var leftSize = size - 2 * Block.INFO;\n    var left = changetype<Block>(start);\n    left.info = leftSize | FREE | (tailInfo & LEFT_FREE);\n    left.prev = null;\n    left.next = null;\n\n    // tail is a zero-length used block\n    var tail = changetype<Block>(start + size - Block.INFO);\n    tail.info = 0 | LEFT_FREE;\n    this.tailRef = changetype<usize>(tail);\n\n    this.insert(left); // also merges with free left before tail / sets jump\n\n    return true;\n  }\n}\n\n/** Determines the first (LSB to MSB) set bit's index of a word. */\nfunction ffs<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  return ctz<T>(word);  // differs from ffs only for 0\n}\n\n/** Determines the last (LSB to MSB) set bit's index of a word. */\nfunction fls<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  const inv: T = (sizeof<T>() << 3) - 1;\n  return inv - clz<T>(word);\n}\n\n/** Reference to the initialized {@link Root} structure, once initialized. */\nvar ROOT: Root = changetype<Root>(0);\n\n// External interface\n\n/** Allocates a chunk of memory. */\n@global\nexport function allocate_memory(size: usize): usize {\n\n  // initialize if necessary\n  var root = ROOT;\n  if (!root) {\n    var rootOffset = (HEAP_BASE + AL_MASK) & ~AL_MASK;\n    ROOT = root = changetype<Root>(rootOffset);\n    root.tailRef = 0;\n    root.flMap = 0;\n    for (var fl: usize = 0; fl < FL_BITS; ++fl) {\n      root.setSLMap(fl, 0);\n      for (var sl: u32 = 0; sl < SL_SIZE; ++sl) {\n        root.setHead(fl, sl, null);\n      }\n    }\n    root.addMemory(rootOffset + Root.SIZE, current_memory() << 16);\n  }\n\n  // search for a suitable block\n  var data: usize = 0;\n  if (size && size < Block.MAX_SIZE) {\n    size = max<usize>((size + AL_MASK) & ~AL_MASK, Block.MIN_SIZE);\n\n    var block = root.search(size);\n    if (!block) {\n\n      // request more memory\n      var pagesBefore = current_memory();\n      var pagesNeeded = ((size + 0xffff) & ~0xffff) >>> 16;\n      var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n      if (grow_memory(pagesWanted) < 0) {\n        if (grow_memory(pagesNeeded) < 0) {\n          unreachable(); // out of memory\n        }\n      }\n      var pagesAfter = current_memory();\n      root.addMemory(<usize>pagesBefore << 16, <usize>pagesAfter << 16);\n      block = assert(root.search(size)); // must be found now\n    }\n\n    assert((block.info & ~TAGS) >= size);\n    data = root.use(block, size);\n  }\n\n  return data;\n}\n\n/** Frees the chunk of memory at the specified address. */\n@global\nexport function free_memory(data: usize): void {\n  if (data) {\n    var root = ROOT;\n    if (root) {\n      var block = changetype<Block>(data - Block.INFO);\n      var blockInfo = block.info;\n      assert(!(blockInfo & FREE)); // must be used\n      block.info = blockInfo | FREE;\n      root.insert(changetype<Block>(data - Block.INFO));\n    }\n  }\n}\n\nexport { reset_memory } from \"./none\";\n","(lib)/array":'export class Array<T> {\n\n  private __memory: usize;\n  private __capacity: i32;  // capped to [0, 0x7fffffff]\n  private __length: i32;    // capped to [0, __capacity]\n\n  private __grow(newCapacity: i32): void {\n    assert(newCapacity > this.__capacity);\n    var newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\n    if (this.__memory) {\n      move_memory(newMemory, this.__memory, <usize>this.__capacity * sizeof<T>());\n      free_memory(this.__memory);\n    }\n    this.__memory = newMemory;\n    this.__capacity = newCapacity;\n  }\n\n  constructor(capacity: i32 = 0) {\n    if (capacity < 0) {\n      throw new RangeError("Invalid array length");\n    }\n    this.__memory = capacity\n      ? allocate_memory(<usize>capacity * sizeof<T>())\n      : 0;\n    this.__capacity = this.__length = capacity;\n  }\n\n  get length(): i32 {\n    return this.__length;\n  }\n\n  set length(length: i32) {\n    if (length < 0) {\n      throw new RangeError("Invalid array length");\n    }\n    if (length > this.__capacity) {\n      this.__grow(max(length, this.__capacity << 1));\n    }\n    this.__length = length;\n  }\n\n  @operator("[]")\n  private __get(index: i32): T {\n    if (<u32>index >= <u32>this.__capacity) {\n      throw new Error("Index out of bounds"); // return changetype<T>(0) ?\n    }\n    return load<T>(this.__memory + <usize>index * sizeof<T>());\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: T): void {\n    if (index < 0) {\n      throw new Error("Index out of bounds");\n    }\n    if (index >= this.__capacity) {\n      this.__grow(max(index + 1, this.__capacity << 1));\n    }\n    store<T>(this.__memory + <usize>index * sizeof<T>(), value);\n  }\n\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    if (fromIndex < 0) {\n      fromIndex = this.__length + fromIndex;\n    }\n    while (<u32>fromIndex < <u32>this.__length) {\n      if (load<T>(this.__memory + <usize>fromIndex * sizeof<T>()) == searchElement) {\n        return fromIndex;\n      }\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    if (fromIndex < 0) {\n      fromIndex = this.__length + fromIndex;\n    } else if (fromIndex >= this.__length) {\n      fromIndex = this.__length - 1;\n    }\n    while (fromIndex >= 0) {\n      if (load<T>(this.__memory + <usize>fromIndex * sizeof<T>()) == searchElement) {\n        return fromIndex;\n      }\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(element: T): i32 {\n    if (this.__length == this.__capacity) {\n      this.__grow(this.__capacity ? this.__capacity << 1 : 1);\n    }\n    store<T>(this.__memory + <usize>this.__length * sizeof<T>(), element);\n    return ++this.__length;\n  }\n\n  pop(): T {\n    if (this.__length < 1) {\n      throw new RangeError("Array is empty"); // return changetype<T>(0) ?\n    }\n    return load<T>(this.__memory + <usize>--this.__length * sizeof<T>());\n  }\n\n  shift(): T {\n    if (this.__length < 1) {\n      throw new RangeError("Array is empty"); // return changetype<T>(0) ?\n    }\n    var element = load<T>(this.__memory);\n    move_memory(\n      this.__memory,\n      this.__memory + sizeof<T>(),\n      <usize>(this.__capacity - 1) * sizeof<T>()\n    );\n    set_memory(\n      this.__memory + <usize>(this.__capacity - 1) * sizeof<T>(),\n      0,\n      sizeof<T>()\n    );\n    --this.__length;\n    return element;\n  }\n\n  unshift(element: T): i32 {\n    var oldCapacity = this.__capacity;\n    if (this.__length == oldCapacity) {\n      // inlined __grow (avoids moving twice)\n      var newCapacity: i32 = oldCapacity ? oldCapacity << 1 : 1;\n      assert(newCapacity > this.__capacity);\n      var newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\n      if (this.__memory) {\n        move_memory(\n          newMemory + sizeof<T>(),\n          this.__memory,\n          <usize>oldCapacity * sizeof<T>()\n        );\n        free_memory(this.__memory);\n      }\n      this.__memory = newMemory;\n      this.__capacity = newCapacity;\n    } else {\n      move_memory(\n        this.__memory + sizeof<T>(),\n        this.__memory,\n        <usize>oldCapacity * sizeof<T>()\n      );\n    }\n    store<T>(this.__memory, element);\n    return ++this.__length;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (begin < 0) {\n      begin = this.__length + begin;\n      if (begin < 0) {\n        begin = 0;\n      }\n    } else if (begin > this.__length) {\n      begin = this.__length;\n    }\n    if (end < 0) {\n      end = this.__length + end;\n    } else if (end > this.__length) {\n      end = this.__length;\n    }\n    if (end < begin) {\n      end = begin;\n    }\n    var capacity = end - begin;\n    assert(capacity >= 0);\n    var sliced = new Array<T>(capacity);\n    if (capacity) {\n      move_memory(\n        sliced.__memory,\n        this.__memory + <usize>begin * sizeof<T>(),\n        <usize>capacity * sizeof<T>()\n      );\n    }\n    return sliced;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): void {\n    if (deleteCount < 1) {\n      return;\n    }\n    if (start < 0) {\n      start = this.__length + start;\n      if (start < 0) {\n        start = 0;\n      } else if (start >= this.__length) {\n        return;\n      }\n    } else if (start >= this.__length) {\n      return;\n    }\n    deleteCount = min(deleteCount, this.__length - start);\n    move_memory(\n      this.__memory + <usize>start * sizeof<T>(),\n      this.__memory + <usize>(start + deleteCount) * sizeof<T>(),\n      <usize>deleteCount * sizeof<T>()\n    );\n    this.__length -= deleteCount;\n  }\n\n  reverse(): Array<T> {\n    for (var front: usize = 0, back: usize = <usize>this.__length - 1; front < back; ++front, --back) {\n      var temp = load<T>(this.__memory + front * sizeof<T>());\n      store<T>(this.__memory + front * sizeof<T>(), load<T>(this.__memory + back * sizeof<T>()));\n      store<T>(this.__memory + back * sizeof<T>(), temp);\n    }\n    return this;\n  }\n}\n\n@unmanaged\nexport class CArray<T> {\n\n  private constructor() {}\n\n  @operator("[]")\n  private __get(index: i32): T {\n    if (index < 0) {\n      throw new RangeError("Index out of range");\n    }\n    return load<T>(changetype<usize>(this) + <usize>index * sizeof<T>());\n  }\n\n  @operator("[]=")\n  private __set(index: i32, value: T): void {\n    if (index < 0) {\n      throw new RangeError("Index out of range");\n    }\n    store<T>(changetype<usize>(this) + <usize>index * sizeof<T>(), value);\n  }\n}\n',"(lib)/builtins":"@builtin\nexport declare const NaN: f64; // | f32\n\n@builtin\nexport declare const Infinity: f64; // | f32\n\n@builtin\nexport declare function isNaN<T>(value: T): bool;\n\n@builtin\nexport declare function isFinite<T>(value: T): bool;\n\n@builtin\nexport declare function clz<T>(value: T): T;\n\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n@builtin\nexport declare function abs<T>(value: T): T;\n\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n@builtin\nexport declare function floor<T>(value: T): T;\n\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n@builtin\nexport declare function nearest<T>(left: T, right: T): T;\n\n@builtin\nexport declare function reinterpret<T>(value: void): T;\n\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n@builtin\nexport declare function load<T>(offset: usize, constantOffset?: usize): T;\n\n@builtin\nexport declare function store<T>(offset: usize, value: void, constantOffset?: usize): T;\n\n@builtin\nexport declare function sizeof<T>(): usize;\n\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n@builtin\nexport declare function unreachable(): void;\n\n@builtin\nexport declare function current_memory(): i32;\n\n@builtin\nexport declare function grow_memory(pages: i32): i32;\n\n// @builtin\n// export declare function move_memory(dest: usize, src: usize: n: usize): void;\n\n// @builtin\n// export declare function set_memory(dest: usize, value: u32, n: usize): void;\n\n@builtin\nexport declare function changetype<T>(value: void): T;\n\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n@builtin\nexport declare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n@builtin\ndeclare function i8(value: void): i8;\nnamespace i8 {\n  export const MIN_VALUE: i8 = -128;\n  export const MAX_VALUE: i8 = 127;\n}\nexport { i8 };\n\n@builtin\ndeclare function i16(value: void): i16;\nnamespace i16 {\n  export const MIN_VALUE: i16 = -32768;\n  export const MAX_VALUE: i16 = 32767;\n}\nexport { i16 };\n\n@builtin\ndeclare function i32(value: void): i32;\nnamespace i32 {\n  export const MIN_VALUE: i32 = -2147483648;\n  export const MAX_VALUE: i32 = 2147483647;\n}\nexport { i32 };\n\n@builtin\ndeclare function i64(value: void): i64;\nnamespace i64 {\n  export const MIN_VALUE: i64 = -9223372036854775808;\n  export const MAX_VALUE: i64 = 9223372036854775807;\n}\nexport { i64 };\n\n@builtin\ndeclare function isize(value: void): isize;\nnamespace isize {\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\nexport { isize };\n\n@builtin\ndeclare function u8(value: void): u8;\nnamespace u8 {\n  export const MIN_VALUE: u8 = 0;\n  export const MAX_VALUE: u8 = 255;\n}\nexport { u8 };\n\n@builtin\ndeclare function u16(value: void): u16;\nnamespace u16 {\n  export const MIN_VALUE: u16 = 0;\n  export const MAX_VALUE: u16 = 65535;\n}\nexport { u16 };\n\n@builtin\ndeclare function u32(value: void): u32;\nnamespace u32 {\n  export const MIN_VALUE: u32 = 0;\n  export const MAX_VALUE: u32 = 4294967295;\n}\nexport { u32 };\n\n@builtin\ndeclare function u64(value: void): u64;\nnamespace u64 {\n  export const MIN_VALUE: u64 = 0;\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\nexport { u64 };\n\n@builtin\ndeclare function usize(value: void): usize;\nnamespace usize {\n  export const MIN_VALUE: usize = 0;\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\nexport { usize };\n\n@builtin\ndeclare function bool(value: void): bool;\nnamespace bool {\n  export const MIN_VALUE: bool = false;\n  export const MAX_VALUE: bool = true;\n}\nexport { bool };\n\n@builtin\ndeclare function f32(value: void): f32;\nnamespace f32 {\n  export const MIN_VALUE: f32 = -3.40282347e+38;\n  export const MAX_VALUE: f32 = 3.40282347e+38;\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n  export const MAX_SAFE_INTEGER: f32 = 16777215;\n  export const EPSILON: f32 = 1.19209290e-07;\n}\nexport { f32 };\n\n@builtin\ndeclare function f64(value: void): f64;\nnamespace f64 {\n  export const MIN_VALUE: f64 = -1.7976931348623157e+308;\n  export const MAX_VALUE: f64 = 1.7976931348623157e+308;\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n  export const MAX_SAFE_INTEGER: f64 = 9007199254740991;\n  export const EPSILON: f64 = 2.2204460492503131e-16;\n}\nexport{ f64 };\n\n@builtin\nexport declare const HEAP_BASE: usize;\n\n@builtin\nexport declare function start(): void;\n","(lib)/error":'export class Error {\n\n  name: string = "Error";\n  message: string;\n  stack: string = ""; // TODO\n\n  constructor(message: string = "") {\n    this.message = message;\n  }\n}\n\nexport class RangeError extends Error {\n  name: string = "RangeError";\n}\n\nexport class TypeError extends Error {\n  name: string = "TypeError";\n}\n',"(lib)/iterator":"// export abstract class Iterator<T> {\n//   abstract get done(): bool;\n//   abstract next(): T;\n// }\n","(lib)/map":"export class Map<K,V> {\n\n  private __keys: K[] = [];\n  private __values: V[] = [];\n\n  // FIXME: not a proper map implementation, just a filler\n\n  get size(): i32 {\n    return this.__keys.length;\n  }\n\n  get(key: K): V | null {\n    var keys = this.__keys;\n    for (var i = 0, k = keys.length; i < k; ++i) {\n      if (keys[i] == key) {\n        return this.__values[i];\n      }\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    var keys = this.__keys;\n    for (var i = 0, k = keys.length; i < k; ++i) {\n      if (keys[i] == key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  set(key: K, value: V): void {\n    this.__keys.push(key);\n    this.__values.push(value);\n  }\n\n  clear(): void {\n    this.__keys.length = 0;\n    this.__values.length = 0;\n  }\n}\n","(lib)/memory":"function copy_memory(dest: usize, src: usize, n: usize): void {\n  // based on musl's implementation of memcpy\n  // not a future instruction and sufficiently covered by the upcoming move_memory intrinsic\n\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1:\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      case 2:\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      case 3:\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\nexport function move_memory(dest: usize, src: usize, n: usize): void {\n  // based on musl's implementation of memmove\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\n\n  if (dest == src) return;\n  if (src + n <= dest || dest + n <= src) {\n    copy_memory(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\nexport function set_memory(dest: usize, c: u8, n: usize): void {\n  // based on musl's implementation of memset\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\n\n  // fill head and tail with minimal branching\n  if (!n) return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2) return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6) return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8) return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = <u32>-1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8) return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24) return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nexport function compare_memory(vl: usize, vr: usize, n: usize): i32 {\n  // based on musl's implementation of memcmp\n  // provided because there's no proposed alternative\n  if (vl == vr) return 0;\n  while (n && load<u8>(vl) == load<u8>(vr)) {\n    n--;\n    vl++;\n    vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n","(lib)/polyfills":"export function bswap<T>(value: T): T {\n  assert(sizeof<T>() == 1 || sizeof<T>() == 2 || sizeof<T>() == 4 || sizeof<T>() == 8);\n\n  if (sizeof<T>() == 2) {\n    return bswap16<T>(value);\n  } else if (sizeof<T>() == 4) {\n    return <T>(\n      rotl<u32>(<u32>value & 0xFF00FF00, 8) |\n      rotr<u32>(<u32>value & 0x00FF00FF, 8)\n    );\n  } else if (sizeof<T>() == 8) {\n    var a: u64 = (<u64>value >> 8) & 0x00FF00FF00FF00FF;\n    var b: u64 = (<u64>value & 0x00FF00FF00FF00FF) << 8;\n    var v: u64 = a | b;\n\n    a = (v >> 16) & 0x0000FFFF0000FFFF;\n    b = (v & 0x0000FFFF0000FFFF) << 16;\n\n    return <T>rotr<u64>(a | b, 32);\n  }\n  return value;\n}\n\nexport function bswap16<T>(value: T): T {\n  assert(sizeof<T>() == 1 || sizeof<T>() == 2 || sizeof<T>() == 4);\n\n  if (sizeof<T>() == 2 || sizeof<T>() == 4) {\n    return <T>(((value << 8) & <T>0xFF00) | ((value >> 8) & <T>0x00FF) | (value & <T>0xFFFF0000));\n  }\n  return value;\n}\n","(lib)/regexp":'export class RegExp {\n\n  // @binding(CALL_NEW, [ STRING, STRING], OBJECT_HANDLE)\n  constructor(pattern: string, flags: string = "") { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [ STRING ], PASS_THRU)\n  test(search: string): bool { throw new Error("unreachable"); }\n\n  // @binding(CALL_THIS, [], STRING)\n  toString(): string { throw new Error("unreachable"); }\n\n}\n',"(lib)/set":'// const prime1: u32 = 73;\n// const prime2: u32 = 5009;\n\nexport class Set<T> {\n\n  private __memory: usize;\n  private __capacity: u32;\n  private __size: u32;\n\n  constructor() {\n    this.__memory = 0;\n    this.__capacity = this.__size = 0;\n  }\n\n  get size(): i32 {\n    return <i32>this.__size;\n  }\n\n  // FIXME: not a proper set implementation, just a filler\n\n  has(value: T): bool {\n    assert(this != null);\n\n    for (var index: usize = 0, limit: usize = this.__size; index < limit; ++index) {\n      if (load<T>(this.__memory + index * sizeof<T>()) == value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  add(value: T): Set<T> {\n    assert(this != null);\n\n    if (this.__size >= this.__capacity) {\n      var newCapacity = max(this.__capacity << 1, 8);\n      var newMemory = allocate_memory(<usize>newCapacity * sizeof<T>());\n      if (this.__memory) {\n        move_memory(newMemory, this.__memory, <usize>this.__capacity * sizeof<T>());\n        free_memory(this.__memory);\n      }\n      this.__capacity = newCapacity;\n      this.__memory = newMemory;\n    }\n    store<T>(this.__memory + <usize>this.__size * sizeof<T>(), value);\n    ++this.__size;\n    return this;\n  }\n\n  delete(value: T): bool {\n    assert(this != null);\n\n    for (var index: usize = 0, limit: usize = this.__size; index < limit; ++index) {\n      if (load<T>(this.__memory + index * sizeof<T>()) == value) {\n        if (index + 1 < limit) {\n          move_memory(\n            this.__memory + index * sizeof<T>(),\n            this.__memory + (index + 1) * sizeof<T>(),\n            limit - index - 1\n          );\n        }\n        --this.__size;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  clear(): void {\n    assert(this != null);\n\n    this.__size = 0;\n  }\n\n  // TODO: think about iterators\n}\n\n// class SetIterator<T> extends Iterator<T> {\n\n//   get done(): bool {\n//     throw new Error("not implemented");\n//   }\n\n//   next(): T {\n//     throw new Error("not implemented");\n//   }\n// }\n',"(lib)/string":'// singleton empty string\nconst EMPTY: String = changetype<String>("");\n\n// number of bytes preceeding string data\nconst HEAD: usize = 4;\n\nfunction allocate(length: i32): String {\n  assert(length > 0); // 0 -> EMPTY\n  var ptr = allocate_memory(HEAD + (<usize>length << 1));\n  store<i32>(ptr, length);\n  return changetype<String>(ptr);\n}\n\nexport class String {\n\n  readonly length: i32; // capped to [0, 0x7fffffff]\n\n  @operator("[]")\n  charAt(pos: i32): String {\n    assert(this != null);\n\n    if (<u32>pos >= <u32>this.length) {\n      return EMPTY;\n    }\n\n    var out = allocate(1);\n    store<u16>(\n      changetype<usize>(out),\n      load<u16>(\n        changetype<usize>(this) + (<usize>pos << 1),\n        HEAD\n      ),\n      HEAD\n    );\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    assert(this != null);\n    if (<u32>pos >= <u32>this.length) {\n      return -1; // (NaN)\n    }\n    return load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEAD\n    );\n  }\n\n  codePointAt(pos: i32): i32 {\n    assert(this != null);\n    if (<u32>pos >= <u32>this.length) {\n      return -1; // (undefined)\n    }\n    var first = <i32>load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEAD\n    );\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) {\n      return first;\n    }\n    var second = <i32>load<u16>(\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\n      HEAD\n    );\n    if (second < 0xDC00 || second > 0xDFFF) {\n      return first;\n    }\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator("+")\n  private static __concat(left: String, right: String): String {\n    if (left == null) {\n      left = changetype<String>("null");\n    }\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    assert(this != null);\n    if (other == null) {\n      other = changetype<String>("null");\n    }\n    var thisLen: isize = this.length;\n    var otherLen: isize = other.length;\n    var outLen: usize = thisLen + otherLen;\n    if (outLen == 0) {\n      return EMPTY;\n    }\n    var out = allocate(outLen);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD,\n      thisLen << 1\n    );\n    move_memory(\n      changetype<usize>(out) + HEAD + (thisLen << 1),\n      changetype<usize>(other) + HEAD,\n      otherLen << 1\n    );\n    return out;\n  }\n\n  endsWith(searchString: String, endPosition: i32 = 0x7fffffff): bool {\n    assert(this != null);\n    if (searchString == null) {\n      return false;\n    }\n    var end: isize = <isize>min(max(endPosition, 0), this.length);\n    var searchLength: isize = searchString.length;\n    var start: isize = end - searchLength;\n    if (start < 0) {\n      return false;\n    }\n    return !compare_memory(\n      changetype<usize>(this) + HEAD + (start << 1),\n      changetype<usize>(searchString) + HEAD,\n      searchLength << 1\n    );\n  }\n\n  @operator("==")\n  private static __eq(left: String, right: String): bool {\n    if (left == null) {\n      return right == null;\n    } else if (right == null) {\n      return false;\n    }\n    var leftLength = left.length;\n    if (leftLength != right.length) {\n      return false;\n    }\n    return !compare_memory(\n      changetype<usize>(left) + HEAD,\n      changetype<usize>(right) + HEAD,\n      (<usize>leftLength << 1)\n    );\n  }\n\n  includes(searchString: String, position: i32 = 0): bool {\n    return this.indexOf(searchString, position) != -1;\n  }\n\n  indexOf(searchString: String, position: i32 = 0): i32 {\n    assert(this != null);\n    if (searchString == null) {\n      searchString = changetype<String>("null");\n    }\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start: isize = min<isize>(max<isize>(pos, 0), len);\n    var searchLen: isize = <isize>searchString.length;\n\n    // TODO: two-way, multiple char codes\n    for (var k: usize = start; <isize>k + searchLen <= len; ++k) {\n      if (!compare_memory(\n        changetype<usize>(this) + HEAD + (k << 1),\n        changetype<usize>(searchString) + HEAD,\n        searchLen << 1)\n      ) {\n        return <i32>k;\n      }\n    }\n    return -1;\n  }\n\n  startsWith(searchString: String, position: i32 = 0): bool {\n    assert(this != null);\n    if (searchString == null) {\n      searchString = changetype<String>("null");\n    }\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start: isize = min<isize>(max<isize>(pos, 0), len);\n    var searchLength: isize = <isize>searchString.length;\n    if (searchLength + start > len) {\n      return false;\n    }\n    return !compare_memory(\n      changetype<usize>(this) + HEAD + (start << 1),\n      changetype<usize>(searchString) + HEAD,\n      searchLength << 1\n    );\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\n    assert(this != null);\n    var intStart: isize = start;\n    var end: isize = length;\n    var size: isize = this.length;\n    if (intStart < 0) {\n      intStart = max<isize>(size + intStart, 0);\n    }\n    var resultLength: isize = min<isize>(max<isize>(end, 0), size - intStart);\n    if (resultLength <= 0) {\n      return EMPTY;\n    }\n    var out = allocate(resultLength);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD + (intStart << 1),\n      <usize>resultLength << 1\n    );\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    assert(this != null);\n    var len = this.length;\n    var finalStart = min<i32>(max<i32>(start, 0), len);\n    var finalEnd = min<i32>(max<i32>(end, 0), len);\n    var from = min<i32>(finalStart, finalEnd);\n    var to = max<i32>(finalStart, finalEnd);\n    len = to - from;\n    if (!len) {\n      return EMPTY;\n    }\n    if (!from && to == this.length) {\n      return this;\n    }\n    var out = allocate(len);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD + (from << 1),\n      len << 1\n    );\n    return out;\n  }\n\n  trim(): String {\n    assert(this != null);\n    var length: usize = this.length;\n    while (\n      length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (length << 1), HEAD)\n      )\n    ) {\n      --length;\n    }\n    var start: usize = 0;\n    while (\n      start < length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEAD)\n      )\n    ) {\n      ++start, --length;\n    }\n    if (!length) {\n      return EMPTY;\n    }\n    if (!start && length == this.length) {\n      return this;\n    }\n    var out = allocate(length);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD + (start << 1),\n      length << 1\n    );\n    return out;\n  }\n\n  trimLeft(): String {\n    assert(this != null);\n    var start: isize = 0;\n    var len: isize = this.length;\n    while (\n      start < len &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEAD)\n      )\n    ) {\n      ++start;\n    }\n    if (!start) {\n      return this;\n    }\n    var outLen = len - start;\n    if (!outLen) {\n      return EMPTY;\n    }\n    var out = allocate(outLen);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD + (start << 1),\n      outLen << 1\n    );\n    return out;\n  }\n\n  trimRight(): String {\n    assert(this != null);\n    var len: isize = this.length;\n    while (\n      len > 0 &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (len << 1), HEAD)\n      )\n    ) {\n      --len;\n    }\n    if (len <= 0) {\n      return EMPTY;\n    }\n    if (<i32>len == this.length) {\n      return this;\n    }\n    var out = allocate(len);\n    move_memory(\n      changetype<usize>(out) + HEAD,\n      changetype<usize>(this) + HEAD,\n      len << 1\n    );\n    return out;\n  }\n}\n\nfunction isWhiteSpaceOrLineTerminator(c: u16): bool {\n  switch (c) {\n    case 10:    // <LF>\n    case 13:    // <CR>\n    case 8232:  // <LS>\n    case 8233:  // <PS>\n    case 9:     // <TAB>\n    case 11:    // <VT>\n    case 12:    // <FF>\n    case 32:    // <SP>\n    case 160:   // <NBSP>\n    case 65279: // <ZWNBSP>\n      return true;\n    default:\n      return false;\n  }\n}\n\nconst enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function parseInt(str: String, radix: i32 = 0): f64 {\n  return parse<f64>(str, radix);\n}\n\nexport function parseI32(str: String, radix: i32 = 0): i32 {\n  return parse<i32>(str, radix);\n}\n\nexport function parseI64(str: String, radix: i32 = 0): i64 {\n  return parse<i64>(str, radix);\n}\n\nfunction parse<T>(str: String, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len) {\n    return <T>NaN;\n  }\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEAD);\n\n  // determine sign\n  var sign: T;\n  if (code == CharCode.MINUS) {\n    if (!--len) {\n      return <T>NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEAD);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) {\n      return <T>NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEAD);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2, HEAD)) {\n\n        case CharCode.B:\n        case CharCode.b:\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n\n        case CharCode.O:\n        case CharCode.o:\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n\n        case CharCode.X:\n        case CharCode.x:\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n\n        default:\n          radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    return <T>NaN;\n  }\n\n  // calculate value\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEAD);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else {\n      break;\n    }\n    if (code >= radix) {\n      break;\n    }\n    num = (num * radix) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n\nexport function parseFloat(str: String): f64 {\n  var len: i32 = str.length;\n  if (!len) {\n    return NaN;\n  }\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEAD);\n\n  // determine sign\n  var sign: f64;\n  if (code == CharCode.MINUS) {\n    if (!--len) {\n      return NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEAD);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) {\n      return NaN;\n    }\n    code = <i32>load<u16>(ptr += 2, HEAD);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // calculate value\n  var num: f64 = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEAD);\n    if (code == CharCode.DOT) {\n      ptr += 2;\n      var fac: f64 = 0.1; // precision :(\n      while (len--) {\n        code = <i32>load<u16>(ptr, HEAD);\n        if (code == CharCode.E || code == CharCode.e) {\n          assert(false); // TODO\n        }\n        code -= CharCode._0;\n        if (<u32>code > 9) {\n          break;\n        }\n        num += <f64>code * fac;\n        fac *= 0.1;\n        ptr += 2;\n      }\n      break;\n    }\n    code -= CharCode._0;\n    if (<u32>code >= 10) {\n      break;\n    }\n    num = (num * 10) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n'}):{},n.definitionFiles=n.isBundle?Object({assembly:'// Definitions for the "AssemblyScript" subset.\n\n// Types\n\n/** An 8-bit signed integer. */\ndeclare type i8 = number;\n/** A 16-bit signed integer. */\ndeclare type i16 = number;\n/** A 32-bit signed integer. */\ndeclare type i32 = number;\n/** A 64-bit signed integer. */\ndeclare type i64 = number;\n/** A 32-bit signed integer when targeting 32-bit WebAssembly or a 64-bit signed integer when targeting 64-bit WebAssembly. */\ndeclare type isize = number;\n/** An 8-bit unsigned integer. */\ndeclare type u8 = number;\n/** A 16-bit unsigned integer. */\ndeclare type u16 = number;\n/** A 32-bit unsigned integer. */\ndeclare type u32 = number;\n/** A 64-bit unsigned integer. */\ndeclare type u64 = number;\n/** A 32-bit unsigned integer when targeting 32-bit WebAssembly or a 64-bit unsigned integer when targeting 64-bit WebAssembly. */\ndeclare type usize = number;\n/** A 1-bit unsigned integer. */\ndeclare type bool = any; // sic\n/** A 32-bit float. */\ndeclare type f32 = number;\n/** A 64-bit float. */\ndeclare type f64 = number;\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace i8 {\n  export const MIN_VALUE: i8;\n  export const MAX_VALUE: i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace i16 {\n  export const MIN_VALUE: i16;\n  export const MAX_VALUE: i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i32;\ndeclare namespace i32 {\n  export const MIN_VALUE: i32;\n  export const MAX_VALUE: i32;\n}\n/** Converts any other numeric value to a 64-bit signed integer. */\ndeclare function i64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i64;\ndeclare namespace i64 {\n  export const MIN_VALUE: i64;\n  export const MAX_VALUE: i64;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare function isize(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): isize;\ndeclare namespace isize {\n  export const MIN_VALUE: isize;\n  export const MAX_VALUE: isize;\n}\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace u8 {\n  export const MIN_VALUE: u8;\n  export const MAX_VALUE: u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i8;\ndeclare namespace u16 {\n  export const MIN_VALUE: u16;\n  export const MAX_VALUE: u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i32;\ndeclare namespace u32 {\n  export const MIN_VALUE: u32;\n  export const MAX_VALUE: u32;\n}\n/** Converts any other numeric value to a 64-bit unsigned integer. */\ndeclare function u64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): i64;\ndeclare namespace u64 {\n  export const MIN_VALUE: u64;\n  export const MAX_VALUE: u64;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare function usize(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): isize;\ndeclare namespace usize {\n  export const MIN_VALUE: usize;\n  export const MAX_VALUE: usize;\n}\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): bool;\ndeclare namespace bool {\n  export const MIN_VALUE: bool;\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): f32;\ndeclare namespace f32 {\n  export const MIN_VALUE: f32;\n  export const MAX_VALUE: f32;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: i8 | i16 | i32 | i64 | isize | u8 | u16 | u32 | u64 | usize | bool | f32 | f64): f64;\ndeclare namespace f64 {\n  export const MIN_VALUE: f64;\n  export const MAX_VALUE: f64;\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n}\n\n// Built-ins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count tailing zero bits operation on a 32-bit or 64-bit integer. All zero bits are considered trailing if the value is zero. */\ndeclare function ctz<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic count number of one bits operation on a 32-bit or 64-bit integer. */\ndeclare function popcnt<T = i32 | i64>(value: T): T;\n/** Performs the sign-agnostic rotate left operation on a 32-bit or 64-bit integer. */\ndeclare function rotl<T = i32 | i64>(value: T, shift: T): T;\n/** Performs the sign-agnostic rotate right operation on a 32-bit or 64-bit integer. */\ndeclare function rotr<T = i32 | i64>(value: T, shift: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | i64 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | i64 | f32 | f64>(left: T, right: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Composes a 32-bit or 64-bit float from the magnitude of `x` and the sign of `y`. */\ndeclare function copysign<T = f32 | f64>(x: T, y: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer tied to even of a 32-bit or 64-bit float. */\ndeclare function nearest<T = f32 | f64>(value: T): T;\n/** Reinterprets the bits of the specified value as type `T`. Valid reinterpretations are u32/i32 to/from f32 and u64/i64 to/from f64. */\ndeclare function reinterpret<T = i32 | i64 | f32 | f64>(value: number): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Loads a value of the specified type from memory. Equivalent to dereferncing a pointer in other languages. */\ndeclare function load<T>(ptr: usize, constantOffset?: usize): T;\n/** Stores a value of the specified type to memory. Equivalent to dereferencing a pointer in other languages when assigning a value. */\ndeclare function store<T>(ptr: usize, value: any, constantOffset?: usize): void;\n/** Returns the current memory size in units of pages. One page is 64kb. */\ndeclare function current_memory(): i32;\n/** Grows linear memory by a given unsigned delta of pages. One page is 64kb. Returns the previous memory size in units of pages or `-1` on failure. */\ndeclare function grow_memory(value: i32): i32;\n/** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\ndeclare function move_memory(destination: usize, source: usize, n: usize): void;\n/** Sets n bytes beginning at the specified destination in memory to the specified byte value. */\ndeclare function set_memory(destination: usize, value: u8, count: usize): void;\n/** Compares two chunks of memory. Returns `0` if equal, otherwise the difference of the first differing bytes. */\ndeclare function compare_memory(vl: usize, vr: usize, n: usize): i32;\n/** Allocates a chunk of memory of the specified size and returns a pointer to it. */\ndeclare function allocate_memory(size: usize): usize;\n/** Disposes a chunk of memory by its pointer. */\ndeclare function free_memory(ptr: usize): void;\n/** Emits an unreachable operation that results in a runtime error when executed. Both a statement and an expression of any type. */\ndeclare function unreachable(): any; // sic\n\n/** [Polyfill] Performs the sign-agnostic reverse bytes **/\ndeclare function bswap<T = i8 | u8 | i16 | u16 | i32 | u32 | i64 | u64 | isize | usize>(value: T): T;\n/** [Polyfill] Performs the sign-agnostic reverse bytes only for last 16-bit **/\ndeclare function bswap16<T = i8 | u8 | i16 | u16 | i32 | u32>(value: T): T;\n\n/** NaN (not a number) as a 32-bit or 64-bit float depending on context. */\ndeclare const NaN: f32 | f64;\n/** Positive infinity as a 32-bit or 64-bit float depending on context. */\ndeclare const Infinity: f32 | f64;\n/** Heap base offset. */\ndeclare const HEAP_BASE: usize;\n/** Determines the byte size of the specified core or class type. Compiles to a constant. */\ndeclare function sizeof<T>(): usize;\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Tests if a 32-bit or 64-bit float is `NaN`. */\ndeclare function isNaN<T = f32 | f64>(value: T): bool;\n/** Tests if a 32-bit or 64-bit float is finite, that is not `NaN` or +/-`Infinity`. */\ndeclare function isFinite<T = f32 | f64>(value: T): bool;\n/** Traps if the specified value is not true-ish, otherwise returns the (non-nullable) value. */\ndeclare function assert<T>(isTrueish: T, message?: string): T & object; // any better way to model `: T != null`?\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses an integer string to a 32-bit integer. */\ndeclare function parseI32(str: string, radix?: i32): i32;\n/** Parses an integer string to a 64-bit integer. */\ndeclare function parseI64(str: string, radix?: i32): i64;\n/** Parses a string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n\n// Standard library (not yet implemented)\n\n/** Class representing a sequence of values of type `T`. */\ndeclare class Array<T> {\n  [key: number]: T;\n  /** Current length of the array. */\n  length: i32;\n  /** Constructs a new array. */\n  constructor(capacity?: i32);\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  push(element: T): void;\n  pop(): T;\n  shift(): T;\n  unshift(element: T): i32;\n  slice(from: i32, to?: i32): T[];\n  splice(start: i32, deleteCount?: i32): void;\n  reverse(): T[];\n}\n\n/** Class representing a C-like array of values of type `T` with limited capabilities. */\ndeclare class CArray<T> {\n  [key: number]: T;\n  private constructor();\n}\n\n/** Class representing a sequence of characters. */\ndeclare class String {\n\n  static fromCharCode(ls: i32, hs?: i32): string;\n  static fromCharCodes(arr: u16[]): string;\n  static fromCodePoint(cp: i32): string;\n  static fromCodePoints(arr: i32[]): string;\n\n  readonly length: u32;\n\n  charAt(index: u32): string;\n  charCodeAt(index: u32): u16;\n  concat(other: string): string;\n  endsWith(other: string): bool;\n  indexOf(other: string): u32;\n  includes(other: string): bool;\n  startsWith(other: string): bool;\n  substr(start: u32, length?: u32): string;\n  substring(start: u32, end?: u32): string;\n  trim(): string;\n  trimLeft(): string;\n  trimRight(): string;\n}\n\n/** Class for representing a runtime error. Base class of all errors. */\ndeclare class Error {\n\n  /** Error name. */\n  name: string;\n\n  /** Message provided on construction. */\n  message: string;\n\n  /** Stack trace. */\n  stack: string;\n\n  /** Constructs a new error, optionally with a message. */\n  constructor(message?: string);\n}\n\n/** Class for indicating an error when a value is not in the set or range of allowed values. */\ndeclare class RangeError extends Error { }\n\ninterface Boolean {}\ninterface Function {}\ninterface IArguments {}\ninterface Number {}\ninterface Object {}\ninterface RegExp {}\n\ndeclare class Set<T> {\n  readonly size: i32;\n  has(value: T): bool;\n  add(value: T): void;\n  delete(value: T): bool;\n  clear(): void;\n}\n\n// Internal decorators\n\n/** Annotates an element as a program global. */\ndeclare function global(target: Function, propertyKey: string, descriptor: any): void;\n\n/** Annotates a method as an operator overload. */\ndeclare function operator(token: string): (target: any, propertyKey: string, descriptor: any) => void;\n\n/** Annotates a class as being unmanaged with limited capabilities. */\ndeclare function unmanaged(target: Function): any;\n\n/** Annotates a class field with an explicit offset. */\ndeclare function offset(offset: usize): any;\n\n/** Annotates an element as begin built-in. */\ndeclare function builtin(target: Function): any;\n',portable:'// Definitions for the "portable AssemblyScript" subset.\n\n// Portable types\n\n// Note that semantic differences require additional explicit conversions for full compatibility.\n// For example, when casting an i32 to an u8, doing `<u8>(someI32 & 0xff)` will yield the same\n// result when compiling to WebAssembly or JS while `<u8>someI32` alone does nothing in JS.\n\n// Note that i64\'s are not portable (JS numbers are IEEE754 doubles with a maximum safe integer value\n// of 2^53-1) and instead require a compatibility layer to work in JS as well. See: src/util/i64.ts\n\ndeclare type i8 = number;\ndeclare type i16 = number;\ndeclare type i32 = number;\ndeclare type isize = number;\ndeclare type u8 = number;\ndeclare type u16 = number;\ndeclare type u32 = number;\ndeclare type bool = boolean;\ndeclare type usize = number;\ndeclare type f32 = number;\ndeclare type f64 = number;\n\n/** Converts any other numeric value to an 8-bit signed integer. */\ndeclare function i8(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace i8 {\n  export const MIN_VALUE: i8;\n  export const MAX_VALUE: i8;\n}\n/** Converts any other numeric value to a 16-bit signed integer. */\ndeclare function i16(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace i16 {\n  export const MIN_VALUE: i16;\n  export const MAX_VALUE: i16;\n}\n/** Converts any other numeric value to a 32-bit signed integer. */\ndeclare function i32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i32;\ndeclare namespace i32 {\n  export const MIN_VALUE: i32;\n  export const MAX_VALUE: i32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) signed integer. */\ndeclare function isize(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): isize;\ndeclare namespace isize {\n  export const MIN_VALUE: isize;\n  export const MAX_VALUE: isize;\n}\n/** Converts any other numeric value to an 8-bit unsigned integer. */\ndeclare function u8(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace u8 {\n  export const MIN_VALUE: u8;\n  export const MAX_VALUE: u8;\n}\n/** Converts any other numeric value to a 16-bit unsigned integer. */\ndeclare function u16(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i8;\ndeclare namespace u16 {\n  export const MIN_VALUE: u16;\n  export const MAX_VALUE: u16;\n}\n/** Converts any other numeric value to a 32-bit unsigned integer. */\ndeclare function u32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): i32;\ndeclare namespace u32 {\n  export const MIN_VALUE: u32;\n  export const MAX_VALUE: u32;\n}\n/** Converts any other numeric value to a 32-bit (in WASM32) respectivel 64-bit (in WASM64) unsigned integer. */\ndeclare function usize(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): isize;\ndeclare namespace usize {\n  export const MIN_VALUE: usize;\n  export const MAX_VALUE: usize;\n}\n/** Converts any other numeric value to a 1-bit unsigned integer. */\ndeclare function bool(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): bool;\ndeclare namespace bool {\n  export const MIN_VALUE: bool;\n  export const MAX_VALUE: bool;\n}\n/** Converts any other numeric value to a 32-bit float. */\ndeclare function f32(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): f32;\ndeclare namespace f32 {\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f32;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f32;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f32;\n}\n/** Converts any other numeric value to a 64-bit float. */\ndeclare function f64(value: i8 | i16 | i32 | isize | u8 | u16 | u32 | usize | bool | f32 | f64): f64;\ndeclare namespace f64 {\n  /** Smallest safely representable integer value. */\n  export const MIN_SAFE_INTEGER: f64;\n  /** Largest safely representable integer value. */\n  export const MAX_SAFE_INTEGER: f64;\n  /** Difference between 1 and the smallest representable value greater than 1. */\n  export const EPSILON: f64;\n}\n\n// Portable built-ins\n\n/** Performs the sign-agnostic count leading zero bits operation on a 32-bit integer. All zero bits are considered leading if the value is zero. */\ndeclare function clz<T = i32>(value: T): T;\n/** Computes the absolute value of an integer or float. */\ndeclare function abs<T = i32 | f32 | f64>(value: T): T;\n/** Determines the maximum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function max<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Determines the minimum of two integers or floats. If either operand is `NaN`, returns `NaN`. */\ndeclare function min<T = i32 | f32 | f64>(left: T, right: T): T;\n/** Performs the ceiling operation on a 32-bit or 64-bit float. */\ndeclare function ceil<T = f32 | f64>(value: T): T;\n/** Performs the floor operation on a 32-bit or 64-bit float. */\ndeclare function floor<T = f32 | f64>(value: T): T;\n/** Selects one of two pre-evaluated values depending on the condition. */\ndeclare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n/** Calculates the square root of a 32-bit or 64-bit float. */\ndeclare function sqrt<T = f32 | f64>(value: T): T;\n/** Rounds to the nearest integer towards zero of a 32-bit or 64-bit float. */\ndeclare function trunc<T = f32 | f64>(value: T): T;\n/** Allocates a chunk of memory of the specified size and returns a pointer to it. */\ndeclare function allocate_memory(size: usize): usize;\n/** Disposes a chunk of memory by its pointer. */\ndeclare function free_memory(ptr: usize): void;\n/** Copies n bytes from the specified source to the specified destination in memory. These regions may overlap. */\ndeclare function move_memory(destination: usize, source: usize, n: usize): void;\n/** Loads a value of the specified type from memory. Type must be `u8`. */\ndeclare function load<T = u8>(ptr: usize, constantOffset?: usize): T;\n/** Stores a value of the specified type to memory. Type must be `u8`. */\ndeclare function store<T = u8>(ptr: usize, value: T, constantOffset?: usize): void;\n/** Emits an unreachable operation that results in a runtime error when executed. */\ndeclare function unreachable(): any; // sic\n\n/** [Polyfill] Performs the sign-agnostic reverse bytes **/\ndeclare function bswap<T = i32 | u32 | isize | usize>(value: T): T;\n/** [Polyfill] Performs the sign-agnostic reverse bytes only for last 16-bit **/\ndeclare function bswap16<T = i16 | u16 | i32 | u32>(value: T): T;\n\n/** Changes the type of any value of `usize` kind to another one of `usize` kind. Useful for casting class instances to their pointer values and vice-versa. Beware that this is unsafe.*/\ndeclare function changetype<T>(value: any): T;\n/** Traps if the specified value is not true-ish, otherwise returns the value. */\ndeclare function assert<T>(isTrueish: T, message?: string): T & object; // any better way to model `: T != null`?\n/** Parses an integer string to a 64-bit float. */\ndeclare function parseInt(str: string, radix?: i32): f64;\n/** Parses an integer string to a 32-bit integer. */\ndeclare function parseI32(str: string, radix?: i32): i32;\n/** Parses a floating point string to a 64-bit float. */\ndeclare function parseFloat(str: string): f64;\n\n// Portable standard library\n// Everything marked @deprecated is a temporary filler. Do not use.\n\ndeclare const NaN: f32 | f64;\ndeclare const Infinity: f32 | f64;\n\ndeclare class Array<T> {\n  [key: number]: T;\n  length: i32;\n  constructor(capacity?: i32);\n  indexOf(searchElement: T, fromIndex?: i32): i32;\n  lastIndexOf(searchElement: T, fromIndex?: i32): i32;\n  push(element: T): void;\n  pop(): T;\n  shift(): T;\n  unshift(element: T): i32;\n  slice(from: i32, to?: i32): T[];\n  splice(start: i32, deleteCount?: i32): void;\n  reverse(): T[];\n\n  join(delim: string): string;\n}\n\ndeclare class Uint8Array extends Array<u8> {}\ndeclare class Uint16Array extends Array<u16> {}\ndeclare class Uint32Array extends Array<u32> {}\ndeclare class Int8Array extends Array<i8> {}\ndeclare class Int16Array extends Array<i16> {}\ndeclare class Int32Array extends Array<i32> {}\ndeclare class Float32Array extends Array<f32> {}\ndeclare class Float64Array extends Array<f64> {}\n\ndeclare class String {\n  static fromCharCode(ls: i32, hs?: i32): string;\n  static fromCharCodes(arr: u16[]): string;\n  static fromCodePoint(cp: i32): string;\n  static fromCodePoints(arr: i32[]): string;\n  readonly length: i32;\n  private constructor();\n  indexOf(subject: string, position?: i32): i32;\n  includes(other: string): bool;\n  lastIndexOf(subject: string, position?: i32): i32;\n  charAt(index: i32): string;\n  charCodeAt(index: i32): i32;\n  substring(from: i32, to?: i32): string;\n  startsWith(subject: string): bool;\n  endsWith(subject: string): bool;\n  replace(search: string, replacement: string): string;\n  toString(): string;\n}\n\ninterface Boolean {}\n\ndeclare class Number {\n  private constructor();\n  toString(radix?: i32): string;\n}\n\ninterface Object {}\n\ninterface Function {}\n\ninterface RegExp {}\n\ninterface IArguments {}\n\ndeclare class Error {\n  constructor(message: string);\n  message: string;\n  stack: string | null;\n}\n\ndeclare class Symbol {\n  private constructor();\n  static readonly iterator: symbol;\n}\n\ndeclare class Set<T> {\n  constructor(entries?: T[]);\n  has(value: T): bool;\n  add(value: T): void;\n  delete(value: T): bool;\n  clear(): void;\n  [Symbol.iterator](): Iterator<T>;\n}\n\ndeclare class Map<K,V> {\n  constructor(entries?: [K, V][]);\n  readonly size: i32;\n  set(key: K, value: V): void;\n  has(key: K): bool;\n  get(key: K): V | null;\n  clear(): void;\n  entries(): Iterable<[K, V]>;\n  keys(): Iterable<K>;\n  values(): Iterable<V>;\n  [Symbol.iterator](): Iterator<[K,V]>;\n}\n\ninterface Iterable<T> {\n  [Symbol.iterator](): Iterator<T>;\n}\n\ninterface Iterator<T> {}\n\ndeclare namespace console {\n  /** @deprecated */\n  function log(message: string): void;\n}\n'}):{},n.main=function(r,f,p){"function"==typeof f?(p=f,f={}):f||(f={});const m=f.stdout||e.stdout,g=f.stderr||e.stderr,y=f.readFile||C,b=f.writeFile||B,v=f.listFiles||N,_=f.stats||{readTime:0,readCount:0,writeTime:0,writeCount:0,parseTime:0,parseCount:0,compileTime:0,compileCount:0,emitTime:0,emitCount:0,validateTime:0,validateCount:0,optimizeTime:0,optimizeCount:0};if(!m)throw Error("'options.stdout' must be specified");if(!g)throw Error("'options.stderr' must be specified");if(!i.readFileSync){if(y===C)throw Error("'options.readFile' must be specified");if(b===B)throw Error("'options.writeFile' must be specified");if(v===N)throw Error("'options.listFiles' must be specified")}const T=u(r);if(p||(p=function(e){var n=0;return e&&(g.write(e.stack+s.EOL),n=1),n}),T.version)return m.write("Version "+n.version+(l?"-dev":"")+s.EOL),p(null);if(T.help||T._.length<1){const e=[];return Object.keys(n.options).forEach(t=>{var r=n.options[t],i=" ";for(i+="--"+t,r.aliases&&1===r.aliases[0].length&&(i+=", -"+r.aliases[0]);i.length<24;)i+=" ";Array.isArray(r.desc)?e.push(i+r.desc[0]+r.desc.slice(1).map(e=>{for(let n=0;n<24;++n)e=" "+e;return s.EOL+e}).join("")):e.push(i+r.desc)}),(T.help?m:g).write(["Version "+n.version+(l?"-dev":""),"Syntax:   asc [entryFile ...] [options]","","Examples: asc hello.ts","          asc hello.ts -b hello.wasm -t hello.wat","          asc hello1.ts hello2.ts -b -O > hello.wasm","","Options:"].concat(e).join(s.EOL)+s.EOL),p(null)}const z=T.baseDir?o.resolve(T.baseDir):e.cwd(),E=o.join(".","..","std","assembly"),A=T.noLib?[]:[E];T.lib&&("string"==typeof T.lib&&(T.lib=T.lib.split(",")),Array.prototype.push.apply(A,T.lib.map(trim)));var x=null;for(let e=0,t=T._.length;e<t;++e){let t=T._[e].replace(/\\/g,"/").replace(/(\.ts|\/)$/,""),r=y(o.join(z,t)+".ts");if(null===r){if(null===(r=y(o.join(z,t,"index.ts"))))return p(Error("Entry file '"+t+".ts' not found."));t+="/index.ts"}else t+=".ts";for(_.parseCount++,_.parseTime+=h(()=>{x=a.parseFile(r,t,!0,x)});null!=(t=x.nextFile());){if(t.startsWith(n.libraryPrefix)){for(let e=0,i=A.length;e<i;++e)if(n.libraryFiles.hasOwnProperty(t))r=n.libraryFiles[t];else if(null!==(r=y(o.join(A[e],t.substring(n.libraryPrefix.length)+".ts")))){t+=".ts";break}}else if(null===(r=y(o.join(z,t+".ts"))))if(null===(r=y(o.join(z,t,"index.ts")))){for(let e=0,i=A.length;e<i;++e){const i=A[e],s=n.libraryPrefix+t;if(n.libraryFiles.hasOwnProperty(s))r=n.libraryFiles[s];else if(null!==(r=y(o.join(i,t+".ts")))){t=n.libraryPrefix+t+".ts";break}}if(null===r)return p(Error("Import file '"+t+".ts' not found."))}else t+="/index.ts";else t+=".ts";_.parseCount++,_.parseTime+=h(()=>{a.parseFile(r,t,!1,x)})}if(c(x,g))return p(Error("Parse error"))}var w=!1;T.noLib||Object.keys(n.libraryFiles).forEach(e=>{e.lastIndexOf("/")>=n.libraryPrefix.length||(_.parseCount++,_.parseTime+=h(()=>{x=a.parseFile(n.libraryFiles[e],e+".ts",!1,x)}),w=!0)});for(let e=0,t=A.length;e<t;++e){if(0===e&&w)continue;let t=A[e],r=v(t);for(let e=0,i=r.length;e<i;++e){let i=r[e],s=y(o.join(t,i));if(null===s)return p(Error("Library file '"+i+"' not found."));_.parseCount++,_.parseTime+=h(()=>{x=a.parseFile(s,n.libraryPrefix+i,!1,x)})}}const S=a.createOptions();var I;a.setTarget(S,0),a.setNoTreeShaking(S,!!T.noTreeShaking),a.setNoAssert(S,!!T.noAssert),a.setNoMemory(S,!!T.noMemory),a.setImportMemory(S,!!T.importMemory),a.setMemoryBase(S,T.memoryBase>>>0),a.setSourceMap(S,null!=T.sourceMap),_.compileCount++;try{_.compileTime+=h(()=>{I=a.compile(x,S)})}catch(e){return p(e)}if(c(x,g))return I&&I.dispose(),p(Error("Compile error"));if(T.validate&&(_.validateCount++,_.validateTime+=h(()=>{if(!I.validate())return I.dispose(),p(Error("Validate error"))})),"clamp"===T.trapMode)_.optimizeCount++,_.optimizeTime+=h(()=>{I.runPasses(["trap-mode-clamp"])});else if("js"===T.trapMode)_.optimizeCount++,_.optimizeTime+=h(()=>{I.runPasses(["trap-mode-js"])});else if("allow"!==T.trapMode)return I.dispose(),p(Error("Unsupported trap mode"));var L=-1,k=0,M=!T.noDebug;!1!==T.optimize&&("number"==typeof T.optimize?L=T.optimize:T[0]?L=0:T[1]?L=1:T[2]?L=2:T[3]?L=3:!0===T.optimize?(L=n.defaultOptimizeLevel,k=n.defaultShrinkLevel):L=0),T.s?k=1:T.z&&(k=2),"number"==typeof T.optimizeLevel&&(L=T.optimizeLevel),"number"==typeof T.shrinkLevel?k=T.shrinkLevel:"s"===T.shrinkLevel?k=1:"z"===T.shrinkLevel&&(k=2),I.setOptimizeLevel(L>0?L:0),I.setShrinkLevel(k),I.setDebugInfo(M);var F=[];if(T.runPasses&&("string"==typeof T.runPasses&&(T.runPasses=T.runPasses.split(",")),T.runPasses.length&&T.runPasses.forEach(e=>{F.indexOf(e)<0&&F.push(e)})),L>=0&&(_.optimizeCount++,_.optimizeTime+=h(()=>{I.optimize()})),F.length&&(_.optimizeCount++,_.optimizeTime+=h(()=>{I.runPasses(F.map(e=>e.trim()))})),!T.noEmit){let e=!1;if(null!=T.outFile&&(/\.was?t$/.test(T.outFile)&&null==T.textFile?T.textFile=T.outFile:/\.js$/.test(T.outFile)&&null==T.asmjsFile?T.asmjsFile=T.outFile:null==T.binaryFile&&(T.binaryFile=T.outFile)),null!=T.binaryFile){let t,r=null!=T.sourceMap?T.sourceMap.length?T.sourceMap:o.basename(T.binaryFile)+".map":null;if(_.emitCount++,_.emitTime+=h(()=>{t=I.toBinary(r)}),T.binaryFile.length?b(o.join(z,T.binaryFile),t.output):(R(t.output),e=!0),null!=t.sourceMap)if(T.binaryFile.length){let e=JSON.parse(t.sourceMap);e.sourceRoot=n.sourceMapRoot,e.sources.forEach((t,r)=>{let i=null;if(t.startsWith(n.libraryPrefix))for(let e=0,r=A.length;e<r&&null===(i=y(o.join(A[e],t.substring(n.libraryPrefix.length))));++e);else i=y(o.join(z,t));if(null===i)return p(Error("Source file '"+t+"' not found."));e.sourceContents||(e.sourceContents=[]),e.sourceContents[r]=i}),b(o.join(z,o.dirname(T.binaryFile),o.basename(r)),JSON.stringify(e))}else g.write("Skipped source map (stdout already occupied)"+s.EOL)}if(null!=T.textFile||null==T.binaryFile&&null==T.asmjsFile){let n;T.textFile&&T.textFile.length?(_.emitCount++,_.emitTime+=h(()=>{n=I.toText()}),b(o.join(z,T.textFile),n)):e||(_.emitCount++,_.emitTime+=h(()=>{n=I.toText()}),R(n),e=!0)}if(null!=T.asmjsFile){let n;T.asmjsFile.length?(_.emitCount++,_.emitTime+=h(()=>{n=I.toAsmjs()}),b(o.join(z,T.asmjsFile),n)):e||(_.emitCount++,_.emitTime+=h(()=>{n=I.toAsmjs()}),R(n),e=!0)}}return I.dispose(),T.measure&&d(_,g),p(null);function C(e){try{var n;return _.readCount++,_.readTime+=h(()=>{n=i.readFileSync(e,{encoding:"utf8"})}),n}catch(e){return null}}function B(e,n){try{return _.writeCount++,_.writeTime+=h(()=>{"string"==typeof n?i.writeFileSync(e,n,{encoding:"utf8"}):i.writeFileSync(e,n)}),!0}catch(e){return!1}}function N(e){var n;try{return _.readTime+=h(()=>{n=t(!function(){var e=new Error('Cannot find module "glob"');throw e.code="MODULE_NOT_FOUND",e}()).sync("*.ts",{cwd:e})}),n}catch(e){return[]}}function R(e){R.used||(_.writeCount++,R.used=!0),_.writeTime+=h(()=>{"string"==typeof e?m.write(e,{encoding:"utf8"}):m.write(e)})}},n.parseArguments=u,n.checkDiagnostics=c,n.createStats=f,e.hrtime||(e.hrtime=t(3)),n.measure=h,n.printStats=d,n.createMemoryStream=function(e){var n=[];return n.write=function(n){"string"==typeof n?this.push(r.from(n,"utf8")):this.push(n),e&&e(n)},n.toBuffer=function(){return r.concat(this)},n.toString=function(){return this.toBuffer().toString("utf8")},n},n.tscOptions={alwaysStrict:!0,noImplicitAny:!0,noImplicitReturns:!0,noImplicitThis:!0,noEmitOnError:!0,strictNullChecks:!0,experimentalDecorators:!0,target:"esnext",module:"commonjs",noLib:!0,types:[],allowJs:!1}}).call(this,t(0),t(12).Buffer)},function(e,n,t){e.exports=t(13)}])});
//# sourceMappingURL=asc.js.map