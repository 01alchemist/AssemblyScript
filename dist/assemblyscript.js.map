{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///assemblyscript.js","webpack:///webpack/bootstrap 2814b8b5f549cb891410","webpack:///./src/module.ts","webpack:///./src/diagnostics.ts","webpack:///./src/program.ts","webpack:///(webpack)/buildin/global.js","webpack:///./src/compiler.ts","webpack:///./src/types.ts","webpack:///./src/ast.ts","webpack:///./src/tokenizer.ts","webpack:///./src/diagnosticMessages.generated.ts","webpack:///./src/util/charcode.ts","webpack:///./src/util/path.ts","webpack:///./src/glue/js/index.ts","webpack:///./std/portable.js","webpack:///./src/glue/js/binaryen.js","webpack:///external \"binaryen\"","webpack:///./src/builtins.ts","webpack:///./src/glue/js/i64.js","webpack:///./node_modules/long/src/long.js","webpack:///./src/index.ts","webpack:///./src/decompiler.ts","webpack:///./src/parser.ts"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE_15__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","allocU8Array","u8s","ptr","allocate_memory","length","idx","k","store","allocI32Array","i32s","val","stringLengthUTF8","str","len","u","charCodeAt","allocString","readInt","load","readBuffer","ret","Uint8Array","readString","cp","u1","u2","u3","u4","u5","arr","Array","push","String","fromCodePoints","value","NativeType","compiler_1","_BinaryenTypeNone","_BinaryenTypeInt32","_BinaryenTypeInt64","_BinaryenTypeFloat32","_BinaryenTypeFloat64","_BinaryenTypeUnreachable","_BinaryenTypeAuto","ExpressionId","_BinaryenInvalidId","_BinaryenBlockId","_BinaryenIfId","_BinaryenLoopId","_BinaryenBreakId","_BinaryenSwitchId","_BinaryenCallId","_BinaryenCallImportId","_BinaryenCallIndirectId","_BinaryenGetLocalId","_BinaryenSetLocalId","_BinaryenGetGlobalId","_BinaryenSetGlobalId","_BinaryenLoadId","_BinaryenStoreId","_BinaryenConstId","_BinaryenUnaryId","_BinaryenBinaryId","_BinaryenSelectId","_BinaryenDropId","_BinaryenReturnId","_BinaryenHostId","_BinaryenNopId","_BinaryenUnreachableId","_BinaryenAtomicCmpxchgId","_BinaryenAtomicRMWId","_BinaryenAtomicWaitId","_BinaryenAtomicWakeId","UnaryOp","_BinaryenClzInt32","_BinaryenCtzInt32","_BinaryenPopcntInt32","_BinaryenNegFloat32","_BinaryenAbsFloat32","_BinaryenCeilFloat32","_BinaryenFloorFloat32","_BinaryenTruncFloat32","_BinaryenNearestFloat32","_BinaryenSqrtFloat32","_BinaryenEqZInt32","_BinaryenClzInt64","_BinaryenCtzInt64","_BinaryenPopcntInt64","_BinaryenNegFloat64","_BinaryenAbsFloat64","_BinaryenCeilFloat64","_BinaryenFloorFloat64","_BinaryenTruncFloat64","_BinaryenNearestFloat64","_BinaryenSqrtFloat64","_BinaryenEqZInt64","_BinaryenExtendSInt32","_BinaryenExtendUInt32","_BinaryenWrapInt64","_BinaryenTruncSFloat32ToInt32","_BinaryenTruncSFloat32ToInt64","_BinaryenTruncUFloat32ToInt32","_BinaryenTruncUFloat32ToInt64","_BinaryenTruncSFloat64ToInt32","_BinaryenTruncSFloat64ToInt64","_BinaryenTruncUFloat64ToInt32","_BinaryenTruncUFloat64ToInt64","_BinaryenReinterpretFloat32","_BinaryenReinterpretFloat64","_BinaryenConvertSInt32ToFloat32","_BinaryenConvertSInt32ToFloat64","_BinaryenConvertUInt32ToFloat32","_BinaryenConvertUInt32ToFloat64","_BinaryenConvertSInt64ToFloat32","_BinaryenConvertSInt64ToFloat64","_BinaryenConvertUInt64ToFloat32","_BinaryenConvertUInt64ToFloat64","_BinaryenPromoteFloat32","_BinaryenDemoteFloat64","_BinaryenReinterpretInt32","_BinaryenReinterpretInt64","BinaryOp","_BinaryenAddInt32","_BinaryenSubInt32","_BinaryenMulInt32","_BinaryenDivSInt32","_BinaryenDivUInt32","_BinaryenRemSInt32","_BinaryenRemUInt32","_BinaryenAndInt32","_BinaryenOrInt32","_BinaryenXorInt32","_BinaryenShlInt32","_BinaryenShrUInt32","_BinaryenShrSInt32","_BinaryenRotLInt32","_BinaryenRotRInt32","_BinaryenEqInt32","_BinaryenNeInt32","_BinaryenLtSInt32","_BinaryenLtUInt32","_BinaryenLeSInt32","_BinaryenLeUInt32","_BinaryenGtSInt32","_BinaryenGtUInt32","_BinaryenGeSInt32","_BinaryenGeUInt32","_BinaryenAddInt64","_BinaryenSubInt64","_BinaryenMulInt64","_BinaryenDivSInt64","_BinaryenDivUInt64","_BinaryenRemSInt64","_BinaryenRemUInt64","_BinaryenAndInt64","_BinaryenOrInt64","_BinaryenXorInt64","_BinaryenShlInt64","_BinaryenShrUInt64","_BinaryenShrSInt64","_BinaryenRotLInt64","_BinaryenRotRInt64","_BinaryenEqInt64","_BinaryenNeInt64","_BinaryenLtSInt64","_BinaryenLtUInt64","_BinaryenLeSInt64","_BinaryenLeUInt64","_BinaryenGtSInt64","_BinaryenGtUInt64","_BinaryenGeSInt64","_BinaryenGeUInt64","_BinaryenAddFloat32","_BinaryenSubFloat32","_BinaryenMulFloat32","_BinaryenDivFloat32","_BinaryenCopySignFloat32","_BinaryenMinFloat32","_BinaryenMaxFloat32","_BinaryenEqFloat32","_BinaryenNeFloat32","_BinaryenLtFloat32","_BinaryenLeFloat32","_BinaryenGtFloat32","_BinaryenGeFloat32","_BinaryenAddFloat64","_BinaryenSubFloat64","_BinaryenMulFloat64","_BinaryenDivFloat64","_BinaryenCopySignFloat64","_BinaryenMinFloat64","_BinaryenMaxFloat64","_BinaryenEqFloat64","_BinaryenNeFloat64","_BinaryenLtFloat64","_BinaryenLeFloat64","_BinaryenGtFloat64","_BinaryenGeFloat64","HostOp","_BinaryenPageSize","_BinaryenCurrentMemory","_BinaryenGrowMemory","_BinaryenHasFeature","AtomicRMWOp","_BinaryenAtomicRMWAdd","_BinaryenAtomicRMWSub","_BinaryenAtomicRMWAnd","_BinaryenAtomicRMWOr","_BinaryenAtomicRMWXor","_BinaryenAtomicRMWXchg","MemorySegment","create","buffer","offset","segment","Module","ref","_BinaryenModuleCreate","out","createFrom","cArr","_BinaryenModuleRead","free_memory","changetype","addFunctionType","result","paramTypes","cStr","_BinaryenAddFunctionType","getFunctionTypeBySignature","_BinaryenGetFunctionTypeBySignature","createI32","_BinaryenLiteralInt32","_BinaryenConst","createI64","valueLow","valueHigh","_BinaryenLiteralInt64","createF32","_BinaryenLiteralFloat32","createF64","_BinaryenLiteralFloat64","createUnary","op","expr","_BinaryenUnary","createBinary","left","right","_BinaryenBinary","createHost","operands","_BinaryenHost","createGetLocal","index","type","_BinaryenGetLocal","createTeeLocal","_BinaryenTeeLocal","createGetGlobal","_BinaryenGetGlobal","createLoad","bytes","signed","_BinaryenLoad","createStore","_BinaryenStore","createAtomicLoad","_BinaryenAtomicLoad","createAtomicStore","_BinaryenAtomicStore","createAtomicRMW","_BinaryenAtomicRMW","createAtomicCmpxchg","expected","replacement","_BinaryenAtomicCmpxchg","createAtomicWait","timeout","expectedType","_BinaryenAtomicWait","createAtomicWake","wakeCount","_BinaryenAtomicWake","createSetLocal","_BinaryenSetLocal","createSetGlobal","_BinaryenSetGlobal","createBlock","label","children","None","_BinaryenBlock","createBreak","condition","_BinaryenBreak","createDrop","expression","_BinaryenDrop","createLoop","body","_BinaryenLoop","createIf","ifTrue","ifFalse","_BinaryenIf","createNop","_BinaryenNop","createReturn","_BinaryenReturn","createSelect","_BinaryenSelect","createSwitch","names","defaultName","strs","_BinaryenSwitch","createCall","target","returnType","_BinaryenCall","createCallImport","_BinaryenCallImport","createUnreachable","_BinaryenUnreachable","addGlobal","mutable","initializer","_BinaryenAddGlobal","addFunction","varTypes","_BinaryenAddFunction","removeFunction","_BinaryenRemoveFunction","addFunctionExport","internalName","externalName","cStr1","cStr2","_BinaryenAddFunctionExport","addTableExport","_BinaryenAddTableExport","addMemoryExport","_BinaryenAddMemoryExport","addGlobalExport","_BinaryenAddGlobalExport","removeExport","_BinaryenRemoveExport","addFunctionImport","externalModuleName","externalBaseName","functionType","cStr3","_BinaryenAddFunctionImport","addTableImport","_BinaryenAddTableImport","addMemoryImport","_BinaryenAddMemoryImport","addGlobalImport","globalType","_BinaryenAddGlobalImport","removeImport","_BinaryenRemoveImport","setMemory","initial","maximum","segments","exportName","segs","offs","sizs","Target","WASM64","i64_low","i64_high","cArr1","cArr2","cArr3","_BinaryenSetMemory","setFunctionTable","funcs","_BinaryenSetFunctionTable","setStart","func","_BinaryenSetStart","setOptimizeLevel","level","_BinaryenSetOptimizeLevel","setShrinkLevel","_BinaryenSetShrinkLevel","setDebugInfo","on","_BinaryenSetDebugInfo","optimize","_BinaryenFunctionOptimize","_BinaryenModuleOptimize","runPasses","passes","_BinaryenFunctionRunPasses","_BinaryenModuleRunPasses","validate","_BinaryenModuleValidate","interpret","_BinaryenModuleInterpret","toBinary","sourceMapUrl","binaryPtr","sourceMapPtr","_BinaryenModuleAllocateAndWrite","binaryBytes","Binary","output","sourceMap","toText","Error","toAsmjs","dispose","_BinaryenModuleDispose","createRelooper","Relooper","cloneExpression","noSideEffects","maxDepth","i32","MAX_VALUE","nested1","nested2","_BinaryenExpressionGetId","Const","_BinaryenExpressionGetType","I32","_BinaryenConstGetValueI32","I64","_BinaryenConstGetValueI64Low","_BinaryenConstGetValueI64High","F32","_BinaryenConstGetValueF32","F64","_BinaryenConstGetValueF64","GetLocal","_BinaryenGetLocalGetIndex","GetGlobal","globalName","_BinaryenGetGlobalGetName","Load","_BinaryenLoadGetPtr","_BinaryenLoadIsAtomic","_BinaryenLoadGetBytes","_BinaryenLoadGetOffset","_BinaryenLoadIsSigned","_BinaryenLoadGetAlign","Unary","_BinaryenUnaryGetValue","_BinaryenUnaryGetOp","_BinaryenBinaryGetLeft","_BinaryenBinaryGetRight","_BinaryenBinaryGetOp","addDebugInfoFile","_BinaryenModuleAddDebugInfoFileName","getDebugInfoFile","_BinaryenModuleGetDebugInfoFileName","setDebugLocation","fileIndex","lineNumber","columnNumber","_BinaryenFunctionSetDebugLocation","MAX_MEMORY_WASM32","relooper","_RelooperCreate","createStub","addBlock","code","_RelooperAddBlock","addBranch","from","to","_RelooperAddBranch","addBlockWithSwitch","_RelooperAddBlockWithSwitch","addBranchForSwitch","indexes","_RelooperAddBranchForSwitch","renderAndDispose","entry","labelHelper","_RelooperRenderAndDispose","diagnosticCategoryToString","category","DiagnosticCategory","INFO","WARNING","ERROR","diagnosticCategoryToColor","colorBlue","colorYellow","colorRed","formatDiagnosticMessage","message","useColors","showContext","context","range","formatDiagnosticContext","sb","colorReset","toString","source","normalizedPath","line","column","join","text","start","end","charcode_1","isLineBreak","substring","diagnosticMessages_generated_1","diagnosticMessages_generated_2","DiagnosticCode","diagnosticCodeToString","DiagnosticMessage","arg0","arg1","arg2","replace","createInfo","createWarning","createError","withRange","DiagnosticEmitter","diagnostics","emitDiagnostic","error","info","warning","__extends","extendStatics","setPrototypeOf","__proto__","b","__","constructor","__values","Symbol","iterator","next","done","__read","r","e","ar","diagnostics_1","types_1","ast_1","module_1","PATH_DELIMITER","PARENT_SUBST","GETTER_PREFIX","SETTER_PREFIX","INSTANCE_DELIMITER","STATIC_DELIMITER","LIBRARY_SUBST","LIBRARY_PREFIX","QueuedExport","QueuedImport","noTypesYet","Map","Program","_super","_this","diagnosticsOffset","elements","types","typeAliases","sources","initialize","options","Type","i8","i16","i64","isizeType","u8","u16","u32","u64","usizeType","bool","f32","f64","void","queuedExports","queuedImports","queuedDerivedClasses","statements","j","statement","kind","NodeKind","CLASSDECLARATION","initializeClass","ENUMDECLARATION","initializeEnum","EXPORT","initializeExports","FUNCTIONDECLARATION","initializeFunction","IMPORT","initializeImports","INTERFACEDECLARATION","initializeInterface","NAMESPACEDECLARATION","initializeNamespace","TYPEDECLARATION","initializeTypeAlias","VARIABLE","initializeVariables","element","queuedImport","tryResolveImport","referencedName","set","splice","referencedNameAlt","Module_0_has_no_exported_member_1","declaration","parent","path","queuedExports_1","queuedExports_1_1","_a","queuedExport","currentExport","isReExport","member","setExportAndCheckLibrary","Cannot_find_name_0","e_1_1","e_1","_b","return","derivedDeclaration","derivedType","assert","extendsType","resolved","resolveIdentifier","ElementKind","CLASS_PROTOTYPE","A_class_may_only_extend_another_class","basePrototype","checkInternalDecorators","isBuiltin","hasDecorator","decorators","ElementFlags","BUILTIN","isLibrary","is","EXPORTED","SOURCE","GLOBAL","has","Duplicate_identifier_0","namespace","fileLevelInternalName","ClassPrototype","isUnmanaged","implementsTypes","Structs_cannot_implement_interfaces","Range","members","Export_declaration_conflicts_with_exported_declaration_of_0","memberDeclarations","memberDeclaration","FIELDDECLARATION","initializeField","METHODDECLARATION","isGetter","hasModifier","ModifierKind","GET","modifiers","SET","initializeAccessor","initializeMethod","programLevelInternalName","instance","resolve","classPrototype","STATIC","staticField","Global","instanceMembers","instanceField","FieldPrototype","CONSTRUCTOR","FunctionPrototype","constructorPrototype","Multiple_constructor_implementations_are_not_allowed","checkOperators","decorator","decoratorKind","Operation_not_supported","numArgs","arguments","firstArg","LITERAL","literalKind","fnIndexedGet","simpleName","fnIndexedSet","fnConcat","fnEquals","String_literal_expected","Expected_0_arguments_but_got_1","propertyName","internalPropertyName","propertyElement","PROPERTY","getterPrototype","setterPrototype","Property","staticName","staticPrototype","instanceName","instancePrototype","enm","Enum","values","initializeEnumValue","EnumValue","initializeExport","internalPath","identifier","referencedElement","seen","Set","add","declarations","initializeImport","namespaceName","indexPart","endsWith","InterfacePrototype","queuedExtendingClasses","parentNamespace","Namespace","alias","global","resolveType","node","contextualTypeArguments","reportNotFound","localName","resolveInclTypeArguments","typeArguments","paramType","instanceKey","typesToString","placeholderType","resolveTypeArguments","typeParameters","typeArgumentNodes","alternativeReportNode","parameterCount","argumentCount","Expected_0_type_arguments_but_got_1","atEnd","contextualFunction","contextualEnum","ENUMVALUE","resolvedElement","ResolvedElement","flow","getScopedLocal","resolvePropertyAccess","propertyAccess","targetExpression","resolveExpression","targetType","LOCAL","FIELD","classType","Property_0_does_not_exist_on_type_1","CLASS","withTarget","base","resolveElementAccess","elementAccess","indexedGet","indexedGetName","FUNCTION_PROTOTYPE","Index_signature_is_missing_in_type_0","PARENTHESIZED","ASSERTION","toType","BINARY","THIS","instanceMethodOf","_this_cannot_be_referenced_in_current_location","SUPER","_super_can_only_be_referenced_in_a_derived_class","IDENTIFIER","PROPERTYACCESS","ELEMENTACCESS","CALL","Element","program","flags","NONE","flag","NAMESPACE","modifierKind","IMPORTED","DECLARE","DECLARED","ENUM","CONST","CONSTANT","constantValue","enum","ConstantValueKind","VariableLikeElement","apply","constantValueKind","withConstantIntegerValue","lo","hi","constantIntegerValue","i64_new","INLINED","withConstantFloatValue","constantFloatValue","LET","SCOPED","READONLY","PUBLIC","PRIVATE","PROTECTED","Parameter","Local","instances","classTypeArguments","GETTER","SETTER","ABSTRACT","isGeneric","GENERIC","INSTANCE","functionTypeArguments","inheritedTypeArguments","inheritedTypeArguments_1","inheritedTypeArguments_1_1","inheritedName","inheritedType","e_2_1","e_2","classDeclaration","classTypeParameters","functionTypeParameters","parameters","typeNode","parameterTypes","parameterDeclaration","parameterType","classInstance","Function","reportNode","resolvedTypeArguments","resolvePartial","partialPrototype","FUNCTION","locals","additionalLocals","breakContext","debugLocations","functionTableIndex","nextBreakId","breakStack","tempI32s","tempI64s","tempF32s","tempF64s","localIndex","_c","e_3_1","e_3","_d","parameter","parameterName","Flow","addLocal","local","getTempLocal","temps","toNativeType","pop","freeTempLocal","getAndFreeTempLocal","enterBreakContext","id","leaveBreakContext","finalize","debugLocation","debugInfoRef","debugInfoIndex","isAssignableTo","toTypeString","FIELD_PROTOTYPE","Field","memoryOffset","UNMANAGED","inheritedTypeArguments_2","inheritedTypeArguments_2_1","e_4_1","e_4","baseClass","baseClassType","Structs_cannot_extend_classes_and_vice_versa","Class","currentMemoryOffset","inheritedMember","e_5_1","e_5","_e","partialConstructor","constructorInstance","_f","_g","fieldDeclaration","fieldType","fieldInstance","byteSize","methodPrototype","instanceProperty","e_6_1","e_6","_h","asClass","baseName","baseType","e_7_1","e_7","current","INTERFACE_PROTOTYPE","Interface","INTERFACE","FlowFlags","scopedLocals","currentFunction","parentFlow","continueLabel","breakLabel","enterBranchOrScope","branchFlow","leaveBranchOrScope","scopedLocal","e_8_1","e_8","addScopedLocal","g","eval","window","makeSmallIntegerWrap","ShrI32","ShlI32","AndI32","makeIsFalseish","EqzI32","EqzI64","size","EqF32","EqF64","makeIsTrueish","NeI64","NeF32","NeF64","builtins_1","program_1","tokenizer_1","Options","WASM32","noTreeShaking","noAssert","noMemory","importMemory","memoryBase","allocateImpl","freeImpl","usize64","usize32","isize64","isize32","ConversionKind","Compiler","startFunctionBody","currentEnum","currentType","memorySegments","stringSegments","functionTable","files","max","compile","startFunctionPrototype","startFunctionInstance","START","startFunction","isEntry","compileSource","typeRef","typesToNativeTypes","i64_align","isWasm64","pages","i64_shr_u","entries","compileSourceByPath","normalizedPathWithoutExtension","File_0_not_found","compileClassDeclaration","compileEnumDeclaration","compileFunctionDeclaration","compileNamespaceDeclaration","variableInit","compileVariableStatement","compileExportStatement","previousFunction","compileStatement","compileGlobalDeclaration","compileGlobal","COMPILED","initExpr","resolvedType","Type_0_is_not_assignable_to_type_1","Type_expected","compileExpression","nativeType","initializeInStart","compileInlineConstant","precomputeExpressionRef","Compiling_constant_with_non_constant_initializer_as_mutable","toNativeZero","setExpr","exprType","isTopLevel","isTopLevelExport","compileEnum","previousValue","initInStart","valueDeclaration","AddI32","Cannot_export_a_mutable_global","compileFunctionUsingTypeArguments","compileFunction","An_implementation_cannot_be_declared_in_ambient_contexts","Function_implementation_is_missing_or_not_immediately_following_the_declaration","stmt","allBranchesReturn","A_function_whose_declared_type_is_not_void_must_return_a_value","numParameters","numParametersInclThis","paramIndex","nativeResultType","nativeParamTypes","signatureNameParts","toSignatureString","compileInterfaceDeclaration","compileNamespace","ns","compileClassUsingTypeArguments","internalExportName","functionInstance","functionDeclaration","needsExplicitExport","globalDeclaration","compileClass","addMemorySegment","alignment","i64_add","addFunctionTableEntry","BLOCK","compileBlockStatement","BREAK","compileBreakStatement","CONTINUE","compileContinueStatement","DO","compileDoStatement","EMPTY","compileEmptyStatement","EXPRESSION","compileExpressionStatement","FOR","compileForStatement","IF","compileIfStatement","RETURN","compileReturnStatement","SWITCH","compileSwitchStatement","THROW","compileThrowStatement","TRY","compileTryStatement","WHILE","compileWhileStatement","addDebugLocation","compileStatements","stmts","stmtReturns","A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement","A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement","previousBreakLabel","previousContinueLabel","incrementor","alwaysReturns","ifTrueReturns","ifFalseReturns","tempLocal","cases","breaks","breakIndex","defaultIndex","case_","EqI32","currentBlock","fallsThrough","nextLabel","isKnownGlobal","initializers","init","_const_declarations_must_be_initialized","compileAssignmentWithValue","contextualType","shift","computeSmallIntegerShift","mask","computeSmallIntegerMask","conversionKind","wrapSmallIntegers","compileAssertionExpression","compileBinaryExpression","compileCallExpression","COMMA","compileCommaExpression","compileElementAccessExpression","FUNCTIONARROW","compileFunctionExpression","FALSE","NULL","TRUE","compileIdentifierExpression","compileLiteralExpression","NEW","compileNewExpression","compileParenthesizedExpression","compilePropertyAccessExpression","TERNARY","compileTernaryExpression","UNARYPOSTFIX","compileUnaryPostfixExpression","UNARYPREFIX","compileUnaryPrefixExpression","convertExpression","precomputeExpression","funcRef","_BinaryenFunctionGetBody","fromType","Conversion_from_type_0_to_1_requires_an_explicit_cast","mod","PromoteF32","DemoteF64","TruncF32ToI64","TruncF32ToI32","TruncF32ToU64","TruncF32ToU32","TruncF64ToI64","TruncF64ToI32","TruncF64ToU64","TruncF64ToU32","ConvertI64ToF32","ConvertU64ToF32","ConvertI32ToF32","ConvertU32ToF32","ConvertI64ToF64","ConvertU64ToF64","ConvertI32ToF64","ConvertU32ToF64","WrapI64","ExtendI32","ExtendU32","computeCommonType","leftType","rightType","compound","possiblyOverflows","operator","Token","LESSTHAN","LtI32","LtI64","LtU32","LtU64","LtF32","LtF64","GREATERTHAN","GtI32","GtI64","GtU32","GtU64","GtF32","GtF64","LESSTHAN_EQUALS","LeI32","LeI64","LeU32","LeU64","LeF32","LeF64","GREATERTHAN_EQUALS","GeI32","GeI64","GeU32","GeU64","GeF32","GeF64","EQUALS_EQUALS_EQUALS","EQUALS_EQUALS","EqI64","EXCLAMATION_EQUALS_EQUALS","EXCLAMATION_EQUALS","NeI32","EQUALS","compileAssignment","PLUS_EQUALS","PLUS","AddI64","AddF32","AddF64","MINUS_EQUALS","MINUS","SubI32","SubI64","SubF32","SubF64","ASTERISK_EQUALS","ASTERISK","MulI32","MulI64","MulF32","MulF64","SLASH_EQUALS","SLASH","DivI32","DivI64","DivU32","DivU64","DivF32","DivF64","PERCENT_EQUALS","PERCENT","RemI32","RemI64","RemU32","RemU64","LESSTHAN_LESSTHAN_EQUALS","LESSTHAN_LESSTHAN","ShlI64","GREATERTHAN_GREATERTHAN_EQUALS","GREATERTHAN_GREATERTHAN","ShrI64","ShrU32","ShrU64","GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS","GREATERTHAN_GREATERTHAN_GREATERTHAN","AMPERSAND_EQUALS","AMPERSAND","AndI64","BAR_EQUALS","BAR","OrI32","OrI64","CARET_EQUALS","CARET","XorI32","XorI64","AMPERSAND_AMPERSAND","BAR_BAR","valueExpression","elementType","setterInstance","Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property","resolvedIndexedSet","valueWithCorrectType","tee","targetExpr","globalNativeType","isReadonly","elementNativeType","makeCall","getterInstance","resolvedIndexedGet","indexedSet","indexedSetName","elementExpr","elementExpression","Index_signature_in_type_0_only_permits_reading","Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures","functionPrototype","compileCall","numArguments","numArgumentsInclThis","argumentIndex","args","argumentExpressions","thisArg","operandIndex","Expected_at_least_0_arguments_but_got_1","expressions","exprs","asFunction","compileGetConstant","A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums","implicitNegate","compileStaticArray","elementExpressions","floatValue","intValue","i64_sub","i64_is_i8","i64_is_i16","i64_is_i32","i64_is_u8","i64_is_u16","i64_is_u32","i64_is_bool","i64_is_f32","i64_to_f32","i64_is_f64","i64_to_f64","compileStaticString","stringValue","stringSegment","stringLength","stringBuffer","stringOffset","stringType","isStatic","Int32Array","Float32Array","Float64Array","thisExpr","compileAllocate","field","nativeSizeType","Cannot_use_new_with_an_expression_whose_type_lacks_a_construct_signature","ifThen","ifElse","nativeOne","getValue","operand","PLUS_PLUS","isReference","toNativeOne","MINUS_MINUS","setValue","NegF32","NegF64","EXCLAMATION","TILDE","toNativeNegOne","TYPEOF","TypeKind","TypeFlags","nullableType","ceil","nonNullableType","asNullable","currentClass","targetClass","targetFunction","kindOnly","setReusableModifiers","reusableModifiers","createModifiers","addModifier","modifier","getModifier","getFirstDecorator","mangleInternalName","asGlobal","VARIABLEDECLARATION","mangleInternalPath","setParent","nodes","setParentOpt","path_1","Node","createType","isNullable","TypeNode","createIdentifierExpression","IdentifierExpression","createArrayLiteralExpression","ArrayLiteralExpression","createAssertionExpression","assertionKind","AssertionExpression","createBinaryExpression","BinaryExpression","createCallExpression","typeArgs","CallExpression","createCommaExpression","CommaExpression","createConstructorExpression","ConstructorExpression","createElementAccessExpression","ElementAccessExpression","createFalseExpression","FalseExpression","createFloatLiteralExpression","FloatLiteralExpression","createFunctionExpression","isArrow","FunctionArrowExpression","FunctionExpression","createIntegerLiteralExpression","IntegerLiteralExpression","createNewExpression","NewExpression","createNullExpression","NullExpression","createParenthesizedExpression","ParenthesizedExpression","createPropertyAccessExpression","PropertyAccessExpression","createRegexpLiteralExpression","pattern","RegexpLiteralExpression","patternFlags","createTernaryExpression","TernaryExpression","createStringLiteralExpression","StringLiteralExpression","createSuperExpression","SuperExpression","createThisExpression","ThisExpression","createTrueExpression","TrueExpression","createUnaryPostfixExpression","UnaryPostfixExpression","createUnaryPrefixExpression","UnaryPrefixExpression","createBlockStatement","BlockStatement","createBreakStatement","BreakStatement","createClassDeclaration","ClassDeclaration","createContinueStatement","ContinueStatement","createDecorator","Decorator","createDoStatement","DoStatement","createEmptyStatement","EmptyStatement","createEnumDeclaration","EnumDeclaration","createEnumValueDeclaration","EnumValueDeclaration","createExportStatement","ExportStatement","normalize","startsWith","createExportImportStatement","ExportImportStatement","createExportMember","elem","ExportMember","createExpressionStatement","ExpressionStatement","createIfStatement","IfStatement","createImportStatement","decls","ImportStatement","createImportStatementWithWildcard","createImportDeclaration","ImportDeclaration","createInterfaceDeclaration","InterfaceDeclaration","createFieldDeclaration","FieldDeclaration","createForStatement","ForStatement","createTypeParameter","TypeParameter","createParameter","parameterKind","createFunctionDeclaration","FunctionDeclaration","createMethodDeclaration","MethodDeclaration","createModifier","Modifier","createNamespaceDeclaration","NamespaceDeclaration","createReturnStatement","ReturnStatement","createSwitchStatement","SwitchStatement","createSwitchCase","SwitchCase","createThrowStatement","ThrowStatement","createTryStatement","catchVariable","catchStatements","finallyStatements","TryStatement","createTypeDeclaration","TypeDeclaration","createVariableStatement","VariableStatement","createVariableDeclaration","VariableDeclaration","createWhileStatement","WhileStatement","TYPE","TYPEPARAMETER","Expression","LiteralKind","LiteralExpression","AssertionKind","UnaryExpression","Statement","SourceKind","Source","tokenizer","sourceKind","ENTRY","LIBRARY","DeclarationStatement","cachedProgramLevelInternalName","cachedFileLevelInternalName","VariableLikeDeclarationStatement","DecoratorKind","DECORATOR","ENUMVALUEDECLARATION","EXPORTIMPORT","EXPORTMEMBER","IMPORTDECLARATION","ParameterKind","PARAMETER","MODIFIER","SWITCHCASE","fromKeyword","AS","ASYNC","AWAIT","CASE","CATCH","DEBUGGER","DEFAULT","DELETE","ELSE","EXTENDS","FINALLY","FROM","IMPLEMENTS","IN","INSTANCEOF","IS","KEYOF","MODULE","OF","PACKAGE","VAR","VOID","WITH","YIELD","INVALID","isAlsoIdentifier","token","operatorToString","DOT_DOT_DOT","ASTERISK_ASTERISK","ASTERISK_ASTERISK_EQUALS","a","pos","Tokenizer","tokenPos","markedPos","markedToken","markedTokenPos","nextToken","nextTokenOnNewLine","preferIdentifier","unsafeNext","maxTokenLength","STRINGLITERAL","OPENPAREN","CLOSEPAREN","isDecimalDigit","FLOATLITERAL","DOT","closed","_0_expected","testInteger","INTEGERLITERAL","COLON","SEMICOLON","EQUALS_GREATERTHAN","QUESTION","OPENBRACKET","CLOSEBRACKET","OPENBRACE","CLOSEBRACE","AT","isIdentifierStart","isKeywordCharacter","posBefore","isIdentifierPart","keywordText","keywordToken","isWhiteSpace","Invalid_character","ENDOFFILE","peek","checkOnNewLine","maxCompoundLength","tokenBefore","tokenPosBefore","skip","mark","reset","readIdentifier","quote","Unterminated_string_literal","readEscapeSequence","Unexpected_end_of_text","readExtendedUnicodeEscape","readUnicodeEscape","fromCharCode","readRegexpPattern","escaped","Unterminated_regular_expression_literal","readRegexpFlags","Invalid_regular_expression_flags","readInteger","readHexInteger","readBinaryInteger","readOctalInteger","isOctalDigit","Octal_literals_are_not_allowed_in_strict_mode","readDecimalInteger","i64_16","i64_mul","Hexadecimal_digit_expected","i64_10","Digit_expected","i64_8","Octal_digit_expected","i64_2","i64_1","Binary_digit_expected","readFloat","parseFloat","remain","value32","invalid","An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive","Unterminated_Unicode_escape_sequence","finish","isUnicodeIdentifierStart","isUnicodeIdentifierPart","lookupInUnicodeMap","map","mid","unicodeIdentifierStart","unicodeIdentifierPart","CharCode","separator","ipos","origin","dirname","UnreachableError","captureStackTrace","stack","AssertionError","globalScope","defineProperties","MIN_VALUE","writable","Math","fround","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","EPSILON","clz32","abs","min","floor","sqrt","trunc","isTrueish","radix","parseInt","undefined","fromCodePoint","binaryen","Binaryen","key","_malloc","_free","move_memory","dest","src","_memmove","HEAPU8","previousPrint","print","x","_BinaryenModulePrint","_BinaryenModulePrintAsmjs","compiler","NaN","Infinity","tempLocal0","tempLocal1","AbsF32","AbsF64","ClzI32","ClzI64","CtzI32","CtzI64","PopcntI32","PopcntI64","RotlI32","RotlI64","RotrI32","RotrI64","MaxF32","MaxF64","MinF32","MinF64","CeilF32","CeilF64","FloorF32","FloorF64","CopysignF32","CopysignF64","NearestF32","NearestF64","ReinterpretF32","ReinterpretF64","ReinterpretI32","ReinterpretI64","SqrtF32","SqrtF64","TruncF32","TruncF64","evaluateConstantOffset","Type_0_is_not_generic","CurrentMemory","GrowMemory","abort","compileAbort","cls","Implementation_0_must_match_the_signature_1","abortPrototype","abortInstance","Long","fromBits","low","high","sub","mul","i64_div","div","i64_div_u","toUnsigned","toSigned","i64_rem","i64_rem_u","i64_and","and","i64_or","or","i64_xor","xor","i64_shl","shl","i64_shr","shr","shru","i64_not","not","fromInt","minSafeF32","fromNumber","maxSafeF32","gte","lte","minSafeF64","maxSafeF64","toNumber","i64_to_string","unsigned","isLong","obj","cachedObj","cache","UINT_CACHE","INT_CACHE","isNaN","UZERO","ZERO","TWO_PWR_64_DBL","MAX_UNSIGNED_VALUE","TWO_PWR_63_DBL","neg","TWO_PWR_32_DBL","lowBits","highBits","fromString","RangeError","indexOf","radixToPower","pow_dbl","power","fromValue","wasm","WebAssembly","Instance","__isLong__","pow","TWO_PWR_16_DBL","TWO_PWR_24","ONE","UONE","NEG_ONE","LongPrototype","toInt","isZero","isNegative","eq","radixLong","rem1","rem","remDiv","intval","digits","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","bit","eqz","isPositive","isOdd","isEven","equals","other","notEquals","neq","ne","lessThan","comp","lt","lessThanOrEqual","le","greaterThan","gt","greaterThanOrEqual","ge","compare","thisNeg","otherNeg","negate","addend","a48","a32","a16","a00","b48","b32","b16","b00","c48","c32","c16","c00","subtract","subtrahend","multiply","multiplier","get_high","divide","divisor","div_u","div_s","approx","res","log2","log","LN2","delta","approxRes","approxRem","modulo","rem_u","rem_s","shiftLeft","numBits","shiftRight","shiftRightUnsigned","shr_u","toBytes","toBytesLE","toBytesBE","fromBytes","fromBytesLE","fromBytesBE","parseFile","parser","parser_1","Parser","nextFile","nextDiagnostic","isInfo","isWarning","isError","createOptions","setTarget","setNoTreeShaking","setNoAssert","setNoMemory","setImportMemory","setSourceMap","setMemoryBase","decompile","decompiler","decompiler_1","Decompiler","formatDiagnostic","nativeTypeToType","Unreachable","Auto","functionId","decompileFunction","_BinaryenFunctionGetName","_BinaryenFunctionGetNumParams","_BinaryenFunctionGetParam","_BinaryenFunctionGetResult","Block","decompileExpression","nested","string","_BinaryenBlockGetName","_BinaryenBlockGetNumChildren","_BinaryenBlockGetChild","If","_BinaryenIfGetCondition","_BinaryenIfGetIfTrue","_BinaryenIfGetIfFalse","Loop","_BinaryenLoopGetName","_BinaryenLoopGetBody","Break","_BinaryenBreakGetCondition","_BinaryenBreakGetName","Switch","Call","CallImport","CallIndirect","SetLocal","_BinaryenSetLocalGetIndex","_BinaryenSetLocalGetValue","SetGlobal","Store","_BinaryenStoreGetOffset","_BinaryenStoreGetPtr","_BinaryenStoreGetValue","Select","_BinaryenSelectGetIfTrue","_BinaryenSelectGetIfFalse","_BinaryenSelectGetCondition","Drop","_BinaryenDropGetValue","Return","_BinaryenReturnGetValue","Host","_BinaryenHostGetOp","_BinaryenHostGetOperand","Nop","AtomicCmpxchg","AtomicRMW","AtomicWait","AtomicWake","determinePrecedenceStart","determinePrecedence","isRightAssociative","backlog","seenlog","tn","parseTopLevelStatement","isNamespaceMember","parseDecorator","Line_break_not_permitted_here","parseEnum","parseVariable","parseFunction","parseClass","parseNamespace","parseExportImport","parseImport","parseTypeDeclaration","parseExport","_0_modifier_cannot_be_used_here","parseStatement","Decorators_are_not_valid_here","clear","parseType","acceptParenthesized","suppressErrors","startPos","innerType","Identifier_expected","nullable","bracketStart","bracketRange","parseArguments","isDeclare","parseVariableDeclaration","parentModifiers","parentDecorators","Initializers_are_not_allowed_in_ambient_contexts","parseExpression","parseEnumValue","parseReturn","parseTypeParameters","Type_parameter_list_cannot_be_empty","typeParameter","parseTypeParameter","parseParameters","seenRest","seenOptional","reportedRest","param","parseParameter","A_rest_parameter_must_be_last_in_a_parameter_list","A_required_parameter_cannot_follow_an_optional_parameter","OPTIONAL","REST","isRest","isOptional","startRange","A_rest_parameter_cannot_be_optional","A_rest_parameter_cannot_have_an_initializer","Parameter_cannot_have_question_mark_and_initializer","isSetter","A_set_accessor_must_have_exactly_one_parameter","A_set_accessor_parameter_cannot_have_an_initializer","A_get_accessor_cannot_have_parameters","parseBlockStatement","parseFunctionExpression","parseFunctionExpressionCommon","parseClassMember","parentIsDeclare","isConstructor","Type_parameters_cannot_appear_on_a_constructor_declaration","Type_annotation_cannot_appear_on_a_constructor_declaration","A_set_accessor_cannot_have_a_return_type_annotation","retMethod","Constructor_implementation_is_missing","retField","parseExportMember","asIdentifier","skipFrom","parseImportDeclaration","topLevel","parseBreak","parseContinue","parseDoStatement","parseForStatement","parseIfStatement","A_return_statement_can_only_be_used_within_a_function_body","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseWhileStatement","parseExpressionStatement","elseStatement","parseSwitchCase","_case_or_default_expected","parseExpressionStart","The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access","again","regexpPattern","Expression_expected","tryParseTypeArgumentsBeforeArguments","precedence","nextPrecedence","commaExprs","propertyCall","Precedence"],"mappings":"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3X,KAAK63C,cAId/xB,EAAAtkB,UAAAg5B,eAAA,SAAe9kB,GACb,GAAIuiC,GACAC,EACA/a,EACAgb,CACJ,IAAIn4C,KAAKi3C,aACP,GAAIvhC,EAAOuhC,YACT,GAAIgB,EAAej4C,KAAK4yB,WACtB,GAAIslB,EAAcxiC,EAAOkd,UACvB,MAAOqlB,GAAazd,eAAe0d,OAEhC,KAAI/a,EAAkBn9B,KAAK2X,gBAC5BwgC,EAAiBziC,EAAOiC,cAC1B,MAAOwlB,GAAgB3C,eAAe2d,OAIvC,KAAKziC,EAAOuhC,YACjB,OAAQj3C,KAAKknB,MAEX,OACE,OAAQxR,EAAOwR,MACb,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,QACA,QACE,OAAO,EAEX,KAEF,QACE,OAAQxR,EAAOwR,MACb,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,QACA,QACE,OAAO,EAEX,KAEF,QACE,OAAQxR,EAAOwR,MACb,OACA,OACA,OACA,OACA,OACA,OACA,QACE,OAAO,EAEX,KAEF,QACE,OAAQxR,EAAOwR,MACb,OACA,OACE,OAAO,CACT,QACA,OACE,MAAsB,KAAfxR,EAAO8oB,KAElB,KAEF,QACE,OAAQ9oB,EAAOwR,MACb,OACA,OACE,MAAoB,KAAblnB,KAAKw+B,IACd,QACA,OACA,OACA,OACE,OAAO,CACT,SACE,MAAsB,KAAf9oB,EAAO8oB,KAElB,KAEF,QACE,OAAQ9oB,EAAOwR,MACb,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,QACA,QACE,OAAO,EAEX,KAEF,QACE,OAAQxR,EAAOwR,MACb,OACA,OACA,OACA,OACA,OACA,OACA,OACA,QACA,QACE,OAAO,EAEX,KAEF,QACE,OAAQxR,EAAOwR,MACb,OACA,OACA,OACA,OACA,QACE,OAAO,EAEX,KAEF,QACE,OAAQxR,EAAOwR,MACb,OACE,OAAO,CACT,QACE,MAAsB,KAAfxR,EAAO8oB,KAElB,KAEF,QACE,OAAQ9oB,EAAOwR,MACb,OACE,MAAoB,KAAblnB,KAAKw+B,IACd,QACA,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AAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAC1C,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,KAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAEtCC,GACJ,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IACtE,IAAK,IAAK,IAAK,IAAK,IACpB,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KACxE,KAAM,KAAM,KAAM,KAAM,KACxB,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,KAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MACtE,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,QXk6VpD,SAAUvrD,EAAQD,EAASS,GAEjC,YY1uWA,SAAA+9C,GAA0Bl1B,GAKxB,IAJA,GAAIu8B,GAAM,EACN9iD,EAAMumB,EAAKhnB,OAGRujD,EAAM,EAAI9iD,GACK,IAApBumB,EAAKrmB,WAAW4iD,IAChBv8B,EAAKrmB,WAAW4iD,EAAM,IAAM6F,GAE5B7F,GAAO,GAGLA,EAAM,GAAK9iD,EAAMumB,EAAKhnB,UACxBgnB,EAAOA,EAAKhH,UAAUujC,EAAK9iD,GAC3BA,GAAO8iD,EACPA,EAAM,EAIR,KADA,GAAI1zB,GACG0zB,EAAM,EAAI9iD,GAAK,CAIpB,GAHAovB,GAAQ,EAIN7I,EAAKrmB,WAAW4iD,IAAQ6F,GACA,IAAxBpiC,EAAKrmB,WAAW4iD,EAAM,GACtB,CAGA,IADA1zB,EAAQ0zB,EAAM,GAAK9iD,IAEjB8iD,EAAM,EAAI9iD,GACVumB,EAAKrmB,WAAW4iD,EAAM,IAAM6F,EAC5B,CACApiC,EAAO6I,EACH7I,EAAKhH,UAAU,EAAGujC,GAClBv8B,EAAKhH,UAAU,EAAGujC,GAAOv8B,EAAKhH,UAAUujC,EAAM,GAClD9iD,GAAO,CACP,UAKF,IADAovB,EAAQ0zB,EAAM,GAAK9iD,IACkB,IAAxBumB,EAAKrmB,WAAW4iD,EAAM,IACjCA,EAAM,EAAI9iD,GACc,IAAxBumB,EAAKrmB,WAAW4iD,EAAM,IACtBv8B,EAAKrmB,WAAW4iD,EAAM,IAAM6F,EAC5B,CAGA,IADA,GAAIC,GAAO9F,IACF8F,GAAQ,GACf,GAAIriC,EAAKrmB,WAAW0oD,IAASD,EAAW,CAClC7F,EAAM8F,GAAQ,GACS,IAAzBriC,EAAKrmB,WAAW0oD,EAAO,IACE,IAAzBriC,EAAKrmB,WAAW0oD,EAAO,KAEvBriC,EAAO6I,EACH7I,EAAKhH,UAAU,EAAGqpC,GAClBriC,EAAKhH,UAAU,EAAGqpC,GAAQriC,EAAKhH,UAAUujC,EAAM,GACnD9iD,GAAO8iD,EAAM,EAAI8F,EACjB9F,EAAM8F,EAAO,EAEf,OAKJ,GAAIA,EAAO,GAAK9F,EAAM,IACT,GAAPA,GACgB,IAAlBv8B,EAAKrmB,WAAW,IACE,IAAlBqmB,EAAKrmB,WAAW,IAChB,CACAqmB,EAAOA,EAAKhH,UAAUujC,EAAM,GAC5B9iD,EAAMumB,EAAKhnB,MACX,YAKRujD,IAEF,MAAO9iD,GAAM,EAAIumB,EAAO,IAI1B,QAAA6D,GAAwBtL,EAAwB+pC,GAC9C,MAAI/pC,GAAe48B,WAAW,QACrB58B,EAEF28B,EACLqN,EAAQD,GAAU1nD,OAAOilD,aAAauC,GAAa7pC,GAKvD,QAAAgqC,GAAwBhqC,GAEtB,IADA,GAAIgkC,GAAMhkC,EAAevf,SAChBujD,EAAM,GACb,GAAIhkC,EAAe5e,WAAW4iD,IAAQ6F,EACpC,MAAO7pC,GAAeS,UAAU,EAAGujC,EAGvC,OAAO,IZuoWTxkD,OAAOC,eAAetB,EAAS,cAAgBoE,OAAO,GYlvWtD,IAAMsnD,GAAS,EAMf1rD,GAAAw+C,YAoFAx+C,EAAAmtB,UAUAntB,EAAA6rD,WZivWM,SAAU5rD,EAAQD,EAASS,GAEjCA,EAAoB,IACpBR,EAAOD,QAAUS,EAAoB,KAK/B,SAAUR,EAAQD,EAASS,GAEjC,YAEAY,QAAOC,eAAetB,EAAS,cAAgBoE,OAAO,Iar2WtD3D,EAAA,IACAA,EAAA,IACAA,EAAA,Kb22WM,SAAUR,EAAQD,EAASS,Ic72WjC,SAAAuwB,GAwGA,QAAA86B,KACA9vC,MAAA+vC,kBACA/vC,MAAA+vC,kBAAAzrD,KAAAwrD,GAEAxrD,KAAA0rD,MAAA1rD,KAAAY,KAAA,KAAAZ,KAAA6gB,QAAA,SAAAnF,QAAAgwC,MAWA,QAAAC,GAAA9qC,GACA7gB,KAAA6gB,WAAA,mBACAnF,MAAA+vC,kBACA/vC,MAAA+vC,kBAAAzrD,KAAA2rD,GAEA3rD,KAAA0rD,MAAA1rD,KAAAY,KAAA,KAAAZ,KAAA6gB,QAAA,SAAAnF,QAAAgwC,MA5HA,GAAAE,GAAA,mBAAA5tB,qBAAA,KAAAtN,MAAA3wB,IAEAgB,QAAA8qD,iBACAD,EAAA,YAAA9nD,GAA0C,MAAAA,IAAA,SAE1CgoD,WAAgBhoD,OAAA,IAAAioD,UAAA,GAChB3vC,WAAgBtY,MAAA,IAAAioD,UAAA,KAGhBhrD,OAAA8qD,iBACAD,EAAA,aAAA9nD,GAA4C,MAAAA,IAAA,SAE5CgoD,WAAgBhoD,OAAA,MAAAioD,UAAA,GAChB3vC,WAAgBtY,MAAA,MAAAioD,UAAA,KAGhBhrD,OAAA8qD,iBACAD,EAAA,IAAAA,EAAA,eAAA9nD,GAAmE,SAAAA,IAEnEgoD,WAAgBhoD,OAAA,WAAAioD,UAAA,GAChB3vC,WAAgBtY,MAAA,WAAAioD,UAAA,KAGhBhrD,OAAA8qD,iBACAD,EAAA,YAAA9nD,GAA0C,WAAAA,IAE1CgoD,WAAgBhoD,MAAA,EAAAioD,UAAA,GAChB3vC,WAAgBtY,MAAA,IAAAioD,UAAA,KAGhBhrD,OAAA8qD,iBACAD,EAAA,aAAA9nD,GAA4C,aAAAA,IAE5CgoD,WAAgBhoD,MAAA,EAAAioD,UAAA,GAChB3vC,WAAgBtY,MAAA,MAAAioD,UAAA,KAGhBhrD,OAAA8qD,iBACAD,EAAA,IAAAA,EAAA,eAAA9nD,GAAmE,MAAAA,KAAA,IAEnEgoD,WAAgBhoD,MAAA,EAAAioD,UAAA,GAChB3vC,WAAgBtY,MAAA,WAAAioD,UAAA,KAGhBhrD,OAAA8qD,iBACAD,EAAA,cAAA9nD,GAA8C,QAAAA,IAE9CgoD,WAAgBhoD,MAAA,EAAAioD,UAAA,GAChB3vC,WAAgBtY,MAAA,EAAAioD,UAAA,KAGhBhrD,OAAA8qD,iBACAD,EAAA,aAAA9nD,GAA4C,MAAAkoD,MAAAC,OAAAnoD,KAE5CgoD,WAAgBhoD,MAAAkoD,KAAAC,QAAA,eAAAF,UAAA,GAChB3vC,WAAgBtY,MAAAkoD,KAAAC,OAAA,eAAAF,UAAA,GAChBG,kBAAuBpoD,OAAA,SAAAioD,UAAA,GACvBI,kBAAuBroD,MAAA,SAAAioD,UAAA,GACvBK,SAActoD,MAAAkoD,KAAAC,OAAA,cAAAF,UAAA,KAGdhrD,OAAA8qD,iBACAD,EAAA,aAAA9nD,GAA4C,OAAAA,IAE5CgoD,WAAgBhoD,OAAA,uBAAAioD,UAAA,GAChB3vC,WAAgBtY,MAAA,uBAAAioD,UAAA,GAChBG,kBAAuBpoD,OAAA,iBAAAioD,UAAA,GACvBI,kBAAuBroD,MAAA,iBAAAioD,UAAA,GACvBK,SAActoD,MAAA,sBAAAioD,UAAA,KAGdH,EAAA,IAAAI,KAAAK,MAEAT,EAAA,IAAAI,KAAAM,IAEAV,EAAA,IAAAI,KAAAxrB,IAEAorB,EAAA,IAAAI,KAAAO,IAEAX,EAAA,KAAAI,KAAAlU,KAEA8T,EAAA,MAAAI,KAAAQ,MAEAZ,EAAA,gBAAAj3C,EAAAC,EAAAV,GACA,MAAAA,GAAAS,EAAAC,GAGAg3C,EAAA,KAAAI,KAAAS,KAEAb,EAAA,MAAAI,KAAAU,MAEAd,EAAA,eAAA9nD,GACA,GAAAwhD,GAAAxhD,GAAA,WACA0f,GAAA,SAAA1f,IAAA,CAIA,OAHAA,GAAAwhD,EAAA9hC,EACA8hC,EAAAxhD,GAAA,SACA0f,GAAA,MAAA1f,IAAA,GACAwhD,EAAA9hC,GAGAooC,EAAA,iBAAA9nD,GACA,MAAAA,IAAA,QAAAA,GAAA,iBAAAA,GAUA0nD,EAAAhqD,UAAAT,OAAAgO,OAAA2M,MAAAla,WACAgqD,EAAAhqD,UAAAZ,KAAA,mBACA4qD,EAAAhqD,UAAAqf,QAAA,cAEA+qC,EAAA,uBACA,SAAAJ,IAWAG,EAAAnqD,UAAAT,OAAAgO,OAAA2M,MAAAla,WACAmqD,EAAAnqD,UAAAZ,KAAA,iBAEAgrD,EAAA,gBAAAe,EAAA9rC,GACA,GAAA8rC,EAAA,MAAAA,EACA,UAAAhB,GAAA9qC,IAGA+qC,EAAA,oBAAA9nD,GACA,MAAAA,IAGA8nD,EAAA,kBAAAppD,EAAAoqD,GACA,SAAAC,SAAArqD,MAAAsqD,KAGAlpD,OAAA,uBAAAH,GACA,MAAAG,QAAAilD,aAAAxzB,MAAAzxB,OAAAH,IAGAG,OAAA,wBAAAH,GACA,MAAAG,QAAAmpD,cAAA13B,MAAAzxB,OAAAH,Mdk3W6BjD,KAAKd,EAASS,EAAoB,KAIzD,SAAUR,EAAQD,EAASS,Ie1gXjC,SAAAuwB,GAEA,KAAAs8B,GAAAt8B,EAAAu8B,UAAA9sD,EAAA,GAEA,QAAA+sD,KAAAF,IACAE,EAAA/O,WAAA,cAAA+O,EAAA/O,WAAA,gBACAztB,EAAAw8B,GAAAF,EAAAE,GAIAx8B,GAAA3uB,gBAAA,SAAAy8B,GACA,MAAAA,GACAwuB,EAAAG,QAAA3uB,GADA,GAIA9N,EAAAhhB,YAAA,SAAA5N,GACAA,GAAAkrD,EAAAI,MAAAtrD,IAGA4uB,EAAA28B,YAAA,SAAAC,EAAAC,EAAAnsD,GACA,MAAA4rD,GAAAQ,SAAAF,EAAAC,EAAAnsD,IAGAsvB,EAAAvuB,MAAA,SAAAL,EAAAQ,GACA0qD,EAAAS,OAAA3rD,GAAAQ,GAGAouB,EAAA5tB,KAAA,SAAAhB,GACA,MAAAkrD,GAAAS,OAAA3rD,GAKA,MAAAqN,GAAAhP,EAAA,GAAAgP,MAEAA,GAAA3N,UAAAia,OAAA,WACA,GAAAiyC,GAAAV,EAAAW,MACA3qD,EAAA,EAIA,OAHAgqD,GAAAW,MAAA,SAAAC,GAAgC5qD,GAAA4qD,EAAA,MAChCC,qBAAA7tD,KAAAoP,KACA49C,EAAAW,MAAAD,EACA1qD,GAGAmM,EAAA3N,UAAAma,QAAA,WACA,GAAA+xC,GAAAV,EAAAW,MACA3qD,EAAA,EAIA,OAHAgqD,GAAAW,MAAA,SAAAC,GAAgC5qD,GAAA4qD,EAAA,MAChCE,0BAAA9tD,KAAAoP,KACA49C,EAAAW,MAAAD,EACA1qD,Kf+gX6BxC,KAAKd,EAASS,EAAoB,KAIzD,SAAUR,EAAQD,GgBrkXxBC,EAAAD,QAAAO,GhB2kXM,SAAUN,EAAQD,EAASS,GAEjC,YiBpiXA,SAAAq0C,GACEuZ,EACAr9B,EACAuH,GAEA,OAAQvH,EAAO/Z,cAEb,IAAK,MACH,MAAIo3C,GAAS5tB,aAAe9b,EAAAyB,KAAKW,IACxBsnC,EAASpuD,OAAO+Q,UAAUs9C,MAEjCD,EAAS5tB,YAAc9b,EAAAyB,KAAKY,IACrBqnC,EAASpuD,OAAOiR,UAAUo9C,KAGrC,KAAK,WACH,MAAID,GAAS5tB,aAAe9b,EAAAyB,KAAKW,IACxBsnC,EAASpuD,OAAO+Q,UAAUu9C,MAEjCF,EAAS5tB,YAAc9b,EAAAyB,KAAKY,IACrBqnC,EAASpuD,OAAOiR,UAAUq9C,KAGrC,KAAK,YAEH,MADAF,GAAS5tB,YAAc4tB,EAASloC,QAAQU,UACjCwnC,EAASpuD,OAAOoS,gBAAgB,YAAag8C,EAAS5tB,YAAYtG,gBAM7E,MAJAk0B,GAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEN8sC,EAASpuD,OAAOoW,oBAIzB,QAAA69B,GACEma,EACAvsD,EACAyvB,EACA1f,EACAq3B,EACA3Q,GAEA,GAEI3V,GACAC,EACAC,EACAxf,EAEAkrD,EACAC,EAEAx8C,EACA1C,EAXAtP,EAASouD,EAASpuD,MAiBtB,QAAQ6B,EAAUmV,cAIhB,IAAK,QAEH,GADAo3C,EAAS5tB,YAAc9b,EAAAyB,KAAKU,KACL,GAAnBjV,EAASvP,OAWX,MAVIivB,IAAyC,GAAxBA,EAAcjvB,QACjC+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAGzD0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAKhB,MAJA+rD,GAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKY,IAAG,EAGzD,QAAQqnC,EAAS5tB,YAAYjZ,MAE3B,QACEgnC,EAAaH,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAKW,KAC/DzjB,EAAMrD,EAAOuR,aAAaqT,EAAAlb,SAASw1B,MACjCl/B,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAWgZ,KAErD,MAEF,SACEmxC,EAAaH,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAKY,KAC/D1jB,EAAMrD,EAAOuR,aAAaqT,EAAAlb,SAASy1B,MACjCn/B,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAWkZ,KAErD,MAEF,SACE8wC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,MAEF,SACE/S,EAAMrD,EAAOwQ,UAAU,GAK3B,MADA49C,GAAS5tB,YAAc9b,EAAAyB,KAAKU,KACrBxjB,CAET,KAAK,WAEH,GADA+qD,EAAS5tB,YAAc9b,EAAAyB,KAAKU,KACL,GAAnBjV,EAASvP,OAWX,MAVIivB,IAAyC,GAAxBA,EAAcjvB,QACjC+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAGzD0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAKhB,MAJA+rD,GAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKY,IAAG,EAGzD,QAAQqnC,EAAS5tB,YAAYjZ,MAE3B,QACEgnC,EAAaH,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAKW,KAC/DzjB,EAAMrD,EAAOuV,aACXvV,EAAOuR,aAAaqT,EAAAlb,SAASw1B,MAC3Bl/B,EAAOmR,YAAYyT,EAAAle,QAAQ+nD,OACzBzuD,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,IAE1C3iB,EAAO+Q,UAAUu9C,MAEnBtuD,EAAOwQ,UAAU,GACjBxQ,EAAOuR,aAAaqT,EAAAlb,SAASo1B,MAC3B9+B,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAWgZ,KACnDpd,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAWgZ,MAGvD,MAEF,SACEmxC,EAAaH,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAKY,KAC/D1jB,EAAMrD,EAAOuV,aACXvV,EAAOuR,aAAaqT,EAAAlb,SAASy1B,MAC3Bn/B,EAAOmR,YAAYyT,EAAAle,QAAQgoD,OACzB1uD,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,IAE1C3iB,EAAOiR,UAAUq9C,MAEnBtuD,EAAOwQ,UAAU,GACjBxQ,EAAOuR,aAAaqT,EAAAlb,SAASq1B,MAC3B/+B,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAWkZ,KACnDtd,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAWkZ,MAGvD,MAEF,SACE8wC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,MAEF,SACE/S,EAAMrD,EAAOwQ,UAAU,GAI3B,MADA49C,GAAS5tB,YAAc9b,EAAAyB,KAAKU,KACrBxjB,CAET,KAAK,MACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAK3J,IAAG,EAGzD,QAAQ4xC,EAAS5tB,YAAYjZ,MAE3B,QACElkB,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQioD,OAAQhsC,EACzC,MAEF,QACE,GAAIyrC,EAAS5tB,YAAY8W,YAAa,CACpC8W,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,OAGJ,OACE/S,EAAMrD,EAAOmR,YACXi9C,EAASloC,QAAQsb,SACb5c,EAAAle,QAAQkoD,OACRhqC,EAAAle,QAAQioD,OACZhsC,EAEF,MAEF,QACA,OACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQkoD,OAAQjsC,EACzC,MAEF,SACA,QACA,QACEyrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,MACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAK3J,IAAG,EAGzD,QAAQ4xC,EAAS5tB,YAAYjZ,MAE3B,QACElkB,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQmoD,OAAQlsC,EACzC,MAEF,QACE,GAAIyrC,EAAS5tB,YAAY8W,YAAa,CACpC8W,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,OAGJ,OACE/S,EAAMrD,EAAOmR,YACXi9C,EAASloC,QAAQsb,SACb5c,EAAAle,QAAQooD,OACRlqC,EAAAle,QAAQmoD,OACZlsC,EAEF,MAEF,QACA,OACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQooD,OAAQnsC,EACzC,MAEF,SACA,QACA,QACEyrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,SACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAK3J,IAAG,EAGzD,QAAQ4xC,EAAS5tB,YAAYjZ,MAE3B,QACElkB,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQqoD,UAAWpsC,EAC5C,MAEF,QACE,GAAIyrC,EAAS5tB,YAAY8W,YAAa,CACpC8W,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,OAGJ,OACE/S,EAAMrD,EAAOmR,YACXi9C,EAASloC,QAAQsb,SACb5c,EAAAle,QAAQsoD,UACRpqC,EAAAle,QAAQqoD,UACZpsC,EAEF,MAEF,QACA,OACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQsoD,UAAWrsC,EAC5C,MAEF,SACA,QACA,QACEyrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,OACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAK3J,IAAG,EAIzD,QAFAoG,EAAOwrC,EAASrrB,kBAAkBnxB,EAAS,GAAIw8C,EAAS5tB,aAEhD4tB,EAAS5tB,YAAYjZ,MAE3B,OACA,OACA,OACA,OACA,QACElkB,EAAMgB,EAAAi6B,qBACJt+B,EAAOuR,aAAaqT,EAAAlb,SAASulD,QAAStsC,EAAMC,GAC5CwrC,EAAS5tB,YACTxgC,EAGJ,QACA,OACEqD,EAAMrD,EAAOuR,aAAaqT,EAAAlb,SAASulD,QAAStsC,EAAMC,EAClD,MAEF,QACE,GAAIwrC,EAAS5tB,YAAY8W,YAAa,CACpC8W,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,OAGJ,OACE/S,EAAMrD,EAAOuR,aACX68C,EAASloC,QAAQsb,SACb5c,EAAAlb,SAASwlD,QACTtqC,EAAAlb,SAASulD,QACbtsC,EACAC,EAEF,MAEF,QACA,OACEvf,EAAMrD,EAAOuR,aAAaqT,EAAAlb,SAASwlD,QAASvsC,EAAMC,EAClD,MAEF,SACEwrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,OACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAK3J,IAAG,EAIzD,QAFAoG,EAAOwrC,EAASrrB,kBAAkBnxB,EAAS,GAAIw8C,EAAS5tB,aAEhD4tB,EAAS5tB,YAAYjZ,MAE3B,OACA,OACA,OACA,OACA,QACElkB,EAAMgB,EAAAi6B,qBACJt+B,EAAOuR,aAAaqT,EAAAlb,SAASylD,QAASxsC,EAAMC,GAC5CwrC,EAAS5tB,YACTxgC,EAEF,MAEF,QACA,OACEqD,EAAMrD,EAAOuR,aAAaqT,EAAAlb,SAASylD,QAASxsC,EAAMC,EAClD,MAEF,QACE,GAAIwrC,EAAS5tB,YAAY8W,YAAa,CACpC8W,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,OAGJ,OACE/S,EAAMrD,EAAOuR,aACX68C,EAASloC,QAAQsb,SACb5c,EAAAlb,SAAS0lD,QACTxqC,EAAAlb,SAASylD,QACbxsC,EACAC,EAEF,MAEF,QACA,OACEvf,EAAMrD,EAAOuR,aAAaqT,EAAAlb,SAAS0lD,QAASzsC,EAAMC,EAClD,MAEF,SACEwrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,MACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKY,IAAG,EAGzD,QAAQqnC,EAAS5tB,YAAYjZ,MAE3B,OACA,OAGA,OACEgnC,EAAaH,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAK3J,KAC/DnZ,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOuR,aAAaqT,EAAAlb,SAASmmC,OAC3B7vC,EAAOwQ,UAAU,GACjBxQ,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW2Y,MAErD/c,EAAOuR,aAAaqT,EAAAlb,SAASgkC,MAC3B1tC,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW2Y,KACnD/c,EAAOwQ,UAAU,IAGrB,MAEF,QACE+9C,EAAaH,EAAS5wB,gBAAgBnD,oBAAoB+zB,EAASloC,QAAQU,WAC3EvjB,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOuR,aACL68C,EAASloC,QAAQsb,SACb5c,EAAAlb,SAASomC,OACTlrB,EAAAlb,SAASmmC,OACbue,EAASloC,QAAQU,UAAUyc,aAAarjC,GACxCA,EAAO8R,eAAey8C,EAAWx8C,MAAOq8C,EAASloC,QAAQ4wB,iBAE3D92C,EAAOuR,aACL68C,EAASloC,QAAQsb,SACb5c,EAAAlb,SAASikC,MACT/oB,EAAAlb,SAASgkC,MACb1tC,EAAO8R,eAAey8C,EAAWx8C,MAAOq8C,EAASloC,QAAQ4wB,gBACzDsX,EAASloC,QAAQU,UAAUyc,aAAarjC,IAG5C,MAEF,QACEuuD,EAAaH,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAKG,KAC/DjjB,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOuR,aAAaqT,EAAAlb,SAASomC,OAC3B9vC,EAAO2Q,UAAU,EAAG,GACpB3Q,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW6Y,MAErDjd,EAAOuR,aAAaqT,EAAAlb,SAASikC,MAC3B3tC,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW6Y,KACnDjd,EAAO2Q,UAAU,EAAG,IAGxB,MAEF,QACE,GAAIy9C,EAAS5tB,YAAY8W,YAAa,CACpC8W,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,OAGJ,OACA,OACA,OACA,OACA,QACE/S,EAAMsf,CACN,MAEF,SACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQ+nD,OAAQ9rC,EACzC,MAEF,SACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQgoD,OAAQ/rC,EACzC,MAEF,SACEtf,EAAMrD,EAAOoW,mBACb,MAEF,SACEg4C,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,MACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKY,IAAG,EAIzD,QAFAnE,EAAOwrC,EAASrrB,kBAAkBnxB,EAAS,GAAIw8C,EAAS5tB,aAEhD4tB,EAAS5tB,YAAYjZ,MAE3B,OACA,OACA,OACEgnC,EAAaH,EAAS5wB,gBAAgBxD,aAAatV,EAAAyB,KAAK3J,KACxDgyC,EAAaJ,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAK3J,KAC/D4xC,EAAS5wB,gBAAgBpD,cAAcm0B,GACvClrD,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOkS,eAAes8C,EAAWz8C,MAAO6Q,GACxC5iB,EAAOuR,aAAaqT,EAAAlb,SAASgkC,MAC3B1tC,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW2Y,KACnD/c,EAAO8R,eAAe08C,EAAWz8C,MAAO6S,EAAAxgB,WAAW2Y,MAGvD,MAEF,QACA,OACA,OACA,QACEwxC,EAAaH,EAAS5wB,gBAAgBxD,aAAatV,EAAAyB,KAAK3J,KACxDgyC,EAAaJ,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAK3J,KAC/D4xC,EAAS5wB,gBAAgBpD,cAAcm0B,GACvClrD,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOkS,eAAes8C,EAAWz8C,MAAO6Q,GACxC5iB,EAAOuR,aAAaqT,EAAAlb,SAASkkC,MAC3B5tC,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW2Y,KACnD/c,EAAO8R,eAAe08C,EAAWz8C,MAAO6S,EAAAxgB,WAAW2Y,MAGvD,MAEF,QACEwxC,EAAaH,EAAS5wB,gBAAgBxD,aAAatV,EAAAyB,KAAKG,KACxDkoC,EAAaJ,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAKG,KAC/D8nC,EAAS5wB,gBAAgBpD,cAAcm0B,GACvClrD,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOkS,eAAes8C,EAAWz8C,MAAO6Q,GACxC5iB,EAAOuR,aAAaqT,EAAAlb,SAASikC,MAC3B3tC,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW6Y,KACnDjd,EAAO8R,eAAe08C,EAAWz8C,MAAO6S,EAAAxgB,WAAW6Y,MAGvD,MAEF,QACEsxC,EAAaH,EAAS5wB,gBAAgBxD,aAAatV,EAAAyB,KAAKG,KACxDkoC,EAAaJ,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAKG,KAC/D8nC,EAAS5wB,gBAAgBpD,cAAcm0B,GACvClrD,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOkS,eAAes8C,EAAWz8C,MAAO6Q,GACxC5iB,EAAOuR,aAAaqT,EAAAlb,SAASmkC,MAC3B7tC,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW6Y,KACnDjd,EAAO8R,eAAe08C,EAAWz8C,MAAO6S,EAAAxgB,WAAW6Y,MAGvD,MAEF,QACEsxC,EAAaH,EAAS5wB,gBAAgBxD,aAAao0B,EAASloC,QAAQU,WACpE4nC,EAAaJ,EAAS5wB,gBAAgBnD,oBAAoB+zB,EAASloC,QAAQU,WAC3EwnC,EAAS5wB,gBAAgBpD,cAAcm0B,GACvClrD,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOkS,eAAes8C,EAAWz8C,MAAO6Q,GACxC5iB,EAAOuR,aACL68C,EAASloC,QAAQsb,SACb5c,EAAAlb,SAASikC,MACT/oB,EAAAlb,SAASgkC,MACb1tC,EAAO8R,eAAey8C,EAAWx8C,MAAOq8C,EAASloC,QAAQ4wB,gBACzD92C,EAAO8R,eAAe08C,EAAWz8C,MAAOq8C,EAASloC,QAAQ4wB,iBAG7D,MAEF,QACE,GAAIsX,EAAS5tB,YAAY8W,YAAa,CACpC8W,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,OAEFm4C,EAAaH,EAAS5wB,gBAAgBxD,aAAao0B,EAASloC,QAAQU,WACpE4nC,EAAaJ,EAAS5wB,gBAAgBnD,oBAAoB+zB,EAASloC,QAAQU,WAC3EwnC,EAAS5wB,gBAAgBpD,cAAcm0B,GACvClrD,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOkS,eAAes8C,EAAWz8C,MAAO6Q,GACxC5iB,EAAOuR,aACL68C,EAASloC,QAAQsb,SACb5c,EAAAlb,SAASmkC,MACTjpB,EAAAlb,SAASkkC,MACb5tC,EAAO8R,eAAey8C,EAAWx8C,MAAOq8C,EAASloC,QAAQ4wB,gBACzD92C,EAAO8R,eAAe08C,EAAWz8C,MAAOq8C,EAASloC,QAAQ4wB,iBAG7D,MAEF,SACEzzC,EAAMrD,EAAOuR,aAAaqT,EAAAlb,SAAS2lD,OAAQ1sC,EAAMC,EACjD,MAEF,SACEvf,EAAMrD,EAAOuR,aAAaqT,EAAAlb,SAAS4lD,OAAQ3sC,EAAMC,EACjD,MAEF,SACEwrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,MACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKY,IAAG,EAIzD,QAFAnE,EAAOwrC,EAASrrB,kBAAkBnxB,EAAS,GAAIw8C,EAAS5tB,aAEhD4tB,EAAS5tB,YAAYjZ,MAE3B,OACA,OACA,OACEgnC,EAAaH,EAAS5wB,gBAAgBxD,aAAatV,EAAAyB,KAAK3J,KACxDgyC,EAAaJ,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAK3J,KAC/D4xC,EAAS5wB,gBAAgBpD,cAAcm0B,GACvClrD,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOkS,eAAes8C,EAAWz8C,MAAO6Q,GACxC5iB,EAAOuR,aAAaqT,EAAAlb,SAASyjC,MAC3BntC,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW2Y,KACnD/c,EAAO8R,eAAe08C,EAAWz8C,MAAO6S,EAAAxgB,WAAW2Y,MAGvD,MAEF,QACA,OACA,OACA,QACEwxC,EAAaH,EAAS5wB,gBAAgBxD,aAAatV,EAAAyB,KAAK3J,KACxDgyC,EAAaJ,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAK3J,KAC/D4xC,EAAS5wB,gBAAgBpD,cAAcm0B,GACvClrD,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOkS,eAAes8C,EAAWz8C,MAAO6Q,GACxC5iB,EAAOuR,aAAaqT,EAAAlb,SAAS2jC,MAC3BrtC,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW2Y,KACnD/c,EAAO8R,eAAe08C,EAAWz8C,MAAO6S,EAAAxgB,WAAW2Y,MAGvD,MAEF,QACEwxC,EAAaH,EAAS5wB,gBAAgBxD,aAAatV,EAAAyB,KAAKG,KACxDkoC,EAAaJ,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAKG,KAC/D8nC,EAAS5wB,gBAAgBpD,cAAcm0B,GACvClrD,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOkS,eAAes8C,EAAWz8C,MAAO6Q,GACxC5iB,EAAOuR,aAAaqT,EAAAlb,SAAS0jC,MAC3BptC,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW6Y,KACnDjd,EAAO8R,eAAe08C,EAAWz8C,MAAO6S,EAAAxgB,WAAW6Y,MAGvD,MAEF,QACEsxC,EAAaH,EAAS5wB,gBAAgBxD,aAAatV,EAAAyB,KAAKG,KACxDkoC,EAAaJ,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAKG,KAC/D8nC,EAAS5wB,gBAAgBpD,cAAcm0B,GACvClrD,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOkS,eAAes8C,EAAWz8C,MAAO6Q,GACxC5iB,EAAOuR,aAAaqT,EAAAlb,SAAS4jC,MAC3BttC,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW6Y,KACnDjd,EAAO8R,eAAe08C,EAAWz8C,MAAO6S,EAAAxgB,WAAW6Y,MAGvD,MAEF,QACEsxC,EAAaH,EAAS5wB,gBAAgBxD,aAAao0B,EAASloC,QAAQU,WACpE4nC,EAAaJ,EAAS5wB,gBAAgBnD,oBAAoB+zB,EAASloC,QAAQU,WAC3EwnC,EAAS5wB,gBAAgBpD,cAAcm0B,GACvClrD,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOkS,eAAes8C,EAAWz8C,MAAO6Q,GACxC5iB,EAAOuR,aACL68C,EAASloC,QAAQsb,SACb5c,EAAAlb,SAAS0jC,MACTxoB,EAAAlb,SAASyjC,MACbntC,EAAO8R,eAAey8C,EAAWx8C,MAAOq8C,EAASloC,QAAQ4wB,gBACzD92C,EAAO8R,eAAe08C,EAAWz8C,MAAOq8C,EAASloC,QAAQ4wB,iBAG7D,MAEF,QACE,GAAIsX,EAAS5tB,YAAY8W,YAAa,CACpC8W,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,OAEFm4C,EAAaH,EAAS5wB,gBAAgBxD,aAAao0B,EAASloC,QAAQU,WACpE4nC,EAAaJ,EAAS5wB,gBAAgBnD,oBAAoB+zB,EAASloC,QAAQU,WAC3EwnC,EAAS5wB,gBAAgBpD,cAAcm0B,GACvClrD,EAAMrD,EAAOuV,aACXvV,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOkS,eAAes8C,EAAWz8C,MAAO6Q,GACxC5iB,EAAOuR,aACL68C,EAASloC,QAAQsb,SACb5c,EAAAlb,SAAS4jC,MACT1oB,EAAAlb,SAAS2jC,MACbrtC,EAAO8R,eAAey8C,EAAWx8C,MAAOq8C,EAASloC,QAAQ4wB,gBACzD92C,EAAO8R,eAAe08C,EAAWz8C,MAAOq8C,EAASloC,QAAQ4wB,iBAG7D,MAEF,SACEzzC,EAAMrD,EAAOuR,aAAaqT,EAAAlb,SAAS6lD,OAAQ5sC,EAAMC,EACjD,MAEF,SACEvf,EAAMrD,EAAOuR,aAAaqT,EAAAlb,SAAS8lD,OAAQ7sC,EAAMC,EACjD,MAEF,SACEwrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,OACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKY,IAAG,EAGzD,QAAQqnC,EAAS5tB,YAAYjZ,MAE3B,OACE,GAAI6mC,EAAS5tB,YAAY8W,YAAa,CACpC8W,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,OAGJ,QACE/S,EAAMsf,CACN,MAEF,SACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQ+oD,QAAS9sC,EAC1C,MAEF,SACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQgpD,QAAS/sC,EAC1C,MAEF,SACEyrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,QACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKY,IAAG,EAGzD,QAAQqnC,EAAS5tB,YAAYjZ,MAE3B,OACE,GAAI6mC,EAAS5tB,YAAY8W,YAAa,CACpC8W,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,OAGJ,QACE/S,EAAMsf,CACN,MAEF,SACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQipD,SAAUhtC,EAC3C,MAEF,SACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQkpD,SAAUjtC,EAC3C,MAEF,SACEyrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,WACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKY,IAAG,EAIzD,QAFAnE,EAAOwrC,EAASrrB,kBAAkBnxB,EAAS,GAAIw8C,EAAS5tB,aAEhD4tB,EAAS5tB,YAAYjZ,MAI3B,QACElkB,EAAMrD,EAAOuR,aAAaqT,EAAAlb,SAASmmD,YAAaltC,EAAMC,EACtD,MAEF,SACEvf,EAAMrD,EAAOuR,aAAaqT,EAAAlb,SAASomD,YAAantC,EAAMC,EACtD,MAEF,SACEwrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,UACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKY,IAAG,EAGzD,QAAQqnC,EAAS5tB,YAAYjZ,MAE3B,OACE,GAAI6mC,EAAS5tB,YAAY8W,YAAa,CACpC8W,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,OAGJ,QACE/S,EAAMsf,CACN,MAEF,SACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQqpD,WAAYptC,EAC7C,MAEF,SACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQspD,WAAYrtC,EAC7C,MAEF,SACEyrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,cACH,GAAuB,GAAnBuO,EAASvP,OAYX,MAXMivB,IAAyC,GAAxBA,EAAcjvB,SAC/BivB,GAAiBA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAChF88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAgBA,EAAcjvB,OAAOqf,SAAS,IAAM,MAG/E0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,KAAMkb,GAAyC,GAAxBA,EAAcjvB,OAMnC,MALIivB,IAAiBA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAChF88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAgBA,EAAcjvB,OAAOqf,SAAS,IAAM,KAEtE1hB,EAAOoW,mBAGhB,QAAQkb,EAAc,GAAG/J,MAEvB,OACA,OACE5E,EAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKW,KACpDzjB,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQupD,eAAgBttC,EACjD,MAEF,QACA,OACEA,EAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKY,KACpD1jB,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQwpD,eAAgBvtC,EACjD,MAEF,QACE,GAAI2O,EAAc,GAAGgmB,YAMnB,MALA8W,GAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEb8sC,EAAS5tB,YAAclP,EAAc,GAC9BtxB,EAAOoW,mBAGlB,QACEuM,EAAOyrC,EAASrrB,kBACdnxB,EAAS,GACTw8C,EAASloC,QAAQsb,SACb9c,EAAAyB,KAAKY,IACLrC,EAAAyB,KAAKW,KAEXzjB,EAAMrD,EAAOmR,YACXi9C,EAASloC,QAAQsb,SACb5c,EAAAle,QAAQwpD,eACRtrC,EAAAle,QAAQupD,eACZttC,EAEF,MAEF,SACEA,EAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKO,KACpDrjB,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQypD,eAAgBxtC,EACjD,MAEF,SACEA,EAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKQ,KACpDtjB,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQ0pD,eAAgBztC,EACjD,MAEF,SACEyrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAIjB,MADAg4C,GAAS5tB,YAAclP,EAAc,GAC9BjuB,CAET,KAAK,OACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKY,IAAG,EAGzD,QAAQqnC,EAAS5tB,YAAYjZ,MAI3B,QACElkB,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQ2pD,QAAS1tC,EAC1C,MAEF,SACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQ4pD,QAAS3tC,EAC1C,MAEF,SAEEyrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,QACH,GAAuB,GAAnBuO,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,GAAiBA,EAAcjvB,OAAQ,CAEzC,GADA+rD,EAAS5tB,YAAclP,EAAc,GACT,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKY,IAAG,EAGzD,QAAQqnC,EAAS5tB,YAAYjZ,MAE3B,OACE,GAAI6mC,EAAS5tB,YAAY8W,YAAa,CACpC8W,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,mBACb,OAGJ,QACE/S,EAAMsf,CACN,MAIF,SACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQ6pD,SAAU5tC,EAC3C,MAEF,SACEtf,EAAMrD,EAAOmR,YAAYyT,EAAAle,QAAQ8pD,SAAU7tC,EAC3C,MAEF,SACEyrC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAIT,KAAK,OACH,MAAIuO,GAASvP,OAAS,GAAKuP,EAASvP,OAAS,GACrCivB,GAAyC,GAAxBA,EAAcjvB,QACnC+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAgBA,EAAcjvB,OAAOqf,SAAS,IAAM,KAG3E9P,EAASvP,OAAS,EACpB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeiyB,wCACfnc,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAGlD0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAG7C1hB,EAAOoW,qBAEVkb,GAAyC,GAAxBA,EAAcjvB,QAQrCsgB,EAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAIw8C,EAASloC,QAAQU,WAChEtX,EAA4B,GAAnBsC,EAASvP,OAAcouD,EAAuBrC,EAAUx8C,EAAS,IAAM,EAC5EtC,EAAS,EACJtP,EAAOoW,oBAETpW,EAAOsS,WACZgf,EAAc,GAAGiL,SACjBjL,EAAc,GAAGlG,GAAG,GACpBzI,EACA2O,EAAc,GAAGlG,GAAE,IACnB6d,EAAe7d,GAAE,IACjB6d,EAAepK,MAAQvN,EAAc,GAAGuN,MACnCuvB,EAAS5tB,YAAcyI,GAAgB/O,gBACvCk0B,EAAS5tB,YAAclP,EAAc,IAAI4I,eAC9C5qB,KArBIgiB,GAAiBA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAChF88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAgBA,EAAcjvB,OAAOqf,SAAS,IAAM,KAEtE1hB,EAAOoW,oBAmBlB,KAAK,QAEH,MADAg4C,GAAS5tB,YAAc9b,EAAAyB,KAAKa,KACxBpV,EAASvP,OAAS,GAAKuP,EAASvP,OAAS,GACrCivB,GAAyC,GAAxBA,EAAcjvB,QACnC+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAgBA,EAAcjvB,OAAOqf,SAAS,IAAM,KAG3E9P,EAASvP,OAAS,EACpB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeiyB,wCACfnc,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAGlD0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAG7C1hB,EAAOoW,qBAEVkb,GAAyC,GAAxBA,EAAcjvB,QAOrCsgB,EAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAIw8C,EAASloC,QAAQU,WAChEhE,EAAOwrC,EAASrrB,kBACdnxB,EAAS,GACT0f,EAAc,GACdA,EAAc,GAAGlG,GAAE,GAChB,EACA,GAGHgjC,EAAS5tB,YAAYpV,GAAE,IACvBkG,EAAc,GAAGlG,GAAE,IACnBkG,EAAc,GAAGuN,KAAOuvB,EAAS5tB,YAAY3B,MAE7Cjc,EAAOwrC,EAASrjB,kBACdnoB,EACAwrC,EAAS5tB,YAAalP,EAAc,GAAE,EAEtC1f,EAAS,IAEXI,EAAOsf,EAAc,IAErBtf,EAAOo8C,EAAS5tB,aAElBlxB,EAA4B,GAAnBsC,EAASvP,OAAcouD,EAAuBrC,EAAUx8C,EAAS,IAAM,GACnE,EACJ5R,EAAOoW,qBAEhBg4C,EAAS5tB,YAAc9b,EAAAyB,KAAKa,KACrBhnB,EAAO0S,YAAY4e,EAAc,GAAGiL,SAAU5Z,EAAMC,EAAM5Q,EAAKkoB,eAAgB5qB,MAlCpF8+C,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAgBA,EAAcjvB,OAAOqf,SAAS,IAAM,KAEtE1hB,EAAOoW,oBAgClB,KAAK,SAEH,MADAg4C,GAAS5tB,YAAc4tB,EAASloC,QAAQU,UACjB,GAAnBhV,EAASvP,QACLivB,GAAyC,GAAxBA,EAAcjvB,QACnC+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAgBA,EAAcjvB,OAAOqf,SAAS,IAAM,KAG/E0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,qBAEZkb,EAC0B,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,qBAEhB/S,EAAM+qD,EAASloC,QAAQsb,SACnBxhC,EAAO2Q,UAAU2gB,EAAc,GAAGiL,SAAU,GAC5Cv8B,EAAOwQ,UAAU8gB,EAAc,GAAGiL,WAEtC6xB,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAK,KAElBthB,EAAOoW,oBAMlB,KAAK,SACH,GAAuB,GAAnBxE,EAASvP,OAcX,MAbIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IACnC,GAAxBA,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAI3D0sC,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAE3C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CACjB,GAA4B,GAAxBA,EAAcjvB,OAMhB,MALIivB,GAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAC/D88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAK3J,IAAG,EAMzD,QAJAoG,EAAOwrC,EAASrrB,kBAAkBnxB,EAAS,GAAII,EAAOo8C,EAAS5tB,aAC/D3d,EAAOurC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKU,MACpDunC,EAAS5tB,YAAcxuB,EAEfo8C,EAAS5tB,YAAYjZ,MAE3B,QACElkB,EAAMrD,EAAOuV,aAAaoN,EAAMC,EAAMC,EACtC,MAEF,SACEurC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMrD,EAAOoW,oBAGjB,MAAO/S,EAET,KAAK,cAaH,MAZuB,IAAnBuO,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAGhD4P,GACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGzBhX,EAAOoW,mBAIhB,KAAK,iBAcH,MAbAg4C,GAAS5tB,YAAc9b,EAAAyB,KAAK3J,IACL,GAAnB5K,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAGhD4P,GACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGzBhX,EAAO2R,WAAWiT,EAAArW,OAAOoiD,cAElC,KAAK,cAiBH,MAhBAvC,GAAS5tB,YAAc9b,EAAAyB,KAAK3J,IACL,GAAnB5K,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElDiB,EAAO3iB,EAAOoW,qBAEduM,EAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAK3J,KAElD8U,GACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGzBhX,EAAO2R,WAAWiT,EAAArW,OAAOqiD,WAAY,MAAQjuC,GAGtD,KAAK,cAOH,GANI2O,GACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,OAMX,MALA+rD,GAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc9b,EAAAyB,KAAKa,KACrBhnB,EAAOoW,mBAMhB,MAJAuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAIw8C,EAASloC,QAAQU,WAChEhE,EAAOwrC,EAASrrB,kBAAkBnxB,EAAS,GAAIw8C,EAASloC,QAAQU,WAChE/D,EAAOurC,EAASrrB,kBAAkBnxB,EAAS,GAAIw8C,EAASloC,QAAQU,WAChEwnC,EAAS5tB,YAAc9b,EAAAyB,KAAKa,KACtB,GAAIjL,OAAM,kBAGlB,KAAK,aAOH,GANIuV,GACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,OAMX,MALA+rD,GAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc9b,EAAAyB,KAAKa,KACrBhnB,EAAOoW,mBAMhB,MAJAuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAIw8C,EAASloC,QAAQU,WAChEhE,EAAOwrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKO,KACpD7D,EAAOurC,EAASrrB,kBAAkBnxB,EAAS,GAAIw8C,EAASloC,QAAQU,WAChEwnC,EAAS5tB,YAAc9b,EAAAyB,KAAKa,KACtB,GAAIjL,OAAM,kBAKlB,KAAK,aACH,MAAMuV,IAAyC,GAAxBA,EAAcjvB,OAOL,GAArBivB,EAAc,GAAG/J,MAC1B6mC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEb8sC,EAAS5tB,YAAclP,EAAc,GAC9BtxB,EAAOoW,qBAEO,GAAnBxE,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAclP,EAAc,GAC9BtxB,EAAOoW,sBAEhBuM,EAAOyrC,EAASrrB,kBACdnxB,EAAS,GACTw8C,EAASloC,QAAQU,UAAS,GAG5BwnC,EAAS5tB,YAAclP,EAAc,GACR,GAAzB88B,EAAS5tB,YAAYjZ,MACvB6mC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAENthB,EAAOoW,qBAITuM,IArCD2O,GAAiBA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,IAChF88B,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAgBA,EAAcjvB,OAAOqf,SAAS,IAAM,KAEtE1hB,EAAOoW,oBAkClB,KAAK,SACH,GAAIxE,EAASvP,OAAS,GAAKuP,EAASvP,OAAS,EAqB3C,MApBIivB,KACEA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,GAAG8mB,iBACtC,GAAxB9mB,EAAcjvB,QAChB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,MAIvD9P,EAASvP,OAAS,EACpB+rD,EAAS9qC,MACPmB,EAAAjC,eAAeiyB,wCACfnc,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAEzC9P,EAASvP,OAAS,GAC3B+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAG7C1hB,EAAOoW,mBAEhB,IAAIkb,EAAe,CAEjB,GADIA,EAAcjvB,SAAQ+rD,EAAS5tB,YAAclP,EAAc,GAAG8mB,iBACtC,GAAxB9mB,EAAcjvB,OAKhB,MAJA+rD,GAAS9qC,MACPmB,EAAAjC,eAAeyP,oCACfqG,EAAWhX,MAAO,IAAKgQ,EAAcjvB,OAAOqf,SAAS,KAEhD1hB,EAAOoW,mBAEhBuM,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI0f,EAAc,QAE7D3O,GAAOyrC,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAK3J,IAAG,EAOzD,IAJAxK,EAAOo8C,EAAS5tB,YAChB4tB,EAAS5tB,YAAcxuB,EAAKomC,gBAGxBgW,EAASloC,QAAQwZ,SACnB,MAAIuJ,IAAkBvkB,EAAAyB,KAAKa,MACzBonC,EAAS5tB,YAAc9b,EAAAyB,KAAKa,KACrBhnB,EAAOmV,aAETwN,CAGT,IAAIkuC,GAAQC,EAAa1C,EAA6B,GAAnBx8C,EAASvP,OAAcuP,EAAS,GAAK,KAAM0mB,EAI9E,IAFA81B,EAAS5tB,YAAcxuB,EAAKomC,gBAExBnP,GAAkBvkB,EAAAyB,KAAKa,KAAM,CAC/B,OAAQonC,EAAS5tB,YAAYjZ,MAE3B,QACElkB,EAAMrD,EAAO+U,SACX/U,EAAOmR,YAAYyT,EAAAle,QAAQi4B,OACzBhc,GAEFkuC,EAEF,MAEF,QACA,OACExtD,EAAMrD,EAAO+U,SACX/U,EAAOmR,YAAYyT,EAAAle,QAAQk4B,OACzBjc,GAEFkuC,EAEF,MAEF,QACA,OACExtD,EAAMrD,EAAO+U,SACX/U,EAAOmR,YACLi9C,EAASloC,QAAQsb,SACb5c,EAAAle,QAAQk4B,OACRha,EAAAle,QAAQi4B,OACZhc,GAEFkuC,EAEF,MAIF,SACExtD,EAAMrD,EAAO+U,SACX/U,EAAOuR,aAAaqT,EAAAlb,SAASo1B,MAC3Bnc,EACA3iB,EAAO+Q,UAAU,IAEnB8/C,EAEF,MAEF,SACExtD,EAAMrD,EAAO+U,SACX/U,EAAOuR,aAAaqT,EAAAlb,SAASq1B,MAC3Bpc,EACA3iB,EAAOiR,UAAU,IAEnB4/C,EAEF,MAEF,SACEzC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMwtD,EAGVzC,EAAS5tB,YAAc9b,EAAAyB,KAAKa,SAE5B,QAAQonC,EAAS5tB,YAAYjZ,MAE3B,QACEgnC,EAAaH,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAK3J,KAC/DnZ,EAAMrD,EAAO+U,SACX/U,EAAOmR,YAAYyT,EAAAle,QAAQi4B,OACzB3+B,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,IAE1CkuC,EACA7wD,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW2Y,KAErD,MAEF,QACA,OACEwxC,EAAaH,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAKG,KAC/DjjB,EAAMrD,EAAO+U,SACX/U,EAAOmR,YAAYyT,EAAAle,QAAQk4B,OACzB5+B,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,IAE1CkuC,EACA7wD,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAW6Y,KAErD,MAEF,QACA,OACEsxC,EAAaH,EAAS5wB,gBAAgBnD,oBAAoB+zB,EAASloC,QAAQU,WAC3EvjB,EAAMrD,EAAO+U,SACX/U,EAAOmR,YACLi9C,EAASloC,QAAQsb,SACb5c,EAAAle,QAAQk4B,OACRha,EAAAle,QAAQi4B,OACZ3+B,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,IAE1CkuC,EACA7wD,EAAO8R,eAAey8C,EAAWx8C,MAAOq8C,EAASloC,QAAQ4wB,gBAE3D,MAEF,SACEyX,EAAaH,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAKW,KAC/DzjB,EAAMrD,EAAO+U,SACX/U,EAAOuR,aAAaqT,EAAAlb,SAASo1B,MAC3B9+B,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAO+Q,UAAU,IAEnB8/C,EACA7wD,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAWgZ,KAErD,MAEF,SACEmxC,EAAaH,EAAS5wB,gBAAgBnD,oBAAoB3V,EAAAyB,KAAKY,KAC/D1jB,EAAMrD,EAAO+U,SACX/U,EAAOuR,aAAaqT,EAAAlb,SAASq1B,MAC3B/+B,EAAOkS,eAAeq8C,EAAWx8C,MAAO4Q,GACxC3iB,EAAOiR,UAAU,IAEnB4/C,EACA7wD,EAAO8R,eAAey8C,EAAWx8C,MAAO6S,EAAAxgB,WAAWkZ,KAErD,MAEF,SACE8wC,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAEbje,EAAMwtD,EAIZ,MAAOxtD,EAIT,KAAK,KAOH,MANIiuB,IACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc9b,EAAAyB,KAAKC,GACrBpmB,EAAOoW,qBAETg4C,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKC,GAAE,EAExD,KAAK,MAOH,MANIkL,IACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc9b,EAAAyB,KAAKE,IACrBrmB,EAAOoW,qBAETg4C,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKE,IAAG,EAEzD,KAAK,MAOH,MANIiL,IACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc9b,EAAAyB,KAAK3J,IACrBxc,EAAOoW,qBAETg4C,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAK3J,IAAG,EAEzD,KAAK,MAOH,MANI8U,IACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc9b,EAAAyB,KAAKG,IACrBtmB,EAAOoW,qBAETg4C,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKG,IAAG,EAEzD,KAAK,QAOH,MANIgL,IACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc4tB,EAASloC,QAAQsb,SACpC9c,EAAAyB,KAAK+Z,QACLxb,EAAAyB,KAAKga,QACFngC,EAAOoW,qBAETg4C,EAASrrB,kBACdnxB,EAAS,GACTw8C,EAASloC,QAAQsb,SACb9c,EAAAyB,KAAK+Z,QACLxb,EAAAyB,KAAKga,QAAO,EAIpB,KAAK,KAOH,MANI7O,IACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc9b,EAAAyB,KAAKK,GACrBxmB,EAAOoW,qBAETg4C,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKK,GAAE,EAExD,KAAK,MAOH,MANI8K,IACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc9b,EAAAyB,KAAKM,IACrBzmB,EAAOoW,qBAETg4C,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKM,IAAG,EAEzD,KAAK,MAOH,MANI6K,IACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc9b,EAAAyB,KAAKO,IACrB1mB,EAAOoW,qBAETg4C,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKO,IAAG,EAEzD,KAAK,MAOH,MANI4K,IACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc9b,EAAAyB,KAAKQ,IACrB3mB,EAAOoW,qBAETg4C,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKQ,IAAG,EAEzD,KAAK,QAOH,MANI2K,IACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc4tB,EAASloC,QAAQU,UACjC5mB,EAAOoW,qBAETg4C,EAASrrB,kBACdnxB,EAAS,GACTw8C,EAASloC,QAAQU,UAAS,EAI9B,KAAK,OAOH,MANI0K,IACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc9b,EAAAyB,KAAKU,KACrB7mB,EAAOoW,qBAETg4C,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKU,KAAI,EAE1D,KAAK,MAOH,MANIyK,IACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc9b,EAAAyB,KAAKW,IACrB9mB,EAAOoW,qBAETg4C,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKW,IAAG,EAEzD,KAAK,MAOH,MANIwK,IACF88B,EAAS9qC,MACPmB,EAAAjC,eAAekuC,sBACfp4B,EAAWhX,MAAOzf,EAAUmV,cAGT,GAAnBpF,EAASvP,QACX+rD,EAAS9qC,MACPmB,EAAAjC,eAAeqM,+BACfyJ,EAAWhX,MAAO,IAAK1P,EAASvP,OAAOqf,SAAS,KAElD0sC,EAAS5tB,YAAc9b,EAAAyB,KAAKY,IACrB/mB,EAAOoW,qBAETg4C,EAASrrB,kBAAkBnxB,EAAS,GAAI8S,EAAAyB,KAAKY,IAAG,GAM3D,MAJAqnC,GAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfqK,EAAWhX,OAENthB,EAAOoW,oBAGhB,QAAAq6C,GAAgCrC,EAAoB15C,GAClD,GAAIrD,GACAlN,CA6BJ,OA5BIiqD,GAASloC,QAAQsb,UACnBnwB,EAAO+8C,EAASpjB,qBAAqBt2B,EAAYgQ,EAAAyB,KAAK6Z,UAEpDpjB,yBAAyBvL,IAASuT,EAAA/f,aAAagY,OAC/CC,2BAA2BzL,IAASuT,EAAAxgB,WAAW6Y,KACR,GAAvCE,8BAA8B9L,KAC7BlN,EAAQ+Y,6BAA6B7L,IAAS,KAE/C+8C,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfvZ,EAAW4M,OAEbnd,GAAS,KAGXkN,EAAO+8C,EAASpjB,qBAAqBt2B,EAAYgQ,EAAAyB,KAAK8Z,UAEpDrjB,yBAAyBvL,IAASuT,EAAA/f,aAAagY,OAC/CC,2BAA2BzL,IAASuT,EAAAxgB,WAAW2Y,MAC9C5Y,EAAQ6Y,0BAA0B3L,IAAS,KAE5C+8C,EAAS9qC,MACPmB,EAAAjC,eAAeyL,wBACfvZ,EAAW4M,OAEbnd,GAAS,IAGNA,EAIT,QAAAyyC,GACEwX,EACA2C,EACAz4B,GAEA,GAAI5D,GAAUq8B,EAAIr8B,QACd7yB,EAAY6yB,EAAQ7O,SAASrkB,IAAI4sD,EAASloC,QAAQ4Z,aACtD,IAAIj+B,EACF,GAAIA,EAAU0lB,MAAQ8X,EAAA5U,YAAYiJ,mBAAoB,CACpD,GAAIzG,GAA+BprB,EAAWqrB,SAC9C,IAAID,EACF,IACGA,EAAS7B,GAAGiU,EAAApU,aAAaiM,UAC1BjK,EAASjX,YAAco4C,EAASloC,QAAQU,WACxCqG,EAAS8K,YACqB,GAA9B9K,EAAS8K,WAAW11B,QACpB4qB,EAAS8K,WAAW,GAAG/lB,MAAQo8C,EAASloC,QAAQU,WAEhD,GAAIwnC,EAASnqB,gBAAgBhX,GAC3B,MAAOmhC,GAAS7a,SAAStmB,GACvBmhC,EAASloC,QAAQsb,SACb4sB,EAASpuD,OAAO2Q,UAAUogD,EAAIp1B,qBAC9ByyB,EAASpuD,OAAOwQ,UAAUugD,EAAIp1B,2BAItCjH,GAAQpR,MACNmB,EAAAjC,eAAewuC,4CACf14B,EAAWhX,MAAO8sC,EAASloC,QAAQ4Z,aAAc,4BAKvDpL,GAAQpR,MACNmB,EAAAjC,eAAeuxB,uGACfzb,EAAWhX,MAAOzf,EAAUmV,kBAIhC0d,GAAQpR,MACNmB,EAAAjC,eAAesH,mBACfwO,EAAWhX,MAAO8sC,EAASloC,QAAQ4Z,aAGvC,OAAOsuB,GAASpuD,OAAOoW,oBAIzB,QAAA06C,GACE1C,EACAltC,EACAoX,GAEA,GAAIt4B,GAASouD,EAASpuD,OAClB6wD,EAAuB7wD,EAAOoW,oBAC9B66C,EAAiB7C,EAAS15B,QAAQ7O,SAASrkB,IAAI,SAC/C80C,EAAa8X,EAAS15B,QAAQ5O,MAAMtkB,IAAI,SAC5C,IACEyvD,GACAA,EAAe1pC,MAAQ8X,EAAA5U,YAAYiJ,oBACnC4iB,EACA,CACA,GAAI4a,GAAoCD,EAAgB/jC,SAEtDgkC,IACA9C,EAASnqB,gBAAgBitB,KAEzB7mC,OAAO6mC,EAAcn5B,YAAiD,GAAnCm5B,EAAcn5B,WAAW11B,QAC5DwuD,EAAQ7wD,EAAOiU,YAAY,MACzBm6C,EAAS7a,SAAS2d,GACL,MAAXhwC,EACIktC,EAASrrB,kBAAkB7hB,EAASo1B,GACpC8X,EAASloC,QAAQU,UAAUyc,aAAarjC,GAC5CouD,EAASpY,oBAAoB1d,EAAWhX,MAAMK,OAAOC,gBACrD5hB,EAAOwQ,UAAU8nB,EAAWhX,MAAMO,MAClC7hB,EAAOwQ,UAAU8nB,EAAWhX,MAAMQ,UAEpC+uC,KAIN,MAAOA,GjB8tSTzvD,OAAOC,eAAetB,EAAS,cAAgBoE,OAAO,GiB/kXtD,IAAAE,GAAA7D,EAAA,GAOAikB,EAAAjkB,EAAA,GASAkkB,EAAAlkB,EAAA,GAMAokB,EAAApkB,EAAA,GASA6+B,EAAA7+B,EAAA,EAUAT,GAAA80C,qBAmCA90C,EAAAk0C,cAotEAl0C,EAAA62C,kBAgDA72C,EAAA+wD,gBjBmvVM,SAAU9wD,EAAQD,EAASS,IkBnkajC,SAAAuwB,GAAA,KAAAogC,GAAApgC,EAAAogC,MAAA3wD,EAAA,GAEAuwB,GAAAiF,QAAA,SAAAH,EAAAC,GACA,MAAAq7B,GAAAC,SAAAv7B,EAAAC,IAGA/E,EAAAzX,QAAA,SAAAnV,GACA,MAAAA,GAAAktD,KAGAtgC,EAAAxX,SAAA,SAAApV,GACA,MAAAA,GAAAmtD,MAGAvgC,EAAA2U,QAAA,SAAAl0B,EAAAC,GACA,MAAAD,GAAA4e,IAAA3e,IAGAsf,EAAAqkB,QAAA,SAAA5jC,EAAAC,GACA,MAAAD,GAAA+/C,IAAA9/C,IAGAsf,EAAAi5B,QAAA,SAAAx4C,EAAAC,GACA,MAAAD,GAAAggD,IAAA//C,IAGAsf,EAAA0gC,QAAA,SAAAjgD,EAAAC,GACA,MAAAD,GAAAkgD,IAAAjgD,IAGAsf,EAAA4gC,UAAA,SAAAngD,EAAAC,GACA,MAAAD,GAAAogD,aAAAF,IAAAjgD,EAAAmgD,cAAAC,YAGA9gC,EAAA+gC,QAAA,SAAAtgD,EAAAC,GACA,MAAAD,GAAA65B,IAAA55B,IAGAsf,EAAAghC,UAAA,SAAAvgD,EAAAC,GACA,MAAAD,GAAAogD,aAAAvmB,IAAA55B,EAAAmgD,cAAAC,YAGA9gC,EAAAihC,QAAA,SAAAxgD,EAAAC,GACA,MAAAD,GAAAygD,IAAAxgD,IAGAsf,EAAAmhC,OAAA,SAAA1gD,EAAAC,GACA,MAAAD,GAAA2gD,GAAA1gD,IAGAsf,EAAAqhC,QAAA,SAAA5gD,EAAAC,GACA,MAAAD,GAAA6gD,IAAA5gD,IAGAsf,EAAAuhC,QAAA,SAAA9gD,EAAAC,GACA,MAAAD,GAAA+gD,IAAA9gD,IAGAsf,EAAAyhC,QAAA,SAAAhhD,EAAAC,GACA,MAAAD,GAAAihD,IAAAhhD,IAGAsf,EAAA2Q,UAAA,SAAAlwB,EAAAC,GACA,MAAAD,GAAAkhD,KAAAjhD,IAGAsf,EAAA4hC,QAAA,SAAAxuD,GACA,MAAAA,GAAAyuD,OAGA7hC,EAAAwQ,UAAA,SAAAp9B,EAAAshC,GACApb,OAAAob,GAAA,IAAAA,IAAA,GACA,IAAA2D,GAAA+nB,EAAA0B,QAAAptB,EAAA,EACA,OAAAthC,GAAAisB,IAAAgZ,GAAA6oB,IAAA7oB,EAAAwpB,QAGA7hC,EAAAskB,UAAA,SAAAlxC,GACA,WAAAA,EAAAmtD,MAAAntD,EAAAktD,KAAA,GAAAltD,EAAAktD,KAAAjrC,GAAA3J,YACA,IAAAtY,EAAAmtD,MAAAntD,EAAAktD,KAAAjrC,GAAA+lC,WAAAhoD,EAAAktD,IAAA,GAGAtgC,EAAAukB,WAAA,SAAAnxC,GACA,WAAAA,EAAAmtD,MAAAntD,EAAAktD,KAAA,GAAAltD,EAAAktD,KAAAhrC,IAAA5J,YACA,IAAAtY,EAAAmtD,MAAAntD,EAAAktD,KAAAhrC,IAAA8lC,WAAAhoD,EAAAktD,IAAA,GAGAtgC,EAAAwkB,WAAA,SAAApxC,GACA,WAAAA,EAAAmtD,MAAAntD,EAAAktD,KAAA,IACA,IAAAltD,EAAAmtD,MAAAntD,EAAAktD,IAAA,GAGAtgC,EAAAykB,UAAA,SAAArxC,GACA,WAAAA,EAAAmtD,MAAAntD,EAAAktD,KAAA,GAAAltD,EAAAktD,KAAA7qC,GAAA/J,WAGAsU,EAAA0kB,WAAA,SAAAtxC,GACA,WAAAA,EAAAmtD,MAAAntD,EAAAktD,KAAA,GAAAltD,EAAAktD,KAAA5qC,IAAAhK,WAGAsU,EAAA2kB,WAAA,SAAAvxC,GACA,WAAAA,EAAAmtD,MAGAvgC,EAAA4kB,YAAA,SAAAxxC,GACA,WAAAA,EAAAmtD,OAAA,IAAAntD,EAAAktD,KAAA,IAAAltD,EAAAktD,KAGA,MAAAyB,GAAA3B,EAAA4B,WAAAjsC,IAAAylC,kBACAyG,EAAA7B,EAAA4B,WAAAjsC,IAAA0lC,iBAEAz7B,GAAA6kB,WAAA,SAAAzxC,GACA,MAAAA,GAAA8uD,IAAAH,IAAA3uD,EAAA+uD,IAAAF,GAGA,MAAAG,GAAAhC,EAAA4B,WAAAhsC,IAAAwlC,kBACA6G,EAAAjC,EAAA4B,WAAAhsC,IAAAylC,iBAEAz7B,GAAA+kB,WAAA,SAAA3xC,GACA,MAAAA,GAAA8uD,IAAAE,IAAAhvD,EAAA+uD,IAAAE,IAGAriC,EAAA8kB,WAAA,SAAA1xC,GACA,MAAA4sB,GAAAs7B,KAAAC,OAAAnoD,EAAAkvD,aAGAtiC,EAAAglB,WAAA,SAAA5xC,GACA,MAAAA,GAAAkvD,YAGAtiC,EAAAuiC,cAAA,SAAAnvD,EAAAovD,GACA,OAAAA,EAAApvD,EAAAytD,aAAAztD,GAAAud,SAAA,OlBwka6B7gB,KAAKd,EAASS,EAAoB,KAIzD,SAAUR,EAAQD,GmBrraxB,QAAAoxD,GAAAE,EAAAC,EAAAiC,GAMAlzD,KAAAgxD,IAAA,EAAAA,EAMAhxD,KAAAixD,KAAA,EAAAA,EAMAjxD,KAAAkzD,aAoCA,QAAAC,GAAAC,GACA,YAAAA,KAAA,YA+BA,QAAAZ,GAAA1uD,EAAAovD,GACA,GAAAE,GAAAC,EAAAC,CACA,OAAAJ,IACApvD,KAAA,GACAwvD,EAAA,GAAAxvD,KAAA,OACAuvD,EAAAE,EAAAzvD,IAEAuvD,GAEAD,EAAArC,EAAAjtD,GAAA,EAAAA,GAAA,WACAwvD,IACAC,EAAAzvD,GAAAsvD,GACAA,KAEAtvD,GAAA,GACAwvD,GAAA,KAAAxvD,KAAA,OACAuvD,EAAAG,EAAA1vD,IAEAuvD,GAEAD,EAAArC,EAAAjtD,IAAA,WACAwvD,IACAE,EAAA1vD,GAAAsvD,GACAA,IAmBA,QAAAV,GAAA5uD,EAAAovD,GACA,GAAAO,MAAA3vD,GACA,MAAAovD,GAAAQ,EAAAC,CACA,IAAAT,EAAA,CACA,GAAApvD,EAAA,EACA,MAAA4vD,EACA,IAAA5vD,GAAA8vD,EACA,MAAAC,OACK,CACL,GAAA/vD,IAAAgwD,EACA,MAAAhI,EACA,IAAAhoD,EAAA,GAAAgwD,EACA,MAAA13C,GAEA,MAAAtY,GAAA,EACA4uD,GAAA5uD,EAAAovD,GAAAa,MACAhD,EAAAjtD,EAAAkwD,EAAA,EAAAlwD,EAAAkwD,EAAA,EAAAd,GAmBA,QAAAnC,GAAAkD,EAAAC,EAAAhB,GACA,UAAApC,GAAAmD,EAAAC,EAAAhB,GA8BA,QAAAiB,GAAA3xD,EAAA0wD,EAAAtG,GACA,OAAApqD,EAAAR,OACA,KAAA0Z,OAAA,eACA,YAAAlZ,GAAA,aAAAA,GAAA,cAAAA,GAAA,cAAAA,EACA,MAAAmxD,EASA,IARA,gBAAAT,IAEAtG,EAAAsG,EACAA,GAAA,GAEAA,OAEAtG,KAAA,IACA,MAAAA,EACA,KAAAwH,YAAA,QAEA,IAAA1yD,EACA,KAAAA,EAAAc,EAAA6xD,QAAA,QACA,KAAA34C,OAAA,kBACA,QAAAha,EACA,MAAAyyD,GAAA3xD,EAAAwf,UAAA,GAAAkxC,EAAAtG,GAAAmH,KAQA,QAHAO,GAAA5B,EAAA6B,EAAA3H,EAAA,IAEA/8C,EAAA8jD,EACArzD,EAAA,EAAmBA,EAAAkC,EAAAR,OAAgB1B,GAAA,GACnC,GAAAk+B,GAAAwtB,KAAAO,IAAA,EAAA/pD,EAAAR,OAAA1B,GACAwD,EAAA+oD,SAAArqD,EAAAwf,UAAA1hB,IAAAk+B,GAAAouB,EACA,IAAApuB,EAAA,GACA,GAAAg2B,GAAA9B,EAAA6B,EAAA3H,EAAApuB,GACA3uB,KAAAshD,IAAAqD,GAAAzkC,IAAA2iC,EAAA5uD,QAEA+L,KAAAshD,IAAAmD,GACAzkD,IAAAkgB,IAAA2iC,EAAA5uD,IAIA,MADA+L,GAAAqjD,WACArjD,EAoBA,QAAA4kD,GAAAnyD,EAAA4wD,GACA,sBAAA5wD,GACAowD,EAAApwD,EAAA4wD,GACA,gBAAA5wD,GACA6xD,EAAA7xD,EAAA4wD,GAEAnC,EAAAzuD,EAAA0uD,IAAA1uD,EAAA2uD,KAAA,iBAAAiC,KAAA5wD,EAAA4wD,UA7RAvzD,EAAAD,QAAAoxD,CAKA,IAAA4D,GAAA,IAEA,KACAA,EAAA,GAAAC,aAAAC,SAAA,GAAAD,aAAAxlD,OAAA,GAAAlM,aACA,u2BACSvD,QACR,MAAAwkB,IA0DD4sC,EAAAtvD,UAAAqzD,WAEA9zD,OAAAC,eAAA8vD,EAAAtvD,UAAA,cAAqDsC,OAAA,IAkBrDgtD,EAAAqC,QAOA,IAAAK,MAOAD,IA0CAzC,GAAA0B,UAkCA1B,EAAA4B,aAsBA5B,EAAAC,UASA,IAAAwD,GAAAvI,KAAA8I,GA4DAhE,GAAAqD,aAyBArD,EAAA2D,WAUA,IAcAT,GAAAe,WAOAnB,EAAAI,IAOAF,EAAAF,EAAA,EAOAoB,EAAAxC,EA5BA,OAkCAmB,EAAAnB,EAAA,EAMA1B,GAAA6C,MAMA,IAAAD,GAAAlB,EAAA,KAMA1B,GAAA4C,OAMA,IAAAuB,GAAAzC,EAAA,EAMA1B,GAAAmE,KAMA,IAAAC,GAAA1C,EAAA,KAMA1B,GAAAoE,MAMA,IAAAC,GAAA3C,GAAA,EAMA1B,GAAAqE,SAMA,IAAA/4C,GAAA20C,GAAA,gBAMAD,GAAA10C,WAMA,IAAAy3C,GAAA9C,GAAA,QAMAD,GAAA+C,oBAMA,IAAA/H,GAAAiF,EAAA,iBAMAD,GAAAhF,WAMA,IAAAsJ,GAAAtE,EAAAtvD,SAMA4zD,GAAAC,MAAA,WACA,MAAAr1D,MAAAkzD,SAAAlzD,KAAAgxD,MAAA,EAAAhxD,KAAAgxD,KAOAoE,EAAApC,SAAA,WACA,MAAAhzD,MAAAkzD,UACAlzD,KAAAixD,OAAA,GAAA+C,GAAAh0D,KAAAgxD,MAAA,GACAhxD,KAAAixD,KAAA+C,GAAAh0D,KAAAgxD,MAAA,IAUAoE,EAAA/zC,SAAA,SAAAurC,GAEA,IADAA,KAAA,IACA,MAAAA,EACA,KAAAwH,YAAA,QACA,IAAAp0D,KAAAs1D,SACA,SACA,IAAAt1D,KAAAu1D,aAAA,CACA,GAAAv1D,KAAAw1D,GAAA1J,GAAA,CAGA,GAAA2J,GAAA/C,EAAA9F,GACAyE,EAAArxD,KAAAqxD,IAAAoE,GACAC,EAAArE,EAAAF,IAAAsE,GAAAvE,IAAAlxD,KACA,OAAAqxD,GAAAhwC,SAAAurC,GAAA8I,EAAAL,QAAAh0C,SAAAurC,GAEA,UAAA5sD,KAAA+zD,MAAA1yC,SAAAurC,GAQA,IAHA,GAAA0H,GAAA5B,EAAA6B,EAAA3H,EAAA,GAAA5sD,KAAAkzD,UACAyC,EAAA31D,KACA6P,EAAA,KACA,CACA,GAAA+lD,GAAAD,EAAAtE,IAAAiD,GACAuB,EAAAF,EAAAzE,IAAA0E,EAAAzE,IAAAmD,IAAAe,UAAA,EACAS,EAAAD,EAAAx0C,SAAAurC,EAEA,IADA+I,EAAAC,EACAD,EAAAL,SACA,MAAAQ,GAAAjmD,CAEA,MAAAimD,EAAA9zD,OAAA,GACA8zD,EAAA,IAAAA,CACAjmD,GAAA,GAAAimD,EAAAjmD,IASAulD,EAAAW,YAAA,WACA,MAAA/1D,MAAAixD,MAOAmE,EAAAY,oBAAA,WACA,MAAAh2D,MAAAixD,OAAA,GAOAmE,EAAAa,WAAA,WACA,MAAAj2D,MAAAgxD,KAOAoE,EAAAc,mBAAA,WACA,MAAAl2D,MAAAgxD,MAAA,GAOAoE,EAAAe,cAAA,WACA,GAAAn2D,KAAAu1D,aACA,MAAAv1D,MAAAw1D,GAAA1J,GAAA,GAAA9rD,KAAA+zD,MAAAoC,eAEA,QADA7zD,GAAA,GAAAtC,KAAAixD,KAAAjxD,KAAAixD,KAAAjxD,KAAAgxD,IACAoF,EAAA,GAAsBA,EAAA,GACtB,IAAA9zD,EAAA,GAAA8zD,GAD+BA,KAG/B,UAAAp2D,KAAAixD,KAAAmF,EAAA,GAAAA,EAAA,GAOAhB,EAAAE,OAAA,WACA,WAAAt1D,KAAAixD,MAAA,IAAAjxD,KAAAgxD,KAOAoE,EAAAiB,IAAAjB,EAAAE,OAMAF,EAAAG,WAAA,WACA,OAAAv1D,KAAAkzD,UAAAlzD,KAAAixD,KAAA,GAOAmE,EAAAkB,WAAA,WACA,MAAAt2D,MAAAkzD,UAAAlzD,KAAAixD,MAAA,GAOAmE,EAAAmB,MAAA,WACA,aAAAv2D,KAAAgxD,MAOAoE,EAAAoB,OAAA,WACA,aAAAx2D,KAAAgxD,MAQAoE,EAAAqB,OAAA,SAAAC,GAGA,MAFAvD,GAAAuD,KACAA,EAAAjC,EAAAiC,KACA12D,KAAAkzD,WAAAwD,EAAAxD,UAAAlzD,KAAAixD,OAAA,OAAAyF,EAAAzF,OAAA,SAEAjxD,KAAAixD,OAAAyF,EAAAzF,MAAAjxD,KAAAgxD,MAAA0F,EAAA1F,MASAoE,EAAAI,GAAAJ,EAAAqB,OAOArB,EAAAuB,UAAA,SAAAD,GACA,OAAA12D,KAAAw1D,GAAAkB,IASAtB,EAAAwB,IAAAxB,EAAAuB,UAQAvB,EAAAyB,GAAAzB,EAAAuB,UAOAvB,EAAA0B,SAAA,SAAAJ,GACA,MAAA12D,MAAA+2D,KAAAL,GAAA,GASAtB,EAAA4B,GAAA5B,EAAA0B,SAOA1B,EAAA6B,gBAAA,SAAAP,GACA,MAAA12D,MAAA+2D,KAAAL,IAAA,GASAtB,EAAAvC,IAAAuC,EAAA6B,gBAQA7B,EAAA8B,GAAA9B,EAAA6B,gBAOA7B,EAAA+B,YAAA,SAAAT,GACA,MAAA12D,MAAA+2D,KAAAL,GAAA,GASAtB,EAAAgC,GAAAhC,EAAA+B,YAOA/B,EAAAiC,mBAAA,SAAAX,GACA,MAAA12D,MAAA+2D,KAAAL,IAAA,GASAtB,EAAAxC,IAAAwC,EAAAiC,mBAQAjC,EAAAkC,GAAAlC,EAAAiC,mBAQAjC,EAAAmC,QAAA,SAAAb,GAGA,GAFAvD,EAAAuD,KACAA,EAAAjC,EAAAiC,IACA12D,KAAAw1D,GAAAkB,GACA,QACA,IAAAc,GAAAx3D,KAAAu1D,aACAkC,EAAAf,EAAAnB,YACA,OAAAiC,KAAAC,GACA,GACAD,GAAAC,EACA,EAEAz3D,KAAAkzD,SAGAwD,EAAAzF,OAAA,EAAAjxD,KAAAixD,OAAA,GAAAyF,EAAAzF,OAAAjxD,KAAAixD,MAAAyF,EAAA1F,MAAA,EAAAhxD,KAAAgxD,MAAA,OAFAhxD,KAAAkxD,IAAAwF,GAAAnB,cAAA,KAYAH,EAAA2B,KAAA3B,EAAAmC,QAMAnC,EAAAsC,OAAA,WACA,OAAA13D,KAAAkzD,UAAAlzD,KAAAw1D,GAAA1J,GACAA,EACA9rD,KAAAuyD,MAAAxiC,IAAAklC,IAQAG,EAAArB,IAAAqB,EAAAsC,OAOAtC,EAAArlC,IAAA,SAAA4nC,GACAxE,EAAAwE,KACAA,EAAAlD,EAAAkD,GAIA,IAAAC,GAAA53D,KAAAixD,OAAA,GACA4G,EAAA,MAAA73D,KAAAixD,KACA6G,EAAA93D,KAAAgxD,MAAA,GACA+G,EAAA,MAAA/3D,KAAAgxD,IAEAgH,EAAAL,EAAA1G,OAAA,GACAgH,EAAA,MAAAN,EAAA1G,KACAiH,EAAAP,EAAA3G,MAAA,GACAmH,EAAA,MAAAR,EAAA3G,IAEAoH,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAAAC,EAAA,CAYA,OAXAA,IAAAR,EAAAI,EACAG,GAAAC,IAAA,GACAA,GAAA,MACAD,GAAAR,EAAAI,EACAG,GAAAC,IAAA,GACAA,GAAA,MACAD,GAAAR,EAAAI,EACAG,GAAAC,IAAA,GACAA,GAAA,MACAD,GAAAR,EAAAI,EACAI,GAAA,MACArH,EAAAuH,GAAA,GAAAC,EAAAH,GAAA,GAAAC,EAAAr4D,KAAAkzD,WAQAkC,EAAAoD,SAAA,SAAAC,GAGA,MAFAtF,GAAAsF,KACAA,EAAAhE,EAAAgE,IACAz4D,KAAA+vB,IAAA0oC,EAAA1E,QASAqB,EAAAlE,IAAAkE,EAAAoD,SAOApD,EAAAsD,SAAA,SAAAC,GACA,GAAA34D,KAAAs1D,SACA,MAAA3B,EAKA,IAJAR,EAAAwF,KACAA,EAAAlE,EAAAkE,IAGAjE,EAAA,CAKA,MAAA3D,GAJA2D,EAAAvD,IAAAnxD,KAAAgxD,IACAhxD,KAAAixD,KACA0H,EAAA3H,IACA2H,EAAA1H,MACAyD,EAAAkE,WAAA54D,KAAAkzD,UAGA,GAAAyF,EAAArD,SACA,MAAA3B,EACA,IAAA3zD,KAAAw1D,GAAA1J,GACA,MAAA6M,GAAApC,QAAAzK,EAAA6H,CACA,IAAAgF,EAAAnD,GAAA1J,GACA,MAAA9rD,MAAAu2D,QAAAzK,EAAA6H,CAEA,IAAA3zD,KAAAu1D,aACA,MAAAoD,GAAApD,aACAv1D,KAAA+zD,MAAA5C,IAAAwH,EAAA5E,OAEA/zD,KAAA+zD,MAAA5C,IAAAwH,GAAA5E,KACK,IAAA4E,EAAApD,aACL,MAAAv1D,MAAAmxD,IAAAwH,EAAA5E,YAGA,IAAA/zD,KAAAg3D,GAAAhC,IAAA2D,EAAA3B,GAAAhC,GACA,MAAAtC,GAAA1yD,KAAAgzD,WAAA2F,EAAA3F,WAAAhzD,KAAAkzD,SAKA,IAAA0E,GAAA53D,KAAAixD,OAAA,GACA4G,EAAA,MAAA73D,KAAAixD,KACA6G,EAAA93D,KAAAgxD,MAAA,GACA+G,EAAA,MAAA/3D,KAAAgxD,IAEAgH,EAAAW,EAAA1H,OAAA,GACAgH,EAAA,MAAAU,EAAA1H,KACAiH,EAAAS,EAAA3H,MAAA,GACAmH,EAAA,MAAAQ,EAAA3H,IAEAoH,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAAAC,EAAA,CAqBA,OApBAA,IAAAR,EAAAI,EACAG,GAAAC,IAAA,GACAA,GAAA,MACAD,GAAAR,EAAAK,EACAE,GAAAC,IAAA,GACAA,GAAA,MACAA,GAAAP,EAAAG,EACAG,GAAAC,IAAA,GACAA,GAAA,MACAD,GAAAR,EAAAM,EACAC,GAAAC,IAAA,GACAA,GAAA,MACAA,GAAAP,EAAAI,EACAE,GAAAC,IAAA,GACAA,GAAA,MACAA,GAAAN,EAAAE,EACAG,GAAAC,IAAA,GACAA,GAAA,MACAD,GAAAR,EAAAO,EAAAN,EAAAK,EAAAJ,EAAAG,EAAAF,EAAAC,EACAI,GAAA,MACArH,EAAAuH,GAAA,GAAAC,EAAAH,GAAA,GAAAC,EAAAr4D,KAAAkzD,WASAkC,EAAAjE,IAAAiE,EAAAsD,SAQAtD,EAAAyD,OAAA,SAAAC,GAGA,GAFA3F,EAAA2F,KACAA,EAAArE,EAAAqE,IACAA,EAAAxD,SACA,KAAA55C,OAAA,mBAGA,IAAAg5C,EAAA,CAIA,IAAA10D,KAAAkzD,WACA,aAAAlzD,KAAAixD,OACA,IAAA6H,EAAA9H,MAAA,IAAA8H,EAAA7H,KAEA,MAAAjxD,KAQA,OAAA+wD,IANA/wD,KAAAkzD,SAAAwB,EAAAqE,MAAArE,EAAAsE,OACAh5D,KAAAgxD,IACAhxD,KAAAixD,KACA6H,EAAA9H,IACA8H,EAAA7H,MAEAyD,EAAAkE,WAAA54D,KAAAkzD,UAGA,GAAAlzD,KAAAs1D,SACA,MAAAt1D,MAAAkzD,SAAAQ,EAAAC,CACA,IAAAsF,GAAAtD,EAAAuD,CACA,IAAAl5D,KAAAkzD,SA6BK,CAKL,GAFA4F,EAAA5F,WACA4F,IAAAvH,cACAuH,EAAA1B,GAAAp3D,MACA,MAAA0zD,EACA,IAAAoF,EAAA1B,GAAAp3D,KAAAqyD,KAAA,IACA,MAAA6C,EACAgE,GAAAxF,MAtCA,CAGA,GAAA1zD,KAAAw1D,GAAA1J,GAAA,CACA,GAAAgN,EAAAtD,GAAAP,IAAA6D,EAAAtD,GAAAL,GACA,MAAArJ,EACA,IAAAgN,EAAAtD,GAAA1J,GACA,MAAAmJ,EAKA,OADAgE,GADAj5D,KAAAoyD,IAAA,GACAf,IAAAyH,GAAA5G,IAAA,GACA+G,EAAAzD,GAAA7B,GACAmF,EAAAvD,aAAAN,EAAAE,GAEAQ,EAAA31D,KAAAkxD,IAAA4H,EAAA3H,IAAA8H,IACAC,EAAAD,EAAAlpC,IAAA4lC,EAAAtE,IAAAyH,KAIS,GAAAA,EAAAtD,GAAA1J,GACT,MAAA9rD,MAAAkzD,SAAAQ,EAAAC,CACA,IAAA3zD,KAAAu1D,aACA,MAAAuD,GAAAvD,aACAv1D,KAAA+zD,MAAA1C,IAAAyH,EAAA/E,OACA/zD,KAAA+zD,MAAA1C,IAAAyH,GAAA/E,KACS,IAAA+E,EAAAvD,aACT,MAAAv1D,MAAAqxD,IAAAyH,EAAA/E,YACAmF,GAAAvF,EAmBA,IADAgC,EAAA31D,KACA21D,EAAA/C,IAAAkG,IAAA,CAGAG,EAAAjN,KAAAxrB,IAAA,EAAAwrB,KAAAQ,MAAAmJ,EAAA3C,WAAA8F,EAAA9F,YAWA,KAPA,GAAAmG,GAAAnN,KAAAlU,KAAAkU,KAAAoN,IAAAH,GAAAjN,KAAAqN,KACAC,EAAAH,GAAA,KAAA5E,EAAA,EAAA4E,EAAA,IAIAI,EAAA7G,EAAAuG,GACAO,EAAAD,EAAApI,IAAA2H,GACAU,EAAAjE,cAAAiE,EAAApC,GAAAzB,IACAsD,GAAAK,EACAC,EAAA7G,EAAAuG,EAAAj5D,KAAAkzD,UACAsG,EAAAD,EAAApI,IAAA2H,EAKAS,GAAAjE,WACAiE,EAAAtE,GAEAiE,IAAAnpC,IAAAwpC,GACA5D,IAAAzE,IAAAsI,GAEA,MAAAN,IASA9D,EAAA/D,IAAA+D,EAAAyD,OAOAzD,EAAAqE,OAAA,SAAAX,GAKA,GAJA3F,EAAA2F,KACAA,EAAArE,EAAAqE,IAGApE,EAAA,CAOA,MAAA3D,IANA/wD,KAAAkzD,SAAAwB,EAAAgF,MAAAhF,EAAAiF,OACA35D,KAAAgxD,IACAhxD,KAAAixD,KACA6H,EAAA9H,IACA8H,EAAA7H,MAEAyD,EAAAkE,WAAA54D,KAAAkzD,UAGA,MAAAlzD,MAAAkxD,IAAAlxD,KAAAqxD,IAAAyH,GAAA3H,IAAA2H,KASA1D,EAAApqB,IAAAoqB,EAAAqE,OAQArE,EAAAO,IAAAP,EAAAqE,OAMArE,EAAA7C,IAAA,WACA,MAAAxB,IAAA/wD,KAAAgxD,KAAAhxD,KAAAixD,KAAAjxD,KAAAkzD,WAQAkC,EAAAxD,IAAA,SAAA8E,GAGA,MAFAvD,GAAAuD,KACAA,EAAAjC,EAAAiC,IACA3F,EAAA/wD,KAAAgxD,IAAA0F,EAAA1F,IAAAhxD,KAAAixD,KAAAyF,EAAAzF,KAAAjxD,KAAAkzD,WAQAkC,EAAAtD,GAAA,SAAA4E,GAGA,MAFAvD,GAAAuD,KACAA,EAAAjC,EAAAiC,IACA3F,EAAA/wD,KAAAgxD,IAAA0F,EAAA1F,IAAAhxD,KAAAixD,KAAAyF,EAAAzF,KAAAjxD,KAAAkzD,WAQAkC,EAAApD,IAAA,SAAA0E,GAGA,MAFAvD,GAAAuD,KACAA,EAAAjC,EAAAiC,IACA3F,EAAA/wD,KAAAgxD,IAAA0F,EAAA1F,IAAAhxD,KAAAixD,KAAAyF,EAAAzF,KAAAjxD,KAAAkzD,WAQAkC,EAAAwE,UAAA,SAAAC,GAGA,MAFA1G,GAAA0G,KACAA,IAAAxE,SACA,IAAAwE,GAAA,IACA75D,KACA65D,EAAA,GACA9I,EAAA/wD,KAAAgxD,KAAA6I,EAAA75D,KAAAixD,MAAA4I,EAAA75D,KAAAgxD,MAAA,GAAA6I,EAAA75D,KAAAkzD,UAEAnC,EAAA,EAAA/wD,KAAAgxD,KAAA6I,EAAA,GAAA75D,KAAAkzD,WASAkC,EAAAlD,IAAAkD,EAAAwE,UAOAxE,EAAA0E,WAAA,SAAAD,GAGA,MAFA1G,GAAA0G,KACAA,IAAAxE,SACA,IAAAwE,GAAA,IACA75D,KACA65D,EAAA,GACA9I,EAAA/wD,KAAAgxD,MAAA6I,EAAA75D,KAAAixD,MAAA,GAAA4I,EAAA75D,KAAAixD,MAAA4I,EAAA75D,KAAAkzD,UAEAnC,EAAA/wD,KAAAixD,MAAA4I,EAAA,GAAA75D,KAAAixD,MAAA,OAAAjxD,KAAAkzD,WASAkC,EAAAhD,IAAAgD,EAAA0E,WAOA1E,EAAA2E,mBAAA,SAAAF,GAIA,GAHA1G,EAAA0G,KACAA,IAAAxE,SAEA,KADAwE,GAAA,IAEA,MAAA75D,KAEA,IAAAixD,GAAAjxD,KAAAixD,IACA,IAAA4I,EAAA,IAEA,MAAA9I,GADA/wD,KAAAgxD,MACA6I,EAAA5I,GAAA,GAAA4I,EAAA5I,IAAA4I,EAAA75D,KAAAkzD,UACS,YAAA2G,EACT9I,EAAAE,EAAA,EAAAjxD,KAAAkzD,UAEAnC,EAAAE,IAAA4I,EAAA,KAAA75D,KAAAkzD,WAUAkC,EAAA/C,KAAA+C,EAAA2E,mBAQA3E,EAAA4E,MAAA5E,EAAA2E,mBAMA3E,EAAA5D,SAAA,WACA,MAAAxxD,MAAAkzD,SAEAnC,EAAA/wD,KAAAgxD,IAAAhxD,KAAAixD,MAAA,GADAjxD,MAQAo1D,EAAA7D,WAAA,WACA,MAAAvxD,MAAAkzD,SACAlzD,KACA+wD,EAAA/wD,KAAAgxD,IAAAhxD,KAAAixD,MAAA,IAQAmE,EAAA6E,QAAA,SAAA/C,GACA,MAAAA,GAAAl3D,KAAAk6D,YAAAl6D,KAAAm6D,aAOA/E,EAAA8E,UAAA,WACA,GAAAzkC,GAAAz1B,KAAAixD,KACAz7B,EAAAx1B,KAAAgxD,GACA,QACA,IAAAx7B,EACAA,IAAA,MACAA,IAAA,OACAA,IAAA,GACA,IAAAC,EACAA,IAAA,MACAA,IAAA,OACAA,IAAA,KAQA2/B,EAAA+E,UAAA,WACA,GAAA1kC,GAAAz1B,KAAAixD,KACAz7B,EAAAx1B,KAAAgxD,GACA,QACAv7B,IAAA,GACAA,IAAA,OACAA,IAAA,MACA,IAAAA,EACAD,IAAA,GACAA,IAAA,OACAA,IAAA,MACA,IAAAA,IAWAs7B,EAAAsJ,UAAA,SAAAloD,EAAAghD,EAAAgE,GACA,MAAAA,GAAApG,EAAAuJ,YAAAnoD,EAAAghD,GAAApC,EAAAwJ,YAAApoD,EAAAghD,IASApC,EAAAuJ,YAAA,SAAAnoD,EAAAghD,GACA,UAAApC,GACA5+C,EAAA,GACAA,EAAA,MACAA,EAAA,OACAA,EAAA,OACAA,EAAA,GACAA,EAAA,MACAA,EAAA,OACAA,EAAA,OACAghD,IAUApC,EAAAwJ,YAAA,SAAApoD,EAAAghD,GACA,UAAApC,GACA5+C,EAAA,OACAA,EAAA,OACAA,EAAA,MACAA,EAAA,GACAA,EAAA,OACAA,EAAA,OACAA,EAAA,MACAA,EAAA,GACAghD,KnButaM,SAAUvzD,EAAQD,EAASS,GAEjC,YoBt+cA,SAAAo6D,GAA0B54C,EAAcqH,EAAc8X,EACpD05B,GAOA,WARoD,KAAA15B,OAAA,OACpD,KAAA05B,MAAA,MAEKA,IACHA,EAAS,GAAIC,GAAAC,OACb55B,GAAU,GAEZ05B,EAAOD,UAAU54C,EAAMqH,EAAM8X,GACtB05B,EAIT,QAAAG,GAAyBH,GACvB,MAAOA,GAAOG,WAIhB,QAAAC,GAA+BJ,GAC7B,GAAInmC,GAAUmmC,EAAOnmC,OACrB,OAAOA,GAAQ9O,kBAAoB8O,EAAQtR,YAAY/gB,OACnDqyB,EAAQtR,YAAYsR,EAAQ9O,qBAC5B,KAON,QAAAs1C,GAAuBh6C,GACrB,MAAOA,GAAQV,UAAYiE,EAAAhE,mBAAmBC,KAIhD,QAAAy6C,GAA0Bj6C,GACxB,MAAOA,GAAQV,UAAYiE,EAAAhE,mBAAmBE,QAIhD,QAAAy6C,GAAwBl6C,GACtB,MAAOA,GAAQV,UAAYiE,EAAAhE,mBAAmBG,MAIhD,QAAAy6C,KACE,MAAO,IAAIh3D,GAAAk7B,QAIb,QAAA+7B,GAA0Bp1C,EAAkBnQ,GAC1CmQ,EAAQnQ,OAASA,EAInB,QAAAwlD,GAAiCr1C,EAAkBuZ,GACjDvZ,EAAQuZ,cAAgBA,EAI1B,QAAA+7B,GAA4Bt1C,EAAkBwZ,GAC5CxZ,EAAQwZ,SAAWA,EAIrB,QAAA+7B,GAA4Bv1C,EAAkByZ,GAC5CzZ,EAAQyZ,SAAWA,EAIrB,QAAA+7B,GAAgCx1C,EAAkB0Z,GAChD1Z,EAAQ0Z,aAAeA,EAIzB,QAAA+7B,GAA6Bz1C,EAAkBrK,GAC7CqK,EAAQrK,UAAYA,EAItB,QAAA+/C,GAA8B11C,EAAkB2Z,GAC9C3Z,EAAQ2Z,WAAaA,EAIvB,QAAAiB,GAAwB+5B,EAAgB30C,OAAA,KAAAA,MAAA,KACtC,IAAIwO,GAAUmmC,EAAO7P,QAErB,OADe,IAAI3mD,GAAAg8B,SAAS3L,EAASxO,GACrB4a,UAIlB,QAAA+6B,GAA0B77D,GACxB,GAAI87D,GAAa,GAAIC,GAAAC,UAErB,OADAF,GAAWD,UAAU77D,GACd87D,EAAW9Q,SpB44cpB5pD,OAAOC,eAAetB,EAAS,cAAgBoE,OAAO,GoBlgdtD,IAAAE,GAAA7D,EAAA,GAMAu7D,EAAAv7D,EAAA,IAIAikB,EAAAjkB,EAAA,EAwCoCT,GAAAk8D,iBArClCx3C,EAAAxD,uBAOF,IAAA65C,GAAAt6D,EAAA,GAKAT,GAAA66D,YAYA76D,EAAAi7D,WAKAj7D,EAAAk7D,iBAWAl7D,EAAAm7D,SAKAn7D,EAAAo7D,YAKAp7D,EAAAq7D,UAKAr7D,EAAAs7D,gBAKAt7D,EAAAu7D,YAKAv7D,EAAAw7D,mBAKAx7D,EAAAy7D,cAKAz7D,EAAA07D,cAKA17D,EAAA27D,kBAKA37D,EAAA47D,eAKA57D,EAAA67D,gBAKA77D,EAAA+gC,UAOA/gC,EAAA87D,WAOA,IAAAx8B,GAAA7+B,EAAA,EAAST,GAAAqlB,eAAAia,EAAAja,gBpBo/cH,SAAUplB,EAAQD,EAASS,GAEjC,YqBhzbA,SAAA07D,GAA0BlqD,GACxB,OAAQA,GACN,IAAK4S,GAAAxgB,WAAWgQ,KAAM,MAAO,MAC7B,KAAKwQ,GAAAxgB,WAAW2Y,IAAK,MAAO,KAC5B,KAAK6H,GAAAxgB,WAAW6Y,IAAK,MAAO,KAC5B,KAAK2H,GAAAxgB,WAAWgZ,IAAK,MAAO,KAC5B,KAAKwH,GAAAxgB,WAAWkZ,IAAK,MAAO,KAC5B,KAAKsH,GAAAxgB,WAAW+3D,YAAa,KAAM,IAAIpgD,OAAM,mBAC7C,KAAK6I,GAAAxgB,WAAWg4D,KAAM,KAAM,IAAIrgD,OAAM,YACtC,SAAS,KAAM,IAAIA,OAAM,oBrByyb7B3a,OAAOC,eAAetB,EAAS,cAAgBoE,OAAO,GqBpndtD,IAAAygB,GAAApkB,EAAA,GAeAw7D,EAAA,WAWE,QAAAA,KAHA37D,KAAA2hB,QACA3hB,KAAAg8D,WAAkB,EAwyBpB,MA/yBSL,GAAAH,UAAP,SAAiB77D,GACf,GAAI87D,GAAa,GAAIE,EAErB,OADAF,GAAWD,UAAU77D,GACd87D,EAAW9Q,UASpBgR,EAAAn6D,UAAAg6D,UAAA,SAAU77D,GACR,KAAM,IAAI+b,OAAM,oBAGlBigD,EAAAn6D,UAAAy6D,kBAAA,SAAkBtiD,GAChB,GAAI/Y,GAAO2jB,EAAArhB,WAAWg5D,yBAAyBviD,KAAU,IAAM3Z,KAAKg8D,WAAW36C,SAAS,IACpF7M,EAAOq2B,yBAAyBlxB,EACpC3Z,MAAK2D,KAAK,aACV3D,KAAK2D,KAAK/C,GACVZ,KAAK2D,KAAK,IACT,KAAK,GAAIrD,GAAW,EAAG4B,EAAWi6D,8BAA8BxiD,GAAOrZ,EAAI4B,IAAK5B,EAC3EA,EAAI,GAAGN,KAAK2D,KAAK,MACrB3D,KAAK2D,KAAK,KACV3D,KAAK2D,KAAKrD,EAAE+gB,SAAS,KACrBrhB,KAAK2D,KAAK,MACV3D,KAAK2D,KAAKk4D,EAAiBO,0BAA0BziD,EAAMrZ,IAE7DN,MAAK2D,KAAK,OACV3D,KAAK2D,KAAKk4D,EAAiBQ,2BAA2B1iD,KACtD3Z,KAAK2D,KAAK,KACN4Y,yBAAyB/H,IAAS+P,EAAA/f,aAAa83D,OACjDt8D,KAAK2D,KAAK,OAEZ3D,KAAKu8D,oBAAoB/nD,GACrB+H,yBAAyB/H,IAAS+P,EAAA/f,aAAa83D,OACjDt8D,KAAK2D,KAAK,WAEV3D,KAAKg8D,YAGTL,EAAAn6D,UAAA+6D,oBAAA,SAAoBvrD,GAClB,GAGIwrD,GACAC,EACAn8D,EAAU4B,EALVg4B,EAAK3d,yBAAyBvL,GAC9BW,EAAO8K,2BAA2BzL,EAMtC,QAAQkpB,GAEN,IAAK3V,GAAA/f,aAAa83D,MAOhB,IAN0D,OAArDG,EAASl4C,EAAArhB,WAAWw5D,sBAAsB1rD,OAC7ChR,KAAK2D,KAAK84D,GACVz8D,KAAK2D,KAAK,OAEZ3D,KAAK2D,KAAK,OACVzB,EAAIy6D,6BAA6B3rD,GAC5B1Q,EAAI,EAAGA,EAAI4B,IAAK5B,EACnBN,KAAKu8D,oBAAoBK,uBAAuB5rD,EAAM1Q,GAGxD,YADAN,MAAK2D,KAAK,MAGZ,KAAK4gB,GAAA/f,aAAaq4D,GAiBhB,YAhBIlrD,GAAQ4S,EAAAxgB,WAAWgQ,MACrB/T,KAAK2D,KAAK,QACV3D,KAAKu8D,oBAAoBO,wBAAwB9rD,IACjDhR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoBQ,qBAAqB/rD,KAC1CwrD,EAASQ,sBAAsBhsD,MACjChR,KAAK2D,KAAK,UACV3D,KAAKu8D,oBAAoBC,MAG3Bx8D,KAAKu8D,oBAAoBO,wBAAwB9rD,IACjDhR,KAAK2D,KAAK,OACV3D,KAAKu8D,oBAAoBQ,qBAAqB/rD,IAC9ChR,KAAK2D,KAAK,OACV3D,KAAKu8D,oBAAoBS,sBAAsBhsD,KAInD,KAAKuT,GAAA/f,aAAay4D,KACyC,OAApDR,EAASl4C,EAAArhB,WAAWg6D,qBAAqBlsD,OAC5ChR,KAAK2D,KAAK84D,GACVz8D,KAAK2D,KAAK,OAEZ3D,KAAK2D,KAAK,OACV3D,KAAKu8D,oBAAoBY,qBAAqBnsD,IAC9ChR,KAAK2D,KAAK,eAEZ,KAAK4gB,GAAA/f,aAAa44D,MAahB,OAZIZ,EAASa,2BAA2BrsD,MACtChR,KAAK2D,KAAK,QACV3D,KAAKu8D,oBAAoBC,GACzBx8D,KAAK2D,KAAK,YAE8C,OAArD84D,EAASl4C,EAAArhB,WAAWo6D,sBAAsBtsD,MAC7ChR,KAAK2D,KAAK,UACV3D,KAAK2D,KAAK84D,GACVz8D,KAAK2D,KAAK,QAEV3D,KAAK2D,KAAK,YAId,KAAK4gB,GAAA/f,aAAa+4D,OAElB,IAAKh5C,GAAA/f,aAAag5D,KAElB,IAAKj5C,GAAA/f,aAAai5D,WAElB,IAAKl5C,GAAA/f,aAAak5D,aAElB,IAAKn5C,GAAA/f,aAAa2Y,SAGhB,MAFAnd,MAAK2D,KAAK,SACV3D,MAAK2D,KAAKyZ,0BAA0BpM,GAAMqQ,SAAS,IAGrD,KAAKkD,GAAA/f,aAAam5D,SAKhB,MAJA39D,MAAK2D,KAAK,KACV3D,KAAK2D,KAAKi6D,0BAA0B5sD,GAAMqQ,SAAS,KACnDrhB,KAAK2D,KAAK,WACV3D,MAAKu8D,oBAAoBsB,0BAA0B7sD,GAGrD,KAAKuT,GAAA/f,aAAa6Y,UAElB,IAAKkH,GAAA/f,aAAas5D,UAElB,IAAKv5C,GAAA/f,aAAagZ,KAQhB,MAPAxd,MAAK2D,KAAK,SACV3D,KAAK2D,KAAKk4D,EAAiBlqD,IAC3B3R,KAAK2D,KAAK,MACV3D,KAAK2D,KAAKia,uBAAuB5M,GAAMqQ,SAAS,KAChDrhB,KAAK2D,KAAK,OACV3D,KAAKu8D,oBAAoB9+C,oBAAoBzM,QAC7ChR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAA/f,aAAau5D,MAUhB,MATA/9D,MAAK2D,KAAK,UACV3D,KAAK2D,KAAKk4D,EAAiBlqD,IAC3B3R,KAAK2D,KAAK,MACV3D,KAAK2D,KAAKq6D,wBAAwBhtD,GAAMqQ,SAAS,KACjDrhB,KAAK2D,KAAK,OACV3D,KAAKu8D,oBAAoB0B,qBAAqBjtD,IAC9ChR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoB2B,uBAAuBltD,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAA/f,aAAagY,MAChB,OAAQ7K,GAEN,IAAK4S,GAAAxgB,WAAW2Y,IAEd,WADA1c,MAAK2D,KAAKgZ,0BAA0B3L,GAAMqQ,SAAS,IAGrD,KAAKkD,GAAAxgB,WAAW6Y,IASd,WARA5c,MAAK2D,KACHsvD,cACEt9B,QACE9Y,6BAA6B7L,GAC7B8L,8BAA8B9L,KAMtC,KAAKuT,GAAAxgB,WAAWgZ,IAEd,WADA/c,MAAK2D,KAAKqZ,0BAA0BhM,GAAMqQ,SAAS,IAGrD,KAAKkD,GAAAxgB,WAAWkZ,IAEd,WADAjd,MAAK2D,KAAKuZ,0BAA0BlM,GAAMqQ,SAAS,KAGvD,KAEF,KAAKkD,GAAA/f,aAAauZ,MAChB,OAAQE,oBAAoBjN,IAE1B,IAAKuT,GAAAle,QAAQioD,OAIX,MAHAtuD,MAAK2D,KAAK,aACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQmoD,OAIX,MAHAxuD,MAAK2D,KAAK,aACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQqoD,UAIX,MAHA1uD,MAAK2D,KAAK,gBACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQgxC,OACb,IAAK9yB,GAAAle,QAAQixC,OAGX,MAFAt3C,MAAK2D,KAAK,SACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQ+nD,OAIX,MAHApuD,MAAK2D,KAAK,aACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQ+oD,QAIX,MAHApvD,MAAK2D,KAAK,cACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQipD,SAIX,MAHAtvD,MAAK2D,KAAK,eACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQ6pD,SAIX,MAHAlwD,MAAK2D,KAAK,eACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQqpD,WAIX,MAHA1vD,MAAK2D,KAAK,iBACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQ2pD,QAIX,MAHAhwD,MAAK2D,KAAK,cACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQi4B,OACb,IAAK/Z,GAAAle,QAAQk4B,OAGX,MAFAv+B,MAAK2D,KAAK,SACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQkoD,OAIX,MAHAvuD,MAAK2D,KAAK,aACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQooD,OAIX,MAHAzuD,MAAK2D,KAAK,aACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQsoD,UAIX,MAHA3uD,MAAK2D,KAAK,gBACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQgoD,OAIX,MAHAruD,MAAK2D,KAAK,aACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQgpD,QAIX,MAHArvD,MAAK2D,KAAK,cACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQkpD,SAIX,MAHAvvD,MAAK2D,KAAK,eACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQ8pD,SAIX,MAHAnwD,MAAK2D,KAAK,eACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQspD,WAIX,MAHA3vD,MAAK2D,KAAK,iBACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQ4pD,QAIX,MAHAjwD,MAAK2D,KAAK,cACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQ+lC,UAGX,MAFApsC,MAAK2D,KAAK,aACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQgmC,UAGX,MAFArsC,MAAK2D,KAAK,kBACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQ8lC,QAKb,IAAK5nB,GAAAle,QAAQ+kC,cAGX,MAFAprC,MAAK2D,KAAK,aACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQ8kC,cAGX,MAFAnrC,MAAK2D,KAAK,aACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQilC,cAGX,MAFAtrC,MAAK2D,KAAK,kBACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQglC,cAGX,MAFArrC,MAAK2D,KAAK,kBACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQmlC,cAGX,MAFAxrC,MAAK2D,KAAK,aACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQklC,cAGX,MAFAvrC,MAAK2D,KAAK,aACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQqlC,cAGX,MAFA1rC,MAAK2D,KAAK,kBACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQolC,cAGX,MAFAzrC,MAAK2D,KAAK,kBACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQupD,eAIX,MAHA5vD,MAAK2D,KAAK,yBACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQwpD,eAIX,MAHA7vD,MAAK2D,KAAK,yBACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQwlC,gBAGX,MAFA7rC,MAAK2D,KAAK,aACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQ4lC,gBAGX,MAFAjsC,MAAK2D,KAAK,aACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQylC,gBAGX,MAFA9rC,MAAK2D,KAAK,kBACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQ6lC,gBAGX,MAFAlsC,MAAK2D,KAAK,kBACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQslC,gBAGX,MAFA3rC,MAAK2D,KAAK,aACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQ0lC,gBAGX,MAFA/rC,MAAK2D,KAAK,aACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQulC,gBAGX,MAFA5rC,MAAK2D,KAAK,kBACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQ2lC,gBAGX,MAFAhsC,MAAK2D,KAAK,kBACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQ4kC,WAGX,MAFAjrC,MAAK2D,KAAK,aACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQ6kC,UAGX,MAFAlrC,MAAK2D,KAAK,aACV3D,MAAKu8D,oBAAoBv+C,uBAAuBhN,GAGlD,KAAKuT,GAAAle,QAAQypD,eAIX,MAHA9vD,MAAK2D,KAAK,yBACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAle,QAAQ0pD,eAIX,MAHA/vD,MAAK2D,KAAK,yBACV3D,KAAKu8D,oBAAoBv+C,uBAAuBhN,QAChDhR,MAAK2D,KAAK,KAGd,KAEF,KAAK4gB,GAAA/f,aAAa8W,OAChB,OAAQ8C,qBAAqBpN,IAE3B,IAAKuT,GAAAlb,SAASo6B,OACd,IAAKlf,GAAAlb,SAAS8lC,OACd,IAAK5qB,GAAAlb,SAAS+lC,OACd,IAAK7qB,GAAAlb,SAASgmC,OAIZ,MAHArvC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,WACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASmmC,OACd,IAAKjrB,GAAAlb,SAASomC,OACd,IAAKlrB,GAAAlb,SAASqmC,OACd,IAAKnrB,GAAAlb,SAASsmC,OAIZ,MAHA3vC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,WACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASymC,OACd,IAAKvrB,GAAAlb,SAAS0mC,OACd,IAAKxrB,GAAAlb,SAAS2mC,OACd,IAAKzrB,GAAAlb,SAAS4mC,OAIZ,MAHAjwC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,WACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAAS+mC,OACd,IAAK7rB,GAAAlb,SAASgnC,OACd,IAAK9rB,GAAAlb,SAASmnC,OACd,IAAKjsB,GAAAlb,SAASonC,OAIZ,MAHAzwC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,WACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASinC,OAMZ,MALAtwC,MAAK2D,KAAK,eACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,YACV3D,KAAKu8D,oBAAoBp+C,wBAAwBnN,QACjDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAlb,SAASunC,OACd,IAAKrsB,GAAAlb,SAASwnC,OAIZ,MAHA7wC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,WACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASynC,OAMZ,MALA9wC,MAAK2D,KAAK,eACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,YACV3D,KAAKu8D,oBAAoBp+C,wBAAwBnN,QACjDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAlb,SAAS+0B,OACd,IAAK7Z,GAAAlb,SAASuoC,OAIZ,MAHA5xC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,WACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAAS0oC,MACd,IAAKxtB,GAAAlb,SAAS2oC,MAIZ,MAHAhyC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,WACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAAS8oC,OACd,IAAK5tB,GAAAlb,SAAS+oC,OAIZ,MAHApyC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,WACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAAS80B,OACd,IAAK5Z,GAAAlb,SAAS6nC,OAIZ,MAHAlxC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,YACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASioC,OACd,IAAK/sB,GAAAlb,SAASkoC,OAIZ,MAHAvxC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,aACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAAS60B,OACd,IAAK3Z,GAAAlb,SAASgoC,OAIZ,MAHArxC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,YACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASulD,QAMZ,MALA5uD,MAAK2D,KAAK,cACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoBp+C,wBAAwBnN,QACjDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAlb,SAASylD,QAMZ,MALA9uD,MAAK2D,KAAK,cACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoBp+C,wBAAwBnN,QACjDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAlb,SAAS8+B,MACd,IAAK5jB,GAAAlb,SAASslC,MACd,IAAKpqB,GAAAlb,SAASo1B,MACd,IAAKla,GAAAlb,SAASq1B,MAIZ,MAHA1+B,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,YACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASylC,MACd,IAAKvqB,GAAAlb,SAASu1B,MACd,IAAKra,GAAAlb,SAASw1B,MACd,IAAKta,GAAAlb,SAASy1B,MAIZ,MAHA9+B,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,YACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASyjC,MACd,IAAKvoB,GAAAlb,SAAS0jC,MACd,IAAKxoB,GAAAlb,SAAS6jC,MACd,IAAK3oB,GAAAlb,SAAS8jC,MAIZ,MAHAntC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,WACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAAS2jC,MAKZ,MAJAhtC,MAAK2D,KAAK,SACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,gBACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASukC,MACd,IAAKrpB,GAAAlb,SAASwkC,MACd,IAAKtpB,GAAAlb,SAAS2kC,MACd,IAAKzpB,GAAAlb,SAAS4kC,MAIZ,MAHAjuC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,YACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASykC,MAKZ,MAJA9tC,MAAK2D,KAAK,SACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,iBACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASgkC,MACd,IAAK9oB,GAAAlb,SAASikC,MACd,IAAK/oB,GAAAlb,SAASokC,MACd,IAAKlpB,GAAAlb,SAASqkC,MAIZ,MAHA1tC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,WACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASkkC,MAKZ,MAJAvtC,MAAK2D,KAAK,SACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,gBACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAAS8kC,MACd,IAAK5pB,GAAAlb,SAAS+kC,MACd,IAAK7pB,GAAAlb,SAASklC,MACd,IAAKhqB,GAAAlb,SAASmlC,MAIZ,MAHAxuC,MAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,YACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASglC,MAKZ,MAJAruC,MAAK2D,KAAK,SACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,iBACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASknC,OAKZ,MAJAvwC,MAAK2D,KAAK,SACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,gBACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAAS0nC,OAKZ,MAJA/wC,MAAK2D,KAAK,SACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,gBACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGlD,KAAKuT,GAAAlb,SAASwlD,QAMb,MALA7uD,MAAK2D,KAAK,cACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoBp+C,wBAAwBnN,QACjDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAlb,SAAS0lD,QAMZ,MALA/uD,MAAK2D,KAAK,cACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoBp+C,wBAAwBnN,QACjDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAlb,SAAS4jC,MAKZ,MAJAjtC,MAAK2D,KAAK,SACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,gBACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAAS0kC,MAKZ,MAJA/tC,MAAK2D,KAAK,SACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,iBACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASmkC,MAKZ,MAJAxtC,MAAK2D,KAAK,SACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,gBACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASilC,MAKZ,MAJAtuC,MAAK2D,KAAK,SACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,iBACV3D,MAAKu8D,oBAAoBp+C,wBAAwBnN,GAGnD,KAAKuT,GAAAlb,SAASmmD,YAMZ,MALAxvD,MAAK2D,KAAK,kBACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoBp+C,wBAAwBnN,QACjDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAlb,SAAS6lD,OAMZ,MALAlvD,MAAK2D,KAAK,aACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoBp+C,wBAAwBnN,QACjDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAlb,SAAS2lD,OAMZ,MALAhvD,MAAK2D,KAAK,aACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoBp+C,wBAAwBnN,QACjDhR,MAAK2D,KAAK,IAGV,KAAK4gB,GAAAlb,SAASomD,YAMd,MALAzvD,MAAK2D,KAAK,kBACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoBp+C,wBAAwBnN,QACjDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAlb,SAAS8lD,OAMZ,MALAnvD,MAAK2D,KAAK,aACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoBp+C,wBAAwBnN,QACjDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAAlb,SAAS4lD,OAMZ,MALAjvD,MAAK2D,KAAK,aACV3D,KAAKu8D,oBAAoBr+C,uBAAuBlN,IAChDhR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoBp+C,wBAAwBnN,QACjDhR,MAAK2D,KAAK,KAGd,MAEF,KAAK4gB,GAAA/f,aAAa25D,OAUhB,MATAn+D,MAAK2D,KAAK,WACV3D,KAAK2D,KAAKk4D,EAAiBlqD,IAC3B3R,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoB6B,yBAAyBptD,IAClDhR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoB8B,0BAA0BrtD,IACnDhR,KAAK2D,KAAK,MACV3D,KAAKu8D,oBAAoB+B,4BAA4BttD,QACrDhR,MAAK2D,KAAK,IAGZ,KAAK4gB,GAAA/f,aAAa+5D,KAGhB,MAFAv+D,MAAKu8D,oBAAoBiC,sBAAsBxtD,QAC/ChR,MAAK2D,KAAK,MAGZ,KAAK4gB,GAAA/f,aAAai6D,OAQhB,aAPIjC,EAASkC,wBAAwB1tD,KACnChR,KAAK2D,KAAK,WACV3D,KAAKu8D,oBAAoBC,GACzBx8D,KAAK2D,KAAK,QAEV3D,KAAK2D,KAAK,aAId,KAAK4gB,GAAA/f,aAAam6D,KAChB,OAAQC,mBAAmB5tD,IACzB,IAAKuT,GAAArW,OAAOoiD,cAEV,WADAtwD,MAAK2D,KAAK,mBAEZ,KAAK4gB,GAAArW,OAAOqiD,WAIV,MAHAvwD,MAAK2D,KAAK,gBACV3D,KAAKu8D,oBAAoBsC,wBAAwB7tD,EAAM,QACvDhR,MAAK2D,KAAK,KAGd,KAEF,KAAK4gB,GAAA/f,aAAas6D,IAEhB,WADA9+D,MAAK2D,KAAK,MAGZ,KAAK4gB,GAAA/f,aAAas3D,YAEhB,WADA97D,MAAK2D,KAAK,gBAGZ,KAAK4gB,GAAA/f,aAAau6D,cAElB,IAAKx6C,GAAA/f,aAAaw6D,UAElB,IAAKz6C,GAAA/f,aAAay6D,WAElB,IAAK16C,GAAA/f,aAAa06D,YAEpB,KAAM,IAAIxjD,OAAM,oBAGVigD,EAAAn6D,UAAAmC,KAAR,SAAage,GAEX3hB,KAAK2hB,KAAKhe,KAAKge,IAGjBg6C,EAAAn6D,UAAAmpD,OAAA,WACE,GAAI3nD,GAAMhD,KAAK2hB,KAAKD,KAAK,GAEzB,OADA1hB,MAAK2hB,QACE3e,GAEX24D,IAjzBaj8D,GAAAi8D,crB6yeP,SAAUh8D,EAAQD,EAASS,GAEjC,YsBhrZA,SAAAg/D,GAAkCj4C,GAChC,OAAQA,GAEN,IAAK+X,GAAA2N,MAAMuY,YACT,MAAM,EAER,KAAKlmB,GAAA2N,MAAMkY,MACT,MAAM,EAER,KAAK7lB,GAAA2N,MAAM2K,YACX,IAAKtY,GAAA2N,MAAM4K,MACX,IAAKvY,GAAA2N,MAAMsC,KACX,IAAKjQ,GAAA2N,MAAM2C,MACX,IAAKtQ,GAAA2N,MAAMoK,UACX,IAAK/X,GAAA2N,MAAMuK,YACX,IAAKlY,GAAA2N,MAAM8K,OACX,IAAKzY,GAAA2N,MAAMgY,KACX,IAAK3lB,GAAA2N,MAAMkX,OACT,MAAM,GAER,KAAK7kB,GAAA2N,MAAM5C,IACT,MAAM,GAER,SACE,OAAM,GAKZ,QAAAo1B,GAA6Bl4C,GAC3B,OAAQA,GAEN,IAAK+X,GAAA2N,MAAMtD,MACT,MAAM,EAER,KAAKrK,GAAA2N,MAAMmC,OACX,IAAK9P,GAAA2N,MAAMqC,YACX,IAAKhQ,GAAA2N,MAAM0C,aACX,IAAKrQ,GAAA2N,MAAMyY,yBACX,IAAKpmB,GAAA2N,MAAMgD,gBACX,IAAK3Q,GAAA2N,MAAMsD,aACX,IAAKjR,GAAA2N,MAAM8D,eACX,IAAKzR,GAAA2N,MAAMoE,yBACX,IAAK/R,GAAA2N,MAAMuE,+BACX,IAAKlS,GAAA2N,MAAM4E,2CACX,IAAKvS,GAAA2N,MAAM8E,iBACX,IAAKzS,GAAA2N,MAAMqF,aACX,IAAKhT,GAAA2N,MAAMiF,WACT,MAAM,EAER,KAAK5S,GAAA2N,MAAMma,SACT,MAAM,EAER,KAAK9nB,GAAA2N,MAAM0F,QACT,MAAM,EAER,KAAKrT,GAAA2N,MAAMyF,oBACT,MAAM,EAER,KAAKpT,GAAA2N,MAAMkF,IACT,MAAM,EAER,KAAK7S,GAAA2N,MAAMsF,MACT,MAAM,EAER,KAAKjT,GAAA2N,MAAM+E,UACT,MAAM,EAER,KAAK1S,GAAA2N,MAAM8B,cACX,IAAKzP,GAAA2N,MAAMiC,mBACX,IAAK5P,GAAA2N,MAAM6B,qBACX,IAAKxP,GAAA2N,MAAMgC,0BACT,MAAM,GAER,KAAK3P,GAAA2N,MAAM2W,GACX,IAAKtkB,GAAA2N,MAAMwX,GACX,IAAKnlB,GAAA2N,MAAMyX,WACX,IAAKplB,GAAA2N,MAAMC,SACX,IAAK5N,GAAA2N,MAAMQ,YACX,IAAKnO,GAAA2N,MAAMe,gBACX,IAAK1O,GAAA2N,MAAMsB,mBACT,MAAM,GAER,KAAKjP,GAAA2N,MAAMqE,kBACX,IAAKhS,GAAA2N,MAAMwE,wBACX,IAAKnS,GAAA2N,MAAM6E,oCACT,MAAM,GAER,KAAKxS,GAAA2N,MAAMsC,KACX,IAAKjQ,GAAA2N,MAAM2C,MACT,MAAM,GAER,KAAKtQ,GAAA2N,MAAMiD,SACX,IAAK5Q,GAAA2N,MAAMuD,MACX,IAAKlR,GAAA2N,MAAM+D,QACT,MAAM,GAER,KAAK1R,GAAA2N,MAAMwY,kBACT,MAAM,GAER,KAAKnmB,GAAA2N,MAAMoK,UACX,IAAK/X,GAAA2N,MAAMuK,YACT,MAAM,GAER,KAAKlY,GAAA2N,MAAM2Z,IACX,IAAKtnB,GAAA2N,MAAM5C,IACX,IAAK/K,GAAA2N,MAAMoa,YACT,MAAM,GAER,SACE,OAAM,GAKZ,QAAAqY,GAA4Bn4C,GAC1B,OAAQA,GAEN,IAAK+X,GAAA2N,MAAMmC,OACX,IAAK9P,GAAA2N,MAAMqC,YACX,IAAKhQ,GAAA2N,MAAM0C,aACX,IAAKrQ,GAAA2N,MAAMyY,yBACX,IAAKpmB,GAAA2N,MAAMgD,gBACX,IAAK3Q,GAAA2N,MAAMsD,aACX,IAAKjR,GAAA2N,MAAM8D,eACX,IAAKzR,GAAA2N,MAAMoE,yBACX,IAAK/R,GAAA2N,MAAMuE,+BACX,IAAKlS,GAAA2N,MAAM4E,2CACX,IAAKvS,GAAA2N,MAAM8E,iBACX,IAAKzS,GAAA2N,MAAMqF,aACX,IAAKhT,GAAA2N,MAAMiF,WACX,IAAK5S,GAAA2N,MAAMma,SACX,IAAK9nB,GAAA2N,MAAMwY,kBACT,OAAO,CAET,SACE,OAAO,GtBijZb,GAAIhiC,GAAapjB,MAAQA,KAAKojB,WAAc,WACxC,GAAIC,GAAgBtiB,OAAOuiB,iBACpBC,uBAA2B7f,QAAS,SAAU/C,EAAG6iB,GAAK7iB,EAAE4iB,UAAYC,IACvE,SAAU7iB,EAAG6iB,GAAK,IAAK,GAAI9hB,KAAK8hB,GAAOA,EAAE/hB,eAAeC,KAAIf,EAAEe,GAAK8hB,EAAE9hB,IACzE,OAAO,UAAUf,EAAG6iB,GAEhB,QAASC,KAAOzjB,KAAK0jB,YAAc/iB,EADnC0iB,EAAc1iB,EAAG6iB,GAEjB7iB,EAAEa,UAAkB,OAANgiB,EAAaziB,OAAOgO,OAAOyU,IAAMC,EAAGjiB,UAAYgiB,EAAEhiB,UAAW,GAAIiiB,OAGvF1iB,QAAOC,eAAetB,EAAS,cAAgBoE,OAAO,GsBz0etD,IAAAk7B,GAAA7+B,EAAA,GAMA8+B,EAAA9+B,EAAA,GAMAikB,EAAAjkB,EAAA,GAKAg5C,EAAAh5C,EAAA,IAIAmkB,EAAAnkB,EAAA,GA0DAu6D,EAAA,SAAAr1C,GAUE,QAAAq1C,KAAA,GAAAp1C,GACED,EAAA7kB,KAAAR,OAAOA,ItBgweH,OsBtweNslB,GAAAg6C,QAAoB,GAAI57D,OAExB4hB,EAAAi6C,QAAuB,GAAIzvC,KAKzBxK,EAAK+O,QAAU,GAAI2K,GAAA5Z,QAAQE,EAAKvC,atB+verBuC,EsBjvZf,MA1hF4BlC,GAAAs3C,EAAAr1C,GAgB1Bq1C,EAAAl5D,UAAA+4D,UAAA,SACE54C,EACAqH,EACA8X,GAKA,IAAK,GADDvf,GAAiB43B,EAAA+E,UAAcl1B,GAC1B1oB,EAAI,EAAG4B,EAAIlC,KAAKq0B,QAAQ1O,QAAQ3jB,OAAQ1B,EAAI4B,IAAK5B,EACxD,GAAIN,KAAKq0B,QAAQ1O,QAAQrlB,GAAGihB,gBAAkBA,EAAgB,MAEhEvhB,MAAKu/D,QAAQxvC,IAAIxO,EAGjB,IAAID,GAAS,GAAIgD,GAAA69B,OACf5gC,EACAI,EACAmf,EACIxc,EAAA49B,WAAWI,MACXt5B,EAAKm1B,WAAWnf,EAAAja,iBAAmBiE,EAAKqrC,QAAQr1B,EAAAxa,eAAgBwa,EAAAja,eAAe/iB,QAAU,EACvFsiB,EAAA49B,WAAWK,QACXj+B,EAAA49B,WAAW2B,QAEnB7jD,MAAKq0B,QAAQ1O,QAAQhiB,KAAK2d,EAG1B,IAAIk+C,GAAK,GAAIvgC,GAAAumB,UAAUlkC,EAAQthB,KAAKq0B,QAAQtR,YAE5C,KADAzB,EAAO8gC,UAAYod,GACXA,EAAGrX,KAAKlpB,EAAA2N,MAAMib,YAAY,CAChC,GAAI5gC,GAAYjnB,KAAKy/D,uBAAuBD,EACxCv4C,KACFA,EAAU8B,OAASzH,EACnBA,EAAOyF,WAAWpjB,KAAKsjB,IAG3Bu4C,EAAG7U,UAIL+P,EAAAl5D,UAAAi+D,uBAAA,SACED,EACAE,OAAA,KAAAA,OAAA,EAKA,KADA,GAAI/0C,GAAiC,KAC9B60C,EAAGrX,KAAKlpB,EAAA2N,MAAMwa,KAAK,CACxB,GAAI15B,GAAY1tB,KAAK2/D,eAAeH,EACpC,KAAK9xC,EAAW,KACX/C,KAAYA,MACjBA,EAAWhnB,KAAK+pB,GAIlB,GAAInB,GAA+B,IAC/BizC,GAAGrX,KAAKlpB,EAAA2N,MAAMplB,UAChB+E,EAAYjI,EAAAk0B,YAAYl0B,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAa7E,OAAQg4C,EAAGv+C,SAAUsL,IAE5EizC,EAAGrX,KAAKlpB,EAAA2N,MAAMhY,WAChBrI,EAAYjI,EAAAk0B,YAAYl0B,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAauI,QAAS4qC,EAAGv+C,SAAUsL,GAC/EizC,EAAG1X,MAAK,GACJ0X,EAAG1Z,oBACL9lD,KAAKijB,MACHmB,EAAAjC,eAAey9C,8BACfJ,EAAGv+C,MAAMu+C,EAAGja,OAMlBia,EAAGpX,MAGH,IACI3P,GADAxxB,EAA8B,IAIlC,QAAQu4C,EAAG17C,QAET,IAAKmb,GAAA2N,MAAM7X,MAET,GADAxI,EAAYjI,EAAAk0B,YAAYl0B,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAa0I,MAAOyqC,EAAGv+C,SAAUsL,GACzEizC,EAAGrX,KAAKlpB,EAAA2N,MAAM9X,MAAO,CACvB7N,EAAYjnB,KAAK6/D,UAAUL,EAAIjzC,EAAW5B,EAC1C,OAEF1D,EAAYjnB,KAAK8/D,cAAcN,EAAIjzC,EAAW5B,GAC9CA,EAAa,IACb,MAEF,KAAKsU,GAAA2N,MAAM7W,IACTxJ,EAAYjI,EAAAk0B,YAAYl0B,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAa0J,IAAKypC,EAAGv+C,SAAUsL,EAG7E,KAAK0S,GAAA2N,MAAM+X,IACT19B,EAAYjnB,KAAK8/D,cAAcN,EAAIjzC,EAAW5B,GAC9CA,EAAa,IACb,MAEF,KAAKsU,GAAA2N,MAAM9X,KACT7N,EAAYjnB,KAAK6/D,UAAUL,EAAIjzC,EAAW5B,GAC1CA,EAAa,IACb,MAEF,KAAKsU,GAAA2N,MAAMvU,SACTpR,EAAYjnB,KAAK+/D,cAAcP,EAAIjzC,EAAW5B,GAC9CA,EAAa,IACb,MAEF,KAAKsU,GAAA2N,MAAMjW,SACT,IAAK6oC,EAAGrX,KAAKlpB,EAAA2N,MAAM9Z,OAAQ,CACzB9yB,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,MAAMu+C,EAAGja,KAAM,QAEpB,OAEFh5B,EAAYjI,EAAAk0B,YACVl0B,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAasK,SAAU6oC,EAAGv+C,SAAUsL,EAI5D,KAAK0S,GAAA2N,MAAM9Z,MACT7L,EAAYjnB,KAAKggE,WAAWR,EAAIjzC,EAAW5B,GAC3CA,EAAa,IACb,MAEF,KAAKsU,GAAA2N,MAAMnY,UACTxN,EAAYjnB,KAAKigE,eAAeT,EAAIjzC,EAAW5B,GAC/CA,EAAa,IACb,MAEF,KAAKsU,GAAA2N,MAAMhlB,OAEPX,GADEwxB,EAAWn0B,EAAAo0B,YAAYp0B,EAAA+H,aAAa7E,OAAQ+E,IAClCvsB,KAAKkgE,kBAAkBV,EAAI/mB,EAASx3B,OAEpCjhB,KAAKmgE,YAAYX,GAE3BjzC,GAAWjI,EAAA+zB,qBAAqB9rB,EACpC,MAEF,KAAK0S,GAAA2N,MAAM8U,KACTz6B,EAAYjnB,KAAKogE,qBAAqBZ,EAAIjzC,EAAW5B,GACrDA,EAAa,IACb,MAEF,SAGMrG,EAAA8H,YAAY9H,EAAA+H,aAAa7E,OAAQ+E,IACnCizC,EAAGnX,QACHphC,EAAYjnB,KAAKqgE,YAAYb,EAAIjzC,KAI7BA,KACEksB,EAAWn0B,EAAAo0B,YAAYp0B,EAAA+H,aAAauI,QAASrI,KAC/CvsB,KAAKijB,MACHmB,EAAAjC,eAAem+C,gCACf7nB,EAASx3B,MAAO,WAGpBqD,EAAA+zB,qBAAqB9rB,IAEvBizC,EAAGnX,QACEqX,IACHz4C,EAAYjnB,KAAKugE,eAAef,GAAI,KAO5C,GAAI70C,EACF,IAAK,GAAIrqB,GAAI,EAAG4B,EAAIyoB,EAAW3oB,OAAQ1B,EAAI4B,IAAK5B,EAC9CN,KAAKijB,MACHmB,EAAAjC,eAAeq+C,8BACf71C,EAAWrqB,GAAG2gB,MAIpB,OAAOgG,IAITyzC,EAAAl5D,UAAAm5D,SAAA,WACE,MAAO36D,MAAKs/D,QAAQt9D,OAAShC,KAAKs/D,QAAQz2B,QAAU,MAItD6xB,EAAAl5D,UAAAmpD,OAAA,WACE,GAAI3qD,KAAKs/D,QAAQt9D,OAAQ,KAAM,IAAI0Z,OAAM,uBAGzC,OAFA1b,MAAKs/D,WACLt/D,KAAKu/D,QAAQkB,QACNzgE,KAAKq0B,SAIdqmC,EAAAl5D,UAAAk/D,UAAA,SACElB,EACAmB,EACAC,OADA,KAAAD,OAAA,OACA,KAAAC,OAAA,EAIA,IAAI3b,GAAQua,EAAG17C,OACX+8C,EAAWrB,EAAG/Z,QAGlB,IAAIR,GAAShmB,EAAA2N,MAAMgY,KACjB,MAAOtgC,GAAA80B,KAAKC,WACV/0B,EAAA80B,KAAKI,2BAA2B,OAAQgmB,EAAGv+C,aAAc,EAAOu+C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAI1F,IAAI5zC,EAGJ,IAAIgvD,GAAuB1b,GAAShmB,EAAA2N,MAAMuZ,UAAW,CACnD,GAAI2a,GAAY9gE,KAAK0gE,UAAUlB,GAAI,EAAOoB,EAC1C,KAAKE,EAAW,MAAO,KACvB,KAAKtB,EAAGrX,KAAKlpB,EAAA2N,MAAMwZ,YAOjB,MANKwa,IACH5gE,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,MAAMu+C,EAAGja,KAAM,KAGf,IAET5zC,GAAOmvD,EACPnvD,EAAKsP,MAAMW,MAAQi/C,EACnBlvD,EAAKsP,MAAMY,IAAM29C,EAAGja,QAGf,IAAIN,GAAShmB,EAAA2N,MAAMjZ,KACxBhiB,EAAO2S,EAAA80B,KAAKC,WACV/0B,EAAA80B,KAAKkD,qBAAqBkjB,EAAGv+C,aAAc,EAAOu+C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,UAIrE,IAAIN,GAAShmB,EAAA2N,MAAM/C,MAAQob,GAAShmB,EAAA2N,MAAMjD,MAC/Ch4B,EAAO2S,EAAA80B,KAAKC,WACV/0B,EAAA80B,KAAKI,2BAA2B,OAAQgmB,EAAGv+C,aAAc,EAAOu+C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,UAInF,IAAIN,GAAShmB,EAAA2N,MAAMsZ,cACxBsZ,EAAGt8D,aACHyO,EAAO2S,EAAA80B,KAAKC,WACV/0B,EAAA80B,KAAKI,2BAA2B,SAAUgmB,EAAGv+C,aAAc,EAAOu+C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,UAIrF,IAAIN,GAAShmB,EAAA2N,MAAM5Y,WA6CxB,MANK4sC,IACH5gE,KAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,SAGA,IA5CP,IAAI0O,GAAarL,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SACrEyW,EAAa,GAAIh0B,OACjBs9D,GAAW,CAGf,IAAIxB,EAAGrX,KAAKlpB,EAAA2N,MAAMC,UAAW,CAC3B,EAAG,CACD,GAAIvT,GAAYt5B,KAAK0gE,UAAUlB,GAAI,EAAMoB,EACzC,KAAKtnC,EAAW,MAAO,KACvB5B,GAAW/zB,KAAe21B,SACnBkmC,EAAGrX,KAAKlpB,EAAA2N,MAAMtD,OACvB,KAAKk2B,EAAGrX,KAAKlpB,EAAA2N,MAAMQ,aAOjB,MANKwzB,IACH5gE,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,MAAMu+C,EAAGja,KAAM,KAGf,KAIX,GAAIia,EAAGrX,KAAKlpB,EAAA2N,MAAMkF,KAAM,CACtB,IAAI0tB,EAAGrX,KAAKlpB,EAAA2N,MAAMhD,MAShB,MANKg3B,IACH5gE,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,MAAMu+C,EAAGja,KAAM,QAGf,IARPyb,IAAW,EAWfrvD,EAAO2S,EAAA80B,KAAKC,WAAW1pB,EAAY+H,EAAYspC,EAAUxB,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MAYjF,KAAOia,EAAGrX,KAAKlpB,EAAA2N,MAAMoa,cAAc,CACjC,GAAIia,GAAezB,EAAG/Z,QACtB,KAAK+Z,EAAGrX,KAAKlpB,EAAA2N,MAAMqa,cAOjB,MANK2Z,IACH5gE,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAGT,IAET,IAAIigD,GAAe1B,EAAGv+C,MAAMggD,EAAczB,EAAGja,IAI7C,IADAyb,GAAW,EACPxB,EAAGrX,KAAKlpB,EAAA2N,MAAMkF,KAAM,CACtB,IAAI0tB,EAAGrX,KAAKlpB,EAAA2N,MAAMhD,MAShB,MANKg3B,IACH5gE,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,QAGT,IARP+/C,IAAW,EAiBf,GANArvD,EAAO2S,EAAA80B,KAAKC,WACV/0B,EAAA80B,KAAKI,2BAA2B,QAAS0nB,IACvCvvD,GACFqvD,EACAxB,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MAEpByb,EAAU,MAGhB,MAAOrvD,IAKT+oD,EAAAl5D,UAAAm+D,eAAA,SACEH,GAKA,GAAIqB,GAAWrB,EAAG/Z,QAClB,IAAI+Z,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAAa,CAG7B,IAFA,GAAIpzB,GAAO4+D,EAAGlX,iBACVj0C,EAAyBiQ,EAAA80B,KAAKI,2BAA2B54C,EAAM4+D,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MAClFia,EAAGrX,KAAKlpB,EAAA2N,MAAM2Z,MAAM,CACzB,IAAIiZ,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAYhB,MAJAh0B,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,SAEE,IAXPrgB,GAAO4+D,EAAGlX,iBACVj0C,EAAaiQ,EAAA80B,KAAKsC,+BAChBrnC,EACAiQ,EAAA80B,KAAKI,2BAA2B54C,EAAM4+D,EAAGv+C,SACzCu+C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MAU5B,GAAIvR,EACJ,KAAIwrB,EAAGrX,KAAKlpB,EAAA2N,MAAMuZ,WAMhB,MAAO7hC,GAAA80B,KAAKkE,gBAAgBjpC,EAAY,KAAMmrD,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAJpE,IADAvR,EAAOh0C,KAAKmhE,eAAe3B,GAEzB,MAAOl7C,GAAA80B,KAAKkE,gBAAgBjpC,EAAY2/B,EAAMwrB,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,UAMxEvlD,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,QAGP,OAAO,OAGTy5C,EAAAl5D,UAAAs+D,cAAA,SACEN,EACAjzC,EACA5B,GAKA,GAAIk2C,GAAWt0C,GAAaA,EAAUvqB,OAASuqB,EAAU,GAAGtL,MAAMW,MAAQ49C,EAAG/Z,SACzE75B,EAAU,GAAIloB,OACd09D,EAAY98C,EAAA8H,YAAY9H,EAAA+H,aAAauI,QAASrI,EAClD,GAAG,CACD,GAAIhD,GAASvpB,KAAKqhE,yBAAyB7B,EAAI4B,EAAW70C,EAAW5B,EACrE,KAAKpB,EAAQ,MAAO,KACpBqC,GAAQjoB,KAA0B4lB,SAC3Bi2C,EAAGrX,KAAKlpB,EAAA2N,MAAMtD,OAEvB,IAAItmC,GAAMshB,EAAA80B,KAAKgI,wBAAwBx1B,EAASW,EAAW5B,EAAY60C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAE7F,OADAia,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,GAGT03D,EAAAl5D,UAAA6/D,yBAAA,SACE7B,EACA4B,EACAE,EACAC,GAKA,OAPA,KAAAH,OAAA,IAOK5B,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAKjB,MAJAh0B,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,SAEE,IAET,IAAI0O,GAAarL,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SAErEtP,EAAwB,IACxB6tD,GAAGrX,KAAKlpB,EAAA2N,MAAMga,SAChBj1C,EAAO3R,KAAK0gE,UAAUlB,GAGxB,IAAIrpD,GAAiC,IACrC,IAAIqpD,EAAGrX,KAAKlpB,EAAA2N,MAAMmC,SAQhB,GAPIqyB,GACFphE,KAAKijB,MACHmB,EAAAjC,eAAeq/C,iDACfhC,EAAGv+C,WAGP9K,EAAcnW,KAAKyhE,gBAAgBjC,EAAI,IACrB,MAAO,UAErBl7C,GAAA8H,YAAY9H,EAAA+H,aAAa0I,MAAOusC,GAC7Bh9C,EAAA8H,YAAY9H,EAAA+H,aAAauI,QAAS0sC,IACrCthE,KAAKijB,MACHmB,EAAAjC,eAAeumB,wCACf/Y,EAAW1O,OAGLtP,GACV3R,KAAKijB,MACHmB,EAAAjC,eAAesgB,cACf+8B,EAAGv+C,MAAMu+C,EAAGja,KAIlB,OAAOjhC,GAAA80B,KAAKkI,0BACV3xB,EACAhe,EACAwE,EACAmrD,EACAC,EACAtiC,EAAAtT,MAAMjK,KAAKiO,EAAW1O,MAAOu+C,EAAGv+C,WAIpCy5C,EAAAl5D,UAAAq+D,UAAA,SACEL,EACAjzC,EACA5B,GAKA,GAAIk2C,GAAWt0C,GAAaA,EAAUvqB,OAASuqB,EAAU,GAAGtL,MAAMW,MAAQ49C,EAAG/Z,QAC7E,IAAI+Z,EAAG17C,QAAUmb,EAAA2N,MAAM5Y,WAKrB,MAJAh0B,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,SAEE,IAET,IAAI0O,GAAarL,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,QACzE,IAAIu+C,EAAG17C,QAAUmb,EAAA2N,MAAMsa,UAKrB,MAJAlnD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,IAET,IAAI2K,GAAU,GAAIloB,MAClB,KAAK87D,EAAGrX,KAAKlpB,EAAA2N,MAAMua,YAAa,CAC9B,EAAG,CACD,GAAI59B,GAASvpB,KAAK0hE,eAAelC,EACjC,KAAKj2C,EAAQ,MAAO,KACpBqC,GAAQjoB,KAA2B4lB,SAC5Bi2C,EAAGrX,KAAKlpB,EAAA2N,MAAMtD,OACvB,KAAKk2B,EAAGrX,KAAKlpB,EAAA2N,MAAMua,YAKjB,MAJAnnD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,KAGX,GAAIje,GAAMshB,EAAA80B,KAAKwE,sBACbjuB,EACA/D,EACAW,EACA5B,EACA60C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAGxB,OADAia,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,GAGT03D,EAAAl5D,UAAAkgE,eAAA,SACElC,GAKA,IAAKA,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAKjB,MAJAh0B,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,SAEE,IAET,IAAI0O,GAAarL,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SACrEnd,EAA2B,IAC/B,OAAI07D,GAAGrX,KAAKlpB,EAAA2N,MAAMmC,WAChBjrC,EAAQ9D,KAAKyhE,gBAAgBjC,EAAI,IACd,KAEdl7C,EAAA80B,KAAK0E,2BACVnuB,EACA7rB,EACAm7B,EAAAtT,MAAMjK,KAAKiO,EAAW1O,MAAOu+C,EAAGv+C,WAIpCy5C,EAAAl5D,UAAAmgE,YAAA,SACEnC,GAKA,GAAIxuD,GAA0B,IAC9B,IACEwuD,EAAG1X,MAAK,IAAS7oB,EAAA2N,MAAMia,WACvB2Y,EAAG3Z,WAAa5mB,EAAA2N,MAAMua,aACrBqY,EAAG1Z,sBAEE90C,EAAOhR,KAAKyhE,gBAAgBjC,IAAM,MAAO,KAGjD,IAAIx8D,GAAMshB,EAAA80B,KAAKiH,sBAAsBrvC,EAAMwuD,EAAGv+C,QAE9C,OADAu+C,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,GAGT03D,EAAAl5D,UAAAogE,oBAAA,SACEpC,GAKA,GAAIjuC,GAAiB,GAAI7tB,MACzB,IAAK87D,EAAGrX,KAAKlpB,EAAA2N,MAAMQ,aAcjBptC,KAAKijB,MACHmB,EAAAjC,eAAe0/C,oCACfrC,EAAGv+C,aAhB0B,CAC/B,EAAG,CACD,GAAI6gD,GAAgB9hE,KAAK+hE,mBAAmBvC,EAC5C,KAAKsC,EAAe,MAAO,KAC3BvwC,GAAe5tB,KAAoBm+D,SAC5BtC,EAAGrX,KAAKlpB,EAAA2N,MAAMtD,OACvB,KAAKk2B,EAAGrX,KAAKlpB,EAAA2N,MAAMQ,aAKjB,MAJAptC,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,KAQX,MAAOsQ,IAGTmpC,EAAAl5D,UAAAugE,mBAAA,SACEvC,GAKA,GAAIA,EAAG17C,QAAUmb,EAAA2N,MAAM5Y,WAAY,CACjC,GAAIrE,GAAarL,EAAA80B,KAAKI,2BACpBgmB,EAAGlX,iBACHkX,EAAGv+C,SAEDgJ,EAA+B,IACnC,OAAIu1C,GAAGrX,KAAKlpB,EAAA2N,MAAMoX,YACV/5B,EAAcjqB,KAAK0gE,UAAUlB,IAAa,KAE3Cl7C,EAAA80B,KAAKqG,oBACV9vB,EACA1F,EACAgV,EAAAtT,MAAMjK,KAAKiO,EAAW1O,MAAOu+C,EAAGv+C,UAQpC,MALEjhB,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,SAGA,MAGTy5C,EAAAl5D,UAAAwgE,gBAAA,SACExC,GAKA,GAAI9nC,GAAa,GAAIh0B,OACjBu+D,EAA6B,KAC7BC,GAAe,EACfC,GAAe,CAEnB,IAAI3C,EAAG1X,QAAU7oB,EAAA2N,MAAMwZ,WACrB,EAAG,CACD,GAAIgc,GAAQpiE,KAAKqiE,eAAe7C,EAChC,KAAK4C,EAAO,MAAO,KAQnB,QAPIH,IAAaE,IACfniE,KAAKijB,MACHmB,EAAAjC,eAAemgD,kDACfL,EAASrhE,KAAKqgB,OAEhBkhD,GAAe,GAETC,EAAMxiB,eAEZ,QACMsiB,GACFliE,KAAKijB,MACHmB,EAAAjC,eAAeogD,yDACfH,EAAMxhE,KAAKqgB,MAGf,MAEF,KAAKqD,GAAA4+B,cAAcsf,SACjBN,GAAe,CACf,MAEF,KAAK59C,GAAA4+B,cAAcuf,KACjBR,EAAWG,EAGf1qC,EAAW/zB,KAAKy+D,SACT5C,EAAGrX,KAAKlpB,EAAA2N,MAAMtD,OAEzB,OAAKk2B,GAAGrX,KAAKlpB,EAAA2N,MAAMwZ,YAOZ1uB,GANL13B,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,OAKXy5C,EAAAl5D,UAAA6gE,eAAA,SACE7C,EACAoB,OAAA,KAAAA,OAAA,EAKA,IAAI8B,IAAS,EACTC,GAAa,EACbC,EAA2B,IAK/B,IAJIpD,EAAGrX,KAAKlpB,EAAA2N,MAAMuY,eAChBud,GAAS,EACTE,EAAapD,EAAGv+C,SAEdu+C,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAAa,CACxB0uC,IAAQE,EAAapD,EAAGv+C,QAC7B,IAAI0O,GAAarL,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SACrEtP,EAAwB,IAS5B,KARIgxD,EAAanD,EAAGrX,KAAKlpB,EAAA2N,MAAMma,YACzB2b,GACF1iE,KAAKijB,MACHmB,EAAAjC,eAAe0gD,oCACflzC,EAAW1O,OAIbu+C,EAAGrX,KAAKlpB,EAAA2N,MAAMga,UAChBj1C,EAAO3R,KAAK0gE,UAAUlB,IACX,MAAO,KAEpB,IAAIrpD,GAAiC,IACrC,QAAIqpD,EAAGrX,KAAKlpB,EAAA2N,MAAMmC,UACZ2zB,GACF1iE,KAAKijB,MACHmB,EAAAjC,eAAe2gD,4CACfnzC,EAAW1O,OAGX0hD,EACF3iE,KAAKijB,MACHmB,EAAAjC,eAAe4gD,oDACfpzC,EAAW1O,OAGb0hD,GAAa,EAEfxsD,EAAcnW,KAAKyhE,gBAAgBjC,EAAI,IAGlCl7C,EAAA80B,KAAKuG,gBACVhwB,EACAhe,EACAwE,EACAusD,EACIp+C,EAAA4+B,cAAcuf,KACdE,EACEr+C,EAAA4+B,cAAcsf,SACdl+C,EAAA4+B,cAAcW,QACpB5kB,EAAAtT,MAAMjK,KAAYkhD,EAAYpD,EAAGv+C,UAXR,KAmB7B,MALEjhB,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,SAGA,MAGTy5C,EAAAl5D,UAAAu+D,cAAA,SACEP,EACAjzC,EACA5B,GAUA,GAAIk2C,GAAWt0C,GAAaA,EAAUvqB,OAASuqB,EAAU,GAAGtL,MAAMW,MAAQ49C,EAAG/Z,QAE7E,KAAK+Z,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAKjB,MAJAh0B,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,MAAMu+C,EAAGja,MAEP,IAGT,IAAI51B,GAAarL,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SAErEsQ,EAAyC,IAC7C,IAAIiuC,EAAGrX,KAAKlpB,EAAA2N,MAAMC,aAChBtb,EAAiBvxB,KAAK4hE,oBAAoBpC,IACrB,MAAO,KAG9B,KAAKA,EAAGrX,KAAKlpB,EAAA2N,MAAMuZ,WAKjB,MAJAnmD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,MAAMu+C,EAAGja,KAAM,KAEb,IAGT,IAAI7tB,GAAa13B,KAAKgiE,gBAAgBxC,EACtC,KAAK9nC,EAAY,MAAO,KAExB,IAAIsrC,GAAW1+C,EAAA8H,YAAY9H,EAAA+H,aAAaG,IAAKD,EACzCy2C,KAEuB,GAArBtrC,EAAW11B,QACbhC,KAAKijB,MACHmB,EAAAjC,eAAe8gD,+CACftzC,EAAW1O,OAIXyW,EAAW11B,QAAU01B,EAAW,GAAGvhB,aACrCnW,KAAKijB,MACHmB,EAAAjC,eAAe+gD,oDACfvzC,EAAW1O,QAKFqD,EAAA8H,YAAY9H,EAAA+H,aAAaC,IAAKC,IAC7BmL,EAAW11B,QACzBhC,KAAKijB,MACHmB,EAAAjC,eAAeghD,sCACfxzC,EAAW1O,MAIf,IAAItL,GAA8B,IAClC,IAAI6pD,EAAGrX,KAAKlpB,EAAA2N,MAAMga,QAEhB,KADAjxC,EAAa3V,KAAK0gE,UAAUlB,EAAIwD,IACf,MAAO,UAEdA,IACVhjE,KAAKijB,MACHmB,EAAAjC,eAAesgB,cACf+8B,EAAGv+C,MAAMu+C,EAAGja,KAIhB,IAAI6b,GAAY98C,EAAA8H,YAAY9H,EAAA+H,aAAauI,QAASrI,GAE9C/X,EAAyB,IAC7B,IAAIgrD,EAAGrX,KAAKlpB,EAAA2N,MAAMsa,YAShB,GARIka,GACFphE,KAAKijB,MACHmB,EAAAjC,eAAe0hB,yDACf27B,EAAGv+C,WAIPzM,EAAOxU,KAAKojE,oBAAoB5D,GAAI,IACzB,MAAO,UACR4B,IACVphE,KAAKijB,MACHmB,EAAAjC,eAAe2hB,gFACf07B,EAAGv+C,MAAMu+C,EAAGja,KAIhB,IAAIviD,GAAMshB,EAAA80B,KAAKyG,0BACblwB,EACA4B,EACamG,EACb/hB,EACAnB,EACA+X,EACA5B,EACA60C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAGxB,OADAia,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,GAGT03D,EAAAl5D,UAAA6hE,wBAAA,SAAwB7D,GACtB,GACI7vC,GADAkxC,EAAWrB,EAAG/Z,SAEd1K,GAAU,CAOd,IAAIykB,EAAGva,OAAShmB,EAAA2N,MAAMvU,UAOpB,GANA0iB,GAAU,EAERprB,EADE6vC,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YACH1P,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SAExDqD,EAAA80B,KAAKI,2BAA2B,GAAIgmB,EAAGv+C,MAAMu+C,EAAGja,IAAKia,EAAGja,OAElEia,EAAGrX,KAAKlpB,EAAA2N,MAAMuZ,WAKjB,MAJAnmD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,MAAMu+C,EAAGja,KAAM,KAEb,SAQTxK,IAAU,EACV/wB,OAAOw1C,EAAGva,OAAShmB,EAAA2N,MAAMuZ,WACzBx2B,EAAarL,EAAA80B,KAAKI,2BAA2B,GAAIgmB,EAAGv+C,MAAMu+C,EAAG/Z,SAAU+Z,EAAG/Z,UAK5E,IAAI/tB,GAAa13B,KAAKgiE,gBAAgBxC,EACtC,OAAK9nC,GAEE13B,KAAKsjE,8BAA8B9D,EAAI7vC,EAAY+H,EAAYqjB,EAAS8lB,GAFvD,MAKlBnG,EAAAl5D,UAAA8hE,8BAAR,SACE9D,EACA7vC,EACA+H,EACAqjB,EACA8lB,OAAA,KAAAA,OAAiB,GAEbA,EAAW,IAAGA,EAAWlxC,EAAW1O,MAAMW,MAE9C,IAAIjM,GAA8B,IAClC,IAAI6pD,EAAGrX,KAAKlpB,EAAA2N,MAAMga,UAChBjxC,EAAa3V,KAAK0gE,UAAUlB,IACX,MAAO,KAG1B,IAAIzkB,IACGykB,EAAGrX,KAAKlpB,EAAA2N,MAAMka,oBAKjB,MAJA9mD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,MAAMu+C,EAAGja,KAAM,MAEb,IAIX,IAAI/wC,EACJ,IAAIumC,EACFvmC,EAAOxU,KAAKugE,eAAef,GAAI,OAC1B,CACL,IAAKA,EAAGrX,KAAKlpB,EAAA2N,MAAMsa,WAKjB,MAJAlnD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,MAAMu+C,EAAGja,KAAM,KAEb,IAET/wC,GAAOxU,KAAKojE,oBAAoB5D,GAAI,GAEtC,IAAKhrD,EAAM,MAAO,KAElB,IAAIsU,GAAcxE,EAAA80B,KAAKyG,0BACrBlwB,EACA,KACA+H,EACA/hB,EACAnB,EACA,KACA,KACAgrD,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAExB,OAAOjhC,GAAA80B,KAAK0B,yBAAyBhyB,EAAaiyB,IAGpD2f,EAAAl5D,UAAAw+D,WAAA,SACER,EACAjzC,EACA5B,GAUA,GAAIk2C,GAAWl2C,GAAcA,EAAW3oB,OACpC2oB,EAAW,GAAG1J,MAAMW,MACpB2K,GAAaA,EAAUvqB,OACvBuqB,EAAU,GAAGtL,MAAMW,MACnB49C,EAAG/Z,QAEP,IAAI+Z,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAAa,CAE7B,GAKIzC,GALA5B,EAAarL,EAAA80B,KAAKI,2BACpBgmB,EAAGlX,iBACHkX,EAAGv+C,QAIL,IAAIu+C,EAAGrX,KAAKlpB,EAAA2N,MAAMC,WAEhB,KADAtb,EAAiBvxB,KAAK4hE,oBAAoBpC,IACrB,MAAO,UAE5BjuC,KAGF,IAAItH,GAA+B,IACnC,IAAIu1C,EAAGrX,KAAKlpB,EAAA2N,MAAMoX,YAChB/5B,EAAcjqB,KAAK0gE,UAAUlB,IACX,MAAO,KAG3B,IAAI/zC,GAAkB,GAAI/nB,MAC1B,IAAI87D,EAAGrX,KAAKlpB,EAAA2N,MAAMuX,YAChB,EAAG,CACD,GAAIxyC,GAAO3R,KAAK0gE,UAAUlB,EAC1B,KAAK7tD,EAAM,MAAO,KAClB8Z,GAAgB9nB,KAAegO,SACxB6tD,EAAGrX,KAAKlpB,EAAA2N,MAAMtD,OAGzB,IAAIk2B,EAAGrX,KAAKlpB,EAAA2N,MAAMsa,WAAY,CAE5B,GAAIt7B,GAAU,GAAIloB,MAClB,KAAK87D,EAAGrX,KAAKlpB,EAAA2N,MAAMua,YAAa,CAC9B,GAAIia,GAAY98C,EAAA8H,YAAY9H,EAAA+H,aAAauI,QAASrI,EAClD,GAAG,CACD,GAAIhD,GAASvpB,KAAKujE,iBAAiB/D,EAAI4B,EACvC,KAAK73C,EAAQ,MAAO,KACpBqC,GAAQjoB,KAA2B4lB,UAC3Bi2C,EAAGrX,KAAKlpB,EAAA2N,MAAMua,aAE1B,MAAO7iC,GAAA80B,KAAK8D,uBACVvtB,EACA4B,EACAtH,EACAwB,EACAG,EACAW,EACA5B,EACA60C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MAIxBvlD,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAIhBjhB,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,QAGP,OAAO,OAGTy5C,EAAAl5D,UAAA+hE,iBAAA,SACE/D,EACAgE,GAYA,IAHA,GAAI3C,GAAWrB,EAAGja,IAEd56B,EAAa,GAAIjnB,OACd87D,EAAGrX,KAAKlpB,EAAA2N,MAAMwa,KAAK,CACxB,GAAI15B,GAAY1tB,KAAK2/D,eAAeH,EACpC,KAAK9xC,EAAW,KAChB/C,GAAWhnB,KAAgB+pB,GAG7B,GAAInB,GAA+B,IAE/BizC,GAAGrX,KAAKlpB,EAAA2N,MAAM1W,QAChB3J,EAAYjI,EAAAk0B,YAAYl0B,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAa6J,OAAQspC,EAAGv+C,SAAUsL,GACrEizC,EAAGrX,KAAKlpB,EAAA2N,MAAMzW,SACvB5J,EAAYjI,EAAAk0B,YAAYl0B,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAa8J,QAASqpC,EAAGv+C,SAAUsL,GACtEizC,EAAGrX,KAAKlpB,EAAA2N,MAAMxW,aACvB7J,EAAYjI,EAAAk0B,YAAYl0B,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAa+J,UAAWopC,EAAGv+C,SAAUsL,IAG/EizC,EAAGrX,KAAKlpB,EAAA2N,MAAM7f,QAChBR,EAAYjI,EAAAk0B,YAAYl0B,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAaU,OAAQyyC,EAAGv+C,SAAUsL,GACrEizC,EAAGrX,KAAKlpB,EAAA2N,MAAMjW,YACvBpK,EAAYjI,EAAAk0B,YAAYl0B,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAasK,SAAU6oC,EAAGv+C,SAAUsL,IAG9EizC,EAAGrX,KAAKlpB,EAAA2N,MAAM3W,YAChB1J,EAAYjI,EAAAk0B,YAAYl0B,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAa4J,SAAUupC,EAAGv+C,SAAUsL,IAIlFizC,EAAGpX,MAEH,IAAIj8B,IAAW,EACX62C,GAAW,GAEX72C,EAAWqzC,EAAGrX,KAAKlpB,EAAA2N,MAAMtgB,MACvBkzC,EAAG1X,MAAK,GAAM,IAAS7oB,EAAA2N,MAAM5Y,YAAewrC,EAAG1Z,oBAGjD0Z,EAAGnX,QACHl8B,GAAW,GAHXI,EAAYjI,EAAAk0B,YAAYl0B,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAaC,IAAKkzC,EAAGv+C,SAAUsL,IAMpEy2C,EAAWxD,EAAGrX,KAAKlpB,EAAA2N,MAAMpgB,QAC9BgzC,EAAG1X,MAAK,GAAM,IAAS7oB,EAAA2N,MAAM5Y,YAAewrC,EAAG1Z,oBAGjD0Z,EAAGnX,QACH2a,GAAW,GAHXz2C,EAAYjI,EAAAk0B,YAAYl0B,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAaG,IAAKgzC,EAAGv+C,SAAUsL,GAO/E,IAAIk3C,GAAgBjE,EAAGrX,KAAKlpB,EAAA2N,MAAMvf,YAClC,IAAIo2C,GAAiBjE,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAAa,CAE9C,GAAIrE,GAAa8zC,EACbn/C,EAAA80B,KAAKkB,4BAA4BklB,EAAGv+C,SACpCqD,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SAExDsQ,EAAyC,IAC7C,IAAIiuC,EAAGrX,KAAKlpB,EAAA2N,MAAMC,YACZ42B,GACFzjE,KAAKijB,MACHmB,EAAAjC,eAAeuhD,2DACflE,EAAGv+C,WAGPsQ,EAAiBvxB,KAAK4hE,oBAAoBpC,KACrB,MAAO,KAI9B,IAAIA,EAAGrX,KAAKlpB,EAAA2N,MAAMuZ,WAAY,CAC5B,GAAIzuB,GAAa13B,KAAKgiE,gBAAgBxC,EACtC,KAAK9nC,EAAY,MAAO,KAEpBvL,IAAYuL,EAAW11B,QACzBhC,KAAKijB,MACHmB,EAAAjC,eAAeghD,sCACfxzC,EAAW1O,OAIX+hD,IACuB,GAArBtrC,EAAW11B,QACbhC,KAAKijB,MACHmB,EAAAjC,eAAe8gD,+CACftzC,EAAW1O,OAGXyW,EAAW11B,QAAU01B,EAAW,GAAGvhB,aACrCnW,KAAKijB,MACHmB,EAAAjC,eAAe+gD,oDACfvzC,EAAW1O,OAKjB,IAAItL,GAA8B,IAClC,IAAI6pD,EAAGrX,KAAKlpB,EAAA2N,MAAMga,QAahB,GAZIj3B,EAAWzI,MAAQ5C,EAAA6C,SAASkG,YAC9BrtB,KAAKijB,MACHmB,EAAAjC,eAAewhD,2DACfnE,EAAGv+C,SAEI+hD,GACThjE,KAAKijB,MACHmB,EAAAjC,eAAeyhD,oDACfpE,EAAGv+C,WAGPtL,EAAa3V,KAAK0gE,UAAUlB,EAAI7vC,EAAWzI,MAAQ5C,EAAA6C,SAASkG,aAAe21C,IAC1D,MAAO,UACdA,IAAYrzC,EAAWzI,MAAQ5C,EAAA6C,SAASkG,aAClDrtB,KAAKijB,MACHmB,EAAAjC,eAAesgB,cACf+8B,EAAGv+C,QAIP,IAAIzM,GAAyB,IAC7B,IAAIgrD,EAAGrX,KAAKlpB,EAAA2N,MAAMsa,YAQhB,GAPIsc,GACFxjE,KAAKijB,MACHmB,EAAAjC,eAAe0hB,yDACf27B,EAAGv+C,WAGPzM,EAAOxU,KAAKojE,oBAAoB5D,GAAI,IACzB,MAAO,UACRgE,IACVxjE,KAAKijB,MACHmB,EAAAjC,eAAe2hB,gFACf07B,EAAGv+C,QAIP,IAAI4iD,GAAYv/C,EAAA80B,KAAK2G,wBACnBpwB,EACA4B,EACAmG,EACA/hB,EACAnB,EACA+X,EACA5B,EACA60C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAGxB,OADAia,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACPgd,EAEF,GAAIJ,EACTzjE,KAAKijB,MACHmB,EAAAjC,eAAe2hD,sCACfn0C,EAAW1O,WAGR,KAAIkL,IAAY62C,EAOhB,CACL,GAAIvqB,IAEAA,EAAWn0B,EAAAo0B,YAAYp0B,EAAA+H,aAAasK,SAAUpK,KAChDvsB,KAAKijB,MACHmB,EAAAjC,eAAem+C,gCACf7nB,EAASx3B,MAAO,aAIhBw3B,EAAWn0B,EAAAo0B,YAAYp0B,EAAA+H,aAAaC,IAAKC,KAC3CvsB,KAAKijB,MACHmB,EAAAjC,eAAem+C,gCACf7nB,EAASx3B,MAAO,QAIhBw3B,EAAWn0B,EAAAo0B,YAAYp0B,EAAA+H,aAAaG,IAAKD,KAC3CvsB,KAAKijB,MACHmB,EAAAjC,eAAem+C,gCACf7nB,EAASx3B,MAAO,MAIpB,IAAItP,GAAwB,IAC5B,IAAI6tD,EAAGrX,KAAKlpB,EAAA2N,MAAMga,QAEhB,KADAj1C,EAAO3R,KAAK0gE,UAAUlB,IACX,MAAO,UAElBx/D,MAAKijB,MACHmB,EAAAjC,eAAesgB,cACf+8B,EAAGv+C,QAGP,IAAI9K,GAAiC,IACrC,IAAIqpD,EAAGrX,KAAKlpB,EAAA2N,MAAMmC,WAChB54B,EAAcnW,KAAKyhE,gBAAgBjC,IACjB,MAAO,KAE3B,IAAIuE,GAAWz/C,EAAA80B,KAAKiG,uBAClB1vB,EACAhe,EACAwE,EACAoW,EACA5B,EACA60C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAGxB,OADAia,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACPkd,EAtDP/jE,KAAKijB,MACHmB,EAAAjC,eAAe2hB,gFACfnU,EAAW1O,YAuDfjhB,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,QAGP,OAAO,OAGTy5C,EAAAl5D,UAAAy+D,eAAA,SACET,EACAjzC,EACA5B,GAKA,GAAIk2C,GAAWt0C,GAAaA,EAAUvqB,OAASuqB,EAAU,GAAGtL,MAAMW,MAAQ49C,EAAG/Z,QAC7E,IAAI+Z,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAAa,CAC7B,GAAIrE,GAAarL,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,QACzE,IAAIu+C,EAAGrX,KAAKlpB,EAAA2N,MAAMsa,WAAY,CAE5B,IADA,GAAIt7B,GAAU,GAAIloB,QACV87D,EAAGrX,KAAKlpB,EAAA2N,MAAMua,aAAa,CACjC,GAAI59B,GAASvpB,KAAKy/D,uBAAuBD,GAAI,EAC7C,KAAKj2C,EAAQ,MAAO,KACpBqC,GAAQjoB,KAAK4lB,GAEf,GAAIvmB,GAAMshB,EAAA80B,KAAK+G,2BACbxwB,EACA/D,EACAW,EACA5B,EACA60C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAGxB,OADAia,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,EAEPhD,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAIhBjhB,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,QAGP,OAAO,OAGTy5C,EAAAl5D,UAAA6+D,YAAA,SACEb,EACAjzC,GAKA,GAAIs0C,GAAWt0C,GAAaA,EAAUvqB,OAASuqB,EAAU,GAAGtL,MAAMW,MAAQ49C,EAAG/Z,QAE7E,IAAI+Z,EAAGrX,KAAKlpB,EAAA2N,MAAMsa,WAAY,CAC5B,GAAIt7B,GAAU,GAAIloB,MAClB,KAAK87D,EAAGrX,KAAKlpB,EAAA2N,MAAMua,YAAa,CAC9B,EAAG,CACD,GAAI59B,GAASvpB,KAAKgkE,kBAAkBxE,EACpC,KAAKj2C,EAAQ,MAAO,KACpBqC,GAAQjoB,KAAK4lB,SACNi2C,EAAGrX,KAAKlpB,EAAA2N,MAAMtD,OACvB,KAAKk2B,EAAGrX,KAAKlpB,EAAA2N,MAAMua,YAKjB,MAJAnnD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,KAGX,GAAI+H,GAAuC,IAC3C,IAAIw2C,EAAGrX,KAAKlpB,EAAA2N,MAAMsX,MAAO,CACvB,IAAIsb,EAAGrX,KAAKlpB,EAAA2N,MAAMsZ,eAOhB,MAJAlmD,MAAKijB,MACHmB,EAAAjC,eAAeoM,wBACfixC,EAAGv+C,SAEE,IANP+H,GAAO1E,EAAA80B,KAAK8C,8BAA8BsjB,EAAGt8D,aAAcs8D,EAAGv+C,SASlE,GAAIje,GAAMshB,EAAA80B,KAAK4E,sBAAsBpyB,EAAS5C,EAAMuD,EAAWizC,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAMrF,OALIviD,GAAIue,iBAAmBvhB,KAAKu/D,QAAQp0C,IAAYnoB,EAAIue,kBACtDvhB,KAAKs/D,QAAQ37D,KAAaX,EAAIue,gBAC9BvhB,KAAKu/D,QAAQxvC,IAAY/sB,EAAIue,iBAE/Bi+C,EAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,EAOT,MALEhD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAGT,MAGTy5C,EAAAl5D,UAAAwiE,kBAAA,SACExE,GAKA,GAAIA,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAAa,CAC7B,GAAIrE,GAAarL,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SACrEgjD,EAA4C,IAChD,IAAIzE,EAAGrX,KAAKlpB,EAAA2N,MAAM2W,IAAK,CACrB,IAAIic,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAOhB,MAJAh0B,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,SAEE,IANPgjD,GAAe3/C,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SAS3E,MAAOqD,GAAA80B,KAAKkF,mBACV3uB,EACAs0C,EACAA,EACIhlC,EAAAtT,MAAMjK,KAAKiO,EAAW1O,MAAOgjD,EAAahjD,OAC1C0O,EAAW1O,OAQnB,MALEjhB,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,SAGA,MAGTy5C,EAAAl5D,UAAA2+D,YAAA,SACEX,GAOA,GAAIqB,GAAWrB,EAAG/Z,SACd75B,EAAsC,KACtCsE,EAA6C,KAC7Cg0C,GAAW,CACf,IAAI1E,EAAGrX,KAAKlpB,EAAA2N,MAAMsa,YAEhB,GADAt7B,EAAU,GAAIloB,QACT87D,EAAGrX,KAAKlpB,EAAA2N,MAAMua,YAAa,CAC9B,EAAG,CACD,GAAI59B,GAASvpB,KAAKmkE,uBAAuB3E,EACzC,KAAKj2C,EAAQ,MAAO,KACpBqC,GAAQjoB,KAAK4lB,SACNi2C,EAAGrX,KAAKlpB,EAAA2N,MAAMtD,OACvB,KAAKk2B,EAAGrX,KAAKlpB,EAAA2N,MAAMua,YAKjB,MAJAnnD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,UAGN,IAAIu+C,EAAGrX,KAAKlpB,EAAA2N,MAAMiD,UAAW,CAClC,IAAI2vB,EAAGrX,KAAKlpB,EAAA2N,MAAM2W,IAehB,MAJAvjD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,MAEP,IAdP,KAAIu+C,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAOhB,MAJAh0B,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,SAEE,IANPiP,GAAgB5L,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,aAgB5EijD,IAAW,CAGb,IAAIA,GAAY1E,EAAGrX,KAAKlpB,EAAA2N,MAAMsX,MAAO,CACnC,GAAIsb,EAAGrX,KAAKlpB,EAAA2N,MAAMsZ,eAAgB,CAChC,GACIljD,GADAgmB,EAAO1E,EAAA80B,KAAK8C,8BAA8BsjB,EAAGt8D,aAAcs8D,EAAGv+C,QAalE,OAXIiP,IACFlG,QAAQ4B,GACR5oB,EAAMshB,EAAA80B,KAAK4F,kCAAkC9uB,EAAelH,EAAMw2C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,OAExFviD,EAAMshB,EAAA80B,KAAKyF,sBAAsBjzB,EAAS5C,EAAMw2C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MAEnEvlD,KAAKu/D,QAAQp0C,IAAInoB,EAAIue,kBACxBvhB,KAAKs/D,QAAQ37D,KAAKX,EAAIue,gBACtBvhB,KAAKu/D,QAAQxvC,IAAI/sB,EAAIue,iBAEvBi+C,EAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,EAEPhD,KAAKijB,MACHmB,EAAAjC,eAAeoM,wBACfixC,EAAGv+C,aAIPjhB,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,OAGhB,OAAO,OAGTy5C,EAAAl5D,UAAA2iE,uBAAA,SACE3E,GAKA,GAAIA,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAAa,CAC7B,GAAIrE,GAAarL,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SACrEgjD,EAA4C,IAChD,IAAIzE,EAAGrX,KAAKlpB,EAAA2N,MAAM2W,IAAK,CACrB,IAAIic,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAOhB,MAJAh0B,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,SAEE,IANPgjD,GAAe3/C,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SAS3E,MAAOqD,GAAA80B,KAAK6F,wBACVtvB,EACAs0C,EACAA,EACIhlC,EAAAtT,MAAMjK,KAAKiO,EAAW1O,MAAOgjD,EAAahjD,OAC1C0O,EAAW1O,OAQnB,MALEjhB,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,SAGA,MAGTy5C,EAAAl5D,UAAA0+D,kBAAA,SACEV,EACAoD,GAKA,GAAIpD,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAAa,CAC7B,GAAIiwC,GAAe3/C,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,QAC3E,IAAIu+C,EAAGrX,KAAKlpB,EAAA2N,MAAMmC,QAAS,CACzB,GAAIywB,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAAa,CAC7B,GAAIrE,GAAarL,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SACrEje,EAAMshB,EAAA80B,KAAKgF,4BAA4BzuB,EAAYs0C,EAAchlC,EAAAtT,MAAMjK,KAAKkhD,EAAYpD,EAAGv+C,SAE/F,OADAu+C,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,EAEPhD,KAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,aAIPjhB,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAIhBjhB,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,QAGP,OAAO,OAGTy5C,EAAAl5D,UAAA++D,eAAA,SACEf,EACA4E,GAOA,WAPA,KAAAA,OAAA,GAKA5E,EAAGpX,OACSoX,EAAG17C,QAGb,IAAKmb,GAAA2N,MAAMnH,MACT,MAAOzlC,MAAKqkE,WAAW7E,EAEzB,KAAKvgC,GAAA2N,MAAM7X,MACT,MAAO/0B,MAAK8/D,cAAcN,GACxBl7C,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAa0I,MAAOyqC,EAAGv+C,UAC1C,KAEL,KAAKge,GAAA2N,MAAMjH,SACT,MAAO3lC,MAAKskE,cAAc9E,EAE5B,KAAKvgC,GAAA2N,MAAM/G,GACT,MAAO7lC,MAAKukE,iBAAiB/E,EAE/B,KAAKvgC,GAAA2N,MAAMzG,IACT,MAAOnmC,MAAKwkE,kBAAkBhF,EAEhC,KAAKvgC,GAAA2N,MAAMvG,GACT,MAAOrmC,MAAKykE,iBAAiBjF,EAE/B,KAAKvgC,GAAA2N,MAAM7W,IACT,MAAO/1B,MAAK8/D,cAAcN,GACxBl7C,EAAA80B,KAAK6G,eAAe37B,EAAA+H,aAAa0J,IAAKypC,EAAGv+C,UACxC,KAEL,KAAKge,GAAA2N,MAAM+X,IACT,MAAO3kD,MAAK8/D,cAAcN,EAAI,KAAM,KAEtC,KAAKvgC,GAAA2N,MAAMsa,UACT,MAAOlnD,MAAKojE,oBAAoB5D,EAAI4E,EAEtC,KAAKnlC,GAAA2N,MAAMrG,OAOT,MANI69B,IACFpkE,KAAKijB,MACHmB,EAAAjC,eAAeuiD,2DACflF,EAAGv+C,SAGAjhB,KAAK2hE,YAAYnC,EAE1B,KAAKvgC,GAAA2N,MAAMia,UACT,MAAOviC,GAAA80B,KAAKsE,qBAAqB8hB,EAAGv+C,MAAMu+C,EAAG/Z,UAE/C,KAAKxmB,GAAA2N,MAAMnG,OACT,MAAOzmC,MAAK2kE,qBAAqBnF,EAEnC,KAAKvgC,GAAA2N,MAAMjG,MACT,MAAO3mC,MAAK4kE,oBAAoBpF,EAElC,KAAKvgC,GAAA2N,MAAM/F,IACT,MAAO7mC,MAAK6kE,kBAAkBrF,EAEhC,KAAKvgC,GAAA2N,MAAM8U,KACT,MAAO1hD,MAAKogE,qBAAqBZ,EAAI,KAEvC,KAAKvgC,GAAA2N,MAAM7F,MACT,MAAO/mC,MAAK8kE,oBAAoBtF,EAElC,SAEE,MADAA,GAAGnX,QACIroD,KAAK+kE,yBAAyBvF,KAI3C9E,EAAAl5D,UAAA4hE,oBAAA,SACE5D,EACA4E,GAOA,IAFA,GAAIvD,GAAWrB,EAAG/Z,SACd1+B,EAAa,GAAIrjB,QACb87D,EAAGrX,KAAKlpB,EAAA2N,MAAMua,aAAa,CACjC,GAAIlgC,GAAYjnB,KAAKugE,eAAef,EAAI4E,EACxC,KAAKn9C,EAAW,MAAO,KACvBF,GAAWpjB,KAAKsjB,GAElB,GAAIjkB,GAAMshB,EAAA80B,KAAK0D,qBAAqB/1B,EAAYy4C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAEtE,OADAia,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,GAGT03D,EAAAl5D,UAAA6iE,WAAA,SACE7E,GAKA,GAAI7vC,GAA0C,IAC1C6vC,GAAG1X,MAAK,IAAS7oB,EAAA2N,MAAM5Y,YAAewrC,EAAG1Z,qBAC3C0Z,EAAG17C,MAAK,GACR6L,EAAarL,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SAEvE,IAAIje,GAAMshB,EAAA80B,KAAK4D,qBAAqBrtB,EAAY6vC,EAAGv+C,QAEnD,OADAu+C,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,GAGT03D,EAAAl5D,UAAA8iE,cAAA,SACE9E,GAKA,GAAI7vC,GAA0C,IAC1C6vC,GAAG1X,MAAK,IAAS7oB,EAAA2N,MAAM5Y,YAAewrC,EAAG1Z,qBAC3C0Z,EAAG17C,MAAK,GACR6L,EAAarL,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,SAEvE,IAAIje,GAAMshB,EAAA80B,KAAKgE,wBAAwBztB,EAAY6vC,EAAGv+C,QAEtD,OADAu+C,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,GAGT03D,EAAAl5D,UAAA+iE,iBAAA,SACE/E,GAKA,GAAIqB,GAAWrB,EAAG/Z,SACdx+B,EAAYjnB,KAAKugE,eAAef,EACpC,KAAKv4C,EAAW,MAAO,KAEvB,IAAIu4C,EAAGrX,KAAKlpB,EAAA2N,MAAM7F,OAEhB,GAAIy4B,EAAGrX,KAAKlpB,EAAA2N,MAAMuZ,WAAY,CAC5B,GAAIjyC,GAAYlU,KAAKyhE,gBAAgBjC,EACrC,KAAKtrD,EAAW,MAAO,KAEvB,IAAIsrD,EAAGrX,KAAKlpB,EAAA2N,MAAMwZ,YAAa,CAC7B,GAAIpjD,GAAMshB,EAAA80B,KAAKoE,kBAA6Bv2B,EAAuB/S,EAAWsrD,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAEpG,OADAia,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,EAEPhD,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAIhBjhB,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAIhBjhB,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,QAGhB,OAAO,OAGTy5C,EAAAl5D,UAAAujE,yBAAA,SACEvF,GAKA,GAAIxuD,GAAOhR,KAAKyhE,gBAAgBjC,EAChC,KAAKxuD,EAAM,MAAO,KAElB,IAAIhO,GAAMshB,EAAA80B,KAAKqF,0BAA0BztC,EAEzC,OADAwuD,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,GAGT03D,EAAAl5D,UAAAgjE,kBAAA,SACEhF,GAKA,GAAIqB,GAAWrB,EAAG/Z,QAElB,IAAI+Z,EAAGrX,KAAKlpB,EAAA2N,MAAMuZ,WAAY,CAE5B,GAAIhwC,GAAgC,IAEpC,IAAIqpD,EAAGrX,KAAKlpB,EAAA2N,MAAM7W,MAAQypC,EAAGrX,KAAKlpB,EAAA2N,MAAM7X,QAAUyqC,EAAGrX,KAAKlpB,EAAA2N,MAAM+X,KAC9DxuC,EAAcnW,KAAK8/D,cAAcN,EAAI,KAAM,UAEtC,KAAKA,EAAGrX,KAAKlpB,EAAA2N,MAAMia,cACxB1wC,EAAcnW,KAAK+kE,yBAAyBvF,IAC1B,MAAO,KAG3B,IAAIA,EAAGva,OAAShmB,EAAA2N,MAAMia,UAAW,CAC/B,GAAI3yC,GAAwC,IAC5C,KAAKsrD,EAAGrX,KAAKlpB,EAAA2N,MAAMia,cACjB3yC,EAAYlU,KAAK+kE,yBAAyBvF,IAC1B,MAAO,KAGzB,IAAIA,EAAGva,OAAShmB,EAAA2N,MAAMia,UAAW,CAC/B,GAAIpf,GAAiC,IACrC,KAAK+3B,EAAGrX,KAAKlpB,EAAA2N,MAAMwZ,YAAa,CAE9B,KADA3e,EAAcznC,KAAKyhE,gBAAgBjC,IACjB,MAAO,KAEzB,KAAKA,EAAGrX,KAAKlpB,EAAA2N,MAAMwZ,YAKjB,MAJApmD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,KAIX,GAAIgG,GAAYjnB,KAAKugE,eAAef,EACpC,OAAKv4C,GAEE3C,EAAA80B,KAAKmG,mBACVppC,EACAjC,EACIA,EAAUG,WACV,KACJozB,EACAxgB,EACAu4C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MATD,KAavBvlD,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAIhBjhB,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAIhBjhB,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,IAGhB,OAAO,OAGTy5C,EAAAl5D,UAAAijE,iBAAA,SACEjF,GAKA,GAAIqB,GAAWrB,EAAG/Z,QAClB,IAAI+Z,EAAGrX,KAAKlpB,EAAA2N,MAAMuZ,WAAY,CAC5B,GAAIjyC,GAAYlU,KAAKyhE,gBAAgBjC,EACrC,KAAKtrD,EAAW,MAAO,KACvB,IAAIsrD,EAAGrX,KAAKlpB,EAAA2N,MAAMwZ,YAAa,CAC7B,GAAIn/B,GAAYjnB,KAAKugE,eAAef,EACpC,KAAKv4C,EAAW,MAAO,KACvB,IAAI+9C,GAAkC,IACtC,OAAIxF,GAAGrX,KAAKlpB,EAAA2N,MAAMmX,SAChBihB,EAAgBhlE,KAAKugE,eAAef,IACT,KAEtBl7C,EAAA80B,KAAKuF,kBACVzqC,EACA+S,EACA+9C,EACAxF,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MAGxBvlD,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAIhBjhB,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,IAGhB,OAAO,OAGTy5C,EAAAl5D,UAAAmjE,qBAAA,SACEnF,GAKA,GAAIqB,GAAWrB,EAAG/Z,QAClB,IAAI+Z,EAAGrX,KAAKlpB,EAAA2N,MAAMuZ,WAAY,CAC5B,GAAIjyC,GAAYlU,KAAKyhE,gBAAgBjC,EACrC,KAAKtrD,EAAW,MAAO,KACvB,IAAIsrD,EAAGrX,KAAKlpB,EAAA2N,MAAMwZ,YAAa,CAC7B,GAAIoZ,EAAGrX,KAAKlpB,EAAA2N,MAAMsa,WAAY,CAE5B,IADA,GAAIpf,GAAQ,GAAIpkC,QACR87D,EAAGrX,KAAKlpB,EAAA2N,MAAMua,aAAa,CACjC,GAAIjf,GAAQloC,KAAKilE,gBAAgBzF,EACjC,KAAKt3B,EAAO,MAAO,KACnBJ,GAAMnkC,KAAiBukC,GAEzB,GAAIllC,GAAMshB,EAAA80B,KAAKmH,sBAAsBrsC,EAAW4zB,EAAO03B,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAE7E,OADAia,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,EAEPhD,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAIhBjhB,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAIhBjhB,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,IAGhB,OAAO,OAGTy5C,EAAAl5D,UAAAyjE,gBAAA,SACEzF,GAGA,GACIz4C,GACAE,EAFA45C,EAAWrB,EAAG/Z,QAMlB,IAAI+Z,EAAGrX,KAAKlpB,EAAA2N,MAAM8W,MAAO,CACvB,GAAI7vC,GAAQ7T,KAAKyhE,gBAAgBjC,EACjC,KAAK3rD,EAAO,MAAO,KACnB,IAAI2rD,EAAGrX,KAAKlpB,EAAA2N,MAAMga,OAAQ,CAExB,IADA7/B,EAAa,GAAIrjB,OACV87D,EAAG1X,QAAU7oB,EAAA2N,MAAM8W,MAAQ8b,EAAG3Z,WAAa5mB,EAAA2N,MAAMiX,SAAW2b,EAAG3Z,WAAa5mB,EAAA2N,MAAMua,YAAY,CAEnG,KADAlgC,EAAYjnB,KAAKugE,eAAef,IAChB,MAAO,KACvBz4C,GAAWpjB,KAAKsjB,GAElB,MAAO3C,GAAA80B,KAAKqH,iBAAiB5sC,EAAOkT,EAAYy4C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MAEtEvlD,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAMX,IAAIu+C,EAAGrX,KAAKlpB,EAAA2N,MAAMiX,SAAU,CACjC,GAAI2b,EAAGrX,KAAKlpB,EAAA2N,MAAMga,OAAQ,CAExB,IADA7/B,EAAa,GAAIrjB,OACV87D,EAAG1X,QAAU7oB,EAAA2N,MAAM8W,MAAQ8b,EAAG3Z,WAAa5mB,EAAA2N,MAAMiX,SAAW2b,EAAG3Z,WAAa5mB,EAAA2N,MAAMua,YAAY,CAEnG,KADAlgC,EAAYjnB,KAAKugE,eAAef,IAChB,MAAO,KACvBz4C,GAAWpjB,KAAKsjB,GAElB,MAAO3C,GAAA80B,KAAKqH,iBAAiB,KAAM15B,EAAYy4C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MAErEvlD,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAIhBjhB,MAAKijB,MACHmB,EAAAjC,eAAe+iD,0BACf1F,EAAGv+C,QAGP,OAAO,OAGTy5C,EAAAl5D,UAAAojE,oBAAA,SACEpF,GAKA,GAAIqB,GAAWrB,EAAG/Z,SACdpxC,EAAarU,KAAKyhE,gBAAgBjC,EACtC,KAAKnrD,EAAY,MAAO,KACxB,IAAIrR,GAAMshB,EAAA80B,KAAKuH,qBAAiCtsC,EAAYmrD,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAElF,OADAia,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,GAGT03D,EAAAl5D,UAAAqjE,kBAAA,SACErF,GAQA,GACIz7B,GADA88B,EAAWrB,EAAG/Z,QAElB,IAAI+Z,EAAGrX,KAAKlpB,EAAA2N,MAAMsa,WAAY,CAE5B,IADA,GAAIngC,GAAa,GAAIrjB,QACb87D,EAAGrX,KAAKlpB,EAAA2N,MAAMua,aAAa,CAEjC,KADApjB,EAAO/jC,KAAKugE,eAAef,IAChB,MAAO,KAClBz4C,GAAWpjB,KAAgBogC,GAE7B,GAAI+c,GAA6C,KAC7CC,EAAsC,KACtCC,EAAwC,IAC5C,IAAIwe,EAAGrX,KAAKlpB,EAAA2N,MAAM+W,OAAQ,CACxB,IAAK6b,EAAGrX,KAAKlpB,EAAA2N,MAAMuZ,WAKjB,MAJAnmD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,IAET,KAAKu+C,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAKjB,MAJAh0B,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,SAEE,IAGT,IADA6/B,EAAgBx8B,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,UACnEu+C,EAAGrX,KAAKlpB,EAAA2N,MAAMwZ,YAKjB,MAJApmD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,IAET,KAAKu+C,EAAGrX,KAAKlpB,EAAA2N,MAAMsa,WAKjB,MAJAlnD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,IAGT,KADA8/B,MACQye,EAAGrX,KAAKlpB,EAAA2N,MAAMua,aAAa,CAEjC,KADApjB,EAAO/jC,KAAKugE,eAAef,IAChB,MAAO,KAClBze,GAAgBp9C,KAAgBogC,IAGpC,GAAIy7B,EAAGrX,KAAKlpB,EAAA2N,MAAMqX,SAAU,CAC1B,IAAKub,EAAGrX,KAAKlpB,EAAA2N,MAAMsa,WAKjB,MAJAlnD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,IAGT,KADA+/B,MACQwe,EAAGrX,KAAKlpB,EAAA2N,MAAMua,aAAa,CAEjC,KADApjB,EAAO/jC,KAAKugE,eAAef,IAChB,MAAO,KAClBxe,GAAkBr9C,KAAgBogC,IAGtC,IAAMgd,IAAmBC,EAKvB,MAJAhhD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAEP,IAET,IAAIje,GAAMshB,EAAA80B,KAAKyH,mBACb95B,EACA+5B,EACAC,EACAC,EACAwe,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAGxB,OADAia,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,EAOT,MALEhD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAGT,MAGTy5C,EAAAl5D,UAAA4+D,qBAAA,SACEZ,EACAjzC,EACA5B,OADA,KAAA4B,MAAA,UACA,KAAA5B,MAAA,KAKA,IAAIk2C,GAAWl2C,GAAcA,EAAW3oB,OAAS2oB,EAAW,GAAG1J,MAAMW,MACtD2K,GAAaA,EAAUvqB,OAASuqB,EAAU,GAAGtL,MAAMW,MACnD49C,EAAG/Z,QAClB,IAAI+Z,EAAGrX,KAAKlpB,EAAA2N,MAAM5Y,YAAa,CAC7B,GAAIpzB,GAAO0jB,EAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,QACnE,IAAIu+C,EAAGrX,KAAKlpB,EAAA2N,MAAMmC,QAAS,CACzB,GAAIp9B,GAAO3R,KAAK0gE,UAAUlB,EAC1B,KAAK7tD,EAAM,MAAO,KAClB,IAAI3O,GAAMshB,EAAA80B,KAAK8H,sBAAsBtgD,EAAM+Q,EAAM4a,EAAW5B,EAAY60C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAE9F,OADAia,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,EAEPhD,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAIhBjhB,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfvB,EAAGv+C,QAGP,OAAO,OAGTy5C,EAAAl5D,UAAAsjE,oBAAA,SACEtF,GAKA,GAAIqB,GAAWrB,EAAG/Z,QAClB,IAAI+Z,EAAGrX,KAAKlpB,EAAA2N,MAAMuZ,WAAY,CAC5B,GAAI9xC,GAAarU,KAAKyhE,gBAAgBjC,EACtC,KAAKnrD,EAAY,MAAO,KACxB,IAAImrD,EAAGrX,KAAKlpB,EAAA2N,MAAMwZ,YAAa,CAC7B,GAAIn/B,GAAYjnB,KAAKugE,eAAef,EACpC,KAAKv4C,EAAW,MAAO,KACvB,IAAIjkB,GAAMshB,EAAA80B,KAAKoI,qBAAiCntC,EAAuB4S,EAAWu4C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAExG,OADAia,GAAGrX,KAAKlpB,EAAA2N,MAAMia,WACP7jD,EAEPhD,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,SAIhBjhB,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,IAGhB,OAAO,OAMTy5C,EAAAl5D,UAAA2jE,qBAAA,SACE3F,GAGA,GAAIva,GAAQua,EAAG17C,MAAK,GAChB+8C,EAAWrB,EAAG/Z,SACdz0C,EAA0B,IAE9B,IAAIi0C,GAAShmB,EAAA2N,MAAMhD,KACjB,MAAOtlB,GAAA80B,KAAKkC,qBAAqBkkB,EAAGv+C,QAEtC,IAAIgkC,GAAShmB,EAAA2N,MAAM/C,KACjB,MAAOvlB,GAAA80B,KAAKoD,qBAAqBgjB,EAAGv+C,QAEtC,IAAIgkC,GAAShmB,EAAA2N,MAAMjD,MACjB,MAAOrlB,GAAA80B,KAAKsB,sBAAsB8kB,EAAGv+C,QAGvC,IAAIvf,GAAIy9D,EAAyBla,EACjC,KAAK,GAADvjD,EAAyB,CAC3B,GAAIq1C,EAKJ,OAAIkO,IAAShmB,EAAA2N,MAAM5C,KACjB+M,EAAU/2C,KAAKyhE,gBAAgBjC,EAAE,KAE7BzoB,EAAQ7vB,MAAQ5C,EAAA6C,SAASgN,KACpB7P,EAAA80B,KAAKgC,oBACOrE,EAAS1iC,WACT0iC,EAAS9lB,cACT8lB,EAASjpB,UAC1B0xC,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,OAGxBvlD,KAAKijB,MACHmB,EAAAjC,eAAeyL,wBACf4xC,EAAGv+C,SAGA,MAdc,MAgBrB81B,EAAU/2C,KAAKyhE,gBAAgBjC,EAAI99D,KAKjCujD,GAAShmB,EAAA2N,MAAMoK,WAAaiO,GAAShmB,EAAA2N,MAAMuK,aAE3CJ,EAAQ7vB,MAAQ5C,EAAA6C,SAAS6M,YACzB+iB,EAAQ7vB,MAAQ5C,EAAA6C,SAAS+M,eACzB6iB,EAAQ7vB,MAAQ5C,EAAA6C,SAAS8M,gBAEzBj0B,KAAKijB,MACHmB,EAAAjC,eAAeijD,0FACfruB,EAAQ91B,OAIPqD,EAAA80B,KAAKwD,4BAA4BqI,EAAOlO,EAASyoB,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,OAhBvD,KAmBzB,OAAQN,GAIN,IAAKhmB,GAAA2N,MAAMuZ,UAGT,GAAIqZ,EAAGrX,KAAKlpB,EAAA2N,MAAMwZ,YAChB,MAAOpmD,MAAKsjE,8BACV9D,EACAl7C,EAAA80B,KAAKI,2BAA2B,GAAIgmB,EAAGv+C,MAAM4/C,EAAUA,QAEvD,EAGJrB,GAAGpX,MACH,IAAIid,IAAQ,CACZ,IACE,OAAQ7F,EAAG17C,MAAK,IAGd,IAAKmb,GAAA2N,MAAMuY,YAET,MADAqa,GAAGnX,QACIroD,KAAKqjE,wBAAwB7D,EAGtC,KAAKvgC,GAAA2N,MAAM5Y,WAET,OADAwrC,EAAGlX,iBACKkX,EAAG17C,QAGT,IAAKmb,GAAA2N,MAAMwZ,WACT,IAAKoZ,EAAGrX,KAAKlpB,EAAA2N,MAAMka,oBAAqB,CACtCue,GAAQ,CACR,OAKJ,IAAKpmC,GAAA2N,MAAMma,SACX,IAAK9nB,GAAA2N,MAAMga,MAET,MADA4Y,GAAGnX,QACIroD,KAAKqjE,wBAAwB7D,EAGtC,KAAKvgC,GAAA2N,MAAMtD,MACT,KAIF,SACE+7B,GAAQ,EAGZ,KAGF,SACEA,GAAQ,SAGLA,EAKT,OAJA7F,GAAGnX,QAGHr3C,EAAOhR,KAAKyhE,gBAAgBjC,GACvBxuD,EACAwuD,EAAGrX,KAAKlpB,EAAA2N,MAAMwZ,YAOZ9hC,EAAA80B,KAAKoC,8BAA8BxqC,EAAMwuD,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,OANpEvlD,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,MANS,IAWpB,KAAKge,GAAA2N,MAAMoa,YACT,GAAIpS,GAAqB,GAAIlxC,MAE7B,KAAK87D,EAAGrX,KAAKlpB,EAAA2N,MAAMqa,cAAe,CAChC,EAAG,CACD,GAAIuY,EAAG1X,QAAU7oB,EAAA2N,MAAMtD,MACrBt4B,EAAO,SAGP,MADAA,EAAOhR,KAAKyhE,gBAAgBjC,EAAI,IACrB,MAAO,KAGpB,IADA5qB,EAAmBjxC,KAAKqN,GACpBwuD,EAAG1X,QAAU7oB,EAAA2N,MAAMqa,aAAc,YAC9BuY,EAAGrX,KAAKlpB,EAAA2N,MAAMtD,OACvB,KAAKk2B,EAAGrX,KAAKlpB,EAAA2N,MAAMqa,cAKjB,MAJAjnD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,KAGX,MAAOqD,GAAA80B,KAAKM,6BAA6B9E,EAAoB4qB,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAGrF,KAAKtmB,GAAA2N,MAAMC,SACT,GAAIpZ,GAASzzB,KAAK0gE,UAAUlB,EAC5B,OAAK/rC,GACA+rC,EAAGrX,KAAKlpB,EAAA2N,MAAMQ,cAOnBp8B,EAAOhR,KAAKyhE,gBAAgBjC,EAAE,IACzBxuD,EACEsT,EAAA80B,KAAKQ,0BAAyB,EAEnC5oC,EACAyiB,EACA+rC,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MALN,OAPhBvlD,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,MANW,IAiBtB,KAAKge,GAAA2N,MAAM5Y,WACT,MAAO1P,GAAA80B,KAAKI,2BAA2BgmB,EAAGlX,iBAAkBkX,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAEpF,KAAKtmB,GAAA2N,MAAMjZ,KACT,MAAOrP,GAAA80B,KAAKkD,qBAAqBkjB,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAEzD,KAAKtmB,GAAA2N,MAAMvf,YACT,MAAO/I,GAAA80B,KAAKkB,4BAA4BklB,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAEhE,KAAKtmB,GAAA2N,MAAM9Y,MACT,MAAOxP,GAAA80B,KAAKgD,sBAAsBojB,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAE1D,KAAKtmB,GAAA2N,MAAMsZ,cACT,MAAO5hC,GAAA80B,KAAK8C,8BAA8BsjB,EAAGt8D,aAAcs8D,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAEnF,KAAKtmB,GAAA2N,MAAM+Z,eACT,MAAOriC,GAAA80B,KAAK8B,+BAA+BskB,EAAGrW,cAAeqW,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAErF,KAAKtmB,GAAA2N,MAAM0Z,aACT,MAAOhiC,GAAA80B,KAAKwB,6BAA6B4kB,EAAGpV,YAAaoV,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAIjF,KAAKtmB,GAAA2N,MAAMuD,MACT,GAAIm1B,GAAgB9F,EAAG1W,mBACvB,OAAK0W,GAAGrX,KAAKlpB,EAAA2N,MAAMuD,OAOZ7rB,EAAA80B,KAAKwC,8BACV0pB,EACA9F,EAAGvW,kBACHuW,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,OATtBvlD,KAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,KAQX,KAAKge,GAAA2N,MAAMvU,SACT,MAAOr4B,MAAKqjE,wBAAwB7D,EAEtC,SAKE,MAJAx/D,MAAKijB,MACHmB,EAAAjC,eAAeojD,oBACf/F,EAAGv+C,SAEE,OAIby5C,EAAAl5D,UAAAgkE,qCAAA,SACEhG,GAMA,GADAA,EAAGpX,QACEoX,EAAGrX,KAAKlpB,EAAA2N,MAAMC,UAAW,MAAO,KACrC,IAAI5b,GAAgB,GAAIvtB,MACxB,GAAG,CACD,GAAIiO,GAAO3R,KAAK0gE,UAAUlB,GAAI,GAAM,EACpC,KAAK7tD,EAEH,MADA6tD,GAAGnX,QACI,IAETp3B,GAActtB,KAAKgO,SACZ6tD,EAAGrX,KAAKlpB,EAAA2N,MAAMtD,OACvB,OAAIk2B,GAAGrX,KAAKlpB,EAAA2N,MAAMQ,cAAgBoyB,EAAGrX,KAAKlpB,EAAA2N,MAAMuZ,WACvCl1B,GAETuuC,EAAGnX,QACI,OAGTqS,EAAAl5D,UAAA2/D,eAAA,SACE3B,GAKA,GAAIxrB,GAAO,GAAItwC,MACf,KAAK87D,EAAGrX,KAAKlpB,EAAA2N,MAAMwZ,YAAa,CAC9B,EAAG,CACD,GAAIp1C,GAAOhR,KAAKyhE,gBAAgBjC,EAAI,EACpC,KAAKxuD,EAAM,MAAO,KAClBgjC,GAAKrwC,KAAKqN,SACHwuD,EAAGrX,KAAKlpB,EAAA2N,MAAMtD,OACvB,KAAKk2B,EAAGrX,KAAKlpB,EAAA2N,MAAMwZ,YAKjB,MAJApmD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,KAGX,MAAO+yB,IAGT0mB,EAAAl5D,UAAAigE,gBAAA,SACEjC,EACAiG,OAAA,KAAAA,MAAA,EAGA,IAAIz0D,GAAOhR,KAAKmlE,qBAAqB3F,EACrC,KAAKxuD,EAAM,MAAO,KAClB,IAAI6vD,GAAW7vD,EAAKiQ,MAAMW,MAGtBqP,EAAgBjxB,KAAKwlE,qCAAqChG,EAE9D,IAAIvuC,GAAiBuuC,EAAGrX,KAAKlpB,EAAA2N,MAAMuZ,WAAY,CAC7C,GAAInS,GAAOh0C,KAAKmhE,eAAe3B,EAC/B,KAAKxrB,EAAM,MAAO,KAClBhjC,GAAOsT,EAAA80B,KAAKa,qBAAqBjpC,EAAMigB,EAAe+iB,EAAMwrB,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MAMpF,IAHA,GAAIN,GAEAygB,EADA5hD,EAA0B,MAG3B4hD,EAAiBtG,EAAoBna,EAAQua,EAAG1X,UAAY2d,GAI7D,OAFAjG,EAAG17C,OAEKmhC,GAGN,IAAKhmB,GAAA2N,MAAM2W,GACT,GAAI9vB,GAASzzB,KAAK0gE,UAAUlB,EAC5B,KAAK/rC,EAAQ,MAAO,KACpBziB,GAAOsT,EAAA80B,KAAKQ,0BAAyB,EAEnC5oC,EACAyiB,EACA+rC,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAExB,MAGF,KAAKtmB,GAAA2N,MAAMoa,YAET,KADAljC,EAAO9jB,KAAKyhE,gBAAgBjC,IACjB,MAAO,KAClB,KAAKA,EAAGrX,KAAKlpB,EAAA2N,MAAMqa,cAKjB,MAJAjnD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,IAETjQ,GAAOsT,EAAA80B,KAAKoB,8BACVxpC,EACA8S,EACA07C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAExB,MAGF,KAAKtmB,GAAA2N,MAAMoK,UACX,IAAK/X,GAAA2N,MAAMuK,YAEPnmC,EAAKkW,MAAQ5C,EAAA6C,SAAS6M,YACtBhjB,EAAKkW,MAAQ5C,EAAA6C,SAAS+M,eACtBljB,EAAKkW,MAAQ5C,EAAA6C,SAAS8M,gBAEtBj0B,KAAKijB,MACHmB,EAAAjC,eAAeijD,0FACfp0D,EAAKiQ,OAGTjQ,EAAOsT,EAAA80B,KAAKsD,6BACVuI,EACAj0C,EACAwuD,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAExB,MAGF,KAAKtmB,GAAA2N,MAAMma,SACT,GAAIpQ,GAAS32C,KAAKyhE,gBAAgBjC,EAClC,KAAK7oB,EAAQ,MAAO,KACpB,KAAK6oB,EAAGrX,KAAKlpB,EAAA2N,MAAMga,OAKjB,MAJA5mD,MAAKijB,MACHmB,EAAAjC,eAAeskC,YACf+Y,EAAGv+C,QAAS,KAEP,IAET,IAAI21B,GAAS52C,KAAKyhE,gBAAgBjC,EAClC,KAAK5oB,EAAQ,MAAO,KACpB5lC,GAAOsT,EAAA80B,KAAK4C,wBACVhrC,EACA2lC,EACAC,EACA4oB,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KAExB,MAGF,KAAKtmB,GAAA2N,MAAMtD,MACT,GAAIq8B,IAA6B30D,EACjC,GAAG,CAED,KADAA,EAAOhR,KAAKyhE,gBAAgBjC,EAAI,IACrB,MAAO,KAClBmG,GAAWhiE,KAAKqN,SACTwuD,EAAGrX,KAAKlpB,EAAA2N,MAAMtD,OACvBt4B,GAAOsT,EAAA80B,KAAKgB,sBAAsBurB,EAAYnG,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,KACpE,MAEF,SAME,KALAzhC,EAAO9jB,KAAKyhE,gBAAgBjC,EAC1BH,EAAmBpa,GACfygB,EACAA,EAAiB,IAEZ,MAAO,KAGlB,IAAIzgB,GAAShmB,EAAA2N,MAAM2Z,IACjB,GAAIziC,EAAKoD,MAAQ5C,EAAA6C,SAAS6M,WACxBhjB,EAAOsT,EAAA80B,KAAKsC,+BACV1qC,EACsB8S,EACtB07C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,UAEnB,IAAIzhC,EAAKoD,MAAQ5C,EAAA6C,SAASgN,KAqB/B,MAJAn0B,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACfj9C,EAAK7C,OAEA,IApBP,IAAI2kD,GAA+B9hD,CACnC,IAAI8hD,EAAavxD,WAAW6S,MAAQ5C,EAAA6C,SAAS6M,WAW3C,MAJAh0B,MAAKijB,MACHmB,EAAAjC,eAAe4+C,oBACf6E,EAAavxD,WAAW4M,OAEnB,IAVP2kD,GAAavxD,WAAaiQ,EAAA80B,KAAKsC,+BAC7B1qC,EACsB40D,EAAavxD,WACnCmrD,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MAS1Bv0C,EAAO40D,MAWT50D,GAAOsT,EAAA80B,KAAKW,uBAAuBkL,EAAOj0C,EAAM8S,EAAM07C,EAAGv+C,MAAM4/C,EAAUrB,EAAGja,MAKpF,MAAOv0C,IAEX0pD,GA1hF4Bt2C,EAAAtB,kBAAfpjB,GAAAg7D,UA6hFb,SAAkBmL,GAChBA,IAAA,iBACAA,IAAA,mBACAA,IAAA,iBACAA,IAAA,2BACAA,IAAA,6BACAA,IAAA,2BACAA,IAAA,6BACAA,IAAA,2BACAA,IAAA,6BACAA,IAAA,6BACAA,IAAA,wBACAA,IAAA,4BACAA,IAAA,kBACAA,IAAA,wBACAA,IAAA,oCACAA,IAAA,kCACAA,IAAA,gCACAA,IAAA,kCACAA,IAAA,gBACAA,IAAA,gCACAA,IAAA,wBACAA,IAAA,uBAtBgBnmE,EAAAmmE,aAAAnmE,EAAAmmE","file":"assemblyscript.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"binaryen\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"binaryen\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"assemblyscript\"] = factory(require(\"binaryen\"));\n\telse\n\t\troot[\"assemblyscript\"] = factory(root[\"binaryen\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_15__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"binaryen\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"binaryen\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"assemblyscript\"] = factory(require(\"binaryen\"));\n\telse\n\t\troot[\"assemblyscript\"] = factory(root[\"binaryen\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_15__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 11);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar compiler_1 = __webpack_require__(4);\r\nvar NativeType;\r\n(function (NativeType) {\r\n    NativeType[NativeType[\"None\"] = _BinaryenTypeNone()] = \"None\";\r\n    NativeType[NativeType[\"I32\"] = _BinaryenTypeInt32()] = \"I32\";\r\n    NativeType[NativeType[\"I64\"] = _BinaryenTypeInt64()] = \"I64\";\r\n    NativeType[NativeType[\"F32\"] = _BinaryenTypeFloat32()] = \"F32\";\r\n    NativeType[NativeType[\"F64\"] = _BinaryenTypeFloat64()] = \"F64\";\r\n    NativeType[NativeType[\"Unreachable\"] = _BinaryenTypeUnreachable()] = \"Unreachable\";\r\n    NativeType[NativeType[\"Auto\"] = _BinaryenTypeAuto()] = \"Auto\";\r\n})(NativeType = exports.NativeType || (exports.NativeType = {}));\r\nvar ExpressionId;\r\n(function (ExpressionId) {\r\n    ExpressionId[ExpressionId[\"Invalid\"] = _BinaryenInvalidId()] = \"Invalid\";\r\n    ExpressionId[ExpressionId[\"Block\"] = _BinaryenBlockId()] = \"Block\";\r\n    ExpressionId[ExpressionId[\"If\"] = _BinaryenIfId()] = \"If\";\r\n    ExpressionId[ExpressionId[\"Loop\"] = _BinaryenLoopId()] = \"Loop\";\r\n    ExpressionId[ExpressionId[\"Break\"] = _BinaryenBreakId()] = \"Break\";\r\n    ExpressionId[ExpressionId[\"Switch\"] = _BinaryenSwitchId()] = \"Switch\";\r\n    ExpressionId[ExpressionId[\"Call\"] = _BinaryenCallId()] = \"Call\";\r\n    ExpressionId[ExpressionId[\"CallImport\"] = _BinaryenCallImportId()] = \"CallImport\";\r\n    ExpressionId[ExpressionId[\"CallIndirect\"] = _BinaryenCallIndirectId()] = \"CallIndirect\";\r\n    ExpressionId[ExpressionId[\"GetLocal\"] = _BinaryenGetLocalId()] = \"GetLocal\";\r\n    ExpressionId[ExpressionId[\"SetLocal\"] = _BinaryenSetLocalId()] = \"SetLocal\";\r\n    ExpressionId[ExpressionId[\"GetGlobal\"] = _BinaryenGetGlobalId()] = \"GetGlobal\";\r\n    ExpressionId[ExpressionId[\"SetGlobal\"] = _BinaryenSetGlobalId()] = \"SetGlobal\";\r\n    ExpressionId[ExpressionId[\"Load\"] = _BinaryenLoadId()] = \"Load\";\r\n    ExpressionId[ExpressionId[\"Store\"] = _BinaryenStoreId()] = \"Store\";\r\n    ExpressionId[ExpressionId[\"Const\"] = _BinaryenConstId()] = \"Const\";\r\n    ExpressionId[ExpressionId[\"Unary\"] = _BinaryenUnaryId()] = \"Unary\";\r\n    ExpressionId[ExpressionId[\"Binary\"] = _BinaryenBinaryId()] = \"Binary\";\r\n    ExpressionId[ExpressionId[\"Select\"] = _BinaryenSelectId()] = \"Select\";\r\n    ExpressionId[ExpressionId[\"Drop\"] = _BinaryenDropId()] = \"Drop\";\r\n    ExpressionId[ExpressionId[\"Return\"] = _BinaryenReturnId()] = \"Return\";\r\n    ExpressionId[ExpressionId[\"Host\"] = _BinaryenHostId()] = \"Host\";\r\n    ExpressionId[ExpressionId[\"Nop\"] = _BinaryenNopId()] = \"Nop\";\r\n    ExpressionId[ExpressionId[\"Unreachable\"] = _BinaryenUnreachableId()] = \"Unreachable\";\r\n    ExpressionId[ExpressionId[\"AtomicCmpxchg\"] = _BinaryenAtomicCmpxchgId()] = \"AtomicCmpxchg\";\r\n    ExpressionId[ExpressionId[\"AtomicRMW\"] = _BinaryenAtomicRMWId()] = \"AtomicRMW\";\r\n    ExpressionId[ExpressionId[\"AtomicWait\"] = _BinaryenAtomicWaitId()] = \"AtomicWait\";\r\n    ExpressionId[ExpressionId[\"AtomicWake\"] = _BinaryenAtomicWakeId()] = \"AtomicWake\";\r\n})(ExpressionId = exports.ExpressionId || (exports.ExpressionId = {}));\r\nvar UnaryOp;\r\n(function (UnaryOp) {\r\n    UnaryOp[UnaryOp[\"ClzI32\"] = _BinaryenClzInt32()] = \"ClzI32\";\r\n    UnaryOp[UnaryOp[\"CtzI32\"] = _BinaryenCtzInt32()] = \"CtzI32\";\r\n    UnaryOp[UnaryOp[\"PopcntI32\"] = _BinaryenPopcntInt32()] = \"PopcntI32\";\r\n    UnaryOp[UnaryOp[\"NegF32\"] = _BinaryenNegFloat32()] = \"NegF32\";\r\n    UnaryOp[UnaryOp[\"AbsF32\"] = _BinaryenAbsFloat32()] = \"AbsF32\";\r\n    UnaryOp[UnaryOp[\"CeilF32\"] = _BinaryenCeilFloat32()] = \"CeilF32\";\r\n    UnaryOp[UnaryOp[\"FloorF32\"] = _BinaryenFloorFloat32()] = \"FloorF32\";\r\n    UnaryOp[UnaryOp[\"TruncF32\"] = _BinaryenTruncFloat32()] = \"TruncF32\";\r\n    UnaryOp[UnaryOp[\"NearestF32\"] = _BinaryenNearestFloat32()] = \"NearestF32\";\r\n    UnaryOp[UnaryOp[\"SqrtF32\"] = _BinaryenSqrtFloat32()] = \"SqrtF32\";\r\n    UnaryOp[UnaryOp[\"EqzI32\"] = _BinaryenEqZInt32()] = \"EqzI32\";\r\n    UnaryOp[UnaryOp[\"ClzI64\"] = _BinaryenClzInt64()] = \"ClzI64\";\r\n    UnaryOp[UnaryOp[\"CtzI64\"] = _BinaryenCtzInt64()] = \"CtzI64\";\r\n    UnaryOp[UnaryOp[\"PopcntI64\"] = _BinaryenPopcntInt64()] = \"PopcntI64\";\r\n    UnaryOp[UnaryOp[\"NegF64\"] = _BinaryenNegFloat64()] = \"NegF64\";\r\n    UnaryOp[UnaryOp[\"AbsF64\"] = _BinaryenAbsFloat64()] = \"AbsF64\";\r\n    UnaryOp[UnaryOp[\"CeilF64\"] = _BinaryenCeilFloat64()] = \"CeilF64\";\r\n    UnaryOp[UnaryOp[\"FloorF64\"] = _BinaryenFloorFloat64()] = \"FloorF64\";\r\n    UnaryOp[UnaryOp[\"TruncF64\"] = _BinaryenTruncFloat64()] = \"TruncF64\";\r\n    UnaryOp[UnaryOp[\"NearestF64\"] = _BinaryenNearestFloat64()] = \"NearestF64\";\r\n    UnaryOp[UnaryOp[\"SqrtF64\"] = _BinaryenSqrtFloat64()] = \"SqrtF64\";\r\n    UnaryOp[UnaryOp[\"EqzI64\"] = _BinaryenEqZInt64()] = \"EqzI64\";\r\n    UnaryOp[UnaryOp[\"ExtendI32\"] = _BinaryenExtendSInt32()] = \"ExtendI32\";\r\n    UnaryOp[UnaryOp[\"ExtendU32\"] = _BinaryenExtendUInt32()] = \"ExtendU32\";\r\n    UnaryOp[UnaryOp[\"WrapI64\"] = _BinaryenWrapInt64()] = \"WrapI64\";\r\n    UnaryOp[UnaryOp[\"TruncF32ToI32\"] = _BinaryenTruncSFloat32ToInt32()] = \"TruncF32ToI32\";\r\n    UnaryOp[UnaryOp[\"TruncF32ToI64\"] = _BinaryenTruncSFloat32ToInt64()] = \"TruncF32ToI64\";\r\n    UnaryOp[UnaryOp[\"TruncF32ToU32\"] = _BinaryenTruncUFloat32ToInt32()] = \"TruncF32ToU32\";\r\n    UnaryOp[UnaryOp[\"TruncF32ToU64\"] = _BinaryenTruncUFloat32ToInt64()] = \"TruncF32ToU64\";\r\n    UnaryOp[UnaryOp[\"TruncF64ToI32\"] = _BinaryenTruncSFloat64ToInt32()] = \"TruncF64ToI32\";\r\n    UnaryOp[UnaryOp[\"TruncF64ToI64\"] = _BinaryenTruncSFloat64ToInt64()] = \"TruncF64ToI64\";\r\n    UnaryOp[UnaryOp[\"TruncF64ToU32\"] = _BinaryenTruncUFloat64ToInt32()] = \"TruncF64ToU32\";\r\n    UnaryOp[UnaryOp[\"TruncF64ToU64\"] = _BinaryenTruncUFloat64ToInt64()] = \"TruncF64ToU64\";\r\n    UnaryOp[UnaryOp[\"ReinterpretF32\"] = _BinaryenReinterpretFloat32()] = \"ReinterpretF32\";\r\n    UnaryOp[UnaryOp[\"ReinterpretF64\"] = _BinaryenReinterpretFloat64()] = \"ReinterpretF64\";\r\n    UnaryOp[UnaryOp[\"ConvertI32ToF32\"] = _BinaryenConvertSInt32ToFloat32()] = \"ConvertI32ToF32\";\r\n    UnaryOp[UnaryOp[\"ConvertI32ToF64\"] = _BinaryenConvertSInt32ToFloat64()] = \"ConvertI32ToF64\";\r\n    UnaryOp[UnaryOp[\"ConvertU32ToF32\"] = _BinaryenConvertUInt32ToFloat32()] = \"ConvertU32ToF32\";\r\n    UnaryOp[UnaryOp[\"ConvertU32ToF64\"] = _BinaryenConvertUInt32ToFloat64()] = \"ConvertU32ToF64\";\r\n    UnaryOp[UnaryOp[\"ConvertI64ToF32\"] = _BinaryenConvertSInt64ToFloat32()] = \"ConvertI64ToF32\";\r\n    UnaryOp[UnaryOp[\"ConvertI64ToF64\"] = _BinaryenConvertSInt64ToFloat64()] = \"ConvertI64ToF64\";\r\n    UnaryOp[UnaryOp[\"ConvertU64ToF32\"] = _BinaryenConvertUInt64ToFloat32()] = \"ConvertU64ToF32\";\r\n    UnaryOp[UnaryOp[\"ConvertU64ToF64\"] = _BinaryenConvertUInt64ToFloat64()] = \"ConvertU64ToF64\";\r\n    UnaryOp[UnaryOp[\"PromoteF32\"] = _BinaryenPromoteFloat32()] = \"PromoteF32\";\r\n    UnaryOp[UnaryOp[\"DemoteF64\"] = _BinaryenDemoteFloat64()] = \"DemoteF64\";\r\n    UnaryOp[UnaryOp[\"ReinterpretI32\"] = _BinaryenReinterpretInt32()] = \"ReinterpretI32\";\r\n    UnaryOp[UnaryOp[\"ReinterpretI64\"] = _BinaryenReinterpretInt64()] = \"ReinterpretI64\";\r\n    // see: https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md#new-sign-extending-operators\r\n    // ExtendI8ToI32 =_BinaryenExtendS8Int32()\r\n    // ExtendI16ToI32 = _BinaryenExtendS16Int32()\r\n    // ExtendI8ToI64 = _BinaryenExtendS8Int64() // operand is I64\r\n    // ExtendI16ToI64 = _BinaryenExtendS16Int64()\r\n    // ExtendI32ToI64 = _BinaryenExtendS32Int64()\r\n    // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\r\n    // TruncF32ToI32Sat\r\n    // TruncF32ToU32Sat\r\n    // TruncF64ToI32Sat\r\n    // TruncF64ToU32Sat\r\n    // TruncF32ToI64Sat\r\n    // TruncF32ToU64Sat\r\n    // TruncF64ToI64Sat\r\n    // TruncF64ToU64Sat\r\n})(UnaryOp = exports.UnaryOp || (exports.UnaryOp = {}));\r\nvar BinaryOp;\r\n(function (BinaryOp) {\r\n    BinaryOp[BinaryOp[\"AddI32\"] = _BinaryenAddInt32()] = \"AddI32\";\r\n    BinaryOp[BinaryOp[\"SubI32\"] = _BinaryenSubInt32()] = \"SubI32\";\r\n    BinaryOp[BinaryOp[\"MulI32\"] = _BinaryenMulInt32()] = \"MulI32\";\r\n    BinaryOp[BinaryOp[\"DivI32\"] = _BinaryenDivSInt32()] = \"DivI32\";\r\n    BinaryOp[BinaryOp[\"DivU32\"] = _BinaryenDivUInt32()] = \"DivU32\";\r\n    BinaryOp[BinaryOp[\"RemI32\"] = _BinaryenRemSInt32()] = \"RemI32\";\r\n    BinaryOp[BinaryOp[\"RemU32\"] = _BinaryenRemUInt32()] = \"RemU32\";\r\n    BinaryOp[BinaryOp[\"AndI32\"] = _BinaryenAndInt32()] = \"AndI32\";\r\n    BinaryOp[BinaryOp[\"OrI32\"] = _BinaryenOrInt32()] = \"OrI32\";\r\n    BinaryOp[BinaryOp[\"XorI32\"] = _BinaryenXorInt32()] = \"XorI32\";\r\n    BinaryOp[BinaryOp[\"ShlI32\"] = _BinaryenShlInt32()] = \"ShlI32\";\r\n    BinaryOp[BinaryOp[\"ShrU32\"] = _BinaryenShrUInt32()] = \"ShrU32\";\r\n    BinaryOp[BinaryOp[\"ShrI32\"] = _BinaryenShrSInt32()] = \"ShrI32\";\r\n    BinaryOp[BinaryOp[\"RotlI32\"] = _BinaryenRotLInt32()] = \"RotlI32\";\r\n    BinaryOp[BinaryOp[\"RotrI32\"] = _BinaryenRotRInt32()] = \"RotrI32\";\r\n    BinaryOp[BinaryOp[\"EqI32\"] = _BinaryenEqInt32()] = \"EqI32\";\r\n    BinaryOp[BinaryOp[\"NeI32\"] = _BinaryenNeInt32()] = \"NeI32\";\r\n    BinaryOp[BinaryOp[\"LtI32\"] = _BinaryenLtSInt32()] = \"LtI32\";\r\n    BinaryOp[BinaryOp[\"LtU32\"] = _BinaryenLtUInt32()] = \"LtU32\";\r\n    BinaryOp[BinaryOp[\"LeI32\"] = _BinaryenLeSInt32()] = \"LeI32\";\r\n    BinaryOp[BinaryOp[\"LeU32\"] = _BinaryenLeUInt32()] = \"LeU32\";\r\n    BinaryOp[BinaryOp[\"GtI32\"] = _BinaryenGtSInt32()] = \"GtI32\";\r\n    BinaryOp[BinaryOp[\"GtU32\"] = _BinaryenGtUInt32()] = \"GtU32\";\r\n    BinaryOp[BinaryOp[\"GeI32\"] = _BinaryenGeSInt32()] = \"GeI32\";\r\n    BinaryOp[BinaryOp[\"GeU32\"] = _BinaryenGeUInt32()] = \"GeU32\";\r\n    BinaryOp[BinaryOp[\"AddI64\"] = _BinaryenAddInt64()] = \"AddI64\";\r\n    BinaryOp[BinaryOp[\"SubI64\"] = _BinaryenSubInt64()] = \"SubI64\";\r\n    BinaryOp[BinaryOp[\"MulI64\"] = _BinaryenMulInt64()] = \"MulI64\";\r\n    BinaryOp[BinaryOp[\"DivI64\"] = _BinaryenDivSInt64()] = \"DivI64\";\r\n    BinaryOp[BinaryOp[\"DivU64\"] = _BinaryenDivUInt64()] = \"DivU64\";\r\n    BinaryOp[BinaryOp[\"RemI64\"] = _BinaryenRemSInt64()] = \"RemI64\";\r\n    BinaryOp[BinaryOp[\"RemU64\"] = _BinaryenRemUInt64()] = \"RemU64\";\r\n    BinaryOp[BinaryOp[\"AndI64\"] = _BinaryenAndInt64()] = \"AndI64\";\r\n    BinaryOp[BinaryOp[\"OrI64\"] = _BinaryenOrInt64()] = \"OrI64\";\r\n    BinaryOp[BinaryOp[\"XorI64\"] = _BinaryenXorInt64()] = \"XorI64\";\r\n    BinaryOp[BinaryOp[\"ShlI64\"] = _BinaryenShlInt64()] = \"ShlI64\";\r\n    BinaryOp[BinaryOp[\"ShrU64\"] = _BinaryenShrUInt64()] = \"ShrU64\";\r\n    BinaryOp[BinaryOp[\"ShrI64\"] = _BinaryenShrSInt64()] = \"ShrI64\";\r\n    BinaryOp[BinaryOp[\"RotlI64\"] = _BinaryenRotLInt64()] = \"RotlI64\";\r\n    BinaryOp[BinaryOp[\"RotrI64\"] = _BinaryenRotRInt64()] = \"RotrI64\";\r\n    BinaryOp[BinaryOp[\"EqI64\"] = _BinaryenEqInt64()] = \"EqI64\";\r\n    BinaryOp[BinaryOp[\"NeI64\"] = _BinaryenNeInt64()] = \"NeI64\";\r\n    BinaryOp[BinaryOp[\"LtI64\"] = _BinaryenLtSInt64()] = \"LtI64\";\r\n    BinaryOp[BinaryOp[\"LtU64\"] = _BinaryenLtUInt64()] = \"LtU64\";\r\n    BinaryOp[BinaryOp[\"LeI64\"] = _BinaryenLeSInt64()] = \"LeI64\";\r\n    BinaryOp[BinaryOp[\"LeU64\"] = _BinaryenLeUInt64()] = \"LeU64\";\r\n    BinaryOp[BinaryOp[\"GtI64\"] = _BinaryenGtSInt64()] = \"GtI64\";\r\n    BinaryOp[BinaryOp[\"GtU64\"] = _BinaryenGtUInt64()] = \"GtU64\";\r\n    BinaryOp[BinaryOp[\"GeI64\"] = _BinaryenGeSInt64()] = \"GeI64\";\r\n    BinaryOp[BinaryOp[\"GeU64\"] = _BinaryenGeUInt64()] = \"GeU64\";\r\n    BinaryOp[BinaryOp[\"AddF32\"] = _BinaryenAddFloat32()] = \"AddF32\";\r\n    BinaryOp[BinaryOp[\"SubF32\"] = _BinaryenSubFloat32()] = \"SubF32\";\r\n    BinaryOp[BinaryOp[\"MulF32\"] = _BinaryenMulFloat32()] = \"MulF32\";\r\n    BinaryOp[BinaryOp[\"DivF32\"] = _BinaryenDivFloat32()] = \"DivF32\";\r\n    BinaryOp[BinaryOp[\"CopysignF32\"] = _BinaryenCopySignFloat32()] = \"CopysignF32\";\r\n    BinaryOp[BinaryOp[\"MinF32\"] = _BinaryenMinFloat32()] = \"MinF32\";\r\n    BinaryOp[BinaryOp[\"MaxF32\"] = _BinaryenMaxFloat32()] = \"MaxF32\";\r\n    BinaryOp[BinaryOp[\"EqF32\"] = _BinaryenEqFloat32()] = \"EqF32\";\r\n    BinaryOp[BinaryOp[\"NeF32\"] = _BinaryenNeFloat32()] = \"NeF32\";\r\n    BinaryOp[BinaryOp[\"LtF32\"] = _BinaryenLtFloat32()] = \"LtF32\";\r\n    BinaryOp[BinaryOp[\"LeF32\"] = _BinaryenLeFloat32()] = \"LeF32\";\r\n    BinaryOp[BinaryOp[\"GtF32\"] = _BinaryenGtFloat32()] = \"GtF32\";\r\n    BinaryOp[BinaryOp[\"GeF32\"] = _BinaryenGeFloat32()] = \"GeF32\";\r\n    BinaryOp[BinaryOp[\"AddF64\"] = _BinaryenAddFloat64()] = \"AddF64\";\r\n    BinaryOp[BinaryOp[\"SubF64\"] = _BinaryenSubFloat64()] = \"SubF64\";\r\n    BinaryOp[BinaryOp[\"MulF64\"] = _BinaryenMulFloat64()] = \"MulF64\";\r\n    BinaryOp[BinaryOp[\"DivF64\"] = _BinaryenDivFloat64()] = \"DivF64\";\r\n    BinaryOp[BinaryOp[\"CopysignF64\"] = _BinaryenCopySignFloat64()] = \"CopysignF64\";\r\n    BinaryOp[BinaryOp[\"MinF64\"] = _BinaryenMinFloat64()] = \"MinF64\";\r\n    BinaryOp[BinaryOp[\"MaxF64\"] = _BinaryenMaxFloat64()] = \"MaxF64\";\r\n    BinaryOp[BinaryOp[\"EqF64\"] = _BinaryenEqFloat64()] = \"EqF64\";\r\n    BinaryOp[BinaryOp[\"NeF64\"] = _BinaryenNeFloat64()] = \"NeF64\";\r\n    BinaryOp[BinaryOp[\"LtF64\"] = _BinaryenLtFloat64()] = \"LtF64\";\r\n    BinaryOp[BinaryOp[\"LeF64\"] = _BinaryenLeFloat64()] = \"LeF64\";\r\n    BinaryOp[BinaryOp[\"GtF64\"] = _BinaryenGtFloat64()] = \"GtF64\";\r\n    BinaryOp[BinaryOp[\"GeF64\"] = _BinaryenGeFloat64()] = \"GeF64\";\r\n})(BinaryOp = exports.BinaryOp || (exports.BinaryOp = {}));\r\nvar HostOp;\r\n(function (HostOp) {\r\n    HostOp[HostOp[\"PageSize\"] = _BinaryenPageSize()] = \"PageSize\";\r\n    HostOp[HostOp[\"CurrentMemory\"] = _BinaryenCurrentMemory()] = \"CurrentMemory\";\r\n    HostOp[HostOp[\"GrowMemory\"] = _BinaryenGrowMemory()] = \"GrowMemory\";\r\n    HostOp[HostOp[\"HasFeature\"] = _BinaryenHasFeature()] = \"HasFeature\";\r\n    // see: https://github.com/WebAssembly/bulk-memory-operations\r\n    // MoveMemory\r\n    // SetMemory\r\n})(HostOp = exports.HostOp || (exports.HostOp = {}));\r\nvar AtomicRMWOp;\r\n(function (AtomicRMWOp) {\r\n    AtomicRMWOp[AtomicRMWOp[\"Add\"] = _BinaryenAtomicRMWAdd()] = \"Add\";\r\n    AtomicRMWOp[AtomicRMWOp[\"Sub\"] = _BinaryenAtomicRMWSub()] = \"Sub\";\r\n    AtomicRMWOp[AtomicRMWOp[\"And\"] = _BinaryenAtomicRMWAnd()] = \"And\";\r\n    AtomicRMWOp[AtomicRMWOp[\"Or\"] = _BinaryenAtomicRMWOr()] = \"Or\";\r\n    AtomicRMWOp[AtomicRMWOp[\"Xor\"] = _BinaryenAtomicRMWXor()] = \"Xor\";\r\n    AtomicRMWOp[AtomicRMWOp[\"Xchg\"] = _BinaryenAtomicRMWXchg()] = \"Xchg\";\r\n})(AtomicRMWOp = exports.AtomicRMWOp || (exports.AtomicRMWOp = {}));\r\nvar MemorySegment = /** @class */ (function () {\r\n    function MemorySegment() {\r\n    }\r\n    MemorySegment.create = function (buffer, offset) {\r\n        var segment = new MemorySegment();\r\n        segment.buffer = buffer;\r\n        segment.offset = offset;\r\n        return segment;\r\n    };\r\n    return MemorySegment;\r\n}());\r\nexports.MemorySegment = MemorySegment;\r\nvar Module = /** @class */ (function () {\r\n    function Module() {\r\n    }\r\n    // TODO: static readonly MAX_MEMORY_WASM64\r\n    Module.create = function () {\r\n        var module = new Module();\r\n        module.ref = _BinaryenModuleCreate();\r\n        module.out = allocate_memory(16);\r\n        return module;\r\n    };\r\n    Module.createFrom = function (buffer) {\r\n        var cArr = allocU8Array(buffer);\r\n        try {\r\n            var module = new Module();\r\n            module.ref = _BinaryenModuleRead(cArr, buffer.length);\r\n            module.out = allocate_memory(3 * 8); // LLVM C-ABI, max used is 3 * usize\r\n            return module;\r\n        }\r\n        finally {\r\n            free_memory(changetype(cArr));\r\n        }\r\n    };\r\n    // types\r\n    Module.prototype.addFunctionType = function (name, result, paramTypes) {\r\n        var cStr = allocString(name);\r\n        var cArr = allocI32Array(paramTypes);\r\n        try {\r\n            return _BinaryenAddFunctionType(this.ref, cStr, result, cArr, paramTypes.length);\r\n        }\r\n        finally {\r\n            free_memory(cArr);\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.getFunctionTypeBySignature = function (result, paramTypes) {\r\n        var cArr = allocI32Array(paramTypes);\r\n        try {\r\n            return _BinaryenGetFunctionTypeBySignature(this.ref, result, cArr, paramTypes.length);\r\n        }\r\n        finally {\r\n            free_memory(cArr);\r\n        }\r\n    };\r\n    // constants\r\n    Module.prototype.createI32 = function (value) {\r\n        var out = this.out;\r\n        _BinaryenLiteralInt32(out, value);\r\n        return _BinaryenConst(this.ref, out);\r\n    };\r\n    Module.prototype.createI64 = function (valueLow, valueHigh) {\r\n        if (valueHigh === void 0) { valueHigh = 0; }\r\n        var out = this.out;\r\n        _BinaryenLiteralInt64(out, valueLow, valueHigh);\r\n        return _BinaryenConst(this.ref, out);\r\n    };\r\n    Module.prototype.createF32 = function (value) {\r\n        var out = this.out;\r\n        _BinaryenLiteralFloat32(out, value);\r\n        return _BinaryenConst(this.ref, out);\r\n    };\r\n    Module.prototype.createF64 = function (value) {\r\n        var out = this.out;\r\n        _BinaryenLiteralFloat64(out, value);\r\n        return _BinaryenConst(this.ref, out);\r\n    };\r\n    // expressions\r\n    Module.prototype.createUnary = function (op, expr) {\r\n        return _BinaryenUnary(this.ref, op, expr);\r\n    };\r\n    Module.prototype.createBinary = function (op, left, right) {\r\n        return _BinaryenBinary(this.ref, op, left, right);\r\n    };\r\n    Module.prototype.createHost = function (op, name, operands) {\r\n        if (name === void 0) { name = null; }\r\n        if (operands === void 0) { operands = null; }\r\n        var cStr = allocString(name);\r\n        var cArr = allocI32Array(operands);\r\n        try {\r\n            return _BinaryenHost(this.ref, op, cStr, cArr, operands ? operands.length : 0);\r\n        }\r\n        finally {\r\n            free_memory(cArr);\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.createGetLocal = function (index, type) {\r\n        return _BinaryenGetLocal(this.ref, index, type);\r\n    };\r\n    Module.prototype.createTeeLocal = function (index, value) {\r\n        return _BinaryenTeeLocal(this.ref, index, value);\r\n    };\r\n    Module.prototype.createGetGlobal = function (name, type) {\r\n        var cStr = allocString(name);\r\n        try {\r\n            return _BinaryenGetGlobal(this.ref, cStr, type);\r\n        }\r\n        finally {\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.createLoad = function (bytes, signed, ptr, type, offset) {\r\n        if (offset === void 0) { offset = 0; }\r\n        return _BinaryenLoad(this.ref, bytes, signed ? 1 : 0, offset, /* always aligned */ bytes, type, ptr);\r\n    };\r\n    Module.prototype.createStore = function (bytes, ptr, value, type, offset) {\r\n        if (offset === void 0) { offset = 0; }\r\n        return _BinaryenStore(this.ref, bytes, offset, /* always aligned */ bytes, ptr, value, type);\r\n    };\r\n    Module.prototype.createAtomicLoad = function (bytes, ptr, type, offset) {\r\n        if (offset === void 0) { offset = 0; }\r\n        return _BinaryenAtomicLoad(this.ref, bytes, offset, type, ptr);\r\n    };\r\n    Module.prototype.createAtomicStore = function (bytes, ptr, value, type, offset) {\r\n        if (offset === void 0) { offset = 0; }\r\n        return _BinaryenAtomicStore(this.ref, bytes, offset, ptr, value, type);\r\n    };\r\n    Module.prototype.createAtomicRMW = function (op, bytes, offset, ptr, value, type) {\r\n        return _BinaryenAtomicRMW(this.ref, op, bytes, offset, ptr, value, type);\r\n    };\r\n    Module.prototype.createAtomicCmpxchg = function (bytes, offset, ptr, expected, replacement, type) {\r\n        return _BinaryenAtomicCmpxchg(this.ref, bytes, offset, ptr, expected, replacement, type);\r\n    };\r\n    Module.prototype.createAtomicWait = function (ptr, expected, timeout, expectedType) {\r\n        return _BinaryenAtomicWait(this.ref, ptr, expected, timeout, expectedType);\r\n    };\r\n    Module.prototype.createAtomicWake = function (ptr, wakeCount) {\r\n        return _BinaryenAtomicWake(this.ref, ptr, wakeCount);\r\n    };\r\n    // statements\r\n    Module.prototype.createSetLocal = function (index, value) {\r\n        return _BinaryenSetLocal(this.ref, index, value);\r\n    };\r\n    Module.prototype.createSetGlobal = function (name, value) {\r\n        var cStr = allocString(name);\r\n        try {\r\n            return _BinaryenSetGlobal(this.ref, cStr, value);\r\n        }\r\n        finally {\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.createBlock = function (label, children, type) {\r\n        if (type === void 0) { type = NativeType.None; }\r\n        var cStr = allocString(label);\r\n        var cArr = allocI32Array(children);\r\n        try {\r\n            return _BinaryenBlock(this.ref, cStr, cArr, children.length, type);\r\n        }\r\n        finally {\r\n            free_memory(cArr);\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.createBreak = function (label, condition, value) {\r\n        if (condition === void 0) { condition = 0; }\r\n        if (value === void 0) { value = 0; }\r\n        var cStr = allocString(label);\r\n        try {\r\n            return _BinaryenBreak(this.ref, cStr, condition, value);\r\n        }\r\n        finally {\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.createDrop = function (expression) {\r\n        return _BinaryenDrop(this.ref, expression);\r\n    };\r\n    Module.prototype.createLoop = function (label, body) {\r\n        var cStr = allocString(label);\r\n        try {\r\n            return _BinaryenLoop(this.ref, cStr, body);\r\n        }\r\n        finally {\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.createIf = function (condition, ifTrue, ifFalse) {\r\n        if (ifFalse === void 0) { ifFalse = 0; }\r\n        return _BinaryenIf(this.ref, condition, ifTrue, ifFalse);\r\n    };\r\n    Module.prototype.createNop = function () {\r\n        return _BinaryenNop(this.ref);\r\n    };\r\n    Module.prototype.createReturn = function (expression) {\r\n        if (expression === void 0) { expression = 0; }\r\n        return _BinaryenReturn(this.ref, expression);\r\n    };\r\n    Module.prototype.createSelect = function (ifTrue, ifFalse, condition) {\r\n        return _BinaryenSelect(this.ref, condition, ifTrue, ifFalse);\r\n    };\r\n    Module.prototype.createSwitch = function (names, defaultName, condition, value) {\r\n        if (value === void 0) { value = 0; }\r\n        var strs = new Array(names.length);\r\n        for (var i = 0, k = names.length; i < k; ++i) {\r\n            strs[i] = allocString(names[i]);\r\n        }\r\n        var cArr = allocI32Array(strs);\r\n        var cStr = allocString(defaultName);\r\n        try {\r\n            return _BinaryenSwitch(this.ref, cArr, k, cStr, condition, value);\r\n        }\r\n        finally {\r\n            free_memory(cStr);\r\n            free_memory(cArr);\r\n            for (i = k - 1; i >= 0; --i)\r\n                free_memory(strs[i]);\r\n        }\r\n    };\r\n    Module.prototype.createCall = function (target, operands, returnType) {\r\n        var cStr = allocString(target);\r\n        var cArr = allocI32Array(operands);\r\n        try {\r\n            return _BinaryenCall(this.ref, cStr, cArr, operands && operands.length || 0, returnType);\r\n        }\r\n        finally {\r\n            free_memory(cArr);\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.createCallImport = function (target, operands, returnType) {\r\n        var cStr = allocString(target);\r\n        var cArr = allocI32Array(operands);\r\n        try {\r\n            return _BinaryenCallImport(this.ref, cStr, cArr, operands && operands.length || 0, returnType);\r\n        }\r\n        finally {\r\n            free_memory(cArr);\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.createUnreachable = function () {\r\n        return _BinaryenUnreachable(this.ref);\r\n    };\r\n    // meta\r\n    Module.prototype.addGlobal = function (name, type, mutable, initializer) {\r\n        var cStr = allocString(name);\r\n        try {\r\n            return _BinaryenAddGlobal(this.ref, cStr, type, mutable ? 1 : 0, initializer);\r\n        }\r\n        finally {\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.addFunction = function (name, type, varTypes, body) {\r\n        var cStr = allocString(name);\r\n        var cArr = allocI32Array(varTypes);\r\n        try {\r\n            return _BinaryenAddFunction(this.ref, cStr, type, cArr, varTypes.length, body);\r\n        }\r\n        finally {\r\n            free_memory(cArr);\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.removeFunction = function (name) {\r\n        var cStr = allocString(name);\r\n        try {\r\n            _BinaryenRemoveFunction(this.ref, cStr);\r\n        }\r\n        finally {\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.addFunctionExport = function (internalName, externalName) {\r\n        var cStr1 = allocString(internalName);\r\n        var cStr2 = allocString(externalName);\r\n        try {\r\n            return _BinaryenAddFunctionExport(this.ref, cStr1, cStr2);\r\n        }\r\n        finally {\r\n            free_memory(cStr2);\r\n            free_memory(cStr1);\r\n        }\r\n    };\r\n    Module.prototype.addTableExport = function (internalName, externalName) {\r\n        var cStr1 = allocString(internalName);\r\n        var cStr2 = allocString(externalName);\r\n        try {\r\n            return _BinaryenAddTableExport(this.ref, cStr1, cStr2);\r\n        }\r\n        finally {\r\n            free_memory(cStr2);\r\n            free_memory(cStr1);\r\n        }\r\n    };\r\n    Module.prototype.addMemoryExport = function (internalName, externalName) {\r\n        var cStr1 = allocString(internalName);\r\n        var cStr2 = allocString(externalName);\r\n        try {\r\n            return _BinaryenAddMemoryExport(this.ref, cStr1, cStr2);\r\n        }\r\n        finally {\r\n            free_memory(cStr2);\r\n            free_memory(cStr1);\r\n        }\r\n    };\r\n    Module.prototype.addGlobalExport = function (internalName, externalName) {\r\n        var cStr1 = allocString(internalName);\r\n        var cStr2 = allocString(externalName);\r\n        try {\r\n            return _BinaryenAddGlobalExport(this.ref, cStr1, cStr2);\r\n        }\r\n        finally {\r\n            free_memory(cStr2);\r\n            free_memory(cStr1);\r\n        }\r\n    };\r\n    Module.prototype.removeExport = function (externalName) {\r\n        var cStr = allocString(externalName);\r\n        try {\r\n            _BinaryenRemoveExport(this.ref, cStr);\r\n        }\r\n        finally {\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.addFunctionImport = function (internalName, externalModuleName, externalBaseName, functionType) {\r\n        var cStr1 = allocString(internalName);\r\n        var cStr2 = allocString(externalModuleName);\r\n        var cStr3 = allocString(externalBaseName);\r\n        try {\r\n            return _BinaryenAddFunctionImport(this.ref, cStr1, cStr2, cStr3, functionType);\r\n        }\r\n        finally {\r\n            free_memory(cStr3);\r\n            free_memory(cStr2);\r\n            free_memory(cStr1);\r\n        }\r\n    };\r\n    Module.prototype.addTableImport = function (internalName, externalModuleName, externalBaseName) {\r\n        var cStr1 = allocString(internalName);\r\n        var cStr2 = allocString(externalModuleName);\r\n        var cStr3 = allocString(externalBaseName);\r\n        try {\r\n            return _BinaryenAddTableImport(this.ref, cStr1, cStr2, cStr3);\r\n        }\r\n        finally {\r\n            free_memory(cStr3);\r\n            free_memory(cStr2);\r\n            free_memory(cStr1);\r\n        }\r\n    };\r\n    Module.prototype.addMemoryImport = function (internalName, externalModuleName, externalBaseName) {\r\n        var cStr1 = allocString(internalName);\r\n        var cStr2 = allocString(externalModuleName);\r\n        var cStr3 = allocString(externalBaseName);\r\n        try {\r\n            return _BinaryenAddMemoryImport(this.ref, cStr1, cStr2, cStr3);\r\n        }\r\n        finally {\r\n            free_memory(cStr3);\r\n            free_memory(cStr2);\r\n            free_memory(cStr1);\r\n        }\r\n    };\r\n    Module.prototype.addGlobalImport = function (internalName, externalModuleName, externalBaseName, globalType) {\r\n        var cStr1 = allocString(internalName);\r\n        var cStr2 = allocString(externalModuleName);\r\n        var cStr3 = allocString(externalBaseName);\r\n        try {\r\n            return _BinaryenAddGlobalImport(this.ref, cStr1, cStr2, cStr3, globalType);\r\n        }\r\n        finally {\r\n            free_memory(cStr3);\r\n            free_memory(cStr2);\r\n            free_memory(cStr1);\r\n        }\r\n    };\r\n    Module.prototype.removeImport = function (internalName) {\r\n        var cStr = allocString(internalName);\r\n        try {\r\n            _BinaryenRemoveImport(this.ref, cStr);\r\n        }\r\n        finally {\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.setMemory = function (initial, maximum, segments, target, exportName) {\r\n        if (exportName === void 0) { exportName = null; }\r\n        var cStr = allocString(exportName);\r\n        var k = segments.length;\r\n        var segs = new Array(k);\r\n        var offs = new Array(k);\r\n        var sizs = new Array(k);\r\n        for (var i = 0; i < k; ++i) {\r\n            var buffer = segments[i].buffer;\r\n            var offset = segments[i].offset;\r\n            segs[i] = allocU8Array(buffer);\r\n            offs[i] = target == compiler_1.Target.WASM64\r\n                ? this.createI64(i64_low(offset), i64_high(offset))\r\n                : this.createI32(i64_low(offset));\r\n            sizs[i] = buffer.length;\r\n        }\r\n        var cArr1 = allocI32Array(segs);\r\n        var cArr2 = allocI32Array(offs);\r\n        var cArr3 = allocI32Array(sizs);\r\n        try {\r\n            _BinaryenSetMemory(this.ref, initial, maximum, cStr, cArr1, cArr2, cArr3, k);\r\n        }\r\n        finally {\r\n            free_memory(cArr3);\r\n            free_memory(cArr2);\r\n            free_memory(cArr1);\r\n            for (i = k - 1; i >= 0; --i)\r\n                free_memory(segs[i]);\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.setFunctionTable = function (funcs) {\r\n        var cArr = allocI32Array(funcs);\r\n        try {\r\n            _BinaryenSetFunctionTable(this.ref, cArr, funcs.length);\r\n        }\r\n        finally {\r\n            free_memory(cArr);\r\n        }\r\n    };\r\n    Module.prototype.setStart = function (func) {\r\n        _BinaryenSetStart(this.ref, func);\r\n    };\r\n    Module.prototype.setOptimizeLevel = function (level) {\r\n        if (level === void 0) { level = 2; }\r\n        _BinaryenSetOptimizeLevel(level);\r\n    };\r\n    Module.prototype.setShrinkLevel = function (level) {\r\n        if (level === void 0) { level = 1; }\r\n        _BinaryenSetShrinkLevel(level);\r\n    };\r\n    Module.prototype.setDebugInfo = function (on) {\r\n        if (on === void 0) { on = false; }\r\n        _BinaryenSetDebugInfo(on);\r\n    };\r\n    Module.prototype.optimize = function (func) {\r\n        if (func === void 0) { func = 0; }\r\n        if (func) {\r\n            _BinaryenFunctionOptimize(func, this.ref);\r\n        }\r\n        else {\r\n            _BinaryenModuleOptimize(this.ref);\r\n        }\r\n    };\r\n    Module.prototype.runPasses = function (passes, func) {\r\n        if (func === void 0) { func = 0; }\r\n        var k = passes.length;\r\n        var names = new Array(k);\r\n        for (var i = 0; i < k; ++i) {\r\n            names[i] = allocString(passes[i]);\r\n        }\r\n        var cArr = allocI32Array(names);\r\n        try {\r\n            if (func) {\r\n                _BinaryenFunctionRunPasses(func, this.ref, cArr, k);\r\n            }\r\n            else {\r\n                _BinaryenModuleRunPasses(this.ref, cArr, k);\r\n            }\r\n        }\r\n        finally {\r\n            free_memory(cArr);\r\n            for (; i >= 0; --i)\r\n                free_memory(names[i]);\r\n        }\r\n    };\r\n    Module.prototype.validate = function () {\r\n        return _BinaryenModuleValidate(this.ref) == 1;\r\n    };\r\n    Module.prototype.interpret = function () {\r\n        _BinaryenModuleInterpret(this.ref);\r\n    };\r\n    Module.prototype.toBinary = function (sourceMapUrl) {\r\n        var out = this.out;\r\n        var cStr = allocString(sourceMapUrl);\r\n        var binaryPtr = 0;\r\n        var sourceMapPtr = 0;\r\n        try {\r\n            _BinaryenModuleAllocateAndWrite(out, this.ref, cStr);\r\n            binaryPtr = readInt(out);\r\n            var binaryBytes = readInt(out + 4);\r\n            sourceMapPtr = readInt(out + 4 * 2);\r\n            var ret = new Binary();\r\n            ret.output = readBuffer(binaryPtr, binaryBytes);\r\n            ret.sourceMap = readString(sourceMapPtr);\r\n            return ret;\r\n        }\r\n        finally {\r\n            if (cStr)\r\n                free_memory(cStr);\r\n            if (binaryPtr)\r\n                free_memory(binaryPtr);\r\n            if (sourceMapPtr)\r\n                free_memory(sourceMapPtr);\r\n        }\r\n    };\r\n    Module.prototype.toText = function () {\r\n        throw new Error(\"not implemented\"); // JS glue overrides this\r\n    };\r\n    Module.prototype.toAsmjs = function () {\r\n        throw new Error(\"not implemented\"); // JS glue overrides this\r\n    };\r\n    Module.prototype.dispose = function () {\r\n        if (!this.ref)\r\n            return; // sic\r\n        _BinaryenModuleDispose(this.ref);\r\n        free_memory(this.out);\r\n    };\r\n    Module.prototype.createRelooper = function () {\r\n        return Relooper.create(this);\r\n    };\r\n    Module.prototype.cloneExpression = function (expr, noSideEffects, maxDepth) {\r\n        if (noSideEffects === void 0) { noSideEffects = false; }\r\n        if (maxDepth === void 0) { maxDepth = i32.MAX_VALUE; }\r\n        if (maxDepth < 0)\r\n            return 0;\r\n        maxDepth -= 1;\r\n        var nested1, nested2;\r\n        switch (_BinaryenExpressionGetId(expr)) {\r\n            case ExpressionId.Const:\r\n                switch (_BinaryenExpressionGetType(expr)) {\r\n                    case NativeType.I32:\r\n                        return this.createI32(_BinaryenConstGetValueI32(expr));\r\n                    case NativeType.I64:\r\n                        return this.createI64(_BinaryenConstGetValueI64Low(expr), _BinaryenConstGetValueI64High(expr));\r\n                    case NativeType.F32:\r\n                        return this.createF32(_BinaryenConstGetValueF32(expr));\r\n                    case NativeType.F64:\r\n                        return this.createF64(_BinaryenConstGetValueF64(expr));\r\n                    default:\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n            case ExpressionId.GetLocal:\r\n                return _BinaryenGetLocal(this.ref, _BinaryenGetLocalGetIndex(expr), _BinaryenExpressionGetType(expr));\r\n            case ExpressionId.GetGlobal:\r\n                var globalName = _BinaryenGetGlobalGetName(expr);\r\n                if (!globalName)\r\n                    break;\r\n                return _BinaryenGetGlobal(this.ref, globalName, _BinaryenExpressionGetType(expr));\r\n            case ExpressionId.Load:\r\n                if (!(nested1 = this.cloneExpression(_BinaryenLoadGetPtr(expr), noSideEffects, maxDepth))) {\r\n                    break;\r\n                }\r\n                return _BinaryenLoadIsAtomic(expr)\r\n                    ? _BinaryenAtomicLoad(this.ref, _BinaryenLoadGetBytes(expr), _BinaryenLoadGetOffset(expr), _BinaryenExpressionGetType(expr), nested1)\r\n                    : _BinaryenLoad(this.ref, _BinaryenLoadGetBytes(expr), _BinaryenLoadIsSigned(expr) ? 1 : 0, _BinaryenLoadGetOffset(expr), _BinaryenLoadGetAlign(expr), _BinaryenExpressionGetType(expr), nested1);\r\n            case ExpressionId.Unary:\r\n                if (!(nested1 = this.cloneExpression(_BinaryenUnaryGetValue(expr), noSideEffects, maxDepth))) {\r\n                    break;\r\n                }\r\n                return _BinaryenUnary(this.ref, _BinaryenUnaryGetOp(expr), nested1);\r\n            case ExpressionId.Binary:\r\n                if (!(nested1 = this.cloneExpression(_BinaryenBinaryGetLeft(expr), noSideEffects, maxDepth))) {\r\n                    break;\r\n                }\r\n                if (!(nested2 = this.cloneExpression(_BinaryenBinaryGetRight(expr), noSideEffects, maxDepth))) {\r\n                    break;\r\n                }\r\n                return _BinaryenBinary(this.ref, _BinaryenBinaryGetOp(expr), nested1, nested2);\r\n        }\r\n        return 0;\r\n    };\r\n    // source map generation\r\n    Module.prototype.addDebugInfoFile = function (name) {\r\n        var cStr = allocString(name);\r\n        try {\r\n            return _BinaryenModuleAddDebugInfoFileName(this.ref, cStr);\r\n        }\r\n        finally {\r\n            free_memory(cStr);\r\n        }\r\n    };\r\n    Module.prototype.getDebugInfoFile = function (index) {\r\n        return readString(_BinaryenModuleGetDebugInfoFileName(this.ref, index));\r\n    };\r\n    Module.prototype.setDebugLocation = function (func, expr, fileIndex, lineNumber, columnNumber) {\r\n        _BinaryenFunctionSetDebugLocation(func, expr, fileIndex, lineNumber, columnNumber);\r\n    };\r\n    Module.MAX_MEMORY_WASM32 = 0xffff;\r\n    return Module;\r\n}());\r\nexports.Module = Module;\r\nvar Relooper = /** @class */ (function () {\r\n    function Relooper() {\r\n    }\r\n    Relooper.create = function (module) {\r\n        var relooper = new Relooper();\r\n        relooper.module = module;\r\n        relooper.ref = _RelooperCreate();\r\n        return relooper;\r\n    };\r\n    Relooper.createStub = function (module) {\r\n        var relooper = new Relooper();\r\n        relooper.module = module;\r\n        relooper.ref = 0;\r\n        return relooper;\r\n    };\r\n    Relooper.prototype.addBlock = function (code) {\r\n        return _RelooperAddBlock(this.ref, code);\r\n    };\r\n    Relooper.prototype.addBranch = function (from, to, condition, code) {\r\n        if (condition === void 0) { condition = 0; }\r\n        if (code === void 0) { code = 0; }\r\n        _RelooperAddBranch(from, to, condition, code);\r\n    };\r\n    Relooper.prototype.addBlockWithSwitch = function (code, condition) {\r\n        return _RelooperAddBlockWithSwitch(this.ref, code, condition);\r\n    };\r\n    Relooper.prototype.addBranchForSwitch = function (from, to, indexes, code) {\r\n        if (code === void 0) { code = 0; }\r\n        var cArr = allocI32Array(indexes);\r\n        try {\r\n            _RelooperAddBranchForSwitch(from, to, cArr, indexes.length, code);\r\n        }\r\n        finally {\r\n            free_memory(cArr);\r\n        }\r\n    };\r\n    Relooper.prototype.renderAndDispose = function (entry, labelHelper) {\r\n        return _RelooperRenderAndDispose(this.ref, entry, labelHelper, this.module.ref);\r\n    };\r\n    return Relooper;\r\n}());\r\nexports.Relooper = Relooper;\r\n// helpers\r\n// can't do stack allocation here: STACKTOP is a global in WASM but a hidden variable in asm.js\r\nfunction allocU8Array(u8s) {\r\n    if (!u8s)\r\n        return 0;\r\n    var ptr = allocate_memory(u8s.length);\r\n    var idx = ptr;\r\n    for (var i = 0, k = u8s.length; i < k; ++i) {\r\n        store(idx++, u8s[i]);\r\n    }\r\n    return ptr;\r\n}\r\nfunction allocI32Array(i32s) {\r\n    if (!i32s)\r\n        return 0;\r\n    var ptr = allocate_memory(i32s.length << 2);\r\n    var idx = ptr;\r\n    for (var i = 0, k = i32s.length; i < k; ++i) {\r\n        var val = i32s[i];\r\n        // store<i32>(idx, val) is not portable\r\n        store(idx, (val & 0xff));\r\n        store(idx + 1, ((val >> 8) & 0xff));\r\n        store(idx + 2, ((val >> 16) & 0xff));\r\n        store(idx + 3, (val >>> 24));\r\n        idx += 4;\r\n    }\r\n    return ptr;\r\n}\r\nfunction stringLengthUTF8(str) {\r\n    var len = 0;\r\n    for (var i = 0, k = str.length; i < k; ++i) {\r\n        var u = str.charCodeAt(i);\r\n        if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {\r\n            u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\r\n        }\r\n        if (u <= 0x7F) {\r\n            ++len;\r\n        }\r\n        else if (u <= 0x7FF) {\r\n            len += 2;\r\n        }\r\n        else if (u <= 0xFFFF) {\r\n            len += 3;\r\n        }\r\n        else if (u <= 0x1FFFFF) {\r\n            len += 4;\r\n        }\r\n        else if (u <= 0x3FFFFFF) {\r\n            len += 5;\r\n        }\r\n        else {\r\n            len += 6;\r\n        }\r\n    }\r\n    return len;\r\n}\r\nfunction allocString(str) {\r\n    if (str == null)\r\n        return 0;\r\n    var ptr = allocate_memory(stringLengthUTF8(str) + 1);\r\n    var idx = ptr;\r\n    for (var i = 0, k = str.length; i < k; ++i) {\r\n        var u = str.charCodeAt(i);\r\n        if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {\r\n            u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\r\n        }\r\n        if (u <= 0x7F) {\r\n            store(idx++, u);\r\n        }\r\n        else if (u <= 0x7FF) {\r\n            store(idx++, (0xC0 | (u >>> 6)));\r\n            store(idx++, (0x80 | (u & 63)));\r\n        }\r\n        else if (u <= 0xFFFF) {\r\n            store(idx++, (0xE0 | (u >>> 12)));\r\n            store(idx++, (0x80 | ((u >>> 6) & 63)));\r\n            store(idx++, (0x80 | (u & 63)));\r\n        }\r\n        else if (u <= 0x1FFFFF) {\r\n            store(idx++, (0xF0 | (u >>> 18)));\r\n            store(idx++, (0x80 | ((u >>> 12) & 63)));\r\n            store(idx++, (0x80 | ((u >>> 6) & 63)));\r\n            store(idx++, (0x80 | (u & 63)));\r\n        }\r\n        else if (u <= 0x3FFFFFF) {\r\n            store(idx++, (0xF8 | (u >>> 24)));\r\n            store(idx++, (0x80 | ((u >>> 18) & 63)));\r\n            store(idx++, (0x80 | ((u >>> 12) & 63)));\r\n            store(idx++, (0x80 | ((u >>> 6) & 63)));\r\n            store(idx++, (0x80 | (u & 63)));\r\n        }\r\n        else {\r\n            store(idx++, (0xFC | (u >>> 30)));\r\n            store(idx++, (0x80 | ((u >>> 24) & 63)));\r\n            store(idx++, (0x80 | ((u >>> 18) & 63)));\r\n            store(idx++, (0x80 | ((u >>> 12) & 63)));\r\n            store(idx++, (0x80 | ((u >>> 6) & 63)));\r\n            store(idx++, (0x80 | (u & 63)));\r\n        }\r\n    }\r\n    store(idx, 0);\r\n    return ptr;\r\n}\r\nfunction readInt(ptr) {\r\n    return (load(ptr) |\r\n        (load(ptr + 1) << 8) |\r\n        (load(ptr + 2) << 16) |\r\n        (load(ptr + 3) << 24));\r\n}\r\nexports.readInt = readInt;\r\nfunction readBuffer(ptr, length) {\r\n    var ret = new Uint8Array(length);\r\n    for (var i = 0; i < length; ++i) {\r\n        ret[i] = load(ptr + i);\r\n    }\r\n    return ret;\r\n}\r\nexports.readBuffer = readBuffer;\r\nfunction readString(ptr) {\r\n    if (!ptr)\r\n        return null;\r\n    var arr = new Array();\r\n    // the following is based on Emscripten's UTF8ArrayToString\r\n    var cp;\r\n    var u1, u2, u3, u4, u5;\r\n    while (cp = load(ptr++)) {\r\n        if (!(cp & 0x80)) {\r\n            arr.push(cp);\r\n            continue;\r\n        }\r\n        u1 = load(ptr++) & 63;\r\n        if ((cp & 0xE0) == 0xC0) {\r\n            arr.push(((cp & 31) << 6) | u1);\r\n            continue;\r\n        }\r\n        u2 = load(ptr++) & 63;\r\n        if ((cp & 0xF0) == 0xE0) {\r\n            cp = ((cp & 15) << 12) | (u1 << 6) | u2;\r\n        }\r\n        else {\r\n            u3 = load(ptr++) & 63;\r\n            if ((cp & 0xF8) == 0xF0) {\r\n                cp = ((cp & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\r\n            }\r\n            else {\r\n                u4 = load(ptr++) & 63;\r\n                if ((cp & 0xFC) == 0xF8) {\r\n                    cp = ((cp & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;\r\n                }\r\n                else {\r\n                    u5 = load(ptr++) & 63;\r\n                    cp = ((cp & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;\r\n                }\r\n            }\r\n        }\r\n        // if (cp < 0x10000) {\r\n        //   arr.push(cp);\r\n        // } else {\r\n        //   var ch = cp - 0x10000;\r\n        //   arr.push(0xD800 | (ch >> 10));\r\n        //   arr.push(0xDC00 | (ch & 0x3FF));\r\n        // }\r\n    }\r\n    // return String.fromCharCodes(arr);\r\n    return String.fromCodePoints(arr);\r\n}\r\nexports.readString = readString;\r\n/** Result structure of {@link Module#toBinary}. */\r\nvar Binary = /** @class */ (function () {\r\n    function Binary() {\r\n    }\r\n    return Binary;\r\n}());\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnosticMessages_generated_1 = __webpack_require__(8);\r\nvar charcode_1 = __webpack_require__(9);\r\nvar diagnosticMessages_generated_2 = __webpack_require__(8);\r\nexports.DiagnosticCode = diagnosticMessages_generated_2.DiagnosticCode;\r\nexports.diagnosticCodeToString = diagnosticMessages_generated_2.diagnosticCodeToString;\r\nvar DiagnosticCategory;\r\n(function (DiagnosticCategory) {\r\n    DiagnosticCategory[DiagnosticCategory[\"INFO\"] = 0] = \"INFO\";\r\n    DiagnosticCategory[DiagnosticCategory[\"WARNING\"] = 1] = \"WARNING\";\r\n    DiagnosticCategory[DiagnosticCategory[\"ERROR\"] = 2] = \"ERROR\";\r\n})(DiagnosticCategory = exports.DiagnosticCategory || (exports.DiagnosticCategory = {}));\r\nfunction diagnosticCategoryToString(category) {\r\n    switch (category) {\r\n        case DiagnosticCategory.INFO: return \"INFO\";\r\n        case DiagnosticCategory.WARNING: return \"WARNING\";\r\n        case DiagnosticCategory.ERROR: return \"ERROR\";\r\n        default: return \"\";\r\n    }\r\n}\r\nexports.diagnosticCategoryToString = diagnosticCategoryToString;\r\nvar colorBlue = \"\\u001b[93m\";\r\nvar colorYellow = \"\\u001b[93m\";\r\nvar colorRed = \"\\u001b[91m\";\r\nvar colorReset = \"\\u001b[0m\";\r\nfunction diagnosticCategoryToColor(category) {\r\n    switch (category) {\r\n        case DiagnosticCategory.INFO: return colorBlue;\r\n        case DiagnosticCategory.WARNING: return colorYellow;\r\n        case DiagnosticCategory.ERROR: return colorRed;\r\n        default: return \"\";\r\n    }\r\n}\r\nexports.diagnosticCategoryToColor = diagnosticCategoryToColor;\r\nvar DiagnosticMessage = /** @class */ (function () {\r\n    function DiagnosticMessage(code, category, message) {\r\n        this.range = null;\r\n        this.code = code;\r\n        this.category = category;\r\n        this.message = message;\r\n    }\r\n    DiagnosticMessage.create = function (code, category, arg0, arg1, arg2) {\r\n        if (arg0 === void 0) { arg0 = null; }\r\n        if (arg1 === void 0) { arg1 = null; }\r\n        if (arg2 === void 0) { arg2 = null; }\r\n        var message = diagnosticMessages_generated_1.diagnosticCodeToString(code);\r\n        if (arg0 != null)\r\n            message = message.replace(\"{0}\", arg0);\r\n        if (arg1 != null)\r\n            message = message.replace(\"{1}\", arg1);\r\n        if (arg2 != null)\r\n            message = message.replace(\"{2}\", arg2);\r\n        return new DiagnosticMessage(code, category, message);\r\n    };\r\n    DiagnosticMessage.createInfo = function (code, arg0, arg1) {\r\n        if (arg0 === void 0) { arg0 = null; }\r\n        if (arg1 === void 0) { arg1 = null; }\r\n        return DiagnosticMessage.create(code, DiagnosticCategory.INFO, arg0, arg1);\r\n    };\r\n    DiagnosticMessage.createWarning = function (code, arg0, arg1) {\r\n        if (arg0 === void 0) { arg0 = null; }\r\n        if (arg1 === void 0) { arg1 = null; }\r\n        return DiagnosticMessage.create(code, DiagnosticCategory.WARNING, arg0, arg1);\r\n    };\r\n    DiagnosticMessage.createError = function (code, arg0, arg1) {\r\n        if (arg0 === void 0) { arg0 = null; }\r\n        if (arg1 === void 0) { arg1 = null; }\r\n        return DiagnosticMessage.create(code, DiagnosticCategory.ERROR, arg0, arg1);\r\n    };\r\n    DiagnosticMessage.prototype.withRange = function (range) {\r\n        this.range = range;\r\n        return this;\r\n    };\r\n    DiagnosticMessage.prototype.toString = function () {\r\n        if (this.range) {\r\n            return (diagnosticCategoryToString(this.category) +\r\n                \" \" +\r\n                this.code.toString(10) +\r\n                \": \\\"\" +\r\n                this.message +\r\n                \"\\\" in \" +\r\n                this.range.source.normalizedPath +\r\n                \" @ \" +\r\n                this.range.start.toString(10) +\r\n                \",\" +\r\n                this.range.end.toString(10));\r\n        }\r\n        return (diagnosticCategoryToString(this.category) +\r\n            \" \" +\r\n            this.code.toString(10) +\r\n            \": \" +\r\n            this.message);\r\n    };\r\n    return DiagnosticMessage;\r\n}());\r\nexports.DiagnosticMessage = DiagnosticMessage;\r\nfunction formatDiagnosticMessage(message, useColors, showContext) {\r\n    if (useColors === void 0) { useColors = false; }\r\n    if (showContext === void 0) { showContext = false; }\r\n    // format context first (uses same string builder)\r\n    var context = \"\";\r\n    if (message.range && showContext) {\r\n        context = formatDiagnosticContext(message.range, useColors);\r\n    }\r\n    // general information\r\n    var sb = [];\r\n    if (useColors)\r\n        sb.push(diagnosticCategoryToColor(message.category));\r\n    sb.push(diagnosticCategoryToString(message.category));\r\n    if (useColors)\r\n        sb.push(colorReset);\r\n    sb.push(message.code < 1000 ? \" AS\" : \" TS\");\r\n    sb.push(message.code.toString(10));\r\n    sb.push(\": \");\r\n    sb.push(message.message);\r\n    // range information if available\r\n    if (message.range) {\r\n        var range = message.range;\r\n        if (showContext) {\r\n            sb.push(\"\\n\");\r\n            sb.push(context);\r\n        }\r\n        sb.push(\"\\n\");\r\n        sb.push(\" in \");\r\n        sb.push(range.source.normalizedPath);\r\n        sb.push(\"(\");\r\n        sb.push(range.line.toString(10));\r\n        sb.push(\",\");\r\n        sb.push(range.column.toString(10));\r\n        sb.push(\")\");\r\n    }\r\n    return sb.join(\"\");\r\n}\r\nexports.formatDiagnosticMessage = formatDiagnosticMessage;\r\nfunction formatDiagnosticContext(range, useColors) {\r\n    if (useColors === void 0) { useColors = false; }\r\n    var text = range.source.text;\r\n    var len = text.length;\r\n    var start = range.start;\r\n    var end = range.end;\r\n    while (start > 0 && !charcode_1.isLineBreak(text.charCodeAt(start - 1))) {\r\n        start--;\r\n    }\r\n    while (end < len && !charcode_1.isLineBreak(text.charCodeAt(end))) {\r\n        end++;\r\n    }\r\n    var sb = [\r\n        \"\\n \",\r\n        text.substring(start, end),\r\n        \"\\n \"\r\n    ];\r\n    while (start < range.start) {\r\n        sb.push(\" \");\r\n        start++;\r\n    }\r\n    if (useColors)\r\n        sb.push(colorRed);\r\n    if (range.start == range.end) {\r\n        sb.push(\"^\");\r\n    }\r\n    else {\r\n        while (start++ < range.end) {\r\n            sb.push(\"~\");\r\n        }\r\n    }\r\n    if (useColors)\r\n        sb.push(colorReset);\r\n    return sb.join(\"\");\r\n}\r\nexports.formatDiagnosticContext = formatDiagnosticContext;\r\nvar DiagnosticEmitter = /** @class */ (function () {\r\n    // silentDiagnostics: bool = false;\r\n    function DiagnosticEmitter(diagnostics) {\r\n        if (diagnostics === void 0) { diagnostics = null; }\r\n        this.diagnostics = diagnostics ? diagnostics : new Array();\r\n    }\r\n    DiagnosticEmitter.prototype.emitDiagnostic = function (code, category, range, arg0, arg1, arg2) {\r\n        if (arg0 === void 0) { arg0 = null; }\r\n        if (arg1 === void 0) { arg1 = null; }\r\n        if (arg2 === void 0) { arg2 = null; }\r\n        var message = DiagnosticMessage.create(code, category, arg0, arg1, arg2).withRange(range);\r\n        this.diagnostics.push(message);\r\n        // console.log(formatDiagnosticMessage(message, true, true) + \"\\n\"); // temporary\r\n        // console.log(<string>new Error(\"stack\").stack);\r\n    };\r\n    DiagnosticEmitter.prototype.error = function (code, range, arg0, arg1, arg2) {\r\n        if (arg0 === void 0) { arg0 = null; }\r\n        if (arg1 === void 0) { arg1 = null; }\r\n        if (arg2 === void 0) { arg2 = null; }\r\n        this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, arg0, arg1, arg2);\r\n    };\r\n    DiagnosticEmitter.prototype.info = function (code, range, arg0, arg1, arg2) {\r\n        if (arg0 === void 0) { arg0 = null; }\r\n        if (arg1 === void 0) { arg1 = null; }\r\n        if (arg2 === void 0) { arg2 = null; }\r\n        this.emitDiagnostic(code, DiagnosticCategory.INFO, range, arg0, arg1, arg2);\r\n    };\r\n    DiagnosticEmitter.prototype.warning = function (code, range, arg0, arg1, arg2) {\r\n        if (arg0 === void 0) { arg0 = null; }\r\n        if (arg1 === void 0) { arg1 = null; }\r\n        if (arg2 === void 0) { arg2 = null; }\r\n        this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, arg0, arg1, arg2);\r\n    };\r\n    return DiagnosticEmitter;\r\n}());\r\nexports.DiagnosticEmitter = DiagnosticEmitter;\r\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __values = (this && this.__values) || function (o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostics_1 = __webpack_require__(1);\r\nvar types_1 = __webpack_require__(5);\r\nvar ast_1 = __webpack_require__(6);\r\nvar module_1 = __webpack_require__(0);\r\n/** Path delimiter inserted between file system levels. */\r\nexports.PATH_DELIMITER = \"/\";\r\n/** Substitution used to indicate the parent directory. */\r\nexports.PARENT_SUBST = \"..\";\r\n/** Function name prefix used for getters. */\r\nexports.GETTER_PREFIX = \"get:\";\r\n/** Function name prefix used for setters. */\r\nexports.SETTER_PREFIX = \"set:\";\r\n/** Delimiter used between class names and instance members. */\r\nexports.INSTANCE_DELIMITER = \"#\";\r\n/** Delimiter used between class and namespace names and static members. */\r\nexports.STATIC_DELIMITER = \".\";\r\n/** Substitution used to indicate a library directory. */\r\nexports.LIBRARY_SUBST = \"(lib)\";\r\n/** Library directory prefix. */\r\nexports.LIBRARY_PREFIX = exports.LIBRARY_SUBST + exports.PATH_DELIMITER;\r\nvar QueuedExport = /** @class */ (function () {\r\n    function QueuedExport() {\r\n    }\r\n    return QueuedExport;\r\n}());\r\nvar QueuedImport = /** @class */ (function () {\r\n    function QueuedImport() {\r\n    }\r\n    return QueuedImport;\r\n}());\r\nvar noTypesYet = new Map();\r\n/** Represents an AssemblyScript program. */\r\nvar Program = /** @class */ (function (_super) {\r\n    __extends(Program, _super);\r\n    /** Constructs a new program, optionally inheriting parser diagnostics. */\r\n    function Program(diagnostics) {\r\n        if (diagnostics === void 0) { diagnostics = null; }\r\n        var _this = _super.call(this, diagnostics) || this;\r\n        /** Diagnostic offset used where repeatedly obtaining the next diagnostic. */\r\n        _this.diagnosticsOffset = 0;\r\n        /** Elements by internal name. */\r\n        _this.elements = new Map();\r\n        /** Types by internal name. */\r\n        _this.types = noTypesYet;\r\n        /** Declared type aliases. */\r\n        _this.typeAliases = new Map();\r\n        /** Exports of individual files by exported name. Not global exports. */\r\n        _this.exports = new Map();\r\n        _this.sources = [];\r\n        return _this;\r\n    }\r\n    /** Initializes the program and its elements prior to compilation. */\r\n    Program.prototype.initialize = function (options) {\r\n        this.options = options;\r\n        this.types = new Map([\r\n            [\"i8\", types_1.Type.i8],\r\n            [\"i16\", types_1.Type.i16],\r\n            [\"i32\", types_1.Type.i32],\r\n            [\"i64\", types_1.Type.i64],\r\n            [\"isize\", options.isizeType],\r\n            [\"u8\", types_1.Type.u8],\r\n            [\"u16\", types_1.Type.u16],\r\n            [\"u32\", types_1.Type.u32],\r\n            [\"u64\", types_1.Type.u64],\r\n            [\"usize\", options.usizeType],\r\n            [\"bool\", types_1.Type.bool],\r\n            [\"f32\", types_1.Type.f32],\r\n            [\"f64\", types_1.Type.f64],\r\n            [\"void\", types_1.Type.void],\r\n            [\"number\", types_1.Type.f64],\r\n            [\"boolean\", types_1.Type.bool]\r\n        ]);\r\n        var queuedExports = new Map();\r\n        var queuedImports = new Array();\r\n        var queuedDerivedClasses = new Array();\r\n        // build initial lookup maps of internal names to declarations\r\n        for (var i = 0, k = this.sources.length; i < k; ++i) {\r\n            var source = this.sources[i];\r\n            var statements = source.statements;\r\n            for (var j = 0, l = statements.length; j < l; ++j) {\r\n                var statement = statements[j];\r\n                switch (statement.kind) {\r\n                    case ast_1.NodeKind.CLASSDECLARATION:\r\n                        this.initializeClass(statement, queuedDerivedClasses);\r\n                        break;\r\n                    case ast_1.NodeKind.ENUMDECLARATION:\r\n                        this.initializeEnum(statement);\r\n                        break;\r\n                    case ast_1.NodeKind.EXPORT:\r\n                        this.initializeExports(statement, queuedExports);\r\n                        break;\r\n                    case ast_1.NodeKind.FUNCTIONDECLARATION:\r\n                        this.initializeFunction(statement);\r\n                        break;\r\n                    case ast_1.NodeKind.IMPORT:\r\n                        this.initializeImports(statement, queuedExports, queuedImports);\r\n                        break;\r\n                    case ast_1.NodeKind.INTERFACEDECLARATION:\r\n                        this.initializeInterface(statement);\r\n                        break;\r\n                    case ast_1.NodeKind.NAMESPACEDECLARATION:\r\n                        this.initializeNamespace(statement, queuedDerivedClasses);\r\n                        break;\r\n                    case ast_1.NodeKind.TYPEDECLARATION:\r\n                        this.initializeTypeAlias(statement);\r\n                        break;\r\n                    case ast_1.NodeKind.VARIABLE:\r\n                        this.initializeVariables(statement);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        var element;\r\n        // queued imports should be resolvable now through traversing exports and\r\n        // queued exports\r\n        for (i = 0; i < queuedImports.length;) {\r\n            var queuedImport = queuedImports[i];\r\n            element = this.tryResolveImport(queuedImport.referencedName, queuedExports);\r\n            if (element) {\r\n                this.elements.set(queuedImport.internalName, element);\r\n                queuedImports.splice(i, 1);\r\n            }\r\n            else {\r\n                element = this.tryResolveImport(queuedImport.referencedNameAlt, queuedExports);\r\n                if (element) {\r\n                    this.elements.set(queuedImport.internalName, element);\r\n                    queuedImports.splice(i, 1);\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode.Module_0_has_no_exported_member_1, queuedImport.declaration.range, queuedImport.declaration.parent.path.value, queuedImport.declaration.externalName.text);\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n        try {\r\n            // queued exports should be resolvable now that imports are finalized\r\n            for (var queuedExports_1 = __values(queuedExports), queuedExports_1_1 = queuedExports_1.next(); !queuedExports_1_1.done; queuedExports_1_1 = queuedExports_1.next()) {\r\n                var _a = __read(queuedExports_1_1.value, 2), exportName = _a[0], queuedExport = _a[1];\r\n                var currentExport = queuedExport; // nullable below\r\n                do {\r\n                    if (currentExport.isReExport) {\r\n                        if (element = this.exports.get(currentExport.referencedName)) {\r\n                            this.setExportAndCheckLibrary(exportName, element, currentExport.member.externalName);\r\n                            break;\r\n                        }\r\n                        currentExport = queuedExports.get(currentExport.referencedName);\r\n                        if (!currentExport) {\r\n                            this.error(diagnostics_1.DiagnosticCode.Module_0_has_no_exported_member_1, queuedExport.member.externalName.range, queuedExport.member.parent.path.value, queuedExport.member.externalName.text);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (\r\n                        // normal export\r\n                        (element = this.elements.get(currentExport.referencedName)) ||\r\n                            // library re-export\r\n                            (element = this.elements.get(currentExport.member.name.text))) {\r\n                            this.setExportAndCheckLibrary(exportName, element, currentExport.member.externalName);\r\n                        }\r\n                        else {\r\n                            this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, queuedExport.member.range, queuedExport.member.name.text);\r\n                        }\r\n                        break;\r\n                    }\r\n                } while (currentExport);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (queuedExports_1_1 && !queuedExports_1_1.done && (_b = queuedExports_1.return)) _b.call(queuedExports_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        // resolve base prototypes of derived classes\r\n        for (i = 0, k = queuedDerivedClasses.length; i < k; ++i) {\r\n            var derivedDeclaration = queuedDerivedClasses[i].declaration;\r\n            var derivedType = assert(derivedDeclaration.extendsType);\r\n            var resolved = this.resolveIdentifier(derivedType.name, null);\r\n            if (resolved) {\r\n                if (resolved.element.kind != ElementKind.CLASS_PROTOTYPE) {\r\n                    this.error(diagnostics_1.DiagnosticCode.A_class_may_only_extend_another_class, derivedType.range);\r\n                    continue;\r\n                }\r\n                queuedDerivedClasses[i].basePrototype = resolved.element;\r\n            }\r\n        }\r\n        var e_1, _b;\r\n    };\r\n    /** Tries to resolve an import by traversing exports and queued exports. */\r\n    Program.prototype.tryResolveImport = function (referencedName, queuedExports) {\r\n        var element;\r\n        do {\r\n            if (element = this.exports.get(referencedName)) {\r\n                return element;\r\n            }\r\n            var queuedExport = queuedExports.get(referencedName);\r\n            if (!queuedExport)\r\n                return null;\r\n            if (queuedExport.isReExport) {\r\n                referencedName = queuedExport.referencedName;\r\n                continue;\r\n            }\r\n            return this.elements.get(queuedExport.referencedName);\r\n        } while (true);\r\n    };\r\n    Program.prototype.checkInternalDecorators = function (element, declaration) {\r\n        var isBuiltin = ast_1.hasDecorator(\"builtin\", declaration.decorators);\r\n        if (isBuiltin) {\r\n            element.set(ElementFlags.BUILTIN);\r\n        }\r\n        if (ast_1.hasDecorator(\"global\", declaration.decorators) ||\r\n            (declaration.range.source.isLibrary &&\r\n                element.is(ElementFlags.EXPORTED) &&\r\n                (assert(declaration.parent).kind == ast_1.NodeKind.SOURCE ||\r\n                    declaration.parent.kind == ast_1.NodeKind.VARIABLE &&\r\n                        assert(declaration.parent.parent).kind == ast_1.NodeKind.SOURCE))) {\r\n            element.set(ElementFlags.GLOBAL);\r\n            if (this.elements.has(declaration.name.text)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, element.internalName);\r\n            }\r\n            else {\r\n                this.elements.set(declaration.name.text, element);\r\n                this.exports.set(declaration.name.text, element);\r\n                if (isBuiltin) {\r\n                    element.internalName = declaration.name.text;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Program.prototype.initializeClass = function (declaration, queuedDerivedClasses, namespace) {\r\n        if (namespace === void 0) { namespace = null; }\r\n        var internalName = declaration.fileLevelInternalName;\r\n        if (this.elements.has(internalName)) {\r\n            this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n            return;\r\n        }\r\n        var prototype = new ClassPrototype(this, declaration.name.text, internalName, declaration);\r\n        prototype.namespace = namespace;\r\n        this.elements.set(internalName, prototype);\r\n        this.checkInternalDecorators(prototype, declaration);\r\n        if (ast_1.hasDecorator(\"unmanaged\", declaration.decorators)) {\r\n            prototype.isUnmanaged = true;\r\n            if (declaration.implementsTypes && declaration.implementsTypes.length) {\r\n                this.error(diagnostics_1.DiagnosticCode.Structs_cannot_implement_interfaces, ast_1.Range.join(declaration.name.range, declaration.implementsTypes[declaration.implementsTypes.length - 1]\r\n                    .range));\r\n            }\r\n        }\r\n        else if (declaration.implementsTypes.length) {\r\n            throw new Error(\"not implemented\");\r\n        }\r\n        // remember classes that extend another one\r\n        if (declaration.extendsType) {\r\n            queuedDerivedClasses.push(prototype);\r\n        }\r\n        // add as namespace member if applicable\r\n        if (namespace) {\r\n            if (namespace.members) {\r\n                if (namespace.members.has(declaration.name.text)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                namespace.members = new Map();\r\n            }\r\n            namespace.members.set(declaration.name.text, prototype);\r\n            // otherwise add to file-level exports if exported\r\n        }\r\n        else if (prototype.is(ElementFlags.EXPORTED)) {\r\n            if (this.exports.has(internalName)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0, declaration.name.range, internalName);\r\n                return;\r\n            }\r\n            this.exports.set(internalName, prototype);\r\n        }\r\n        // initialize members\r\n        var memberDeclarations = declaration.members;\r\n        for (var i = 0, k = memberDeclarations.length; i < k; ++i) {\r\n            var memberDeclaration = memberDeclarations[i];\r\n            switch (memberDeclaration.kind) {\r\n                case ast_1.NodeKind.FIELDDECLARATION:\r\n                    this.initializeField(memberDeclaration, prototype);\r\n                    break;\r\n                case ast_1.NodeKind.METHODDECLARATION:\r\n                    var isGetter = ast_1.hasModifier(ast_1.ModifierKind.GET, memberDeclaration.modifiers);\r\n                    if (isGetter ||\r\n                        ast_1.hasModifier(ast_1.ModifierKind.SET, memberDeclaration.modifiers)) {\r\n                        this.initializeAccessor(memberDeclaration, prototype, isGetter);\r\n                    }\r\n                    else {\r\n                        this.initializeMethod(memberDeclaration, prototype);\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw new Error(\"class member expected\");\r\n            }\r\n        }\r\n        // check and possibly register string type\r\n        if (prototype.is(ElementFlags.GLOBAL) &&\r\n            declaration.name.text == \"String\") {\r\n            if (!this.types.has(\"string\")) {\r\n                var instance = prototype.resolve(null);\r\n                if (instance) {\r\n                    this.types.set(\"string\", instance.type);\r\n                }\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, declaration.programLevelInternalName);\r\n            }\r\n        }\r\n    };\r\n    Program.prototype.initializeField = function (declaration, classPrototype) {\r\n        var name = declaration.name.text;\r\n        var internalName = declaration.fileLevelInternalName;\r\n        // static fields become global variables\r\n        if (ast_1.hasModifier(ast_1.ModifierKind.STATIC, declaration.modifiers)) {\r\n            if (this.elements.has(internalName)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                return;\r\n            }\r\n            if (classPrototype.members) {\r\n                if (classPrototype.members.has(name)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                classPrototype.members = new Map();\r\n            }\r\n            var staticField = new Global(this, name, internalName, declaration, types_1.Type.void);\r\n            classPrototype.members.set(name, staticField);\r\n            this.elements.set(internalName, staticField);\r\n            // instance fields are remembered until resolved\r\n        }\r\n        else {\r\n            if (classPrototype.instanceMembers) {\r\n                if (classPrototype.instanceMembers.has(name)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                classPrototype.instanceMembers = new Map();\r\n            }\r\n            var instanceField = new FieldPrototype(classPrototype, name, internalName, declaration);\r\n            classPrototype.instanceMembers.set(name, instanceField);\r\n        }\r\n    };\r\n    Program.prototype.initializeMethod = function (declaration, classPrototype) {\r\n        var name = declaration.name.text;\r\n        var internalName = declaration.fileLevelInternalName;\r\n        var prototype = null;\r\n        // static methods become global functions\r\n        if (ast_1.hasModifier(ast_1.ModifierKind.STATIC, declaration.modifiers)) {\r\n            assert(declaration.name.kind != ast_1.NodeKind.CONSTRUCTOR);\r\n            if (this.elements.has(internalName)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                return;\r\n            }\r\n            if (classPrototype.members) {\r\n                if (classPrototype.members.has(name)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                classPrototype.members = new Map();\r\n            }\r\n            prototype = new FunctionPrototype(this, name, internalName, declaration, null);\r\n            classPrototype.members.set(name, prototype);\r\n            this.elements.set(internalName, prototype);\r\n            // instance methods are remembered until resolved\r\n        }\r\n        else {\r\n            if (classPrototype.instanceMembers) {\r\n                if (classPrototype.instanceMembers.has(name)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                classPrototype.instanceMembers = new Map();\r\n            }\r\n            prototype = new FunctionPrototype(this, name, internalName, declaration, classPrototype);\r\n            // if (classPrototype.isUnmanaged && instancePrototype.isAbstract) {\r\n            //   this.error( Unmanaged classes cannot declare abstract methods. );\r\n            // }\r\n            if (declaration.name.kind == ast_1.NodeKind.CONSTRUCTOR) {\r\n                if (classPrototype.constructorPrototype) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Multiple_constructor_implementations_are_not_allowed, declaration.name.range);\r\n                }\r\n                else {\r\n                    prototype.set(ElementFlags.CONSTRUCTOR);\r\n                    classPrototype.constructorPrototype = prototype;\r\n                }\r\n            }\r\n            else {\r\n                classPrototype.instanceMembers.set(name, prototype);\r\n            }\r\n        }\r\n        this.checkOperators(declaration.decorators, prototype, classPrototype);\r\n    };\r\n    Program.prototype.checkOperators = function (decorators, prototype, classPrototype) {\r\n        // handle operator annotations. operators are either instance methods taking\r\n        // a second argument of the instance's type or static methods taking two\r\n        // arguments of the instance's type. return values vary depending on the\r\n        // operation.\r\n        if (decorators) {\r\n            for (var i = 0, k = decorators.length; i < k; ++i) {\r\n                var decorator = decorators[i];\r\n                if (decorator.decoratorKind == 2 /* OPERATOR */) {\r\n                    if (!prototype) {\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, decorator.range);\r\n                        continue;\r\n                    }\r\n                    var numArgs = decorator.arguments && decorator.arguments.length || 0;\r\n                    if (numArgs == 1) {\r\n                        var firstArg = decorator.arguments[0];\r\n                        if (firstArg.kind == ast_1.NodeKind.LITERAL &&\r\n                            firstArg.literalKind == 2 /* STRING */) {\r\n                            switch (firstArg.value) {\r\n                                case \"[]\":\r\n                                    classPrototype.fnIndexedGet = prototype.simpleName;\r\n                                    break;\r\n                                case \"[]=\":\r\n                                    classPrototype.fnIndexedSet = prototype.simpleName;\r\n                                    break;\r\n                                case \"+\":\r\n                                    classPrototype.fnConcat = prototype.simpleName;\r\n                                    break;\r\n                                case \"==\":\r\n                                    classPrototype.fnEquals = prototype.simpleName;\r\n                                    break;\r\n                                default:\r\n                                    this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, firstArg.range);\r\n                            }\r\n                        }\r\n                        else {\r\n                            this.error(diagnostics_1.DiagnosticCode.String_literal_expected, firstArg.range);\r\n                        }\r\n                    }\r\n                    else {\r\n                        this.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, decorator.range, \"1\", numArgs.toString(0));\r\n                    }\r\n                }\r\n                else if (decorator.decoratorKind != 0 /* CUSTOM */) {\r\n                    // methods support built-in @operator only\r\n                    this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, decorator.range);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Program.prototype.initializeAccessor = function (declaration, classPrototype, isGetter) {\r\n        var propertyName = declaration.name.text;\r\n        var internalPropertyName = declaration.fileLevelInternalName;\r\n        var propertyElement = this.elements.get(internalPropertyName);\r\n        if (propertyElement) {\r\n            if (propertyElement.kind != ElementKind.PROPERTY ||\r\n                (isGetter\r\n                    ? propertyElement.getterPrototype\r\n                    : propertyElement.setterPrototype)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalPropertyName);\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            propertyElement = new Property(this, propertyName, internalPropertyName, classPrototype);\r\n        }\r\n        var name = (isGetter ? exports.GETTER_PREFIX : exports.SETTER_PREFIX) + propertyName;\r\n        // static accessors become global functions\r\n        if (ast_1.hasModifier(ast_1.ModifierKind.STATIC, declaration.modifiers)) {\r\n            var staticName = classPrototype.internalName + exports.STATIC_DELIMITER + name;\r\n            if (this.elements.has(staticName)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, staticName);\r\n                return;\r\n            }\r\n            var staticPrototype = new FunctionPrototype(this, name, staticName, declaration, null);\r\n            if (isGetter) {\r\n                propertyElement.getterPrototype = staticPrototype;\r\n            }\r\n            else {\r\n                propertyElement.setterPrototype = staticPrototype;\r\n            }\r\n            if (!classPrototype.members) {\r\n                classPrototype.members = new Map();\r\n            }\r\n            classPrototype.members.set(propertyName, propertyElement); // check above\r\n            this.elements.set(internalPropertyName, propertyElement);\r\n            // instance accessors are remembered until resolved\r\n        }\r\n        else {\r\n            var instanceName = classPrototype.internalName + exports.INSTANCE_DELIMITER + name;\r\n            if (classPrototype.instanceMembers) {\r\n                if (classPrototype.instanceMembers.has(name)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalPropertyName);\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                classPrototype.instanceMembers = new Map();\r\n            }\r\n            var instancePrototype = new FunctionPrototype(this, name, instanceName, declaration, classPrototype);\r\n            if (isGetter) {\r\n                propertyElement.getterPrototype = instancePrototype;\r\n            }\r\n            else {\r\n                propertyElement.setterPrototype = instancePrototype;\r\n            }\r\n            classPrototype.instanceMembers.set(name, propertyElement);\r\n            this.elements.set(internalPropertyName, propertyElement);\r\n        }\r\n    };\r\n    Program.prototype.initializeEnum = function (declaration, namespace) {\r\n        if (namespace === void 0) { namespace = null; }\r\n        var internalName = declaration.fileLevelInternalName;\r\n        if (this.elements.has(internalName)) {\r\n            this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n            return;\r\n        }\r\n        var enm = new Enum(this, declaration.name.text, internalName, declaration);\r\n        enm.namespace = namespace;\r\n        this.elements.set(internalName, enm);\r\n        this.checkInternalDecorators(enm, declaration);\r\n        if (namespace) {\r\n            if (namespace.members) {\r\n                if (namespace.members.has(declaration.name.text)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                namespace.members = new Map();\r\n            }\r\n            namespace.members.set(declaration.name.text, enm);\r\n        }\r\n        else if (enm.is(ElementFlags.EXPORTED)) {\r\n            if (this.exports.has(internalName)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0, declaration.name.range, internalName);\r\n                return;\r\n            }\r\n            this.exports.set(internalName, enm);\r\n        }\r\n        var values = declaration.values;\r\n        for (var i = 0, k = values.length; i < k; ++i) {\r\n            this.initializeEnumValue(values[i], enm);\r\n        }\r\n    };\r\n    Program.prototype.initializeEnumValue = function (declaration, enm) {\r\n        var name = declaration.name.text;\r\n        var internalName = declaration.fileLevelInternalName;\r\n        if (enm.members) {\r\n            if (enm.members.has(name)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                return;\r\n            }\r\n        }\r\n        else {\r\n            enm.members = new Map();\r\n        }\r\n        var value = new EnumValue(enm, this, name, internalName, declaration);\r\n        enm.members.set(name, value);\r\n    };\r\n    Program.prototype.initializeExports = function (statement, queuedExports) {\r\n        var members = statement.members;\r\n        for (var i = 0, k = members.length; i < k; ++i) {\r\n            this.initializeExport(members[i], statement.internalPath, queuedExports);\r\n        }\r\n    };\r\n    Program.prototype.setExportAndCheckLibrary = function (name, element, identifier) {\r\n        this.exports.set(name, element);\r\n        if (identifier.range.source.isLibrary) {\r\n            if (this.elements.has(identifier.text)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0, identifier.range, identifier.text);\r\n            }\r\n            else {\r\n                element.internalName = identifier.text;\r\n                this.elements.set(identifier.text, element);\r\n            }\r\n        }\r\n    };\r\n    Program.prototype.initializeExport = function (member, internalPath, queuedExports) {\r\n        var externalName = member.range.source.internalPath + exports.PATH_DELIMITER + member.externalName.text;\r\n        if (this.exports.has(externalName)) {\r\n            this.error(diagnostics_1.DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0, member.externalName.range, externalName);\r\n            return;\r\n        }\r\n        var referencedName;\r\n        var referencedElement;\r\n        var queuedExport;\r\n        // export local element\r\n        if (internalPath == null) {\r\n            referencedName = member.range.source.internalPath + exports.PATH_DELIMITER + member.name.text;\r\n            // resolve right away if the element exists\r\n            if (referencedElement = this.elements.get(referencedName)) {\r\n                this.setExportAndCheckLibrary(externalName, referencedElement, member.externalName);\r\n                return;\r\n            }\r\n            // otherwise queue it\r\n            if (queuedExports.has(externalName)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0, member.externalName.range, externalName);\r\n                return;\r\n            }\r\n            queuedExport = new QueuedExport();\r\n            queuedExport.isReExport = false;\r\n            queuedExport.referencedName = referencedName; // -> internal name\r\n            queuedExport.member = member;\r\n            queuedExports.set(externalName, queuedExport);\r\n            // export external element\r\n        }\r\n        else {\r\n            referencedName = internalPath + exports.PATH_DELIMITER + member.name.text;\r\n            // resolve right away if the export exists\r\n            referencedElement = this.elements.get(referencedName);\r\n            if (referencedElement) {\r\n                this.setExportAndCheckLibrary(externalName, referencedElement, member.externalName);\r\n                return;\r\n            }\r\n            // walk already known queued exports\r\n            var seen = new Set();\r\n            while (queuedExport = queuedExports.get(referencedName)) {\r\n                if (queuedExport.isReExport) {\r\n                    referencedElement = this.exports.get(queuedExport.referencedName);\r\n                    if (referencedElement) {\r\n                        this.setExportAndCheckLibrary(externalName, referencedElement, member.externalName);\r\n                        return;\r\n                    }\r\n                    referencedName = queuedExport.referencedName;\r\n                    if (seen.has(queuedExport))\r\n                        break;\r\n                    seen.add(queuedExport);\r\n                }\r\n                else {\r\n                    referencedElement = this.elements.get(queuedExport.referencedName);\r\n                    if (referencedElement) {\r\n                        this.setExportAndCheckLibrary(externalName, referencedElement, member.externalName);\r\n                        return;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            // otherwise queue it\r\n            if (queuedExports.has(externalName)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0, member.externalName.range, externalName);\r\n                return;\r\n            }\r\n            queuedExport = new QueuedExport();\r\n            queuedExport.isReExport = true;\r\n            queuedExport.referencedName = referencedName; // -> export name\r\n            queuedExport.member = member;\r\n            queuedExports.set(externalName, queuedExport);\r\n        }\r\n    };\r\n    Program.prototype.initializeFunction = function (declaration, namespace) {\r\n        if (namespace === void 0) { namespace = null; }\r\n        var internalName = declaration.fileLevelInternalName;\r\n        if (this.elements.has(internalName)) {\r\n            this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n            return;\r\n        }\r\n        var prototype = new FunctionPrototype(this, declaration.name.text, internalName, declaration, null);\r\n        prototype.namespace = namespace;\r\n        this.elements.set(internalName, prototype);\r\n        this.checkInternalDecorators(prototype, declaration);\r\n        if (namespace) {\r\n            if (namespace.members) {\r\n                if (namespace.members.has(declaration.name.text)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                namespace.members = new Map();\r\n            }\r\n            namespace.members.set(declaration.name.text, prototype);\r\n        }\r\n        else if (prototype.is(ElementFlags.EXPORTED)) {\r\n            if (this.exports.has(internalName)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0, declaration.name.range, internalName);\r\n                return;\r\n            }\r\n            this.exports.set(internalName, prototype);\r\n        }\r\n    };\r\n    Program.prototype.initializeImports = function (statement, queuedExports, queuedImports) {\r\n        var declarations = statement.declarations;\r\n        if (declarations) {\r\n            for (var i = 0, k = declarations.length; i < k; ++i) {\r\n                this.initializeImport(declarations[i], statement.internalPath, queuedExports, queuedImports);\r\n            }\r\n        }\r\n        else if (statement.namespaceName) {\r\n            var internalName = (statement.range.source.internalPath +\r\n                exports.PATH_DELIMITER +\r\n                statement.namespaceName.text);\r\n            if (this.elements.has(internalName)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, statement.namespaceName.range, internalName);\r\n                return;\r\n            }\r\n            this.error(// TODO\r\n            diagnostics_1.DiagnosticCode.Operation_not_supported, statement.range);\r\n        }\r\n    };\r\n    Program.prototype.initializeImport = function (declaration, internalPath, queuedExports, queuedImports) {\r\n        var internalName = declaration.fileLevelInternalName;\r\n        if (this.elements.has(internalName)) {\r\n            this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n            return;\r\n        }\r\n        var referencedName = internalPath + exports.PATH_DELIMITER + declaration.externalName.text;\r\n        // resolve right away if the exact export exists\r\n        var element;\r\n        if (element = this.exports.get(referencedName)) {\r\n            this.elements.set(internalName, element);\r\n            return;\r\n        }\r\n        // otherwise queue it\r\n        var indexPart = exports.PATH_DELIMITER + \"index\";\r\n        var queuedImport = new QueuedImport();\r\n        queuedImport.internalName = internalName;\r\n        if (internalPath.endsWith(indexPart)) {\r\n            queuedImport.referencedName = referencedName; // try exact first\r\n            queuedImport.referencedNameAlt = (internalPath.substring(0, internalPath.length - indexPart.length + 1) +\r\n                declaration.externalName.text);\r\n        }\r\n        else {\r\n            queuedImport.referencedName = referencedName; // try exact first\r\n            queuedImport.referencedNameAlt = (internalPath +\r\n                indexPart +\r\n                exports.PATH_DELIMITER +\r\n                declaration.externalName.text);\r\n        }\r\n        queuedImport.declaration = declaration;\r\n        queuedImports.push(queuedImport);\r\n    };\r\n    Program.prototype.initializeInterface = function (declaration, namespace) {\r\n        if (namespace === void 0) { namespace = null; }\r\n        var internalName = declaration.fileLevelInternalName;\r\n        if (this.elements.has(internalName)) {\r\n            this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n            return;\r\n        }\r\n        var prototype = new InterfacePrototype(this, declaration.name.text, internalName, declaration);\r\n        prototype.namespace = namespace;\r\n        this.elements.set(internalName, prototype);\r\n        this.checkInternalDecorators(prototype, declaration);\r\n        if (namespace) {\r\n            if (namespace.members) {\r\n                if (namespace.members.has(prototype.internalName)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                namespace.members = new Map();\r\n            }\r\n            namespace.members.set(prototype.internalName, prototype);\r\n        }\r\n        else if (prototype.is(ElementFlags.EXPORTED)) {\r\n            if (this.exports.has(internalName)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0, declaration.name.range, internalName);\r\n                return;\r\n            }\r\n            this.exports.set(internalName, prototype);\r\n        }\r\n        var memberDeclarations = declaration.members;\r\n        for (var i = 0, k = memberDeclarations.length; i < k; ++i) {\r\n            var memberDeclaration = memberDeclarations[i];\r\n            switch (memberDeclaration.kind) {\r\n                case ast_1.NodeKind.FIELDDECLARATION:\r\n                    this.initializeField(memberDeclaration, prototype);\r\n                    break;\r\n                case ast_1.NodeKind.METHODDECLARATION:\r\n                    var isGetter = ast_1.hasModifier(ast_1.ModifierKind.GET, memberDeclaration.modifiers);\r\n                    if (isGetter || ast_1.hasModifier(ast_1.ModifierKind.SET, memberDeclaration.modifiers)) {\r\n                        this.initializeAccessor(memberDeclaration, prototype, isGetter);\r\n                    }\r\n                    else {\r\n                        this.initializeMethod(memberDeclaration, prototype);\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw new Error(\"interface member expected\");\r\n            }\r\n        }\r\n    };\r\n    Program.prototype.initializeNamespace = function (declaration, queuedExtendingClasses, parentNamespace) {\r\n        if (parentNamespace === void 0) { parentNamespace = null; }\r\n        var internalName = declaration.fileLevelInternalName;\r\n        var namespace = this.elements.get(internalName);\r\n        if (!namespace) {\r\n            namespace = new Namespace(this, declaration.name.text, internalName, declaration);\r\n            namespace.namespace = parentNamespace;\r\n            this.elements.set(internalName, namespace);\r\n            this.checkInternalDecorators(namespace, declaration);\r\n        }\r\n        if (parentNamespace) {\r\n            if (parentNamespace.members) {\r\n                if (parentNamespace.members.has(declaration.name.text)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                parentNamespace.members = new Map();\r\n            }\r\n            parentNamespace.members.set(declaration.name.text, namespace);\r\n        }\r\n        else if (namespace.is(ElementFlags.EXPORTED)) {\r\n            if (this.exports.has(internalName)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0, declaration.name.range, internalName);\r\n                return;\r\n            }\r\n            this.exports.set(internalName, namespace);\r\n        }\r\n        var members = declaration.members;\r\n        for (var i = 0, k = members.length; i < k; ++i) {\r\n            switch (members[i].kind) {\r\n                case ast_1.NodeKind.CLASSDECLARATION:\r\n                    this.initializeClass(members[i], queuedExtendingClasses, namespace);\r\n                    break;\r\n                case ast_1.NodeKind.ENUMDECLARATION:\r\n                    this.initializeEnum(members[i], namespace);\r\n                    break;\r\n                case ast_1.NodeKind.FUNCTIONDECLARATION:\r\n                    this.initializeFunction(members[i], namespace);\r\n                    break;\r\n                case ast_1.NodeKind.INTERFACEDECLARATION:\r\n                    this.initializeInterface(members[i], namespace);\r\n                    break;\r\n                case ast_1.NodeKind.NAMESPACEDECLARATION:\r\n                    this.initializeNamespace(members[i], queuedExtendingClasses, namespace);\r\n                    break;\r\n                case ast_1.NodeKind.TYPEDECLARATION:\r\n                    // this.initializeTypeAlias(<TypeDeclaration>members[i], namespace);\r\n                    // TODO: what about namespaced types?\r\n                    this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, members[i].range);\r\n                    break;\r\n                case ast_1.NodeKind.VARIABLE:\r\n                    this.initializeVariables(members[i], namespace);\r\n                    break;\r\n                default:\r\n                    throw new Error(\"namespace member expected\");\r\n            }\r\n        }\r\n    };\r\n    Program.prototype.initializeTypeAlias = function (declaration, namespace) {\r\n        if (namespace === void 0) { namespace = null; }\r\n        // type aliases are program globals\r\n        // TODO: what about namespaced types?\r\n        var name = declaration.name.text;\r\n        if (this.types.has(name) || this.typeAliases.has(name)) {\r\n            this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, name);\r\n            return;\r\n        }\r\n        this.typeAliases.set(name, declaration.alias);\r\n    };\r\n    Program.prototype.initializeVariables = function (statement, namespace) {\r\n        if (namespace === void 0) { namespace = null; }\r\n        var declarations = statement.declarations;\r\n        for (var i = 0, k = declarations.length; i < k; ++i) {\r\n            var declaration = declarations[i];\r\n            var internalName = declaration.fileLevelInternalName;\r\n            if (this.elements.has(internalName)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                continue;\r\n            }\r\n            var global = new Global(this, declaration.name.text, internalName, declaration, types_1.Type.void // resolved later on\r\n            );\r\n            global.namespace = namespace;\r\n            this.elements.set(internalName, global);\r\n            this.checkInternalDecorators(global, declaration);\r\n            if (namespace) {\r\n                if (namespace.members) {\r\n                    if (namespace.members.has(declaration.name.text)) {\r\n                        this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    namespace.members = new Map();\r\n                }\r\n                namespace.members.set(declaration.name.text, global);\r\n            }\r\n            else if (global.is(ElementFlags.EXPORTED)) {\r\n                if (this.exports.has(internalName)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, internalName);\r\n                }\r\n                else {\r\n                    this.exports.set(internalName, global);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /** Resolves a {@link TypeNode} to a concrete {@link Type}. */\r\n    Program.prototype.resolveType = function (node, contextualTypeArguments, reportNotFound) {\r\n        if (contextualTypeArguments === void 0) { contextualTypeArguments = null; }\r\n        if (reportNotFound === void 0) { reportNotFound = true; }\r\n        var globalName = node.name.text;\r\n        var localName = node.range.source.internalPath + exports.PATH_DELIMITER + node.name.text;\r\n        var element;\r\n        // check file-global / program-global element\r\n        if ((element = this.elements.get(localName)) || (element = this.elements.get(globalName))) {\r\n            switch (element.kind) {\r\n                case ElementKind.CLASS_PROTOTYPE:\r\n                    var instance = element.resolveInclTypeArguments(node.typeArguments, contextualTypeArguments, null); // reports\r\n                    return instance ? instance.type : null;\r\n            }\r\n        }\r\n        // resolve parameters\r\n        var k = node.typeArguments.length;\r\n        var paramTypes = new Array(k);\r\n        for (var i = 0; i < k; ++i) {\r\n            var paramType = this.resolveType(// reports\r\n            node.typeArguments[i], contextualTypeArguments, reportNotFound);\r\n            if (!paramType)\r\n                return null;\r\n            paramTypes[i] = paramType;\r\n        }\r\n        if (k) {\r\n            var instanceKey = types_1.typesToString(paramTypes);\r\n            if (instanceKey.length) {\r\n                localName += \"<\" + instanceKey + \">\";\r\n                globalName += \"<\" + instanceKey + \">\";\r\n            }\r\n        }\r\n        else if (contextualTypeArguments) {\r\n            var placeholderType = contextualTypeArguments.get(globalName);\r\n            if (placeholderType)\r\n                return placeholderType;\r\n        }\r\n        var type;\r\n        // check file-global / program-global type\r\n        if ((type = this.types.get(localName)) || (type = this.types.get(globalName))) {\r\n            return type;\r\n        }\r\n        // check type alias\r\n        var alias = this.typeAliases.get(globalName);\r\n        if (alias && (type = this.resolveType(alias, null, reportNotFound))) {\r\n            return type;\r\n        }\r\n        if (reportNotFound) {\r\n            this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, node.name.range, globalName);\r\n        }\r\n        return null;\r\n    };\r\n    /** Resolves an array of type parameters to concrete types. */\r\n    Program.prototype.resolveTypeArguments = function (typeParameters, typeArgumentNodes, contextualTypeArguments, alternativeReportNode) {\r\n        if (contextualTypeArguments === void 0) { contextualTypeArguments = null; }\r\n        if (alternativeReportNode === void 0) { alternativeReportNode = null; }\r\n        var parameterCount = typeParameters.length;\r\n        var argumentCount = typeArgumentNodes ? typeArgumentNodes.length : 0;\r\n        if (parameterCount != argumentCount) {\r\n            if (argumentCount) {\r\n                this.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, ast_1.Range.join(typeArgumentNodes[0].range, typeArgumentNodes[argumentCount - 1].range), parameterCount.toString(10), argumentCount.toString(10));\r\n            }\r\n            else if (alternativeReportNode) {\r\n                this.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, alternativeReportNode.range.atEnd, parameterCount.toString(10), \"0\");\r\n            }\r\n            return null;\r\n        }\r\n        var typeArguments = new Array(parameterCount);\r\n        for (var i = 0; i < parameterCount; ++i) {\r\n            var type = this.resolveType(// reports\r\n            typeArgumentNodes[i], contextualTypeArguments, true);\r\n            if (!type)\r\n                return null;\r\n            // TODO: check extendsType\r\n            typeArguments[i] = type;\r\n        }\r\n        return typeArguments;\r\n    };\r\n    /** Resolves an identifier to the element it refers to. */\r\n    Program.prototype.resolveIdentifier = function (identifier, contextualFunction, contextualEnum) {\r\n        if (contextualEnum === void 0) { contextualEnum = null; }\r\n        var name = identifier.text;\r\n        var element;\r\n        var namespace;\r\n        // check siblings\r\n        if (contextualEnum) {\r\n            if (contextualEnum.members &&\r\n                (element = contextualEnum.members.get(name)) &&\r\n                element.kind == ElementKind.ENUMVALUE) {\r\n                if (!resolvedElement)\r\n                    resolvedElement = new ResolvedElement();\r\n                return resolvedElement.set(element);\r\n            }\r\n        }\r\n        else if (contextualFunction) {\r\n            // check locals\r\n            if (element = contextualFunction.flow.getScopedLocal(name)) {\r\n                if (!resolvedElement)\r\n                    resolvedElement = new ResolvedElement();\r\n                return resolvedElement.set(element);\r\n            }\r\n            // search contextual parent namespaces if applicable\r\n            if (namespace = contextualFunction.prototype.namespace) {\r\n                do {\r\n                    if (element = this.elements.get(namespace.internalName + exports.STATIC_DELIMITER + name)) {\r\n                        if (!resolvedElement)\r\n                            resolvedElement = new ResolvedElement();\r\n                        return resolvedElement.set(element);\r\n                    }\r\n                } while (namespace = namespace.namespace);\r\n            }\r\n        }\r\n        // search current file\r\n        if (element = this.elements.get(identifier.range.source.internalPath + exports.PATH_DELIMITER + name)) {\r\n            if (!resolvedElement)\r\n                resolvedElement = new ResolvedElement();\r\n            return resolvedElement.set(element);\r\n        }\r\n        // search global scope\r\n        if (element = this.elements.get(name)) {\r\n            if (!resolvedElement)\r\n                resolvedElement = new ResolvedElement();\r\n            return resolvedElement.set(element);\r\n        }\r\n        this.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, identifier.range, name);\r\n        return null;\r\n    };\r\n    /** Resolves a property access to the element it refers to. */\r\n    Program.prototype.resolvePropertyAccess = function (propertyAccess, contextualFunction) {\r\n        // start by resolving the lhs target (expression before the last dot)\r\n        var targetExpression = propertyAccess.expression;\r\n        resolvedElement = this.resolveExpression(targetExpression, contextualFunction); // reports\r\n        if (!resolvedElement)\r\n            return null;\r\n        var target = resolvedElement.element;\r\n        // at this point we know exactly what the target is, so look up the element within\r\n        var propertyName = propertyAccess.property.text;\r\n        var targetType;\r\n        var member;\r\n        // Resolve variable-likes to their class type first\r\n        switch (target.kind) {\r\n            case ElementKind.GLOBAL:\r\n            case ElementKind.LOCAL:\r\n            case ElementKind.FIELD:\r\n                if (!(targetType = target.type).classType) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Property_0_does_not_exist_on_type_1, propertyAccess.property.range, propertyName, targetType.toString());\r\n                    return null;\r\n                }\r\n                target = targetType.classType;\r\n                break;\r\n            case ElementKind.PROPERTY:\r\n                var getter = assert(target.getterPrototype).resolve(); // reports\r\n                if (!getter)\r\n                    return null;\r\n                if (!(targetType = getter.returnType).classType) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Property_0_does_not_exist_on_type_1, propertyAccess.property.range, propertyName, targetType.toString());\r\n                    return null;\r\n                }\r\n                target = targetType.classType;\r\n                break;\r\n        }\r\n        // Look up the member within\r\n        switch (target.kind) {\r\n            case ElementKind.CLASS_PROTOTYPE:\r\n            case ElementKind.CLASS:\r\n                do {\r\n                    if (target.members && (member = target.members.get(propertyName))) {\r\n                        return resolvedElement.set(member).withTarget(target, targetExpression);\r\n                    }\r\n                    // check inherited static members on the base prototype while target is a class prototype\r\n                    if (target.kind == ElementKind.CLASS_PROTOTYPE) {\r\n                        if (target.basePrototype) {\r\n                            target = target.basePrototype;\r\n                        }\r\n                        else {\r\n                            break;\r\n                        }\r\n                        // or inherited instance members on the cbase class while target is a class instance\r\n                    }\r\n                    else if (target.kind == ElementKind.CLASS) {\r\n                        if (target.base) {\r\n                            target = target.base;\r\n                        }\r\n                        else {\r\n                            break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                } while (true);\r\n                break;\r\n            default:// enums or other namespace-like elements\r\n                if (target.members && (member = target.members.get(propertyName))) {\r\n                    return resolvedElement.set(member).withTarget(target, targetExpression);\r\n                }\r\n                break;\r\n        }\r\n        this.error(diagnostics_1.DiagnosticCode.Property_0_does_not_exist_on_type_1, propertyAccess.property.range, propertyName, target.internalName);\r\n        return null;\r\n    };\r\n    Program.prototype.resolveElementAccess = function (elementAccess, contextualFunction) {\r\n        // start by resolving the lhs target (expression before the last dot)\r\n        var targetExpression = elementAccess.expression;\r\n        resolvedElement = this.resolveExpression(targetExpression, contextualFunction);\r\n        if (!resolvedElement)\r\n            return null;\r\n        var target = resolvedElement.element;\r\n        switch (target.kind) {\r\n            case ElementKind.GLOBAL:\r\n            case ElementKind.LOCAL:\r\n            case ElementKind.FIELD:\r\n                var type = target.type;\r\n                if (type.classType) {\r\n                    var indexedGetName = (target = type.classType).prototype.fnIndexedGet;\r\n                    var indexedGet;\r\n                    if (indexedGetName != null &&\r\n                        target.members &&\r\n                        (indexedGet = target.members.get(indexedGetName)) &&\r\n                        indexedGet.kind == ElementKind.FUNCTION_PROTOTYPE) {\r\n                        return resolvedElement.set(indexedGet).withTarget(type.classType, targetExpression);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n        this.error(diagnostics_1.DiagnosticCode.Index_signature_is_missing_in_type_0, targetExpression.range, target.internalName);\r\n        return null;\r\n    };\r\n    Program.prototype.resolveExpression = function (expression, contextualFunction) {\r\n        var classType;\r\n        while (expression.kind == ast_1.NodeKind.PARENTHESIZED) {\r\n            expression = expression.expression;\r\n        }\r\n        switch (expression.kind) {\r\n            case ast_1.NodeKind.ASSERTION:\r\n                var type = this.resolveType(expression.toType); // reports\r\n                if (type && (classType = type.classType)) {\r\n                    if (!resolvedElement)\r\n                        resolvedElement = new ResolvedElement();\r\n                    return resolvedElement.set(classType);\r\n                }\r\n                return null;\r\n            case ast_1.NodeKind.BINARY:\r\n                // TODO: string concatenation, mostly\r\n                throw new Error(\"not implemented\");\r\n            case ast_1.NodeKind.THIS:// -> Class\r\n                if (classType = contextualFunction.instanceMethodOf) {\r\n                    if (!resolvedElement)\r\n                        resolvedElement = new ResolvedElement();\r\n                    return resolvedElement.set(classType);\r\n                }\r\n                this.error(diagnostics_1.DiagnosticCode._this_cannot_be_referenced_in_current_location, expression.range);\r\n                return null;\r\n            case ast_1.NodeKind.SUPER:// -> Class\r\n                if ((classType = contextualFunction.instanceMethodOf) && (classType = classType.base)) {\r\n                    if (!resolvedElement)\r\n                        resolvedElement = new ResolvedElement();\r\n                    return resolvedElement.set(classType);\r\n                }\r\n                this.error(diagnostics_1.DiagnosticCode._super_can_only_be_referenced_in_a_derived_class, expression.range);\r\n                return null;\r\n            case ast_1.NodeKind.IDENTIFIER:\r\n                return this.resolveIdentifier(expression, contextualFunction);\r\n            case ast_1.NodeKind.PROPERTYACCESS:\r\n                return this.resolvePropertyAccess(expression, contextualFunction);\r\n            case ast_1.NodeKind.ELEMENTACCESS:\r\n                return this.resolveElementAccess(expression, contextualFunction);\r\n            case ast_1.NodeKind.CALL:\r\n                var resolved = this.resolveExpression(expression.expression, contextualFunction);\r\n                if (resolved) {\r\n                    var element = resolved.element;\r\n                    if (element && element.kind == ElementKind.FUNCTION_PROTOTYPE) {\r\n                        var instance = element.resolveInclTypeArguments(expression.typeArguments, null, expression);\r\n                        if (instance && instance.returnType.classType) {\r\n                            if (!resolvedElement)\r\n                                resolvedElement = new ResolvedElement();\r\n                            return resolvedElement.set(instance.returnType.classType);\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n        return null;\r\n    };\r\n    return Program;\r\n}(diagnostics_1.DiagnosticEmitter));\r\nexports.Program = Program;\r\n/** Common result structure returned when calling any of the resolve functions on a {@link Program}. */\r\nvar ResolvedElement = /** @class */ (function () {\r\n    function ResolvedElement() {\r\n    }\r\n    /** Clears the target and sets the resolved element. */\r\n    ResolvedElement.prototype.set = function (element) {\r\n        this.target = null;\r\n        this.targetExpression = null;\r\n        this.element = element;\r\n        return this;\r\n    };\r\n    /** Sets the resolved target in addition to the previously set element. */\r\n    ResolvedElement.prototype.withTarget = function (target, targetExpression) {\r\n        this.target = target;\r\n        this.targetExpression = targetExpression;\r\n        return this;\r\n    };\r\n    return ResolvedElement;\r\n}());\r\nexports.ResolvedElement = ResolvedElement;\r\n// Cached result structure instance\r\nvar resolvedElement;\r\n/** Indicates the specific kind of an {@link Element}. */\r\nvar ElementKind;\r\n(function (ElementKind) {\r\n    /** A {@link Global}. */\r\n    ElementKind[ElementKind[\"GLOBAL\"] = 0] = \"GLOBAL\";\r\n    /** A {@link Local}. */\r\n    ElementKind[ElementKind[\"LOCAL\"] = 1] = \"LOCAL\";\r\n    /** An {@link Enum}. */\r\n    ElementKind[ElementKind[\"ENUM\"] = 2] = \"ENUM\";\r\n    /** An {@link EnumValue}. */\r\n    ElementKind[ElementKind[\"ENUMVALUE\"] = 3] = \"ENUMVALUE\";\r\n    /** A {@link FunctionPrototype}. */\r\n    ElementKind[ElementKind[\"FUNCTION_PROTOTYPE\"] = 4] = \"FUNCTION_PROTOTYPE\";\r\n    /** A {@link Function}. */\r\n    ElementKind[ElementKind[\"FUNCTION\"] = 5] = \"FUNCTION\";\r\n    /** A {@link ClassPrototype}. */\r\n    ElementKind[ElementKind[\"CLASS_PROTOTYPE\"] = 6] = \"CLASS_PROTOTYPE\";\r\n    /** A {@link Class}. */\r\n    ElementKind[ElementKind[\"CLASS\"] = 7] = \"CLASS\";\r\n    /** An {@link InterfacePrototype}. */\r\n    ElementKind[ElementKind[\"INTERFACE_PROTOTYPE\"] = 8] = \"INTERFACE_PROTOTYPE\";\r\n    /** An {@link Interface}. */\r\n    ElementKind[ElementKind[\"INTERFACE\"] = 9] = \"INTERFACE\";\r\n    /** A {@link FieldPrototype}. */\r\n    ElementKind[ElementKind[\"FIELD_PROTOTYPE\"] = 10] = \"FIELD_PROTOTYPE\";\r\n    /** A {@link Field}. */\r\n    ElementKind[ElementKind[\"FIELD\"] = 11] = \"FIELD\";\r\n    /** A {@link Property}. */\r\n    ElementKind[ElementKind[\"PROPERTY\"] = 12] = \"PROPERTY\";\r\n    /** A {@link Namespace}. */\r\n    ElementKind[ElementKind[\"NAMESPACE\"] = 13] = \"NAMESPACE\";\r\n})(ElementKind = exports.ElementKind || (exports.ElementKind = {}));\r\n/** Indicates traits of an {@link Element}. */\r\nvar ElementFlags;\r\n(function (ElementFlags) {\r\n    /** No flags set. */\r\n    ElementFlags[ElementFlags[\"NONE\"] = 0] = \"NONE\";\r\n    /** Is compiled. */\r\n    ElementFlags[ElementFlags[\"COMPILED\"] = 1] = \"COMPILED\";\r\n    /** Is an import. */\r\n    ElementFlags[ElementFlags[\"IMPORTED\"] = 2] = \"IMPORTED\";\r\n    /** Is an export. */\r\n    ElementFlags[ElementFlags[\"EXPORTED\"] = 4] = \"EXPORTED\";\r\n    /** Is built-in. */\r\n    ElementFlags[ElementFlags[\"BUILTIN\"] = 8] = \"BUILTIN\";\r\n    /** Is declared. */\r\n    ElementFlags[ElementFlags[\"DECLARED\"] = 16] = \"DECLARED\";\r\n    /** Is generic. */\r\n    ElementFlags[ElementFlags[\"GENERIC\"] = 32] = \"GENERIC\";\r\n    /** Is constant. */\r\n    ElementFlags[ElementFlags[\"CONSTANT\"] = 64] = \"CONSTANT\";\r\n    /** Has a constant value and is therefore inlined. */\r\n    ElementFlags[ElementFlags[\"INLINED\"] = 128] = \"INLINED\";\r\n    /** Is instance member. */\r\n    ElementFlags[ElementFlags[\"INSTANCE\"] = 256] = \"INSTANCE\";\r\n    /** Is getter. */\r\n    ElementFlags[ElementFlags[\"GETTER\"] = 512] = \"GETTER\";\r\n    /** Is setter. */\r\n    ElementFlags[ElementFlags[\"SETTER\"] = 1024] = \"SETTER\";\r\n    /** Is global. */\r\n    ElementFlags[ElementFlags[\"GLOBAL\"] = 2048] = \"GLOBAL\";\r\n    /** Is read-only. */\r\n    ElementFlags[ElementFlags[\"READONLY\"] = 4096] = \"READONLY\";\r\n    /** Is a public member. */\r\n    ElementFlags[ElementFlags[\"PUBLIC\"] = 8192] = \"PUBLIC\";\r\n    /** Is a protected member. */\r\n    ElementFlags[ElementFlags[\"PROTECTED\"] = 16384] = \"PROTECTED\";\r\n    /** Is a private member. */\r\n    ElementFlags[ElementFlags[\"PRIVATE\"] = 32768] = \"PRIVATE\";\r\n    /** Is an abstract member. */\r\n    ElementFlags[ElementFlags[\"ABSTRACT\"] = 65536] = \"ABSTRACT\";\r\n    /** Is a constructor. */\r\n    ElementFlags[ElementFlags[\"CONSTRUCTOR\"] = 131072] = \"CONSTRUCTOR\";\r\n    /** Is an unmanaged class with limited capabilites. */\r\n    ElementFlags[ElementFlags[\"UNMANAGED\"] = 262144] = \"UNMANAGED\";\r\n    /** Is scoped. */\r\n    ElementFlags[ElementFlags[\"SCOPED\"] = 524288] = \"SCOPED\";\r\n    /** Is the start function. */\r\n    ElementFlags[ElementFlags[\"START\"] = 1048576] = \"START\";\r\n})(ElementFlags = exports.ElementFlags || (exports.ElementFlags = {}));\r\n/** Base class of all program elements. */\r\nvar Element = /** @class */ (function () {\r\n    /** Constructs a new element, linking it to its containing {@link Program}. */\r\n    function Element(program, simpleName, internalName) {\r\n        /** Element flags. */\r\n        this.flags = ElementFlags.NONE;\r\n        /** Namespaced member elements. */\r\n        this.members = null;\r\n        /** Parent namespace, if applicable. */\r\n        this.namespace = null;\r\n        this.program = program;\r\n        this.simpleName = simpleName;\r\n        this.internalName = internalName;\r\n    }\r\n    /** Tests if this element has a specific flag or flags. */\r\n    Element.prototype.is = function (flag) { return (this.flags & flag) == flag; };\r\n    /** Sets a specific flag or flags. */\r\n    Element.prototype.set = function (flag) { this.flags |= flag; };\r\n    return Element;\r\n}());\r\nexports.Element = Element;\r\n/** A namespace. */\r\nvar Namespace = /** @class */ (function (_super) {\r\n    __extends(Namespace, _super);\r\n    /** Constructs a new namespace. */\r\n    function Namespace(program, simpleName, internalName, declaration) {\r\n        var _this = _super.call(this, program, simpleName, internalName) || this;\r\n        // All elements have namespace semantics. This is an explicitly declared one.\r\n        _this.kind = ElementKind.NAMESPACE;\r\n        _this.declaration = declaration;\r\n        if (_this.declaration.modifiers) {\r\n            for (var i = 0, k = _this.declaration.modifiers.length; i < k; ++i) {\r\n                switch (_this.declaration.modifiers[i].modifierKind) {\r\n                    case ast_1.ModifierKind.IMPORT:\r\n                        _this.set(ElementFlags.IMPORTED);\r\n                        break;\r\n                    case ast_1.ModifierKind.EXPORT:\r\n                        _this.set(ElementFlags.EXPORTED);\r\n                        break;\r\n                    case ast_1.ModifierKind.DECLARE:\r\n                        _this.set(ElementFlags.DECLARED);\r\n                        break;\r\n                    default: throw new Error(\"unexpected modifier\");\r\n                }\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    return Namespace;\r\n}(Element));\r\nexports.Namespace = Namespace;\r\n/** An enum. */\r\nvar Enum = /** @class */ (function (_super) {\r\n    __extends(Enum, _super);\r\n    /** Constructs a new enum. */\r\n    function Enum(program, simpleName, internalName, declaration) {\r\n        var _this = _super.call(this, program, simpleName, internalName) || this;\r\n        _this.kind = ElementKind.ENUM;\r\n        _this.declaration = declaration;\r\n        if (_this.declaration.modifiers) {\r\n            for (var i = 0, k = _this.declaration.modifiers.length; i < k; ++i) {\r\n                switch (_this.declaration.modifiers[i].modifierKind) {\r\n                    case ast_1.ModifierKind.EXPORT:\r\n                        _this.set(ElementFlags.EXPORTED);\r\n                        break;\r\n                    case ast_1.ModifierKind.IMPORT:\r\n                        _this.set(ElementFlags.IMPORTED);\r\n                        break;\r\n                    case ast_1.ModifierKind.DECLARE:\r\n                        _this.set(ElementFlags.DECLARED);\r\n                        break;\r\n                    case ast_1.ModifierKind.CONST:\r\n                        _this.set(ElementFlags.CONSTANT);\r\n                        break;\r\n                    default: throw new Error(\"unexpected modifier\");\r\n                }\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    return Enum;\r\n}(Element));\r\nexports.Enum = Enum;\r\n/** An enum value. */\r\nvar EnumValue = /** @class */ (function (_super) {\r\n    __extends(EnumValue, _super);\r\n    function EnumValue(enm, program, simpleName, internalName, declaration) {\r\n        var _this = _super.call(this, program, simpleName, internalName) || this;\r\n        _this.kind = ElementKind.ENUMVALUE;\r\n        /** Constant value, if applicable. */\r\n        _this.constantValue = 0;\r\n        _this.enum = enm;\r\n        _this.declaration = declaration;\r\n        return _this;\r\n    }\r\n    return EnumValue;\r\n}(Element));\r\nexports.EnumValue = EnumValue;\r\nvar ConstantValueKind;\r\n(function (ConstantValueKind) {\r\n    ConstantValueKind[ConstantValueKind[\"NONE\"] = 0] = \"NONE\";\r\n    ConstantValueKind[ConstantValueKind[\"INTEGER\"] = 1] = \"INTEGER\";\r\n    ConstantValueKind[ConstantValueKind[\"FLOAT\"] = 2] = \"FLOAT\";\r\n})(ConstantValueKind = exports.ConstantValueKind || (exports.ConstantValueKind = {}));\r\nvar VariableLikeElement = /** @class */ (function (_super) {\r\n    __extends(VariableLikeElement, _super);\r\n    function VariableLikeElement() {\r\n        // kind varies\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /** Constant value kind. */\r\n        _this.constantValueKind = 0 /* NONE */;\r\n        return _this;\r\n    }\r\n    VariableLikeElement.prototype.withConstantIntegerValue = function (lo, hi) {\r\n        this.constantValueKind = 1 /* INTEGER */;\r\n        this.constantIntegerValue = i64_new(lo, hi);\r\n        this.set(ElementFlags.CONSTANT | ElementFlags.INLINED);\r\n        return this;\r\n    };\r\n    VariableLikeElement.prototype.withConstantFloatValue = function (value) {\r\n        this.constantValueKind = 2 /* FLOAT */;\r\n        this.constantFloatValue = value;\r\n        this.set(ElementFlags.CONSTANT | ElementFlags.INLINED);\r\n        return this;\r\n    };\r\n    return VariableLikeElement;\r\n}(Element));\r\nexports.VariableLikeElement = VariableLikeElement;\r\n/** A global variable. */\r\nvar Global = /** @class */ (function (_super) {\r\n    __extends(Global, _super);\r\n    function Global(program, simpleName, internalName, declaration, type) {\r\n        var _this = _super.call(this, program, simpleName, internalName) || this;\r\n        _this.kind = ElementKind.GLOBAL;\r\n        _this.declaration = declaration;\r\n        if (_this.declaration.modifiers) {\r\n            for (var i = 0, k = _this.declaration.modifiers.length; i < k; ++i) {\r\n                switch (_this.declaration.modifiers[i].modifierKind) {\r\n                    case ast_1.ModifierKind.IMPORT:\r\n                        _this.set(ElementFlags.IMPORTED);\r\n                        break;\r\n                    case ast_1.ModifierKind.EXPORT:\r\n                        _this.set(ElementFlags.EXPORTED);\r\n                        break;\r\n                    case ast_1.ModifierKind.CONST:\r\n                        _this.set(ElementFlags.CONSTANT);\r\n                        break;\r\n                    case ast_1.ModifierKind.LET:\r\n                        _this.set(ElementFlags.SCOPED);\r\n                        break;\r\n                    case ast_1.ModifierKind.DECLARE:\r\n                        _this.set(ElementFlags.DECLARED);\r\n                        break;\r\n                    case ast_1.ModifierKind.READONLY:\r\n                        _this.set(_this.declaration.initializer\r\n                            ? ElementFlags.CONSTANT | ElementFlags.READONLY\r\n                            : ElementFlags.READONLY);\r\n                        break;\r\n                    case ast_1.ModifierKind.PUBLIC:\r\n                    case ast_1.ModifierKind.PRIVATE:\r\n                    case ast_1.ModifierKind.PROTECTED:\r\n                    case ast_1.ModifierKind.STATIC:\r\n                        break; // static fields become globals\r\n                    default:\r\n                        throw new Error(\"unexpected modifier\");\r\n                }\r\n            }\r\n        }\r\n        _this.type = type; // resolved later if `void`\r\n        return _this;\r\n    }\r\n    return Global;\r\n}(VariableLikeElement));\r\nexports.Global = Global;\r\n/** A function parameter. */\r\nvar Parameter = /** @class */ (function () {\r\n    /** Constructs a new function parameter. */\r\n    function Parameter(name, type, initializer) {\r\n        if (initializer === void 0) { initializer = null; }\r\n        this.name = name;\r\n        this.type = type;\r\n        this.initializer = initializer;\r\n    }\r\n    return Parameter;\r\n}());\r\nexports.Parameter = Parameter;\r\n/** A function local. */\r\nvar Local = /** @class */ (function (_super) {\r\n    __extends(Local, _super);\r\n    function Local(program, simpleName, index, type) {\r\n        var _this = _super.call(this, program, simpleName, simpleName) || this;\r\n        _this.kind = ElementKind.LOCAL;\r\n        _this.index = index;\r\n        _this.type = type;\r\n        return _this;\r\n    }\r\n    return Local;\r\n}(VariableLikeElement));\r\nexports.Local = Local;\r\n/** A yet unresolved function prototype. */\r\nvar FunctionPrototype = /** @class */ (function (_super) {\r\n    __extends(FunctionPrototype, _super);\r\n    /** Constructs a new function prototype. */\r\n    function FunctionPrototype(program, simpleName, internalName, declaration, classPrototype) {\r\n        if (classPrototype === void 0) { classPrototype = null; }\r\n        var _this = _super.call(this, program, simpleName, internalName) || this;\r\n        _this.kind = ElementKind.FUNCTION_PROTOTYPE;\r\n        /** Resolved instances. */\r\n        _this.instances = new Map();\r\n        /** Class type arguments, if a partially resolved method of a generic class. */\r\n        _this.classTypeArguments = null;\r\n        _this.declaration = declaration;\r\n        if (_this.declaration.modifiers) {\r\n            for (var i = 0, k = _this.declaration.modifiers.length; i < k; ++i) {\r\n                switch (_this.declaration.modifiers[i].modifierKind) {\r\n                    case ast_1.ModifierKind.IMPORT:\r\n                        _this.set(ElementFlags.IMPORTED);\r\n                        break;\r\n                    case ast_1.ModifierKind.EXPORT:\r\n                        _this.set(ElementFlags.EXPORTED);\r\n                        break;\r\n                    case ast_1.ModifierKind.DECLARE:\r\n                        _this.set(ElementFlags.DECLARED);\r\n                        break;\r\n                    case ast_1.ModifierKind.GET:\r\n                        _this.set(ElementFlags.GETTER);\r\n                        break;\r\n                    case ast_1.ModifierKind.SET:\r\n                        _this.set(ElementFlags.SETTER);\r\n                        break;\r\n                    case ast_1.ModifierKind.STATIC:\r\n                    case ast_1.ModifierKind.ABSTRACT:\r\n                    case ast_1.ModifierKind.PRIVATE:\r\n                    case ast_1.ModifierKind.PROTECTED:\r\n                    case ast_1.ModifierKind.PUBLIC:\r\n                        break; // already handled\r\n                    default:\r\n                        throw new Error(\"unexpected modifier\");\r\n                }\r\n            }\r\n        }\r\n        if (_this.declaration.isGeneric) {\r\n            _this.set(ElementFlags.GENERIC);\r\n        }\r\n        if (_this.classPrototype = classPrototype) {\r\n            _this.set(ElementFlags.INSTANCE);\r\n        }\r\n        return _this;\r\n    }\r\n    FunctionPrototype.prototype.resolve = function (functionTypeArguments, contextualTypeArguments) {\r\n        if (functionTypeArguments === void 0) { functionTypeArguments = null; }\r\n        if (contextualTypeArguments === void 0) { contextualTypeArguments = null; }\r\n        var instanceKey = functionTypeArguments ? types_1.typesToString(functionTypeArguments) : \"\";\r\n        var instance = this.instances.get(instanceKey);\r\n        if (instance)\r\n            return instance;\r\n        var declaration = this.declaration;\r\n        // inherit contextual type arguments\r\n        var inheritedTypeArguments = contextualTypeArguments;\r\n        contextualTypeArguments = new Map();\r\n        if (inheritedTypeArguments) {\r\n            try {\r\n                for (var inheritedTypeArguments_1 = __values(inheritedTypeArguments), inheritedTypeArguments_1_1 = inheritedTypeArguments_1.next(); !inheritedTypeArguments_1_1.done; inheritedTypeArguments_1_1 = inheritedTypeArguments_1.next()) {\r\n                    var _a = __read(inheritedTypeArguments_1_1.value, 2), inheritedName = _a[0], inheritedType = _a[1];\r\n                    contextualTypeArguments.set(inheritedName, inheritedType);\r\n                }\r\n            }\r\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n            finally {\r\n                try {\r\n                    if (inheritedTypeArguments_1_1 && !inheritedTypeArguments_1_1.done && (_b = inheritedTypeArguments_1.return)) _b.call(inheritedTypeArguments_1);\r\n                }\r\n                finally { if (e_2) throw e_2.error; }\r\n            }\r\n        }\r\n        var i, k;\r\n        // inherit class type arguments if a partially resolved instance method (classTypeArguments is set)\r\n        if (this.classTypeArguments) {\r\n            if (!this.classPrototype) {\r\n                throw new Error(\"partially resolved instance method must reference its class prototype\");\r\n            }\r\n            var classDeclaration = this.classPrototype.declaration;\r\n            var classTypeParameters = classDeclaration.typeParameters;\r\n            if ((k = this.classTypeArguments.length) != classTypeParameters.length) {\r\n                throw new Error(\"type argument count mismatch\");\r\n            }\r\n            for (i = 0; i < k; ++i) {\r\n                contextualTypeArguments.set(classTypeParameters[i].name.text, this.classTypeArguments[i]);\r\n            }\r\n        }\r\n        // override call specific contextual type arguments\r\n        var functionTypeParameters = declaration.typeParameters;\r\n        if (functionTypeArguments && (k = functionTypeArguments.length)) {\r\n            if (!functionTypeParameters || k != functionTypeParameters.length) {\r\n                throw new Error(\"type argument count mismatch\");\r\n            }\r\n            for (i = 0; i < k; ++i) {\r\n                contextualTypeArguments.set(functionTypeParameters[i].name.text, functionTypeArguments[i]);\r\n            }\r\n        }\r\n        // resolve parameters\r\n        // TODO: 'this' type\r\n        k = declaration.parameters.length;\r\n        var parameters = new Array(k);\r\n        var parameterTypes = new Array(k);\r\n        var typeNode;\r\n        for (i = 0; i < k; ++i) {\r\n            var parameterDeclaration = declaration.parameters[i];\r\n            typeNode = assert(parameterDeclaration.type);\r\n            var parameterType = this.program.resolveType(typeNode, contextualTypeArguments, true); // reports\r\n            if (parameterType) {\r\n                parameters[i] = new Parameter(parameterDeclaration.name.text, parameterType, parameterDeclaration.initializer);\r\n                parameterTypes[i] = parameterType;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        var internalName = this.internalName;\r\n        if (instanceKey.length) {\r\n            internalName += \"<\" + instanceKey + \">\";\r\n        }\r\n        var classInstance = null;\r\n        if (this.classPrototype) {\r\n            classInstance = this.classPrototype.resolve(this.classTypeArguments, contextualTypeArguments); // reports\r\n            if (!classInstance)\r\n                return null;\r\n        }\r\n        // resolve return type\r\n        // TODO: 'this' type\r\n        var returnType;\r\n        if (this.is(ElementFlags.SETTER) || this.is(ElementFlags.CONSTRUCTOR)) {\r\n            returnType = types_1.Type.void; // not annotated\r\n        }\r\n        else {\r\n            typeNode = assert(declaration.returnType);\r\n            var type = this.program.resolveType(typeNode, contextualTypeArguments, true); // reports\r\n            if (type) {\r\n                returnType = type;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n        instance = new Function(this, internalName, functionTypeArguments, parameters, returnType, classInstance);\r\n        instance.contextualTypeArguments = contextualTypeArguments;\r\n        this.instances.set(instanceKey, instance);\r\n        return instance;\r\n        var e_2, _b;\r\n    };\r\n    FunctionPrototype.prototype.resolveInclTypeArguments = function (typeArgumentNodes, contextualTypeArguments, reportNode) {\r\n        var resolvedTypeArguments = null;\r\n        if (this.is(ElementFlags.GENERIC)) {\r\n            assert(typeArgumentNodes != null && typeArgumentNodes.length != 0);\r\n            resolvedTypeArguments = this.program.resolveTypeArguments(assert(this.declaration.typeParameters), typeArgumentNodes, contextualTypeArguments, reportNode);\r\n            if (!resolvedTypeArguments)\r\n                return null;\r\n        }\r\n        return this.resolve(resolvedTypeArguments, contextualTypeArguments);\r\n    };\r\n    FunctionPrototype.prototype.resolvePartial = function (classTypeArguments) {\r\n        if (!this.classPrototype) {\r\n            throw new Error(\"partially resolved instance method must reference its class prototype\");\r\n        }\r\n        if (classTypeArguments && classTypeArguments.length) {\r\n            var partialPrototype = new FunctionPrototype(this.program, this.simpleName, this.internalName, this.declaration, this.classPrototype);\r\n            partialPrototype.flags = this.flags;\r\n            partialPrototype.classTypeArguments = classTypeArguments;\r\n            return partialPrototype;\r\n        }\r\n        return this; // no need to clone\r\n    };\r\n    FunctionPrototype.prototype.toString = function () { return this.simpleName; };\r\n    return FunctionPrototype;\r\n}(Element));\r\nexports.FunctionPrototype = FunctionPrototype;\r\n/** A resolved function. */\r\nvar Function = /** @class */ (function (_super) {\r\n    __extends(Function, _super);\r\n    /** Constructs a new concrete function. */\r\n    function Function(prototype, internalName, typeArguments, parameters, returnType, instanceMethodOf) {\r\n        if (instanceMethodOf === void 0) { instanceMethodOf = null; }\r\n        var _this = _super.call(this, prototype.program, prototype.simpleName, internalName) || this;\r\n        _this.kind = ElementKind.FUNCTION;\r\n        /** Map of locals by name. */\r\n        _this.locals = new Map();\r\n        /** List of additional non-parameter locals. */\r\n        _this.additionalLocals = [];\r\n        /** Current break context label. */\r\n        _this.breakContext = null;\r\n        /** Remembered debug locations. */\r\n        _this.debugLocations = null;\r\n        /** Function reference, if compiled. */\r\n        _this.ref = 0;\r\n        /** Function table index, if any. */\r\n        _this.functionTableIndex = -1;\r\n        _this.nextBreakId = 0;\r\n        _this.breakStack = null;\r\n        _this.tempI32s = null;\r\n        _this.tempI64s = null;\r\n        _this.tempF32s = null;\r\n        _this.tempF64s = null;\r\n        _this.prototype = prototype;\r\n        _this.typeArguments = typeArguments;\r\n        _this.parameters = parameters || [];\r\n        _this.returnType = returnType;\r\n        _this.instanceMethodOf = instanceMethodOf;\r\n        _this.flags = prototype.flags;\r\n        if (!(prototype.is(ElementFlags.BUILTIN) || prototype.is(ElementFlags.DECLARED))) {\r\n            var localIndex = 0;\r\n            if (instanceMethodOf) {\r\n                assert(_this.is(ElementFlags.INSTANCE)); // internal error\r\n                _this.locals.set(\"this\", new Local(prototype.program, \"this\", localIndex++, instanceMethodOf.type));\r\n                if (instanceMethodOf.contextualTypeArguments) {\r\n                    if (!_this.contextualTypeArguments) {\r\n                        _this.contextualTypeArguments = new Map();\r\n                    }\r\n                    try {\r\n                        for (var _a = __values(instanceMethodOf.contextualTypeArguments), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                            var _c = __read(_b.value, 2), inheritedName = _c[0], inheritedType = _c[1];\r\n                            _this.contextualTypeArguments.set(inheritedName, inheritedType);\r\n                        }\r\n                    }\r\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n                    finally {\r\n                        try {\r\n                            if (_b && !_b.done && (_d = _a.return)) _d.call(_a);\r\n                        }\r\n                        finally { if (e_3) throw e_3.error; }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                assert(!_this.is(ElementFlags.INSTANCE)); // internal error\r\n            }\r\n            for (var i = 0, k = _this.parameters.length; i < k; ++i) {\r\n                var parameter = _this.parameters[i];\r\n                var parameterName = assert(parameter.name, \"parameter must be named\"); // not a builtin or declared\r\n                _this.locals.set(parameterName, new Local(prototype.program, parameterName, localIndex++, parameter.type));\r\n            }\r\n        }\r\n        _this.flow = Flow.create(_this);\r\n        return _this;\r\n        var e_3, _d;\r\n    }\r\n    /** Adds a local of the specified type, with an optional name. */\r\n    Function.prototype.addLocal = function (type, name) {\r\n        if (name === void 0) { name = null; }\r\n        // if it has a name, check previously as this method will throw otherwise\r\n        var localIndex = (this.parameters ? this.parameters.length : 0) + this.additionalLocals.length;\r\n        if (this.is(ElementFlags.INSTANCE))\r\n            localIndex++; // plus 'this'\r\n        var local = new Local(this.prototype.program, name\r\n            ? name\r\n            : \"var$\" + localIndex.toString(10), localIndex, type);\r\n        if (name) {\r\n            if (this.locals.has(name))\r\n                throw new Error(\"duplicate local name\");\r\n            this.locals.set(name, local);\r\n        }\r\n        this.additionalLocals.push(type);\r\n        return local;\r\n    };\r\n    /** Gets a free temporary local of the specified type. */\r\n    Function.prototype.getTempLocal = function (type) {\r\n        var temps;\r\n        switch (type.toNativeType()) {\r\n            case module_1.NativeType.I32:\r\n                temps = this.tempI32s;\r\n                break;\r\n            case module_1.NativeType.I64:\r\n                temps = this.tempI64s;\r\n                break;\r\n            case module_1.NativeType.F32:\r\n                temps = this.tempF32s;\r\n                break;\r\n            case module_1.NativeType.F64:\r\n                temps = this.tempF64s;\r\n                break;\r\n            default: throw new Error(\"concrete type expected\");\r\n        }\r\n        if (temps && temps.length) {\r\n            var ret = temps.pop();\r\n            ret.type = type;\r\n            return ret;\r\n        }\r\n        return this.addLocal(type);\r\n    };\r\n    /** Frees the temporary local for reuse. */\r\n    Function.prototype.freeTempLocal = function (local) {\r\n        var temps;\r\n        assert(local.type != null); // internal error\r\n        switch (local.type.toNativeType()) {\r\n            case module_1.NativeType.I32:\r\n                temps = this.tempI32s || (this.tempI32s = []);\r\n                break;\r\n            case module_1.NativeType.I64:\r\n                temps = this.tempI64s || (this.tempI64s = []);\r\n                break;\r\n            case module_1.NativeType.F32:\r\n                temps = this.tempF32s || (this.tempF32s = []);\r\n                break;\r\n            case module_1.NativeType.F64:\r\n                temps = this.tempF64s || (this.tempF64s = []);\r\n                break;\r\n            default: throw new Error(\"concrete type expected\");\r\n        }\r\n        temps.push(local);\r\n    };\r\n    /** Gets and immediately frees a temporary local of the specified type. */\r\n    Function.prototype.getAndFreeTempLocal = function (type) {\r\n        var temps;\r\n        switch (type.toNativeType()) {\r\n            case module_1.NativeType.I32:\r\n                temps = this.tempI32s || (this.tempI32s = []);\r\n                break;\r\n            case module_1.NativeType.I64:\r\n                temps = this.tempI64s || (this.tempI64s = []);\r\n                break;\r\n            case module_1.NativeType.F32:\r\n                temps = this.tempF32s || (this.tempF32s = []);\r\n                break;\r\n            case module_1.NativeType.F64:\r\n                temps = this.tempF64s || (this.tempF64s = []);\r\n                break;\r\n            default: throw new Error(\"concrete type expected\");\r\n        }\r\n        if (temps.length > 0) {\r\n            return temps[temps.length - 1];\r\n        }\r\n        var local = this.addLocal(type);\r\n        temps.push(local);\r\n        return local;\r\n    };\r\n    /** Enters a(nother) break context. */\r\n    Function.prototype.enterBreakContext = function () {\r\n        var id = this.nextBreakId++;\r\n        if (!this.breakStack) {\r\n            this.breakStack = [id];\r\n        }\r\n        else {\r\n            this.breakStack.push(id);\r\n        }\r\n        return this.breakContext = id.toString(10);\r\n    };\r\n    /** Leaves the current break context. */\r\n    Function.prototype.leaveBreakContext = function () {\r\n        assert(this.breakStack != null);\r\n        var length = this.breakStack.length;\r\n        assert(length > 0);\r\n        this.breakStack.pop();\r\n        if (length > 1) {\r\n            this.breakContext = this.breakStack[length - 2].toString(10);\r\n        }\r\n        else {\r\n            this.breakContext = null;\r\n            this.breakStack = null;\r\n        }\r\n    };\r\n    /** Finalizes the function once compiled, releasing no longer needed resources. */\r\n    Function.prototype.finalize = function (module, ref) {\r\n        this.ref = ref;\r\n        assert(!this.breakStack || !this.breakStack.length); // internal error\r\n        this.breakStack = null;\r\n        this.breakContext = null;\r\n        this.tempI32s = this.tempI64s = this.tempF32s = this.tempF64s = null;\r\n        if (this.program.options.sourceMap) {\r\n            var debugLocations = this.debugLocations;\r\n            if (debugLocations) {\r\n                for (var i = 0, k = debugLocations.length; i < k; ++i) {\r\n                    var debugLocation = debugLocations[i];\r\n                    module.setDebugLocation(ref, debugLocation.debugInfoRef, debugLocation.source.debugInfoIndex, debugLocation.line, debugLocation.column);\r\n                }\r\n            }\r\n        }\r\n        this.debugLocations = null;\r\n    };\r\n    /** Tests if a value of this function type is assignable to a target of the specified function type. */\r\n    Function.prototype.isAssignableTo = function (target) {\r\n        return this == target; // TODO\r\n    };\r\n    /** Returns the TypeScript representation of this function. */\r\n    Function.prototype.toString = function () { return this.prototype.simpleName; };\r\n    /** Returns the function type TypeScript representation of this function.*/\r\n    Function.prototype.toTypeString = function () { throw new Error(\"not implemented\"); };\r\n    return Function;\r\n}(Element));\r\nexports.Function = Function;\r\n/** A yet unresolved instance field prototype. */\r\nvar FieldPrototype = /** @class */ (function (_super) {\r\n    __extends(FieldPrototype, _super);\r\n    /** Constructs a new field prototype. */\r\n    function FieldPrototype(classPrototype, simpleName, internalName, declaration) {\r\n        var _this = _super.call(this, classPrototype.program, simpleName, internalName) || this;\r\n        _this.kind = ElementKind.FIELD_PROTOTYPE;\r\n        _this.classPrototype = classPrototype;\r\n        _this.declaration = declaration;\r\n        if (_this.declaration.modifiers) {\r\n            for (var i = 0, k = _this.declaration.modifiers.length; i < k; ++i) {\r\n                switch (_this.declaration.modifiers[i].modifierKind) {\r\n                    case ast_1.ModifierKind.EXPORT:\r\n                        _this.set(ElementFlags.EXPORTED);\r\n                        break;\r\n                    case ast_1.ModifierKind.READONLY:\r\n                        _this.set(ElementFlags.READONLY);\r\n                        break;\r\n                    case ast_1.ModifierKind.PRIVATE:\r\n                    case ast_1.ModifierKind.PROTECTED:\r\n                    case ast_1.ModifierKind.PUBLIC:\r\n                    case ast_1.ModifierKind.STATIC:\r\n                        break; // already handled\r\n                    default:\r\n                        throw new Error(\"unexpected modifier\");\r\n                }\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    Object.defineProperty(FieldPrototype.prototype, \"isReadonly\", {\r\n        /** Whether the field is read-only or not. */\r\n        get: function () {\r\n            return (this.flags & ElementFlags.READONLY) != 0;\r\n        },\r\n        set: function (is) {\r\n            if (is) {\r\n                this.flags |= ElementFlags.READONLY;\r\n            }\r\n            else {\r\n                this.flags &= ~ElementFlags.READONLY;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return FieldPrototype;\r\n}(Element));\r\nexports.FieldPrototype = FieldPrototype;\r\n/** A resolved instance field. */\r\nvar Field = /** @class */ (function (_super) {\r\n    __extends(Field, _super);\r\n    /** Constructs a new field. */\r\n    function Field(prototype, internalName, type) {\r\n        var _this = _super.call(this, prototype.program, prototype.simpleName, internalName) || this;\r\n        _this.kind = ElementKind.FIELD;\r\n        /** Field memory offset, if an instance field. */\r\n        _this.memoryOffset = -1;\r\n        _this.prototype = prototype;\r\n        _this.flags = prototype.flags;\r\n        _this.type = type;\r\n        return _this;\r\n    }\r\n    return Field;\r\n}(VariableLikeElement));\r\nexports.Field = Field;\r\n/** A property comprised of a getter and a setter function. */\r\nvar Property = /** @class */ (function (_super) {\r\n    __extends(Property, _super);\r\n    /** Constructs a new property prototype. */\r\n    function Property(program, simpleName, internalName, parent) {\r\n        var _this = _super.call(this, program, simpleName, internalName) || this;\r\n        _this.kind = ElementKind.PROPERTY;\r\n        /** Getter prototype. */\r\n        _this.getterPrototype = null;\r\n        /** Setter prototype. */\r\n        _this.setterPrototype = null;\r\n        _this.parent = parent;\r\n        return _this;\r\n    }\r\n    return Property;\r\n}(Element));\r\nexports.Property = Property;\r\n/** A yet unresolved class prototype. */\r\nvar ClassPrototype = /** @class */ (function (_super) {\r\n    __extends(ClassPrototype, _super);\r\n    function ClassPrototype(program, simpleName, internalName, declaration) {\r\n        var _this = _super.call(this, program, simpleName, internalName) || this;\r\n        _this.kind = ElementKind.CLASS_PROTOTYPE;\r\n        /** Resolved instances. */\r\n        _this.instances = new Map();\r\n        /** Instance member prototypes. */\r\n        _this.instanceMembers = null;\r\n        /** Base class prototype, if applicable. */\r\n        _this.basePrototype = null; // set in Program#initialize\r\n        /** Constructor prototype. */\r\n        _this.constructorPrototype = null;\r\n        /** Overloaded indexed get method, if any. */\r\n        _this.fnIndexedGet = null;\r\n        /** Overloaded indexed set method, if any. */\r\n        _this.fnIndexedSet = null;\r\n        /** Overloaded concatenation method, if any. */\r\n        _this.fnConcat = null;\r\n        /** Overloaded equality comparison method, if any. */\r\n        _this.fnEquals = null;\r\n        _this.declaration = declaration;\r\n        if (_this.declaration.modifiers) {\r\n            for (var i = 0, k = _this.declaration.modifiers.length; i < k; ++i) {\r\n                switch (_this.declaration.modifiers[i].modifierKind) {\r\n                    case ast_1.ModifierKind.IMPORT:\r\n                        _this.set(ElementFlags.IMPORTED);\r\n                        break;\r\n                    case ast_1.ModifierKind.EXPORT:\r\n                        _this.set(ElementFlags.EXPORTED);\r\n                        break;\r\n                    case ast_1.ModifierKind.DECLARE:\r\n                        _this.set(ElementFlags.DECLARED);\r\n                        break;\r\n                    default: throw new Error(\"unexpected modifier\");\r\n                }\r\n            }\r\n        }\r\n        if (_this.declaration.typeParameters.length) {\r\n            _this.set(ElementFlags.GENERIC);\r\n        }\r\n        return _this;\r\n    }\r\n    Object.defineProperty(ClassPrototype.prototype, \"isUnmanaged\", {\r\n        /** Whether an unamanaged class or not. */\r\n        get: function () {\r\n            return (this.flags & ElementFlags.UNMANAGED) != 0;\r\n        },\r\n        set: function (is) {\r\n            if (is) {\r\n                this.flags |= ElementFlags.UNMANAGED;\r\n            }\r\n            else {\r\n                this.flags &= ~ElementFlags.UNMANAGED;\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    ClassPrototype.prototype.resolve = function (typeArguments, contextualTypeArguments) {\r\n        if (contextualTypeArguments === void 0) { contextualTypeArguments = null; }\r\n        var instanceKey = typeArguments ? types_1.typesToString(typeArguments) : \"\";\r\n        var instance = this.instances.get(instanceKey);\r\n        if (instance)\r\n            return instance;\r\n        // inherit contextual type arguments\r\n        var inheritedTypeArguments = contextualTypeArguments;\r\n        contextualTypeArguments = new Map();\r\n        if (inheritedTypeArguments) {\r\n            try {\r\n                for (var inheritedTypeArguments_2 = __values(inheritedTypeArguments), inheritedTypeArguments_2_1 = inheritedTypeArguments_2.next(); !inheritedTypeArguments_2_1.done; inheritedTypeArguments_2_1 = inheritedTypeArguments_2.next()) {\r\n                    var _a = __read(inheritedTypeArguments_2_1.value, 2), inheritedName = _a[0], inheritedType = _a[1];\r\n                    contextualTypeArguments.set(inheritedName, inheritedType);\r\n                }\r\n            }\r\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n            finally {\r\n                try {\r\n                    if (inheritedTypeArguments_2_1 && !inheritedTypeArguments_2_1.done && (_b = inheritedTypeArguments_2.return)) _b.call(inheritedTypeArguments_2);\r\n                }\r\n                finally { if (e_4) throw e_4.error; }\r\n            }\r\n        }\r\n        var declaration = this.declaration;\r\n        var baseClass = null;\r\n        if (declaration.extendsType) {\r\n            var baseClassType = this.program.resolveType(declaration.extendsType, null); // reports\r\n            if (!baseClassType)\r\n                return null;\r\n            if (!(baseClass = baseClassType.classType)) {\r\n                this.program.error(diagnostics_1.DiagnosticCode.A_class_may_only_extend_another_class, declaration.extendsType.range);\r\n                return null;\r\n            }\r\n            if (baseClass.prototype.isUnmanaged != this.isUnmanaged) {\r\n                this.program.error(diagnostics_1.DiagnosticCode.Structs_cannot_extend_classes_and_vice_versa, ast_1.Range.join(declaration.name.range, declaration.extendsType.range));\r\n                return null;\r\n            }\r\n        }\r\n        // override call specific contextual type arguments if provided\r\n        var i, k;\r\n        if (typeArguments) {\r\n            if ((k = typeArguments.length) != declaration.typeParameters.length) {\r\n                throw new Error(\"type argument count mismatch\");\r\n            }\r\n            for (i = 0; i < k; ++i) {\r\n                contextualTypeArguments.set(declaration.typeParameters[i].name.text, typeArguments[i]);\r\n            }\r\n        }\r\n        else if (declaration.typeParameters.length) {\r\n            throw new Error(\"type argument count mismatch\");\r\n        }\r\n        var internalName = this.internalName;\r\n        if (instanceKey.length) {\r\n            internalName += \"<\" + instanceKey + \">\";\r\n        }\r\n        instance = new Class(this, internalName, typeArguments, baseClass);\r\n        instance.contextualTypeArguments = contextualTypeArguments;\r\n        this.instances.set(instanceKey, instance);\r\n        var memoryOffset = 0;\r\n        if (baseClass) {\r\n            memoryOffset = baseClass.currentMemoryOffset;\r\n            if (baseClass.members) {\r\n                if (!instance.members)\r\n                    instance.members = new Map();\r\n                try {\r\n                    for (var _c = __values(baseClass.members.values()), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                        var inheritedMember = _d.value;\r\n                        instance.members.set(inheritedMember.simpleName, inheritedMember);\r\n                    }\r\n                }\r\n                catch (e_5_1) { e_5 = { error: e_5_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_d && !_d.done && (_e = _c.return)) _e.call(_c);\r\n                    }\r\n                    finally { if (e_5) throw e_5.error; }\r\n                }\r\n            }\r\n        }\r\n        if (this.constructorPrototype) {\r\n            var partialConstructor = this.constructorPrototype.resolvePartial(typeArguments); // reports\r\n            if (partialConstructor) {\r\n                instance.constructorInstance = partialConstructor.resolve(); // reports\r\n            }\r\n            // TODO: ^ doesn't know the return type, hence returns null\r\n        }\r\n        if (this.instanceMembers) {\r\n            try {\r\n                for (var _f = __values(this.instanceMembers.values()), _g = _f.next(); !_g.done; _g = _f.next()) {\r\n                    var member = _g.value;\r\n                    switch (member.kind) {\r\n                        case ElementKind.FIELD_PROTOTYPE:// fields are layed out in advance\r\n                            if (!instance.members)\r\n                                instance.members = new Map();\r\n                            var fieldDeclaration = member.declaration;\r\n                            if (!fieldDeclaration.type) {\r\n                                throw new Error(\"type expected\"); // TODO: check if parent class defines a type\r\n                            }\r\n                            var fieldType = this.program.resolveType(// reports\r\n                            fieldDeclaration.type, instance.contextualTypeArguments);\r\n                            if (fieldType) {\r\n                                var fieldInstance = new Field(member, member.internalName, fieldType);\r\n                                switch (fieldType.byteSize) {\r\n                                    case 1: break;\r\n                                    case 2:\r\n                                        if (memoryOffset & 1)\r\n                                            ++memoryOffset;\r\n                                        break;\r\n                                    case 4:\r\n                                        if (memoryOffset & 3)\r\n                                            memoryOffset = (memoryOffset | 3) + 1;\r\n                                        break;\r\n                                    case 8:\r\n                                        if (memoryOffset & 7)\r\n                                            memoryOffset = (memoryOffset | 7) + 1;\r\n                                        break;\r\n                                    default: assert(false);\r\n                                }\r\n                                fieldInstance.memoryOffset = memoryOffset;\r\n                                memoryOffset += fieldType.byteSize;\r\n                                instance.members.set(member.simpleName, fieldInstance);\r\n                            }\r\n                            break;\r\n                        case ElementKind.FUNCTION_PROTOTYPE:// instance methods remain partially resolved prototypes until compiled\r\n                            if (!instance.members)\r\n                                instance.members = new Map();\r\n                            var methodPrototype = member.resolvePartial(typeArguments); // reports\r\n                            if (methodPrototype) {\r\n                                instance.members.set(member.simpleName, methodPrototype);\r\n                            }\r\n                            break;\r\n                        case ElementKind.PROPERTY:// instance properties are cloned with partially resolved getters and setters\r\n                            if (!instance.members)\r\n                                instance.members = new Map();\r\n                            assert(member.getterPrototype);\r\n                            var instanceProperty = new Property(this.program, member.simpleName, member.internalName, this);\r\n                            instanceProperty.getterPrototype = (member.getterPrototype.resolvePartial(typeArguments));\r\n                            if (member.setterPrototype) {\r\n                                instanceProperty.setterPrototype = (member.setterPrototype.resolvePartial(typeArguments));\r\n                            }\r\n                            instance.members.set(member.simpleName, instanceProperty);\r\n                            break;\r\n                        default:\r\n                            throw new Error(\"instance member expected\");\r\n                    }\r\n                }\r\n            }\r\n            catch (e_6_1) { e_6 = { error: e_6_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_g && !_g.done && (_h = _f.return)) _h.call(_f);\r\n                }\r\n                finally { if (e_6) throw e_6.error; }\r\n            }\r\n        }\r\n        instance.currentMemoryOffset = memoryOffset; // sizeof<this>() is its byte size in memory\r\n        return instance;\r\n        var e_4, _b, e_5, _e, e_6, _h;\r\n    };\r\n    ClassPrototype.prototype.resolveInclTypeArguments = function (typeArgumentNodes, contextualTypeArguments, alternativeReportNode) {\r\n        var resolvedTypeArguments = null;\r\n        if (this.is(ElementFlags.GENERIC)) {\r\n            assert(typeArgumentNodes != null && typeArgumentNodes.length != 0);\r\n            resolvedTypeArguments = this.program.resolveTypeArguments(this.declaration.typeParameters, typeArgumentNodes, contextualTypeArguments, alternativeReportNode);\r\n            if (!resolvedTypeArguments)\r\n                return null;\r\n        }\r\n        else {\r\n            assert(typeArgumentNodes == null || !typeArgumentNodes.length);\r\n        }\r\n        return this.resolve(resolvedTypeArguments, contextualTypeArguments);\r\n    };\r\n    ClassPrototype.prototype.toString = function () {\r\n        return this.simpleName;\r\n    };\r\n    return ClassPrototype;\r\n}(Element));\r\nexports.ClassPrototype = ClassPrototype;\r\n/** A resolved class. */\r\nvar Class = /** @class */ (function (_super) {\r\n    __extends(Class, _super);\r\n    /** Constructs a new class. */\r\n    function Class(prototype, internalName, typeArguments, base) {\r\n        if (typeArguments === void 0) { typeArguments = null; }\r\n        if (base === void 0) { base = null; }\r\n        var _this = _super.call(this, prototype.program, prototype.simpleName, internalName) || this;\r\n        _this.kind = ElementKind.CLASS;\r\n        /** Contextual type arguments for fields and methods. */\r\n        _this.contextualTypeArguments = null;\r\n        /** Current member memory offset. */\r\n        _this.currentMemoryOffset = 0;\r\n        /** Constructor instance. */\r\n        _this.constructorInstance = null;\r\n        _this.prototype = prototype;\r\n        _this.flags = prototype.flags;\r\n        _this.typeArguments = typeArguments;\r\n        _this.type = prototype.program.options.usizeType.asClass(_this);\r\n        _this.base = base;\r\n        // inherit static members and contextual type arguments from base class\r\n        if (base) {\r\n            if (base.contextualTypeArguments) {\r\n                if (!_this.contextualTypeArguments)\r\n                    _this.contextualTypeArguments = new Map();\r\n                try {\r\n                    for (var _a = __values(base.contextualTypeArguments), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                        var _c = __read(_b.value, 2), baseName = _c[0], baseType = _c[1];\r\n                        _this.contextualTypeArguments.set(baseName, baseType);\r\n                    }\r\n                }\r\n                catch (e_7_1) { e_7 = { error: e_7_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_b && !_b.done && (_d = _a.return)) _d.call(_a);\r\n                    }\r\n                    finally { if (e_7) throw e_7.error; }\r\n                }\r\n            }\r\n        }\r\n        // apply instance-specific contextual type arguments\r\n        var declaration = _this.prototype.declaration;\r\n        var i, k;\r\n        if (declaration) {\r\n            var typeParameters = declaration.typeParameters;\r\n            if (typeArguments) {\r\n                if ((k = typeArguments.length) != typeParameters.length) {\r\n                    throw new Error(\"type argument count mismatch\");\r\n                }\r\n                if (k) {\r\n                    if (!_this.contextualTypeArguments)\r\n                        _this.contextualTypeArguments = new Map();\r\n                    for (i = 0; i < k; ++i) {\r\n                        _this.contextualTypeArguments.set(typeParameters[i].name.text, typeArguments[i]);\r\n                    }\r\n                }\r\n            }\r\n            else if (typeParameters.length) {\r\n                throw new Error(\"type argument count mismatch\");\r\n            }\r\n        }\r\n        return _this;\r\n        var e_7, _d;\r\n    }\r\n    /** Tests if a value of this class type is assignable to a target of the specified class type. */\r\n    Class.prototype.isAssignableTo = function (target) {\r\n        var current = this;\r\n        do {\r\n            if (current == target) {\r\n                return true;\r\n            }\r\n        } while (current = current.base);\r\n        return false;\r\n    };\r\n    Class.prototype.toString = function () {\r\n        return this.prototype.simpleName;\r\n    };\r\n    return Class;\r\n}(Element));\r\nexports.Class = Class;\r\n/** A yet unresolved interface. */\r\nvar InterfacePrototype = /** @class */ (function (_super) {\r\n    __extends(InterfacePrototype, _super);\r\n    /** Constructs a new interface prototype. */\r\n    function InterfacePrototype(program, simpleName, internalName, declaration) {\r\n        var _this = _super.call(this, program, simpleName, internalName, declaration) || this;\r\n        _this.kind = ElementKind.INTERFACE_PROTOTYPE;\r\n        return _this;\r\n    }\r\n    return InterfacePrototype;\r\n}(ClassPrototype));\r\nexports.InterfacePrototype = InterfacePrototype;\r\n/** A resolved interface. */\r\nvar Interface = /** @class */ (function (_super) {\r\n    __extends(Interface, _super);\r\n    /** Constructs a new interface. */\r\n    function Interface(prototype, internalName, typeArguments, base) {\r\n        if (typeArguments === void 0) { typeArguments = []; }\r\n        if (base === void 0) { base = null; }\r\n        var _this = _super.call(this, prototype, internalName, typeArguments, base) || this;\r\n        _this.kind = ElementKind.INTERFACE;\r\n        return _this;\r\n    }\r\n    return Interface;\r\n}(Class));\r\nexports.Interface = Interface;\r\n/** Control flow flags indicating specific conditions. */\r\nvar FlowFlags;\r\n(function (FlowFlags) {\r\n    /** No specific conditions. */\r\n    FlowFlags[FlowFlags[\"NONE\"] = 0] = \"NONE\";\r\n    /** This branch always returns. */\r\n    FlowFlags[FlowFlags[\"RETURNS\"] = 1] = \"RETURNS\";\r\n    /** This branch possibly throws. */\r\n    FlowFlags[FlowFlags[\"POSSIBLY_THROWS\"] = 2] = \"POSSIBLY_THROWS\";\r\n    /** This branch possible breaks. */\r\n    FlowFlags[FlowFlags[\"POSSIBLY_BREAKS\"] = 4] = \"POSSIBLY_BREAKS\";\r\n    /** This branch possible continues. */\r\n    FlowFlags[FlowFlags[\"POSSIBLY_CONTINUES\"] = 8] = \"POSSIBLY_CONTINUES\";\r\n})(FlowFlags = exports.FlowFlags || (exports.FlowFlags = {}));\r\n/** A control flow evaluator. */\r\nvar Flow = /** @class */ (function () {\r\n    function Flow() {\r\n        /** Scoped local variables. */\r\n        this.scopedLocals = null;\r\n    }\r\n    /** Creates the parent flow of the specified function. */\r\n    Flow.create = function (currentFunction) {\r\n        var parentFlow = new Flow();\r\n        parentFlow.parent = null;\r\n        parentFlow.flags = 0 /* NONE */;\r\n        parentFlow.currentFunction = currentFunction;\r\n        parentFlow.continueLabel = null;\r\n        parentFlow.breakLabel = null;\r\n        return parentFlow;\r\n    };\r\n    /** Tests if this flow has the specified flag or flags. */\r\n    Flow.prototype.is = function (flag) { return (this.flags & flag) == flag; };\r\n    /** Sets the specified flag or flags. */\r\n    Flow.prototype.set = function (flag) { this.flags |= flag; };\r\n    /** Enters a new branch or scope and returns the new flow. */\r\n    Flow.prototype.enterBranchOrScope = function () {\r\n        var branchFlow = new Flow();\r\n        branchFlow.parent = this;\r\n        branchFlow.flags = this.flags;\r\n        branchFlow.currentFunction = this.currentFunction;\r\n        branchFlow.continueLabel = this.continueLabel;\r\n        branchFlow.breakLabel = this.breakLabel;\r\n        return branchFlow;\r\n    };\r\n    /** Leaves the current branch or scope and returns the parent flow. */\r\n    Flow.prototype.leaveBranchOrScope = function () {\r\n        var parent = assert(this.parent);\r\n        // Free block-scoped locals\r\n        if (this.scopedLocals) {\r\n            try {\r\n                for (var _a = __values(this.scopedLocals.values()), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                    var scopedLocal = _b.value;\r\n                    this.currentFunction.freeTempLocal(scopedLocal);\r\n                }\r\n            }\r\n            catch (e_8_1) { e_8 = { error: e_8_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n                }\r\n                finally { if (e_8) throw e_8.error; }\r\n            }\r\n            this.scopedLocals = null;\r\n        }\r\n        // Propagate flags to parent\r\n        if (this.is(2 /* POSSIBLY_THROWS */)) {\r\n            parent.set(2 /* POSSIBLY_THROWS */);\r\n        }\r\n        if (this.is(4 /* POSSIBLY_BREAKS */) && parent.breakLabel == this.breakLabel) {\r\n            parent.set(4 /* POSSIBLY_BREAKS */);\r\n        }\r\n        if (this.is(8 /* POSSIBLY_CONTINUES */) && parent.continueLabel == this.continueLabel) {\r\n            parent.set(8 /* POSSIBLY_CONTINUES */);\r\n        }\r\n        return parent;\r\n        var e_8, _c;\r\n    };\r\n    /** Adds a new scoped local of the specified name. */\r\n    Flow.prototype.addScopedLocal = function (name, type, reportNode) {\r\n        var scopedLocal = this.currentFunction.getTempLocal(type);\r\n        if (!this.scopedLocals)\r\n            this.scopedLocals = new Map();\r\n        else if (this.scopedLocals.has(name)) {\r\n            this.currentFunction.program.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, reportNode.range);\r\n            return;\r\n        }\r\n        this.scopedLocals.set(name, scopedLocal);\r\n    };\r\n    /** Gets the local of the specified name in the current scope. */\r\n    Flow.prototype.getScopedLocal = function (name) {\r\n        var local;\r\n        var current = this;\r\n        do {\r\n            if (current.scopedLocals && (local = current.scopedLocals.get(name))) {\r\n                return local;\r\n            }\r\n        } while (current = current.parent);\r\n        return this.currentFunction.locals.get(name);\r\n    };\r\n    /** Finalizes this flow. Must be the topmost parent flow of the function. */\r\n    Flow.prototype.finalize = function () {\r\n        assert(this.parent == null, \"must be the topmost parent flow\");\r\n        this.continueLabel = null;\r\n        this.breakLabel = null;\r\n        return this.is(1 /* RETURNS */);\r\n    };\r\n    return Flow;\r\n}());\r\nexports.Flow = Flow;\r\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __values = (this && this.__values) || function (o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar builtins_1 = __webpack_require__(16);\r\nvar diagnostics_1 = __webpack_require__(1);\r\nvar module_1 = __webpack_require__(0);\r\nvar program_1 = __webpack_require__(2);\r\nvar tokenizer_1 = __webpack_require__(7);\r\nvar ast_1 = __webpack_require__(6);\r\nvar types_1 = __webpack_require__(5);\r\n/** Compilation target. */\r\nvar Target;\r\n(function (Target) {\r\n    /** WebAssembly with 32-bit pointers. */\r\n    Target[Target[\"WASM32\"] = 0] = \"WASM32\";\r\n    /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\r\n    Target[Target[\"WASM64\"] = 1] = \"WASM64\";\r\n})(Target = exports.Target || (exports.Target = {}));\r\n/** Compiler options. */\r\nvar Options = /** @class */ (function () {\r\n    function Options() {\r\n        /** WebAssembly target. Defaults to {@link Target.WASM32}. */\r\n        this.target = Target.WASM32;\r\n        /** If true, compiles everything instead of just reachable code. */\r\n        this.noTreeShaking = false;\r\n        /** If true, replaces assertions with nops. */\r\n        this.noAssert = false;\r\n        /** If true, does not set up a memory. */\r\n        this.noMemory = false;\r\n        /** If true, imports the memory provided by the embedder. */\r\n        this.importMemory = false;\r\n        /** Static memory start offset. */\r\n        this.memoryBase = 0;\r\n        /** Memory allocation implementation to use. */\r\n        this.allocateImpl = \"allocate_memory\";\r\n        /** Memory freeing implementation to use. */\r\n        this.freeImpl = \"free_memory\";\r\n        /** If true, generates information necessary for source maps. */\r\n        this.sourceMap = false;\r\n    }\r\n    Object.defineProperty(Options.prototype, \"isWasm64\", {\r\n        /** Tests if the target is WASM64 or, otherwise, WASM32. */\r\n        get: function () {\r\n            return this.target == Target.WASM64;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Options.prototype, \"usizeType\", {\r\n        /** Gets the unsigned size type matching the target. */\r\n        get: function () {\r\n            return this.target == Target.WASM64 ? types_1.Type.usize64 : types_1.Type.usize32;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Options.prototype, \"isizeType\", {\r\n        /** Gets the signed size type matching the target. */\r\n        get: function () {\r\n            return this.target == Target.WASM64 ? types_1.Type.isize64 : types_1.Type.isize32;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Options.prototype, \"nativeSizeType\", {\r\n        /** Gets the native size type matching the target. */\r\n        get: function () {\r\n            return this.target == Target.WASM64 ? module_1.NativeType.I64 : module_1.NativeType.I32;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Options;\r\n}());\r\nexports.Options = Options;\r\n/** Indicates the desired kind of a conversion. */\r\nvar ConversionKind;\r\n(function (ConversionKind) {\r\n    /** No conversion. */\r\n    ConversionKind[ConversionKind[\"NONE\"] = 0] = \"NONE\";\r\n    /** Implicit conversion. */\r\n    ConversionKind[ConversionKind[\"IMPLICIT\"] = 1] = \"IMPLICIT\";\r\n    /** Explicit conversion. */\r\n    ConversionKind[ConversionKind[\"EXPLICIT\"] = 2] = \"EXPLICIT\";\r\n})(ConversionKind = exports.ConversionKind || (exports.ConversionKind = {}));\r\n/** Compiler interface. */\r\nvar Compiler = /** @class */ (function (_super) {\r\n    __extends(Compiler, _super);\r\n    /** Constructs a new compiler for a {@link Program} using the specified options. */\r\n    function Compiler(program, options) {\r\n        if (options === void 0) { options = null; }\r\n        var _this = _super.call(this, program.diagnostics) || this;\r\n        /** Start function statements. */\r\n        _this.startFunctionBody = new Array();\r\n        /** Current enum in compilation. */\r\n        _this.currentEnum = null;\r\n        /** Current type in compilation. */\r\n        _this.currentType = types_1.Type.void;\r\n        /** Memory segments being compiled. */\r\n        _this.memorySegments = new Array();\r\n        /** Map of already compiled static string segments. */\r\n        _this.stringSegments = new Map();\r\n        /** Function table being compiled. */\r\n        _this.functionTable = new Array();\r\n        /** Already processed file names. */\r\n        _this.files = new Set();\r\n        _this.program = program;\r\n        _this.options = options ? options : new Options();\r\n        _this.memoryOffset = i64_new(max(_this.options.memoryBase, _this.options.usizeType.byteSize) // leave space for `null`\r\n        );\r\n        _this.module = module_1.Module.create();\r\n        return _this;\r\n    }\r\n    /** Compiles a {@link Program} to a {@link Module} using the specified options. */\r\n    Compiler.compile = function (program, options) {\r\n        if (options === void 0) { options = null; }\r\n        return new Compiler(program, options).compile();\r\n    };\r\n    /** Performs compilation of the underlying {@link Program} to a {@link Module}. */\r\n    Compiler.prototype.compile = function () {\r\n        // initialize lookup maps, built-ins, imports, exports, etc.\r\n        this.program.initialize(this.options);\r\n        // set up the start function wrapping top-level statements, of all files.\r\n        var startFunctionPrototype = assert(this.program.elements.get(\"start\"));\r\n        assert(startFunctionPrototype.kind == program_1.ElementKind.FUNCTION_PROTOTYPE);\r\n        var startFunctionInstance = new program_1.Function(startFunctionPrototype, startFunctionPrototype.internalName, null, // not generic\r\n        null, // no parameters\r\n        types_1.Type.void);\r\n        startFunctionInstance.set(program_1.ElementFlags.START);\r\n        this.currentFunction = this.startFunction = startFunctionInstance;\r\n        var sources = this.program.sources;\r\n        // compile entry file(s) while traversing to reachable elements\r\n        for (var i = 0, k = sources.length; i < k; ++i) {\r\n            if (sources[i].isEntry) {\r\n                this.compileSource(sources[i]);\r\n            }\r\n        }\r\n        // compile the start function if not empty\r\n        if (this.startFunctionBody.length) {\r\n            var typeRef = this.module.getFunctionTypeBySignature(module_1.NativeType.None, []);\r\n            if (!typeRef)\r\n                typeRef = this.module.addFunctionType(\"v\", module_1.NativeType.None, []);\r\n            var ref;\r\n            this.module.setStart(ref = this.module.addFunction(this.startFunction.prototype.internalName, typeRef, types_1.typesToNativeTypes(this.startFunction.additionalLocals), this.module.createBlock(null, this.startFunctionBody)));\r\n            this.startFunction.finalize(this.module, ref);\r\n        }\r\n        // set up static memory segments and the heap base pointer\r\n        if (!this.options.noMemory) {\r\n            var memoryOffset = this.memoryOffset;\r\n            memoryOffset = i64_align(memoryOffset, this.options.usizeType.byteSize);\r\n            this.memoryOffset = memoryOffset;\r\n            if (this.options.isWasm64) {\r\n                this.module.addGlobal(\"HEAP_BASE\", module_1.NativeType.I64, false, this.module.createI64(i64_low(memoryOffset), i64_high(memoryOffset)));\r\n            }\r\n            else {\r\n                this.module.addGlobal(\"HEAP_BASE\", module_1.NativeType.I32, false, this.module.createI32(i64_low(memoryOffset)));\r\n            }\r\n            // determine initial page size\r\n            var pages = i64_shr_u(i64_align(memoryOffset, 0x10000), i64_new(16, 0));\r\n            this.module.setMemory(i64_low(pages), module_1.Module.MAX_MEMORY_WASM32 /* TODO: not WASM64 compatible yet */, this.memorySegments, this.options.target, \"memory\");\r\n        }\r\n        // import memory if requested\r\n        if (this.options.importMemory) {\r\n            this.module.addMemoryImport(\"memory\", \"env\", \"memory\");\r\n        }\r\n        // set up function table\r\n        if (k = this.functionTable.length) {\r\n            var entries = new Array(k);\r\n            for (i = 0; i < k; ++i) {\r\n                entries[i] = this.functionTable[i].ref;\r\n            }\r\n            this.module.setFunctionTable(entries);\r\n        }\r\n        return this.module;\r\n    };\r\n    // sources\r\n    Compiler.prototype.compileSourceByPath = function (normalizedPathWithoutExtension, reportNode) {\r\n        var sources = this.program.sources;\r\n        var source;\r\n        var expected = normalizedPathWithoutExtension + \".ts\";\r\n        for (var i = 0, k = sources.length; i < k; ++i) {\r\n            source = sources[i];\r\n            if (source.normalizedPath == expected) {\r\n                this.compileSource(source);\r\n                return;\r\n            }\r\n        }\r\n        expected = normalizedPathWithoutExtension + \"/index.ts\";\r\n        for (i = 0, k = sources.length; i < k; ++i) {\r\n            source = sources[i];\r\n            if (source.normalizedPath == expected) {\r\n                this.compileSource(source);\r\n                return;\r\n            }\r\n        }\r\n        expected = program_1.LIBRARY_PREFIX + normalizedPathWithoutExtension + \".ts\";\r\n        for (i = 0, k = sources.length; i < k; ++i) {\r\n            source = sources[i];\r\n            if (source.normalizedPath == expected) {\r\n                this.compileSource(source);\r\n                return;\r\n            }\r\n        }\r\n        this.error(diagnostics_1.DiagnosticCode.File_0_not_found, reportNode.range, normalizedPathWithoutExtension);\r\n    };\r\n    Compiler.prototype.compileSource = function (source) {\r\n        var files = this.files;\r\n        if (files.has(source.normalizedPath))\r\n            return;\r\n        files.add(source.normalizedPath);\r\n        var noTreeShaking = this.options.noTreeShaking;\r\n        var isEntry = source.isEntry;\r\n        var startFunctionBody = this.startFunctionBody;\r\n        var statements = source.statements;\r\n        for (var i = 0, k = statements.length; i < k; ++i) {\r\n            var statement = statements[i];\r\n            switch (statement.kind) {\r\n                case ast_1.NodeKind.CLASSDECLARATION:\r\n                    if ((noTreeShaking ||\r\n                        (isEntry && ast_1.hasModifier(ast_1.ModifierKind.EXPORT, statement.modifiers))) &&\r\n                        !statement.typeParameters.length) {\r\n                        this.compileClassDeclaration(statement, []);\r\n                    }\r\n                    break;\r\n                case ast_1.NodeKind.ENUMDECLARATION:\r\n                    if (noTreeShaking ||\r\n                        (isEntry && ast_1.hasModifier(ast_1.ModifierKind.EXPORT, statement.modifiers))) {\r\n                        this.compileEnumDeclaration(statement);\r\n                    }\r\n                    break;\r\n                case ast_1.NodeKind.FUNCTIONDECLARATION:\r\n                    if ((noTreeShaking ||\r\n                        (isEntry && ast_1.hasModifier(ast_1.ModifierKind.EXPORT, statement.modifiers))) &&\r\n                        !statement.isGeneric) {\r\n                        this.compileFunctionDeclaration(statement, []);\r\n                    }\r\n                    break;\r\n                case ast_1.NodeKind.IMPORT:\r\n                    this.compileSourceByPath(statement.normalizedPath, statement.path);\r\n                    break;\r\n                case ast_1.NodeKind.NAMESPACEDECLARATION:\r\n                    if (noTreeShaking ||\r\n                        (isEntry && ast_1.hasModifier(ast_1.ModifierKind.EXPORT, statement.modifiers))) {\r\n                        this.compileNamespaceDeclaration(statement);\r\n                    }\r\n                    break;\r\n                case ast_1.NodeKind.VARIABLE:// global, always compiled as initializers might have side effects\r\n                    var variableInit = this.compileVariableStatement(statement);\r\n                    if (variableInit)\r\n                        startFunctionBody.push(variableInit);\r\n                    break;\r\n                case ast_1.NodeKind.EXPORT:\r\n                    if (statement.normalizedPath != null) {\r\n                        this.compileSourceByPath(statement.normalizedPath, statement.path);\r\n                    }\r\n                    if (noTreeShaking || isEntry) {\r\n                        this.compileExportStatement(statement);\r\n                    }\r\n                    break;\r\n                // otherwise a top-level statement that is part of the start function's body\r\n                default:\r\n                    var previousFunction = this.currentFunction;\r\n                    this.currentFunction = this.startFunction;\r\n                    var expr = this.compileStatement(statement);\r\n                    this.startFunctionBody.push(expr);\r\n                    this.currentFunction = previousFunction;\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n    // globals\r\n    Compiler.prototype.compileGlobalDeclaration = function (declaration) {\r\n        var element = this.program.elements.get(declaration.fileLevelInternalName);\r\n        if (!element || element.kind != program_1.ElementKind.GLOBAL) {\r\n            throw new Error(\"global expected\");\r\n        }\r\n        if (!this.compileGlobal(element)) {\r\n            return null;\r\n        }\r\n        return element;\r\n    };\r\n    Compiler.prototype.compileGlobal = function (global) {\r\n        if (global.is(program_1.ElementFlags.COMPILED) || global.is(program_1.ElementFlags.BUILTIN)) {\r\n            return true;\r\n        }\r\n        var declaration = global.declaration;\r\n        var initExpr = 0;\r\n        if (global.type == types_1.Type.void) {\r\n            if (declaration.type) {\r\n                var resolvedType = this.program.resolveType(declaration.type); // reports\r\n                if (!resolvedType)\r\n                    return false;\r\n                if (resolvedType == types_1.Type.void) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, declaration.type.range, \"*\", resolvedType.toString());\r\n                    return false;\r\n                }\r\n                global.type = resolvedType;\r\n            }\r\n            else if (declaration.initializer) {\r\n                initExpr = this.compileExpression(// reports\r\n                declaration.initializer, types_1.Type.void, 0 /* NONE */);\r\n                if (this.currentType == types_1.Type.void) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, declaration.initializer.range, this.currentType.toString(), \"<auto>\");\r\n                    return false;\r\n                }\r\n                global.type = this.currentType;\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode.Type_expected, declaration.name.range.atEnd);\r\n                return false;\r\n            }\r\n        }\r\n        var nativeType = global.type.toNativeType();\r\n        if (global.is(program_1.ElementFlags.DECLARED)) {\r\n            if (global.is(program_1.ElementFlags.CONSTANT)) {\r\n                this.module.addGlobalImport(global.internalName, global.namespace\r\n                    ? global.namespace.simpleName\r\n                    : \"env\", global.simpleName, nativeType);\r\n                global.set(program_1.ElementFlags.COMPILED);\r\n                return true;\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, declaration.range);\r\n            }\r\n            return false;\r\n        }\r\n        var initializeInStart = false;\r\n        if (global.is(program_1.ElementFlags.INLINED)) {\r\n            initExpr = this.compileInlineConstant(global, global.type);\r\n        }\r\n        else {\r\n            if (declaration.initializer) {\r\n                if (!initExpr) {\r\n                    initExpr = this.compileExpression(declaration.initializer, global.type);\r\n                }\r\n                if (_BinaryenExpressionGetId(initExpr) != module_1.ExpressionId.Const) {\r\n                    if (global.is(program_1.ElementFlags.CONSTANT)) {\r\n                        initExpr = this.precomputeExpressionRef(initExpr);\r\n                        if (_BinaryenExpressionGetId(initExpr) != module_1.ExpressionId.Const) {\r\n                            this.warning(diagnostics_1.DiagnosticCode.Compiling_constant_with_non_constant_initializer_as_mutable, declaration.range);\r\n                            initializeInStart = true;\r\n                        }\r\n                    }\r\n                    else {\r\n                        initializeInStart = true;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                initExpr = global.type.toNativeZero(this.module);\r\n            }\r\n        }\r\n        var internalName = global.internalName;\r\n        if (initializeInStart) {\r\n            this.module.addGlobal(internalName, nativeType, true, global.type.toNativeZero(this.module));\r\n            var setExpr = this.module.createSetGlobal(internalName, initExpr);\r\n            this.startFunctionBody.push(setExpr);\r\n        }\r\n        else {\r\n            if (global.is(program_1.ElementFlags.CONSTANT)) {\r\n                var exprType = _BinaryenExpressionGetType(initExpr);\r\n                switch (exprType) {\r\n                    case module_1.NativeType.I32:\r\n                        global.constantValueKind = 1 /* INTEGER */;\r\n                        global.constantIntegerValue = i64_new(_BinaryenConstGetValueI32(initExpr), 0);\r\n                        break;\r\n                    case module_1.NativeType.I64:\r\n                        global.constantValueKind = 1 /* INTEGER */;\r\n                        global.constantIntegerValue = i64_new(_BinaryenConstGetValueI64Low(initExpr), _BinaryenConstGetValueI64High(initExpr));\r\n                        break;\r\n                    case module_1.NativeType.F32:\r\n                        global.constantValueKind = 2 /* FLOAT */;\r\n                        global.constantFloatValue = _BinaryenConstGetValueF32(initExpr);\r\n                        break;\r\n                    case module_1.NativeType.F64:\r\n                        global.constantValueKind = 2 /* FLOAT */;\r\n                        global.constantFloatValue = _BinaryenConstGetValueF64(initExpr);\r\n                        break;\r\n                    default:\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                global.set(program_1.ElementFlags.INLINED);\r\n                if (declaration.isTopLevel) {\r\n                    this.module.addGlobal(internalName, nativeType, !global.is(program_1.ElementFlags.CONSTANT), initExpr);\r\n                }\r\n                if (declaration.range.source.isEntry && declaration.isTopLevelExport) {\r\n                    this.module.addGlobalExport(global.internalName, declaration.programLevelInternalName);\r\n                }\r\n            }\r\n            else {\r\n                this.module.addGlobal(internalName, nativeType, !global.is(program_1.ElementFlags.CONSTANT), initExpr);\r\n            }\r\n        }\r\n        global.set(program_1.ElementFlags.COMPILED);\r\n        return true;\r\n    };\r\n    // enums\r\n    Compiler.prototype.compileEnumDeclaration = function (declaration) {\r\n        var element = this.program.elements.get(declaration.fileLevelInternalName);\r\n        if (!element || element.kind != program_1.ElementKind.ENUM)\r\n            throw new Error(\"enum expected\");\r\n        return this.compileEnum(element) ? element : null;\r\n    };\r\n    Compiler.prototype.compileEnum = function (element) {\r\n        if (element.is(program_1.ElementFlags.COMPILED))\r\n            return true;\r\n        // members might reference each other, triggering another compile\r\n        element.set(program_1.ElementFlags.COMPILED);\r\n        this.currentEnum = element;\r\n        var previousValue = null;\r\n        if (element.members) {\r\n            try {\r\n                for (var _a = __values(element.members.values()), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                    var member = _b.value;\r\n                    if (member.kind != program_1.ElementKind.ENUMVALUE)\r\n                        continue; // happens if an enum is also a namespace\r\n                    var initInStart = false;\r\n                    var val = member;\r\n                    var valueDeclaration = val.declaration;\r\n                    val.set(program_1.ElementFlags.COMPILED);\r\n                    if (val.is(program_1.ElementFlags.INLINED)) {\r\n                        if (element.declaration.isTopLevelExport) {\r\n                            this.module.addGlobal(val.internalName, module_1.NativeType.I32, false, // constant\r\n                            this.module.createI32(val.constantValue));\r\n                        }\r\n                    }\r\n                    else {\r\n                        var initExpr;\r\n                        if (valueDeclaration.value) {\r\n                            initExpr = this.compileExpression(valueDeclaration.value, types_1.Type.i32);\r\n                            if (_BinaryenExpressionGetId(initExpr) != module_1.ExpressionId.Const) {\r\n                                initExpr = this.precomputeExpressionRef(initExpr);\r\n                                if (_BinaryenExpressionGetId(initExpr) != module_1.ExpressionId.Const) {\r\n                                    if (element.is(program_1.ElementFlags.CONSTANT)) {\r\n                                        this.warning(diagnostics_1.DiagnosticCode.Compiling_constant_with_non_constant_initializer_as_mutable, valueDeclaration.range);\r\n                                    }\r\n                                    initInStart = true;\r\n                                }\r\n                            }\r\n                        }\r\n                        else if (previousValue == null) {\r\n                            initExpr = this.module.createI32(0);\r\n                        }\r\n                        else if (previousValue.is(program_1.ElementFlags.INLINED)) {\r\n                            initExpr = this.module.createI32(previousValue.constantValue + 1);\r\n                        }\r\n                        else {\r\n                            // in TypeScript this errors with TS1061, but actually we can do:\r\n                            initExpr = this.module.createBinary(module_1.BinaryOp.AddI32, this.module.createGetGlobal(previousValue.internalName, module_1.NativeType.I32), this.module.createI32(1));\r\n                            if (element.is(program_1.ElementFlags.CONSTANT)) {\r\n                                this.warning(diagnostics_1.DiagnosticCode.Compiling_constant_with_non_constant_initializer_as_mutable, valueDeclaration.range);\r\n                            }\r\n                            initInStart = true;\r\n                        }\r\n                        if (initInStart) {\r\n                            this.module.addGlobal(val.internalName, module_1.NativeType.I32, true, // mutable\r\n                            this.module.createI32(0));\r\n                            var setExpr = this.module.createSetGlobal(val.internalName, initExpr);\r\n                            this.startFunctionBody.push(setExpr);\r\n                        }\r\n                        else {\r\n                            this.module.addGlobal(val.internalName, module_1.NativeType.I32, false, initExpr);\r\n                            if (_BinaryenExpressionGetType(initExpr) == module_1.NativeType.I32) {\r\n                                val.constantValue = _BinaryenConstGetValueI32(initExpr);\r\n                                val.set(program_1.ElementFlags.INLINED);\r\n                            }\r\n                            else {\r\n                                throw new Error(\"i32 expected\");\r\n                            }\r\n                        }\r\n                    }\r\n                    previousValue = val;\r\n                    // export values if the enum is exported\r\n                    if (element.declaration.range.source.isEntry && element.declaration.isTopLevelExport) {\r\n                        if (member.is(program_1.ElementFlags.INLINED)) {\r\n                            this.module.addGlobalExport(member.internalName, member.internalName);\r\n                        }\r\n                        else if (valueDeclaration) {\r\n                            this.warning(diagnostics_1.DiagnosticCode.Cannot_export_a_mutable_global, valueDeclaration.range);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n        }\r\n        this.currentEnum = null;\r\n        return true;\r\n        var e_1, _c;\r\n    };\r\n    // functions\r\n    Compiler.prototype.compileFunctionDeclaration = function (declaration, typeArguments, contextualTypeArguments) {\r\n        if (contextualTypeArguments === void 0) { contextualTypeArguments = null; }\r\n        var element = this.program.elements.get(declaration.fileLevelInternalName);\r\n        if (!element || element.kind != program_1.ElementKind.FUNCTION_PROTOTYPE) {\r\n            throw new Error(\"function expected\");\r\n        }\r\n        return this.compileFunctionUsingTypeArguments(// reports\r\n        element, typeArguments, contextualTypeArguments, element.declaration.name);\r\n    };\r\n    Compiler.prototype.compileFunctionUsingTypeArguments = function (prototype, typeArguments, contextualTypeArguments, reportNode) {\r\n        var instance = prototype.resolveInclTypeArguments(// reports\r\n        typeArguments, contextualTypeArguments, reportNode);\r\n        if (!instance)\r\n            return null;\r\n        return this.compileFunction(instance) ? instance : null;\r\n    };\r\n    Compiler.prototype.compileFunction = function (instance) {\r\n        if (instance.is(program_1.ElementFlags.COMPILED))\r\n            return true;\r\n        assert(!instance.is(program_1.ElementFlags.BUILTIN) || instance.simpleName == \"abort\");\r\n        var declaration = instance.prototype.declaration;\r\n        if (instance.is(program_1.ElementFlags.DECLARED)) {\r\n            if (declaration.body) {\r\n                this.error(diagnostics_1.DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts, declaration.name.range);\r\n                return false;\r\n            }\r\n        }\r\n        else if (!declaration.body) {\r\n            this.error(diagnostics_1.DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration, declaration.name.range);\r\n            return false;\r\n        }\r\n        // might trigger compilation of other functions referring to this one\r\n        instance.set(program_1.ElementFlags.COMPILED);\r\n        // compile statements\r\n        var stmt = 0;\r\n        if (!instance.is(program_1.ElementFlags.DECLARED)) {\r\n            var previousFunction = this.currentFunction;\r\n            this.currentFunction = instance;\r\n            var body = assert(declaration.body, \"implementation expected\");\r\n            stmt = this.compileStatement(body);\r\n            // make sure the top-level branch or all child branches return\r\n            var allBranchesReturn = this.currentFunction.flow.finalize();\r\n            if (instance.returnType != types_1.Type.void && !allBranchesReturn) {\r\n                this.error(diagnostics_1.DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value, assert(declaration.returnType, \"return type expected\").range);\r\n            }\r\n            this.currentFunction = previousFunction;\r\n        }\r\n        // create the function type\r\n        var numParameters = instance.parameters ? instance.parameters.length : 0;\r\n        var numParametersInclThis = instance.instanceMethodOf ? numParameters + 1 : numParameters;\r\n        var paramIndex = 0;\r\n        var nativeResultType = instance.returnType.toNativeType();\r\n        var nativeParamTypes = new Array(numParametersInclThis);\r\n        var signatureNameParts = new Array(numParametersInclThis + 1);\r\n        if (instance.instanceMethodOf) {\r\n            nativeParamTypes[paramIndex] = this.options.isWasm64 ? module_1.NativeType.I64 : module_1.NativeType.I32;\r\n            signatureNameParts[paramIndex++] = instance.instanceMethodOf.type.toSignatureString();\r\n        }\r\n        if (instance.parameters) {\r\n            for (var i = 0; i < numParameters; ++i) {\r\n                nativeParamTypes[paramIndex] = instance.parameters[i].type.toNativeType();\r\n                signatureNameParts[paramIndex++] = instance.parameters[i].type.toSignatureString();\r\n            }\r\n        }\r\n        signatureNameParts[paramIndex] = instance.returnType.toSignatureString();\r\n        var typeRef = this.module.getFunctionTypeBySignature(nativeResultType, nativeParamTypes);\r\n        if (!typeRef) {\r\n            typeRef = this.module.addFunctionType(signatureNameParts.join(\"\"), nativeResultType, nativeParamTypes);\r\n        }\r\n        // create the function\r\n        var ref;\r\n        if (instance.is(program_1.ElementFlags.DECLARED)) {\r\n            ref = this.module.addFunctionImport(instance.internalName, instance.prototype.namespace\r\n                ? instance.prototype.namespace.simpleName\r\n                : \"env\", instance.simpleName, typeRef);\r\n        }\r\n        else {\r\n            ref = this.module.addFunction(instance.internalName, typeRef, types_1.typesToNativeTypes(instance.additionalLocals), assert(stmt));\r\n        }\r\n        // check module export\r\n        if (declaration.range.source.isEntry && declaration.isTopLevelExport) {\r\n            this.module.addFunctionExport(instance.internalName, declaration.name.text);\r\n        }\r\n        instance.finalize(this.module, ref);\r\n        return true;\r\n    };\r\n    // namespaces\r\n    Compiler.prototype.compileNamespaceDeclaration = function (declaration) {\r\n        var members = declaration.members;\r\n        var noTreeShaking = this.options.noTreeShaking;\r\n        for (var i = 0, k = members.length; i < k; ++i) {\r\n            var member = members[i];\r\n            switch (member.kind) {\r\n                case ast_1.NodeKind.CLASSDECLARATION:\r\n                    if ((noTreeShaking ||\r\n                        ast_1.hasModifier(ast_1.ModifierKind.EXPORT, member.modifiers)) && !member.typeParameters.length) {\r\n                        this.compileClassDeclaration(member, []);\r\n                    }\r\n                    break;\r\n                case ast_1.NodeKind.INTERFACEDECLARATION:\r\n                    if ((noTreeShaking ||\r\n                        ast_1.hasModifier(ast_1.ModifierKind.EXPORT, member.modifiers)) && !member.typeParameters.length) {\r\n                        this.compileInterfaceDeclaration(member, []);\r\n                    }\r\n                    break;\r\n                case ast_1.NodeKind.ENUMDECLARATION:\r\n                    if (noTreeShaking ||\r\n                        ast_1.hasModifier(ast_1.ModifierKind.EXPORT, member.modifiers)) {\r\n                        this.compileEnumDeclaration(member);\r\n                    }\r\n                    break;\r\n                case ast_1.NodeKind.FUNCTIONDECLARATION:\r\n                    if ((noTreeShaking ||\r\n                        ast_1.hasModifier(ast_1.ModifierKind.EXPORT, member.modifiers)) &&\r\n                        !member.isGeneric) {\r\n                        this.compileFunctionDeclaration(member, []);\r\n                    }\r\n                    break;\r\n                case ast_1.NodeKind.NAMESPACEDECLARATION:\r\n                    if (noTreeShaking ||\r\n                        ast_1.hasModifier(ast_1.ModifierKind.EXPORT, member.modifiers)) {\r\n                        this.compileNamespaceDeclaration(member);\r\n                    }\r\n                    break;\r\n                case ast_1.NodeKind.VARIABLE:\r\n                    if (noTreeShaking ||\r\n                        ast_1.hasModifier(ast_1.ModifierKind.EXPORT, member.modifiers)) {\r\n                        var variableInit = this.compileVariableStatement(member, true);\r\n                        if (variableInit)\r\n                            this.startFunctionBody.push(variableInit);\r\n                    }\r\n                    break;\r\n                default:\r\n                    throw new Error(\"namespace member expected\");\r\n            }\r\n        }\r\n    };\r\n    Compiler.prototype.compileNamespace = function (ns) {\r\n        if (!ns.members)\r\n            return;\r\n        var noTreeShaking = this.options.noTreeShaking;\r\n        try {\r\n            for (var _a = __values(ns.members.values()), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                var element = _b.value;\r\n                switch (element.kind) {\r\n                    case program_1.ElementKind.CLASS_PROTOTYPE:\r\n                        if ((noTreeShaking ||\r\n                            element.is(program_1.ElementFlags.EXPORTED)) && !element.is(program_1.ElementFlags.GENERIC)) {\r\n                            this.compileClassUsingTypeArguments(element, []);\r\n                        }\r\n                        break;\r\n                    case program_1.ElementKind.ENUM:\r\n                        this.compileEnum(element);\r\n                        break;\r\n                    case program_1.ElementKind.FUNCTION_PROTOTYPE:\r\n                        if ((noTreeShaking || element.is(program_1.ElementFlags.EXPORTED)) && !element.is(program_1.ElementFlags.GENERIC)) {\r\n                            this.compileFunctionUsingTypeArguments(element, [], null, element.declaration.name);\r\n                        }\r\n                        break;\r\n                    case program_1.ElementKind.GLOBAL:\r\n                        this.compileGlobal(element);\r\n                        break;\r\n                    case program_1.ElementKind.NAMESPACE:\r\n                        this.compileNamespace(element);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        var e_2, _c;\r\n    };\r\n    // exports\r\n    Compiler.prototype.compileExportStatement = function (statement) {\r\n        var members = statement.members;\r\n        for (var i = 0, k = members.length; i < k; ++i) {\r\n            var member = members[i];\r\n            var internalExportName = (statement.range.source.internalPath +\r\n                program_1.PATH_DELIMITER +\r\n                member.externalName.text);\r\n            var element = this.program.exports.get(internalExportName);\r\n            if (!element)\r\n                continue; // reported in Program#initialize\r\n            switch (element.kind) {\r\n                case program_1.ElementKind.CLASS_PROTOTYPE:\r\n                    if (!element.is(program_1.ElementFlags.GENERIC)) {\r\n                        this.compileClassUsingTypeArguments(element, []);\r\n                    }\r\n                    break;\r\n                case program_1.ElementKind.ENUM:\r\n                    this.compileEnum(element);\r\n                    break;\r\n                case program_1.ElementKind.FUNCTION_PROTOTYPE:\r\n                    if (!element.is(program_1.ElementFlags.GENERIC) &&\r\n                        statement.range.source.isEntry) {\r\n                        var functionInstance = this.compileFunctionUsingTypeArguments(element, [], null, element.declaration.name);\r\n                        if (functionInstance) {\r\n                            var functionDeclaration = functionInstance.prototype.declaration;\r\n                            if (functionDeclaration && functionDeclaration.needsExplicitExport(member)) {\r\n                                this.module.addFunctionExport(functionInstance.internalName, member.externalName.text);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                case program_1.ElementKind.GLOBAL:\r\n                    if (this.compileGlobal(element) && statement.range.source.isEntry) {\r\n                        var globalDeclaration = element.declaration;\r\n                        if (globalDeclaration && globalDeclaration.needsExplicitExport(member)) {\r\n                            if (element.is(program_1.ElementFlags.INLINED)) {\r\n                                this.module.addGlobalExport(element.internalName, member.externalName.text);\r\n                            }\r\n                            else {\r\n                                this.warning(diagnostics_1.DiagnosticCode.Cannot_export_a_mutable_global, member.range);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                case program_1.ElementKind.NAMESPACE:\r\n                    this.compileNamespace(element);\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n    // classes\r\n    Compiler.prototype.compileClassDeclaration = function (declaration, typeArguments, contextualTypeArguments, alternativeReportNode) {\r\n        if (contextualTypeArguments === void 0) { contextualTypeArguments = null; }\r\n        if (alternativeReportNode === void 0) { alternativeReportNode = null; }\r\n        var element = this.program.elements.get(declaration.fileLevelInternalName);\r\n        if (!element || element.kind != program_1.ElementKind.CLASS_PROTOTYPE) {\r\n            throw new Error(\"class expected\");\r\n        }\r\n        this.compileClassUsingTypeArguments(element, typeArguments, contextualTypeArguments, alternativeReportNode);\r\n    };\r\n    Compiler.prototype.compileClassUsingTypeArguments = function (prototype, typeArguments, contextualTypeArguments, alternativeReportNode) {\r\n        if (contextualTypeArguments === void 0) { contextualTypeArguments = null; }\r\n        if (alternativeReportNode === void 0) { alternativeReportNode = null; }\r\n        var instance = prototype.resolveInclTypeArguments(// reports\r\n        typeArguments, contextualTypeArguments, alternativeReportNode);\r\n        if (!instance)\r\n            return;\r\n        this.compileClass(instance);\r\n    };\r\n    Compiler.prototype.compileClass = function (instance) {\r\n        if (instance.is(program_1.ElementFlags.COMPILED))\r\n            return true;\r\n        instance.set(program_1.ElementFlags.COMPILED);\r\n        return true;\r\n    };\r\n    Compiler.prototype.compileInterfaceDeclaration = function (declaration, typeArguments, contextualTypeArguments, alternativeReportNode) {\r\n        if (contextualTypeArguments === void 0) { contextualTypeArguments = null; }\r\n        if (alternativeReportNode === void 0) { alternativeReportNode = null; }\r\n        throw new Error(\"not implemented\");\r\n    };\r\n    // memory\r\n    /** Adds a static memory segment with the specified data. */\r\n    Compiler.prototype.addMemorySegment = function (buffer, alignment) {\r\n        if (alignment === void 0) { alignment = 8; }\r\n        var memoryOffset = i64_align(this.memoryOffset, alignment);\r\n        var segment = module_1.MemorySegment.create(buffer, memoryOffset);\r\n        this.memorySegments.push(segment);\r\n        this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length, 0));\r\n        return segment;\r\n    };\r\n    // function table\r\n    /** Adds a function table entry and returns the assigned index. */\r\n    Compiler.prototype.addFunctionTableEntry = function (func) {\r\n        assert(func.is(program_1.ElementFlags.COMPILED));\r\n        if (func.functionTableIndex >= 0) {\r\n            return func.functionTableIndex;\r\n        }\r\n        var index = this.functionTable.length;\r\n        this.functionTable.push(func);\r\n        func.functionTableIndex = index;\r\n        return index;\r\n    };\r\n    // statements\r\n    Compiler.prototype.compileStatement = function (statement) {\r\n        var expr;\r\n        switch (statement.kind) {\r\n            case ast_1.NodeKind.BLOCK:\r\n                expr = this.compileBlockStatement(statement);\r\n                break;\r\n            case ast_1.NodeKind.BREAK:\r\n                expr = this.compileBreakStatement(statement);\r\n                break;\r\n            case ast_1.NodeKind.CONTINUE:\r\n                expr = this.compileContinueStatement(statement);\r\n                break;\r\n            case ast_1.NodeKind.DO:\r\n                expr = this.compileDoStatement(statement);\r\n                break;\r\n            case ast_1.NodeKind.EMPTY:\r\n                expr = this.compileEmptyStatement(statement);\r\n                break;\r\n            case ast_1.NodeKind.EXPRESSION:\r\n                expr = this.compileExpressionStatement(statement);\r\n                break;\r\n            case ast_1.NodeKind.FOR:\r\n                expr = this.compileForStatement(statement);\r\n                break;\r\n            case ast_1.NodeKind.IF:\r\n                expr = this.compileIfStatement(statement);\r\n                break;\r\n            case ast_1.NodeKind.RETURN:\r\n                expr = this.compileReturnStatement(statement);\r\n                break;\r\n            case ast_1.NodeKind.SWITCH:\r\n                expr = this.compileSwitchStatement(statement);\r\n                break;\r\n            case ast_1.NodeKind.THROW:\r\n                expr = this.compileThrowStatement(statement);\r\n                break;\r\n            case ast_1.NodeKind.TRY:\r\n                expr = this.compileTryStatement(statement);\r\n                break;\r\n            case ast_1.NodeKind.VARIABLE:\r\n                var variableInit = this.compileVariableStatement(statement);\r\n                expr = variableInit ? variableInit : this.module.createNop();\r\n                break;\r\n            case ast_1.NodeKind.WHILE:\r\n                expr = this.compileWhileStatement(statement);\r\n                break;\r\n            case ast_1.NodeKind.TYPEDECLARATION:\r\n                if (this.currentFunction == this.startFunction) {\r\n                    return this.module.createNop();\r\n                }\r\n            // fall-through: must be top-level; function bodies are not guaranteed to be evaluated\r\n            default:\r\n                throw new Error(\"statement expected\");\r\n        }\r\n        this.addDebugLocation(expr, statement.range);\r\n        return expr;\r\n    };\r\n    Compiler.prototype.compileStatements = function (statements) {\r\n        var k = statements.length;\r\n        var stmts = new Array(k);\r\n        for (var i = 0; i < k; ++i) {\r\n            stmts[i] = this.compileStatement(statements[i]);\r\n        }\r\n        return stmts; // array of 0-es in noEmit-mode\r\n    };\r\n    Compiler.prototype.compileBlockStatement = function (statement) {\r\n        var statements = statement.statements;\r\n        // NOTE that we could optimize this to a NOP if empty or unwrap a single\r\n        // statement, but that's not what the source told us to do and left to the\r\n        // optimizer.\r\n        // Not actually a branch, but can contain its own scoped variables.\r\n        this.currentFunction.flow = this.currentFunction.flow.enterBranchOrScope();\r\n        var stmt = this.module.createBlock(null, this.compileStatements(statements), module_1.NativeType.None);\r\n        var stmtReturns = this.currentFunction.flow.is(1 /* RETURNS */);\r\n        // Switch back to the parent flow\r\n        this.currentFunction.flow = this.currentFunction.flow.leaveBranchOrScope();\r\n        if (stmtReturns) {\r\n            this.currentFunction.flow.set(1 /* RETURNS */);\r\n        }\r\n        return stmt;\r\n    };\r\n    Compiler.prototype.compileBreakStatement = function (statement) {\r\n        if (statement.label) {\r\n            this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, statement.label.range);\r\n            return this.module.createUnreachable();\r\n        }\r\n        var breakLabel = this.currentFunction.flow.breakLabel;\r\n        if (breakLabel == null) {\r\n            this.error(diagnostics_1.DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement, statement.range);\r\n            return this.module.createUnreachable();\r\n        }\r\n        this.currentFunction.flow.set(4 /* POSSIBLY_BREAKS */);\r\n        return this.module.createBreak(breakLabel);\r\n    };\r\n    Compiler.prototype.compileContinueStatement = function (statement) {\r\n        if (statement.label) {\r\n            this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, statement.label.range);\r\n            return this.module.createUnreachable();\r\n        }\r\n        // Check if 'continue' is allowed here\r\n        var continueLabel = this.currentFunction.flow.continueLabel;\r\n        if (continueLabel == null) {\r\n            this.error(diagnostics_1.DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement, statement.range);\r\n            return this.module.createUnreachable();\r\n        }\r\n        this.currentFunction.flow.set(8 /* POSSIBLY_CONTINUES */);\r\n        return this.module.createBreak(continueLabel);\r\n    };\r\n    Compiler.prototype.compileDoStatement = function (statement) {\r\n        // A do statement does not initiate a new branch because it is executed at\r\n        // least once, but has its own break and continue labels.\r\n        var label = this.currentFunction.enterBreakContext();\r\n        var previousBreakLabel = this.currentFunction.flow.breakLabel;\r\n        var previousContinueLabel = this.currentFunction.flow.continueLabel;\r\n        var breakLabel = this.currentFunction.flow.breakLabel = \"break|\" + label;\r\n        var continueLabel = this.currentFunction.flow.continueLabel = \"continue|\" + label;\r\n        var body = this.compileStatement(statement.statement);\r\n        // Reset to the previous break and continue labels, if any.\r\n        this.currentFunction.flow.breakLabel = previousBreakLabel;\r\n        this.currentFunction.flow.continueLabel = previousContinueLabel;\r\n        var condition = makeIsTrueish(this.compileExpression(statement.condition, types_1.Type.i32, 0 /* NONE */), this.currentType, this.module);\r\n        this.currentFunction.leaveBreakContext();\r\n        return this.module.createBlock(breakLabel, [\r\n            this.module.createLoop(continueLabel, this.module.createBlock(null, [\r\n                body,\r\n                this.module.createBreak(continueLabel, condition)\r\n            ], module_1.NativeType.None))\r\n        ], module_1.NativeType.None);\r\n    };\r\n    Compiler.prototype.compileEmptyStatement = function (statement) {\r\n        return this.module.createNop();\r\n    };\r\n    Compiler.prototype.compileExpressionStatement = function (statement) {\r\n        var expr = this.compileExpression(statement.expression, types_1.Type.void, 0 /* NONE */);\r\n        if (this.currentType != types_1.Type.void) {\r\n            expr = this.module.createDrop(expr);\r\n            this.currentType = types_1.Type.void;\r\n        }\r\n        return expr;\r\n    };\r\n    Compiler.prototype.compileForStatement = function (statement) {\r\n        // A for statement initiates a new branch with its own scoped variables\r\n        // possibly declared in its initializer, and break context.\r\n        var context = this.currentFunction.enterBreakContext();\r\n        this.currentFunction.flow = this.currentFunction.flow.enterBranchOrScope();\r\n        var breakLabel = this.currentFunction.flow.breakLabel = \"break|\" + context;\r\n        var continueLabel = this.currentFunction.flow.continueLabel = \"continue|\" + context;\r\n        // Compile in correct order\r\n        var initializer = statement.initializer\r\n            ? this.compileStatement(statement.initializer)\r\n            : this.module.createNop();\r\n        var condition = statement.condition\r\n            ? this.compileExpression(statement.condition, types_1.Type.i32)\r\n            : this.module.createI32(1);\r\n        var incrementor = statement.incrementor\r\n            ? this.compileExpression(statement.incrementor, types_1.Type.void)\r\n            : this.module.createNop();\r\n        var body = this.compileStatement(statement.statement);\r\n        var alwaysReturns = !statement.condition && this.currentFunction.flow.is(1 /* RETURNS */);\r\n        // TODO: check other always-true conditions as well, not just omitted\r\n        // Switch back to the parent flow\r\n        this.currentFunction.flow = this.currentFunction.flow.leaveBranchOrScope();\r\n        this.currentFunction.leaveBreakContext();\r\n        var expr = this.module.createBlock(breakLabel, [\r\n            initializer,\r\n            this.module.createLoop(continueLabel, this.module.createBlock(null, [\r\n                this.module.createIf(condition, this.module.createBlock(null, [\r\n                    body,\r\n                    incrementor,\r\n                    this.module.createBreak(continueLabel)\r\n                ], module_1.NativeType.None))\r\n            ], module_1.NativeType.None))\r\n        ], module_1.NativeType.None);\r\n        // If the loop is guaranteed to run and return, propagate that and append a hint\r\n        if (alwaysReturns) {\r\n            this.currentFunction.flow.set(1 /* RETURNS */);\r\n            expr = this.module.createBlock(null, [\r\n                expr,\r\n                this.module.createUnreachable()\r\n            ]);\r\n        }\r\n        return expr;\r\n    };\r\n    Compiler.prototype.compileIfStatement = function (statement) {\r\n        // The condition doesn't initiate a branch yet\r\n        var condition = makeIsTrueish(this.compileExpression(statement.condition, types_1.Type.i32, 0 /* NONE */), this.currentType, this.module);\r\n        // Each arm initiates a branch\r\n        this.currentFunction.flow = this.currentFunction.flow.enterBranchOrScope();\r\n        var ifTrue = this.compileStatement(statement.ifTrue);\r\n        var ifTrueReturns = this.currentFunction.flow.is(1 /* RETURNS */);\r\n        this.currentFunction.flow = this.currentFunction.flow.leaveBranchOrScope();\r\n        var ifFalse = 0;\r\n        var ifFalseReturns = false;\r\n        if (statement.ifFalse) {\r\n            this.currentFunction.flow = this.currentFunction.flow.enterBranchOrScope();\r\n            ifFalse = this.compileStatement(statement.ifFalse);\r\n            ifFalseReturns = this.currentFunction.flow.is(1 /* RETURNS */);\r\n            this.currentFunction.flow = this.currentFunction.flow.leaveBranchOrScope();\r\n        }\r\n        if (ifTrueReturns && ifFalseReturns) {\r\n            this.currentFunction.flow.set(1 /* RETURNS */);\r\n        }\r\n        return this.module.createIf(condition, ifTrue, ifFalse);\r\n    };\r\n    Compiler.prototype.compileReturnStatement = function (statement) {\r\n        var expression = 0;\r\n        if (statement.value) {\r\n            expression = this.compileExpression(statement.value, this.currentFunction.returnType);\r\n        }\r\n        // Remember that this flow returns\r\n        this.currentFunction.flow.set(1 /* RETURNS */);\r\n        return this.module.createReturn(expression);\r\n    };\r\n    Compiler.prototype.compileSwitchStatement = function (statement) {\r\n        // Everything within a switch uses the same break context\r\n        var context = this.currentFunction.enterBreakContext();\r\n        // introduce a local for evaluating the condition (exactly once)\r\n        var tempLocal = this.currentFunction.getTempLocal(types_1.Type.u32);\r\n        var k = statement.cases.length;\r\n        // Prepend initializer to inner block. Does not initiate a new branch, yet.\r\n        var breaks = new Array(1 + k);\r\n        breaks[0] = this.module.createSetLocal(// initializer\r\n        tempLocal.index, this.compileExpression(statement.condition, types_1.Type.u32));\r\n        // make one br_if per (possibly dynamic) labeled case (binaryen optimizes to br_table where possible)\r\n        var breakIndex = 1;\r\n        var defaultIndex = -1;\r\n        for (var i = 0; i < k; ++i) {\r\n            var case_ = statement.cases[i];\r\n            if (case_.label) {\r\n                breaks[breakIndex++] = this.module.createBreak(\"case\" + i.toString(10) + \"|\" + context, this.module.createBinary(module_1.BinaryOp.EqI32, this.module.createGetLocal(tempLocal.index, module_1.NativeType.I32), this.compileExpression(case_.label, types_1.Type.i32)));\r\n            }\r\n            else {\r\n                defaultIndex = i;\r\n            }\r\n        }\r\n        this.currentFunction.freeTempLocal(tempLocal);\r\n        // otherwise br to default respectively out of the switch if there is no default case\r\n        breaks[breakIndex] = this.module.createBreak((defaultIndex >= 0\r\n            ? \"case\" + defaultIndex.toString(10)\r\n            : \"break\") + \"|\" + context);\r\n        // nest blocks in order\r\n        var currentBlock = this.module.createBlock(\"case0|\" + context, breaks, module_1.NativeType.None);\r\n        var alwaysReturns = true;\r\n        for (i = 0; i < k; ++i) {\r\n            case_ = statement.cases[i];\r\n            var l = case_.statements.length;\r\n            var body = new Array(1 + l);\r\n            body[0] = currentBlock;\r\n            // Each switch case initiates a new branch\r\n            this.currentFunction.flow = this.currentFunction.flow.enterBranchOrScope();\r\n            var breakLabel = this.currentFunction.flow.breakLabel = \"break|\" + context;\r\n            var fallsThrough = i != k - 1;\r\n            var nextLabel = !fallsThrough ? breakLabel : \"case\" + (i + 1).toString(10) + \"|\" + context;\r\n            for (var j = 0; j < l; ++j) {\r\n                body[j + 1] = this.compileStatement(case_.statements[j]);\r\n            }\r\n            if (!(fallsThrough || this.currentFunction.flow.is(1 /* RETURNS */))) {\r\n                alwaysReturns = false; // ignore fall-throughs\r\n            }\r\n            // Switch back to the parent flow\r\n            this.currentFunction.flow = this.currentFunction.flow.leaveBranchOrScope();\r\n            currentBlock = this.module.createBlock(nextLabel, body, module_1.NativeType.None);\r\n        }\r\n        this.currentFunction.leaveBreakContext();\r\n        // If the switch has a default and always returns, propagate that\r\n        if (defaultIndex >= 0 && alwaysReturns) {\r\n            this.currentFunction.flow.set(1 /* RETURNS */);\r\n            // Binaryen understands that so we don't need a hint\r\n        }\r\n        return currentBlock;\r\n    };\r\n    Compiler.prototype.compileThrowStatement = function (statement) {\r\n        // Remember that this branch possibly throws\r\n        this.currentFunction.flow.set(2 /* POSSIBLY_THROWS */);\r\n        // FIXME: without try-catch it is safe to assume RETURNS as well for now\r\n        this.currentFunction.flow.set(1 /* RETURNS */);\r\n        // TODO: requires exception-handling spec.\r\n        return this.module.createUnreachable();\r\n    };\r\n    Compiler.prototype.compileTryStatement = function (statement) {\r\n        throw new Error(\"not implemented\");\r\n        // can't yet support something like: try { return ... } finally { ... }\r\n        // worthwhile to investigate lowering returns to block results (here)?\r\n    };\r\n    /**\r\n     * Compiles a variable statement. Returns `0` if an initializer is not\r\n     * necessary.\r\n     */\r\n    Compiler.prototype.compileVariableStatement = function (statement, isKnownGlobal) {\r\n        if (isKnownGlobal === void 0) { isKnownGlobal = false; }\r\n        var declarations = statement.declarations;\r\n        // top-level variables and constants become globals\r\n        if (isKnownGlobal || (this.currentFunction == this.startFunction &&\r\n            statement.parent && statement.parent.kind == ast_1.NodeKind.SOURCE)) {\r\n            // NOTE that the above condition also covers top-level variables declared with 'let', even\r\n            // though such variables could also become start function locals if, and only if, not used\r\n            // within any function declared in the same source, which is unknown at this point. the only\r\n            // efficient way to deal with this would be to keep track of all occasions it is used and\r\n            // replace these instructions afterwards, dynamically. (TOOD: what about a Binaryen pass?)\r\n            for (var i = 0, k = declarations.length; i < k; ++i) {\r\n                this.compileGlobalDeclaration(declarations[i]);\r\n            }\r\n            return 0;\r\n        }\r\n        // other variables become locals\r\n        var initializers = new Array();\r\n        for (i = 0, k = declarations.length; i < k; ++i) {\r\n            var declaration = declarations[i];\r\n            var name = declaration.name.text;\r\n            var type = null;\r\n            var init = 0;\r\n            if (declaration.type) {\r\n                type = this.program.resolveType(// reports\r\n                declaration.type, this.currentFunction.contextualTypeArguments);\r\n                if (!type)\r\n                    continue;\r\n                if (declaration.initializer) {\r\n                    init = this.compileExpression(declaration.initializer, type); // reports\r\n                }\r\n            }\r\n            else if (declaration.initializer) {\r\n                init = this.compileExpression(// reports\r\n                declaration.initializer, types_1.Type.void, 0 /* NONE */);\r\n                if (this.currentType == types_1.Type.void) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, declaration.range, this.currentType.toString(), \"<auto>\");\r\n                    continue;\r\n                }\r\n                type = this.currentType;\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode.Type_expected, declaration.name.range.atEnd);\r\n                continue;\r\n            }\r\n            if (ast_1.hasModifier(ast_1.ModifierKind.CONST, declaration.modifiers)) {\r\n                if (init) {\r\n                    init = this.precomputeExpressionRef(init);\r\n                    if (_BinaryenExpressionGetId(init) == module_1.ExpressionId.Const) {\r\n                        var local = new program_1.Local(this.program, name, -1, type);\r\n                        switch (_BinaryenExpressionGetType(init)) {\r\n                            case module_1.NativeType.I32:\r\n                                local = local.withConstantIntegerValue(_BinaryenConstGetValueI32(init), 0);\r\n                                break;\r\n                            case module_1.NativeType.I64:\r\n                                local = local.withConstantIntegerValue(_BinaryenConstGetValueI64Low(init), _BinaryenConstGetValueI64High(init));\r\n                                break;\r\n                            case module_1.NativeType.F32:\r\n                                local = local.withConstantFloatValue(_BinaryenConstGetValueF32(init));\r\n                                break;\r\n                            case module_1.NativeType.F64:\r\n                                local = local.withConstantFloatValue(_BinaryenConstGetValueF64(init));\r\n                                break;\r\n                            default:\r\n                                throw new Error(\"concrete type expected\");\r\n                        }\r\n                        // Create a virtual local that doesn't actually exist in WebAssembly\r\n                        var scopedLocals = this.currentFunction.flow.scopedLocals;\r\n                        if (!scopedLocals)\r\n                            scopedLocals = this.currentFunction.flow.scopedLocals = new Map();\r\n                        else if (scopedLocals.has(name)) {\r\n                            this.error(diagnostics_1.DiagnosticCode.Duplicate_identifier_0, declaration.name.range, name);\r\n                            return 0;\r\n                        }\r\n                        scopedLocals.set(name, local);\r\n                        return 0;\r\n                    }\r\n                    else {\r\n                        this.warning(diagnostics_1.DiagnosticCode.Compiling_constant_with_non_constant_initializer_as_mutable, declaration.range);\r\n                    }\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode._const_declarations_must_be_initialized, declaration.range);\r\n                }\r\n            }\r\n            if (ast_1.hasModifier(ast_1.ModifierKind.LET, declaration.modifiers)) {\r\n                this.currentFunction.flow.addScopedLocal(name, type, declaration.name); // reports\r\n            }\r\n            else {\r\n                this.currentFunction.addLocal(type, name); // reports\r\n            }\r\n            if (init) {\r\n                initializers.push(this.compileAssignmentWithValue(declaration.name, init));\r\n            }\r\n        }\r\n        return initializers.length // we can unwrap these here because the\r\n            ? initializers.length == 1 // source didn't tell us exactly what to do\r\n                ? initializers[0]\r\n                : this.module.createBlock(null, initializers, module_1.NativeType.None)\r\n            : 0;\r\n    };\r\n    Compiler.prototype.compileWhileStatement = function (statement) {\r\n        // The condition does not yet initialize a branch\r\n        var condition = makeIsTrueish(this.compileExpression(statement.condition, types_1.Type.i32, 0 /* NONE */), this.currentType, this.module);\r\n        // Statements initiate a new branch with its own break context\r\n        var label = this.currentFunction.enterBreakContext();\r\n        this.currentFunction.flow = this.currentFunction.flow.enterBranchOrScope();\r\n        var breakLabel = this.currentFunction.flow.breakLabel = \"break|\" + label;\r\n        var continueLabel = this.currentFunction.flow.continueLabel = \"continue|\" + label;\r\n        var body = this.compileStatement(statement.statement);\r\n        var alwaysReturns = false && this.currentFunction.flow.is(1 /* RETURNS */);\r\n        // TODO: evaluate possible always-true conditions\r\n        // Switch back to the parent flow\r\n        this.currentFunction.flow = this.currentFunction.flow.leaveBranchOrScope();\r\n        this.currentFunction.leaveBreakContext();\r\n        var expr = this.module.createBlock(breakLabel, [\r\n            this.module.createLoop(continueLabel, this.module.createIf(condition, this.module.createBlock(null, [\r\n                body,\r\n                this.module.createBreak(continueLabel)\r\n            ], module_1.NativeType.None)))\r\n        ], module_1.NativeType.None);\r\n        // If the loop is guaranteed to run and return, propagate that and append a hint\r\n        if (alwaysReturns) {\r\n            expr = this.module.createBlock(null, [\r\n                expr,\r\n                this.module.createUnreachable()\r\n            ]);\r\n        }\r\n        return expr;\r\n    };\r\n    // expressions\r\n    /** Compiles an inlined constant value of a variable-like element. */\r\n    Compiler.prototype.compileInlineConstant = function (element, contextualType) {\r\n        assert(element.is(program_1.ElementFlags.INLINED));\r\n        switch (element.type.is(4 /* INTEGER */) &&\r\n            contextualType.is(4 /* INTEGER */) &&\r\n            element.type.size < contextualType.size\r\n            ? (this.currentType = contextualType).kind // essentially precomputes a (sign-)extension\r\n            : (this.currentType = element.type).kind) {\r\n            case 0 /* I8 */:\r\n            case 1 /* I16 */:\r\n                var shift = element.type.computeSmallIntegerShift(types_1.Type.i32);\r\n                return this.module.createI32(element.constantValueKind == 1 /* INTEGER */\r\n                    ? i64_low(element.constantIntegerValue) << shift >> shift\r\n                    : 0);\r\n            case 5 /* U8 */:\r\n            case 6 /* U16 */:\r\n            case 10 /* BOOL */:\r\n                var mask = element.type.computeSmallIntegerMask(types_1.Type.i32);\r\n                return this.module.createI32(element.constantValueKind == 1 /* INTEGER */\r\n                    ? i64_low(element.constantIntegerValue) & mask\r\n                    : 0);\r\n            case 2 /* I32 */:\r\n            case 7 /* U32 */:\r\n                return this.module.createI32(element.constantValueKind == 1 /* INTEGER */\r\n                    ? i64_low(element.constantIntegerValue)\r\n                    : 0);\r\n            case 4 /* ISIZE */:\r\n            case 9 /* USIZE */:\r\n                if (!element.program.options.isWasm64) {\r\n                    return this.module.createI32(element.constantValueKind == 1 /* INTEGER */\r\n                        ? i64_low(element.constantIntegerValue)\r\n                        : 0);\r\n                }\r\n            // fall-through\r\n            case 3 /* I64 */:\r\n            case 8 /* U64 */:\r\n                return element.constantValueKind == 1 /* INTEGER */\r\n                    ? this.module.createI64(i64_low(element.constantIntegerValue), i64_high(element.constantIntegerValue))\r\n                    : this.module.createI64(0);\r\n            case 11 /* F32 */:\r\n                return this.module.createF32(element.constantFloatValue);\r\n            case 12 /* F64 */:\r\n                return this.module.createF64(element.constantFloatValue);\r\n            default:\r\n                throw new Error(\"concrete type expected\");\r\n        }\r\n    };\r\n    Compiler.prototype.compileExpression = function (expression, contextualType, conversionKind, wrapSmallIntegers) {\r\n        if (conversionKind === void 0) { conversionKind = 1 /* IMPLICIT */; }\r\n        if (wrapSmallIntegers === void 0) { wrapSmallIntegers = true; }\r\n        this.currentType = contextualType;\r\n        var expr;\r\n        switch (expression.kind) {\r\n            case ast_1.NodeKind.ASSERTION:\r\n                expr = this.compileAssertionExpression(expression, contextualType);\r\n                break;\r\n            case ast_1.NodeKind.BINARY:\r\n                expr = this.compileBinaryExpression(expression, contextualType, wrapSmallIntegers);\r\n                break;\r\n            case ast_1.NodeKind.CALL:\r\n                expr = this.compileCallExpression(expression, contextualType);\r\n                break;\r\n            case ast_1.NodeKind.COMMA:\r\n                expr = this.compileCommaExpression(expression, contextualType);\r\n                break;\r\n            case ast_1.NodeKind.ELEMENTACCESS:\r\n                expr = this.compileElementAccessExpression(expression, contextualType);\r\n                break;\r\n            case ast_1.NodeKind.FUNCTION:\r\n            case ast_1.NodeKind.FUNCTIONARROW:\r\n                expr = this.compileFunctionExpression(expression, contextualType);\r\n                break;\r\n            case ast_1.NodeKind.IDENTIFIER:\r\n            case ast_1.NodeKind.FALSE:\r\n            case ast_1.NodeKind.NULL:\r\n            case ast_1.NodeKind.THIS:\r\n            case ast_1.NodeKind.TRUE:\r\n                expr = this.compileIdentifierExpression(expression, contextualType);\r\n                break;\r\n            case ast_1.NodeKind.LITERAL:\r\n                expr = this.compileLiteralExpression(expression, contextualType);\r\n                break;\r\n            case ast_1.NodeKind.NEW:\r\n                expr = this.compileNewExpression(expression, contextualType);\r\n                break;\r\n            case ast_1.NodeKind.PARENTHESIZED:\r\n                expr = this.compileParenthesizedExpression(expression, contextualType);\r\n                break;\r\n            case ast_1.NodeKind.PROPERTYACCESS:\r\n                expr = this.compilePropertyAccessExpression(expression, contextualType);\r\n                break;\r\n            case ast_1.NodeKind.TERNARY:\r\n                expr = this.compileTernaryExpression(expression, contextualType);\r\n                break;\r\n            case ast_1.NodeKind.UNARYPOSTFIX:\r\n                expr = this.compileUnaryPostfixExpression(expression, contextualType);\r\n                break;\r\n            case ast_1.NodeKind.UNARYPREFIX:\r\n                expr = this.compileUnaryPrefixExpression(expression, contextualType, wrapSmallIntegers);\r\n                break;\r\n            default:\r\n                throw new Error(\"expression expected\");\r\n        }\r\n        if (conversionKind != 0 /* NONE */ && this.currentType != contextualType) {\r\n            expr = this.convertExpression(expr, this.currentType, contextualType, conversionKind, expression);\r\n            this.currentType = contextualType;\r\n        }\r\n        this.addDebugLocation(expr, expression.range);\r\n        return expr;\r\n    };\r\n    Compiler.prototype.precomputeExpression = function (expression, contextualType, conversionKind) {\r\n        if (conversionKind === void 0) { conversionKind = 1 /* IMPLICIT */; }\r\n        return this.precomputeExpressionRef(this.compileExpression(expression, contextualType, conversionKind));\r\n    };\r\n    Compiler.prototype.precomputeExpressionRef = function (expr) {\r\n        var nativeType = this.currentType.toNativeType();\r\n        var typeRef = this.module.getFunctionTypeBySignature(nativeType, []);\r\n        var typeRefAdded = false;\r\n        if (!typeRef) {\r\n            typeRef = this.module.addFunctionType(this.currentType.toSignatureString(), nativeType, []);\r\n            typeRefAdded = true;\r\n        }\r\n        var funcRef = this.module.addFunction(\"__precompute\", typeRef, [], expr);\r\n        this.module.runPasses([\"precompute\"], funcRef);\r\n        var ret = _BinaryenFunctionGetBody(funcRef);\r\n        this.module.removeFunction(\"__precompute\");\r\n        if (typeRefAdded) {\r\n            // TODO: also remove the function type somehow if no longer used or make the C-API accept\r\n            // a `null` typeRef, using an implicit type.\r\n        }\r\n        return ret;\r\n    };\r\n    Compiler.prototype.convertExpression = function (expr, fromType, toType, conversionKind, reportNode) {\r\n        if (conversionKind == 0 /* NONE */) {\r\n            assert(false, \"concrete type expected\");\r\n            return expr;\r\n        }\r\n        // void to any\r\n        if (fromType.kind == 13 /* VOID */) {\r\n            this.error(diagnostics_1.DiagnosticCode.Type_0_is_not_assignable_to_type_1, reportNode.range, fromType.toString(), toType.toString());\r\n            return this.module.createUnreachable();\r\n        }\r\n        // any to void\r\n        if (toType.kind == 13 /* VOID */) {\r\n            return this.module.createDrop(expr);\r\n        }\r\n        if (conversionKind == 1 /* IMPLICIT */ && !fromType.isAssignableTo(toType)) {\r\n            this.error(diagnostics_1.DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast, reportNode.range, fromType.toString(), toType.toString());\r\n        }\r\n        var mod = this.module;\r\n        var losesInformation = false;\r\n        if (fromType.is(8 /* FLOAT */)) {\r\n            // float to float\r\n            if (toType.is(8 /* FLOAT */)) {\r\n                if (fromType.kind == 11 /* F32 */) {\r\n                    // f32 to f64\r\n                    if (toType.kind == 12 /* F64 */) {\r\n                        expr = mod.createUnary(module_1.UnaryOp.PromoteF32, expr);\r\n                    }\r\n                    // otherwise f32 to f32\r\n                    // f64 to f32\r\n                }\r\n                else if (toType.kind == 11 /* F32 */) {\r\n                    losesInformation = true;\r\n                    expr = mod.createUnary(module_1.UnaryOp.DemoteF64, expr);\r\n                }\r\n                // otherwise f64 to f64\r\n                // float to int\r\n            }\r\n            else if (toType.is(4 /* INTEGER */)) {\r\n                losesInformation = true;\r\n                // f32 to int\r\n                if (fromType.kind == 11 /* F32 */) {\r\n                    if (toType.is(1 /* SIGNED */)) {\r\n                        if (toType.is(64 /* LONG */)) {\r\n                            expr = mod.createUnary(module_1.UnaryOp.TruncF32ToI64, expr);\r\n                        }\r\n                        else {\r\n                            expr = mod.createUnary(module_1.UnaryOp.TruncF32ToI32, expr);\r\n                            if (toType.is(32 /* SMALL */)) {\r\n                                expr = makeSmallIntegerWrap(expr, toType, this.module);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (toType.is(64 /* LONG */)) {\r\n                            expr = mod.createUnary(module_1.UnaryOp.TruncF32ToU64, expr);\r\n                        }\r\n                        else {\r\n                            expr = mod.createUnary(module_1.UnaryOp.TruncF32ToU32, expr);\r\n                            if (toType.is(32 /* SMALL */)) {\r\n                                expr = makeSmallIntegerWrap(expr, toType, this.module);\r\n                            }\r\n                        }\r\n                    }\r\n                    // f64 to int\r\n                }\r\n                else {\r\n                    if (toType.is(1 /* SIGNED */)) {\r\n                        if (toType.is(64 /* LONG */)) {\r\n                            expr = mod.createUnary(module_1.UnaryOp.TruncF64ToI64, expr);\r\n                        }\r\n                        else {\r\n                            expr = mod.createUnary(module_1.UnaryOp.TruncF64ToI32, expr);\r\n                            if (toType.is(32 /* SMALL */)) {\r\n                                expr = makeSmallIntegerWrap(expr, toType, this.module);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (toType.is(64 /* LONG */)) {\r\n                            expr = mod.createUnary(module_1.UnaryOp.TruncF64ToU64, expr);\r\n                        }\r\n                        else {\r\n                            expr = mod.createUnary(module_1.UnaryOp.TruncF64ToU32, expr);\r\n                            if (toType.is(32 /* SMALL */)) {\r\n                                expr = makeSmallIntegerWrap(expr, toType, this.module);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // float to void\r\n            }\r\n            else {\r\n                assert(toType.flags == 0 /* NONE */, \"void type expected\");\r\n                expr = this.module.createDrop(expr);\r\n            }\r\n            // int to float\r\n        }\r\n        else if (fromType.is(4 /* INTEGER */) && toType.is(8 /* FLOAT */)) {\r\n            // int to f32\r\n            if (toType.kind == 11 /* F32 */) {\r\n                if (fromType.is(64 /* LONG */)) {\r\n                    losesInformation = true;\r\n                    expr = mod.createUnary(fromType.is(1 /* SIGNED */)\r\n                        ? module_1.UnaryOp.ConvertI64ToF32\r\n                        : module_1.UnaryOp.ConvertU64ToF32, expr);\r\n                }\r\n                else {\r\n                    losesInformation = !fromType.is(32 /* SMALL */);\r\n                    expr = mod.createUnary(fromType.is(1 /* SIGNED */)\r\n                        ? module_1.UnaryOp.ConvertI32ToF32\r\n                        : module_1.UnaryOp.ConvertU32ToF32, expr);\r\n                }\r\n                // int to f64\r\n            }\r\n            else {\r\n                if (fromType.is(64 /* LONG */)) {\r\n                    losesInformation = true;\r\n                    expr = mod.createUnary(fromType.is(1 /* SIGNED */)\r\n                        ? module_1.UnaryOp.ConvertI64ToF64\r\n                        : module_1.UnaryOp.ConvertU64ToF64, expr);\r\n                }\r\n                else {\r\n                    expr = mod.createUnary(fromType.is(1 /* SIGNED */)\r\n                        ? module_1.UnaryOp.ConvertI32ToF64\r\n                        : module_1.UnaryOp.ConvertU32ToF64, expr);\r\n                }\r\n            }\r\n            // int to int\r\n        }\r\n        else {\r\n            if (fromType.is(64 /* LONG */)) {\r\n                // i64 to i32\r\n                if (!toType.is(64 /* LONG */)) {\r\n                    losesInformation = true;\r\n                    expr = mod.createUnary(module_1.UnaryOp.WrapI64, expr); // discards upper bits\r\n                    if (toType.is(32 /* SMALL */)) {\r\n                        expr = makeSmallIntegerWrap(expr, toType, this.module);\r\n                    }\r\n                }\r\n                // i32 to i64\r\n            }\r\n            else if (toType.is(64 /* LONG */)) {\r\n                expr = mod.createUnary(toType.is(1 /* SIGNED */) ? module_1.UnaryOp.ExtendI32 : module_1.UnaryOp.ExtendU32, expr);\r\n                // i32 or smaller to even smaller or same size int with change of sign\r\n            }\r\n            else if (toType.is(32 /* SMALL */) &&\r\n                (fromType.size > toType.size ||\r\n                    (fromType.size == toType.size &&\r\n                        fromType.is(1 /* SIGNED */) != toType.is(1 /* SIGNED */)))) {\r\n                losesInformation = true;\r\n                expr = makeSmallIntegerWrap(expr, toType, this.module);\r\n            }\r\n            // otherwise (smaller) i32/u32 to (same size) i32/u32\r\n        }\r\n        return expr;\r\n    };\r\n    /** Computes the common compatible type of two types. Returns `null` if incompatible. */\r\n    Compiler.prototype.computeCommonType = function (leftType, rightType) {\r\n        if (leftType.isAssignableTo(rightType)) {\r\n            return rightType;\r\n        }\r\n        else if (rightType.isAssignableTo(leftType)) {\r\n            return leftType;\r\n        }\r\n        return null;\r\n    };\r\n    Compiler.prototype.compileAssertionExpression = function (expression, contextualType) {\r\n        var toType = this.program.resolveType(// reports\r\n        expression.toType, this.currentFunction.contextualTypeArguments);\r\n        if (!toType)\r\n            return this.module.createUnreachable();\r\n        return this.compileExpression(expression.expression, toType, 2 /* EXPLICIT */);\r\n    };\r\n    Compiler.prototype.compileBinaryExpression = function (expression, contextualType, wrapSmallIntegers) {\r\n        if (wrapSmallIntegers === void 0) { wrapSmallIntegers = true; }\r\n        var left;\r\n        var right;\r\n        // TODO: Currently, the common type of any binary expression is the first operand's type. This\r\n        // differs from C and other languages where comparing an int to a long, in this order, upcasts\r\n        // left to a long before comparison, instead of failing when trying to downcast right to an int.\r\n        // NOTE that if we change the current behaviour, some examples, tests and wiki pages will have\r\n        // to be updated, while compound binary operations must retain the previous behavior.\r\n        // var left = this.compileExpression(\r\n        //   expression.left,\r\n        //   contextualType == Type.void\r\n        //     ? Type.i32\r\n        //     : contextualType,\r\n        //   ConversionKind.NONE\r\n        // );\r\n        // var leftType = this.currentType;\r\n        // var right = this.compileExpression(\r\n        //   expression.right,\r\n        //   leftType,\r\n        //   ConversionKind.NONE\r\n        // );\r\n        // var rightType = this.currentType;\r\n        // var commonType = this.computeCommonType(leftType, rightType);\r\n        // if (!commonType) {\r\n        //   this.error(\r\n        //     DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n        //     expression.range,\r\n        //     Token.operatorToString(expression.operator), leftType.toString(), rightType.toString()\r\n        //   );\r\n        //   this.currentType = contextualType;\r\n        //   return this.module.createUnreachable();\r\n        // }\r\n        var condition;\r\n        var expr;\r\n        var compound = false;\r\n        var possiblyOverflows = false;\r\n        var tempLocal = null;\r\n        switch (expression.operator) {\r\n            case tokenizer_1.Token.LESSTHAN:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */);\r\n                right = this.compileExpression(expression.right, this.currentType);\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 2 /* I32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.LtI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.LtI64, left, right);\r\n                        break;\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.LtI64\r\n                            : module_1.BinaryOp.LtI32, left, right);\r\n                        break;\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 7 /* U32 */:\r\n                    case 10 /* BOOL */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.LtU32, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                        // TODO: check operator overload\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.LtU64\r\n                            : module_1.BinaryOp.LtU32, left, right);\r\n                        break;\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.LtU64, left, right);\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.LtF32, left, right);\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.LtF64, left, right);\r\n                        break;\r\n                    default:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                this.currentType = types_1.Type.bool;\r\n                break;\r\n            case tokenizer_1.Token.GREATERTHAN:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */);\r\n                right = this.compileExpression(expression.right, this.currentType);\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 2 /* I32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.GtI32, left, right);\r\n                        break;\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.GtI64\r\n                            : module_1.BinaryOp.GtI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.GtI64, left, right);\r\n                        break;\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 7 /* U32 */:\r\n                    case 10 /* BOOL */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.GtU32, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                        // TODO: check operator overload\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.GtU64\r\n                            : module_1.BinaryOp.GtU32, left, right);\r\n                        break;\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.GtU64, left, right);\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.GtF32, left, right);\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.GtF64, left, right);\r\n                        break;\r\n                    default:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                this.currentType = types_1.Type.bool;\r\n                break;\r\n            case tokenizer_1.Token.LESSTHAN_EQUALS:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */);\r\n                right = this.compileExpression(expression.right, this.currentType);\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 2 /* I32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.LeI32, left, right);\r\n                        break;\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.LeI64\r\n                            : module_1.BinaryOp.LeI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.LeI64, left, right);\r\n                        break;\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 7 /* U32 */:\r\n                    case 10 /* BOOL */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.LeU32, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                        // TODO: check operator overload\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.LeU64\r\n                            : module_1.BinaryOp.LeU32, left, right);\r\n                        break;\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.LeU64, left, right);\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.LeF32, left, right);\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.LeF64, left, right);\r\n                        break;\r\n                    default:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                this.currentType = types_1.Type.bool;\r\n                break;\r\n            case tokenizer_1.Token.GREATERTHAN_EQUALS:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */);\r\n                right = this.compileExpression(expression.right, this.currentType);\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 2 /* I32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.GeI32, left, right);\r\n                        break;\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.GeI64\r\n                            : module_1.BinaryOp.GeI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.GeI64, left, right);\r\n                        break;\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 7 /* U32 */:\r\n                    case 10 /* BOOL */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.GeU32, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                        // TODO: check operator overload\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.GeU64\r\n                            : module_1.BinaryOp.GeU32, left, right);\r\n                        break;\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.GeU64, left, right);\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.GeF32, left, right);\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.GeF64, left, right);\r\n                        break;\r\n                    default:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                this.currentType = types_1.Type.bool;\r\n                break;\r\n            case tokenizer_1.Token.EQUALS_EQUALS_EQUALS:\r\n            // TODO?\r\n            case tokenizer_1.Token.EQUALS_EQUALS:\r\n                // NOTE that this favors correctness, in terms of emitting a binary expression, over\r\n                // checking for a possible use of unary EQZ. while the most classic of all optimizations,\r\n                // that's not what the source told us to do. for reference, `!left` emits unary EQZ.\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */);\r\n                right = this.compileExpression(expression.right, this.currentType);\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 2 /* I32 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 7 /* U32 */:\r\n                    case 10 /* BOOL */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.EqI32, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                    // TODO: check operator overload\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.EqI64\r\n                            : module_1.BinaryOp.EqI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.EqI64, left, right);\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.EqF32, left, right);\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.EqF64, left, right);\r\n                        break;\r\n                    default:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                this.currentType = types_1.Type.bool;\r\n                break;\r\n            case tokenizer_1.Token.EXCLAMATION_EQUALS_EQUALS:\r\n            // TODO?\r\n            case tokenizer_1.Token.EXCLAMATION_EQUALS:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */);\r\n                right = this.compileExpression(expression.right, this.currentType);\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 2 /* I32 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 7 /* U32 */:\r\n                    case 10 /* BOOL */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.NeI32, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                    // TODO: check operator overload\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.NeI64\r\n                            : module_1.BinaryOp.NeI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.NeI64, left, right);\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.NeF32, left, right);\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.NeF64, left, right);\r\n                        break;\r\n                    default:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                this.currentType = types_1.Type.bool;\r\n                break;\r\n            case tokenizer_1.Token.EQUALS:\r\n                return this.compileAssignment(expression.left, expression.right, contextualType);\r\n            case tokenizer_1.Token.PLUS_EQUALS:\r\n                compound = true;\r\n            case tokenizer_1.Token.PLUS:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */, false // retains low bits of small integers\r\n                );\r\n                right = this.compileExpression(expression.right, this.currentType, 1 /* IMPLICIT */, false // ^\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                        possiblyOverflows = true;\r\n                    case 2 /* I32 */:\r\n                    case 7 /* U32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.AddI32, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                    // TODO: check operator overload\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.AddI64\r\n                            : module_1.BinaryOp.AddI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.AddI64, left, right);\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.AddF32, left, right);\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.AddF64, left, right);\r\n                        break;\r\n                    default:\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.MINUS_EQUALS:\r\n                compound = true;\r\n            case tokenizer_1.Token.MINUS:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */, false // retains low bits of small integers\r\n                );\r\n                right = this.compileExpression(expression.right, this.currentType, 1 /* IMPLICIT */, false // ^\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                        possiblyOverflows = true;\r\n                    case 2 /* I32 */:\r\n                    case 7 /* U32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.SubI32, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                    // TODO: check operator overload\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.SubI64\r\n                            : module_1.BinaryOp.SubI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.SubI64, left, right);\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.SubF32, left, right);\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.SubF64, left, right);\r\n                        break;\r\n                    default:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.ASTERISK_EQUALS:\r\n                compound = true;\r\n            case tokenizer_1.Token.ASTERISK:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */, false // retains low bits of small integers\r\n                );\r\n                right = this.compileExpression(expression.right, this.currentType, 1 /* IMPLICIT */, false // ^\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                        possiblyOverflows = true;\r\n                    // fall-through\r\n                    case 2 /* I32 */:\r\n                    case 7 /* U32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.MulI32, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                    // TODO: check operator overload\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.MulI64\r\n                            : module_1.BinaryOp.MulI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.MulI64, left, right);\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.MulF32, left, right);\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.MulF64, left, right);\r\n                        break;\r\n                    default:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.SLASH_EQUALS:\r\n                compound = true;\r\n            case tokenizer_1.Token.SLASH:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */, true // TODO: when can division remain unwrapped? does it overflow?\r\n                );\r\n                right = this.compileExpression(expression.right, this.currentType, 1 /* IMPLICIT */, true // ^\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                        possiblyOverflows = true;\r\n                    case 2 /* I32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.DivI32, left, right);\r\n                        break;\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.DivI64\r\n                            : module_1.BinaryOp.DivI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.DivI64, left, right);\r\n                        break;\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                        possiblyOverflows = true;\r\n                    case 7 /* U32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.DivU32, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                        // TODO: check operator overload\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.DivU64\r\n                            : module_1.BinaryOp.DivU32, left, right);\r\n                        break;\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.DivU64, left, right);\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.DivF32, left, right);\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.DivF64, left, right);\r\n                        break;\r\n                    default:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.PERCENT_EQUALS:\r\n                compound = true;\r\n            case tokenizer_1.Token.PERCENT:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */, true // TODO: when can remainder remain unwrapped? may it overflow?\r\n                );\r\n                right = this.compileExpression(expression.right, this.currentType, 1 /* IMPLICIT */, true // ^\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 2 /* I32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.RemI32, left, right);\r\n                        break;\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.RemI64\r\n                            : module_1.BinaryOp.RemI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.RemI64, left, right);\r\n                        break;\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 7 /* U32 */:\r\n                    case 10 /* BOOL */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.RemU32, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                        // TODO: check operator overload\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.RemU64\r\n                            : module_1.BinaryOp.RemU32, left, right);\r\n                        break;\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.RemU64, left, right);\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                    case 12 /* F64 */:\r\n                        // TODO: internal fmod, possibly simply imported from JS\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        expr = this.module.createUnreachable();\r\n                        break;\r\n                    default:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.LESSTHAN_LESSTHAN_EQUALS:\r\n                compound = true;\r\n            case tokenizer_1.Token.LESSTHAN_LESSTHAN:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType.is(8 /* FLOAT */)\r\n                        ? types_1.Type.i64\r\n                        : contextualType, 0 /* NONE */, false // retains low bits of small integers\r\n                );\r\n                right = this.compileExpression(expression.right, this.currentType, 1 /* IMPLICIT */, false // ^\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                        possiblyOverflows = true;\r\n                    default:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.ShlI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.ShlI64, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                    // TODO: check operator overload\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.ShlI64\r\n                            : module_1.BinaryOp.ShlI32, left, right);\r\n                        break;\r\n                    case 13 /* VOID */:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_EQUALS:\r\n                compound = true;\r\n            case tokenizer_1.Token.GREATERTHAN_GREATERTHAN:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType.is(8 /* FLOAT */)\r\n                        ? types_1.Type.i64\r\n                        : contextualType, 0 /* NONE */, true // must wrap small integers\r\n                );\r\n                right = this.compileExpression(expression.right, this.currentType, 1 /* IMPLICIT */, true // ^\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    default:\r\n                        // assumes signed shr on signed small integers does not overflow\r\n                        expr = this.module.createBinary(module_1.BinaryOp.ShrI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.ShrI64, left, right);\r\n                        break;\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.ShrI64\r\n                            : module_1.BinaryOp.ShrI32, left, right);\r\n                        break;\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                    // assumes unsigned shr on unsigned small integers does not overflow\r\n                    case 7 /* U32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.ShrU32, left, right);\r\n                        break;\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.ShrU64, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                        // TODO: check operator overload\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.ShrU64\r\n                            : module_1.BinaryOp.ShrU32, left, right);\r\n                        break;\r\n                    case 13 /* VOID */:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\r\n                compound = true;\r\n            case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType == types_1.Type.void\r\n                        ? types_1.Type.u64\r\n                        : contextualType, 0 /* NONE */, true // modifies low bits of small integers if unsigned\r\n                );\r\n                right = this.compileExpression(expression.right, this.currentType, 1 /* IMPLICIT */, true // ^\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                        possiblyOverflows = true;\r\n                    // fall-through\r\n                    default:\r\n                        // assumes that unsigned shr on unsigned small integers does not overflow\r\n                        expr = this.module.createBinary(module_1.BinaryOp.ShrU32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.ShrU64, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                    // TODO: check operator overload\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.ShrU64\r\n                            : module_1.BinaryOp.ShrU32, left, right);\r\n                        break;\r\n                    case 13 /* VOID */:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.AMPERSAND_EQUALS:\r\n                compound = true;\r\n            case tokenizer_1.Token.AMPERSAND:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType.is(8 /* FLOAT */)\r\n                        ? types_1.Type.i64\r\n                        : contextualType, 0 /* NONE */, false // retains low bits of small integers\r\n                );\r\n                right = this.compileExpression(expression.right, this.currentType, 1 /* IMPLICIT */, false // ^\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                        possiblyOverflows = true; // if left or right already did\r\n                    default:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.AndI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.AndI64, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                    // TODO: check operator overload\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.AndI64\r\n                            : module_1.BinaryOp.AndI32, left, right);\r\n                        break;\r\n                    case 13 /* VOID */:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.BAR_EQUALS:\r\n                compound = true;\r\n            case tokenizer_1.Token.BAR:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType.is(8 /* FLOAT */)\r\n                        ? types_1.Type.i64\r\n                        : contextualType, 0 /* NONE */, false // retains low bits of small integers\r\n                );\r\n                right = this.compileExpression(expression.right, this.currentType, 1 /* IMPLICIT */, false // ^\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                        possiblyOverflows = true; // if left or right already did\r\n                    default:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.OrI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.OrI64, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                    // TODO: check operator overload\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.OrI64\r\n                            : module_1.BinaryOp.OrI32, left, right);\r\n                        break;\r\n                    case 13 /* VOID */:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.CARET_EQUALS:\r\n                compound = true;\r\n            case tokenizer_1.Token.CARET:\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType.is(8 /* FLOAT */)\r\n                        ? types_1.Type.i64\r\n                        : contextualType, 0 /* NONE */, false // retains low bits of small integers\r\n                );\r\n                right = this.compileExpression(expression.right, this.currentType, 1 /* IMPLICIT */, false // ^\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                        possiblyOverflows = true; // if left or right already did\r\n                    default:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.XorI32, left, right);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.XorI64, left, right);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                    // TODO: check operator overload\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.XorI64\r\n                            : module_1.BinaryOp.XorI32, left, right);\r\n                        break;\r\n                    case 13 /* VOID */:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                break;\r\n            // logical (no overloading)\r\n            case tokenizer_1.Token.AMPERSAND_AMPERSAND:// left && right\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */);\r\n                right = this.compileExpression(expression.right, this.currentType, 1 /* IMPLICIT */, false);\r\n                // clone left if free of side effects\r\n                expr = this.module.cloneExpression(left, true, 0);\r\n                // if not possible, tee left to a temp. local\r\n                if (!expr) {\r\n                    tempLocal = this.currentFunction.getAndFreeTempLocal(this.currentType);\r\n                    left = this.module.createTeeLocal(tempLocal.index, left);\r\n                }\r\n                possiblyOverflows = this.currentType.is(32 /* SMALL */ | 4 /* INTEGER */);\r\n                condition = makeIsTrueish(left, this.currentType, this.module);\r\n                // simplify when cloning left without side effects was successful\r\n                if (expr) {\r\n                    expr = this.module.createIf(condition, // left\r\n                    right, //   ? right\r\n                    expr //   : cloned left\r\n                    );\r\n                }\r\n                else {\r\n                    expr = this.module.createIf(condition, right, this.module.createGetLocal(assert(tempLocal, \"tempLocal must be set\").index, this.currentType.toNativeType()));\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.BAR_BAR:// left || right\r\n                left = this.compileExpression(expression.left, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */);\r\n                right = this.compileExpression(expression.right, this.currentType, 1 /* IMPLICIT */, false);\r\n                // clone left if free of side effects\r\n                expr = this.module.cloneExpression(left, true, 0);\r\n                // if not possible, tee left to a temp. local\r\n                if (!expr) {\r\n                    tempLocal = this.currentFunction.getAndFreeTempLocal(this.currentType);\r\n                    left = this.module.createTeeLocal(tempLocal.index, left);\r\n                }\r\n                possiblyOverflows = this.currentType.is(32 /* SMALL */ | 4 /* INTEGER */); // if right did\r\n                condition = makeIsTrueish(left, this.currentType, this.module);\r\n                // simplify when cloning left without side effects was successful\r\n                if (expr) {\r\n                    expr = this.module.createIf(condition, // left\r\n                    expr, //   ? cloned left\r\n                    right //   : right\r\n                    );\r\n                }\r\n                else {\r\n                    expr = this.module.createIf(condition, this.module.createGetLocal(assert(tempLocal, \"tempLocal must be set\").index, this.currentType.toNativeType()), right);\r\n                }\r\n                break;\r\n            default:\r\n                this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                throw new Error(\"not implemented\");\r\n        }\r\n        if (possiblyOverflows && wrapSmallIntegers) {\r\n            assert(this.currentType.is(32 /* SMALL */ | 4 /* INTEGER */), \"small integer type expected\");\r\n            expr = makeSmallIntegerWrap(expr, this.currentType, this.module);\r\n        }\r\n        return compound\r\n            ? this.compileAssignmentWithValue(expression.left, expr, contextualType != types_1.Type.void)\r\n            : expr;\r\n    };\r\n    Compiler.prototype.compileAssignment = function (expression, valueExpression, contextualType) {\r\n        var resolved = this.program.resolveExpression(expression, this.currentFunction); // reports\r\n        if (!resolved)\r\n            return this.module.createUnreachable();\r\n        // to compile just the value, we need to know the target's type\r\n        var element = resolved.element;\r\n        var elementType;\r\n        switch (element.kind) {\r\n            case program_1.ElementKind.GLOBAL:\r\n                if (!this.compileGlobal(element)) {\r\n                    return this.module.createUnreachable();\r\n                }\r\n                assert(element.type != types_1.Type.void, \"concrete type expected\");\r\n            // fall-through\r\n            case program_1.ElementKind.LOCAL:\r\n            case program_1.ElementKind.FIELD:\r\n                elementType = element.type;\r\n                break;\r\n            case program_1.ElementKind.PROPERTY:\r\n                var setterPrototype = element.setterPrototype;\r\n                if (setterPrototype) {\r\n                    var setterInstance = setterPrototype.resolve(); // reports\r\n                    if (!setterInstance)\r\n                        return this.module.createUnreachable();\r\n                    assert(setterInstance.parameters && setterInstance.parameters.length == 1);\r\n                    elementType = setterInstance.parameters[0].type;\r\n                    break;\r\n                }\r\n                this.error(diagnostics_1.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, expression.range, element.internalName);\r\n                return this.module.createUnreachable();\r\n            case program_1.ElementKind.FUNCTION_PROTOTYPE:\r\n                if (expression.kind == ast_1.NodeKind.ELEMENTACCESS) {\r\n                    assert(resolved.target &&\r\n                        resolved.target.kind == program_1.ElementKind.CLASS &&\r\n                        element.simpleName == resolved.target.prototype.fnIndexedGet);\r\n                    var resolvedIndexedSet = element.resolve(null);\r\n                    if (resolvedIndexedSet) {\r\n                        elementType = resolvedIndexedSet.returnType;\r\n                        break;\r\n                    }\r\n                }\r\n            // fall-through\r\n            default:\r\n                this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                return this.module.createUnreachable();\r\n        }\r\n        // now compile the value and do the assignment\r\n        this.currentType = elementType;\r\n        return this.compileAssignmentWithValue(expression, this.compileExpression(valueExpression, elementType), contextualType != types_1.Type.void);\r\n    };\r\n    Compiler.prototype.compileAssignmentWithValue = function (expression, valueWithCorrectType, tee) {\r\n        if (tee === void 0) { tee = false; }\r\n        var resolved = this.program.resolveExpression(expression, this.currentFunction); // reports\r\n        if (!resolved)\r\n            return this.module.createUnreachable();\r\n        var element = resolved.element;\r\n        var tempLocal;\r\n        var targetExpr;\r\n        switch (element.kind) {\r\n            case program_1.ElementKind.LOCAL:\r\n                this.currentType = tee ? element.type : types_1.Type.void;\r\n                if (element.is(program_1.ElementFlags.CONSTANT)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, expression.range, element.internalName);\r\n                    return this.module.createUnreachable();\r\n                }\r\n                return tee\r\n                    ? this.module.createTeeLocal(element.index, valueWithCorrectType)\r\n                    : this.module.createSetLocal(element.index, valueWithCorrectType);\r\n            case program_1.ElementKind.GLOBAL:\r\n                if (!this.compileGlobal(element)) {\r\n                    return this.module.createUnreachable();\r\n                }\r\n                assert(element.type != types_1.Type.void, \"concrete type expected\");\r\n                this.currentType = tee ? element.type : types_1.Type.void;\r\n                if (element.is(program_1.ElementFlags.CONSTANT)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, expression.range, element.internalName);\r\n                    return this.module.createUnreachable();\r\n                }\r\n                if (!tee) {\r\n                    return this.module.createSetGlobal(element.internalName, valueWithCorrectType);\r\n                }\r\n                var globalNativeType = element.type.toNativeType();\r\n                return this.module.createBlock(null, [\r\n                    this.module.createSetGlobal(element.internalName, valueWithCorrectType),\r\n                    this.module.createGetGlobal(element.internalName, globalNativeType)\r\n                ], globalNativeType);\r\n            case program_1.ElementKind.FIELD:\r\n                if (element.prototype.isReadonly) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, expression.range, element.internalName);\r\n                    return this.module.createUnreachable();\r\n                }\r\n                assert(resolved.targetExpression != null, \"target expression expected\");\r\n                targetExpr = this.compileExpression(resolved.targetExpression, this.options.isWasm64\r\n                    ? types_1.Type.usize64\r\n                    : types_1.Type.usize32, 0 /* NONE */);\r\n                assert(this.currentType.classType, \"class type expected\");\r\n                this.currentType = tee ? element.type : types_1.Type.void;\r\n                var elementNativeType = element.type.toNativeType();\r\n                if (!tee) {\r\n                    return this.module.createStore(element.type.size >> 3, targetExpr, valueWithCorrectType, elementNativeType, element.memoryOffset);\r\n                }\r\n                tempLocal = this.currentFunction.getAndFreeTempLocal(element.type);\r\n                // TODO: simplify if valueWithCorrectType has no side effects\r\n                return this.module.createBlock(null, [\r\n                    this.module.createSetLocal(tempLocal.index, valueWithCorrectType),\r\n                    this.module.createStore(element.type.size >> 3, targetExpr, this.module.createGetLocal(tempLocal.index, elementNativeType), elementNativeType, element.memoryOffset),\r\n                    this.module.createGetLocal(tempLocal.index, elementNativeType)\r\n                ], elementNativeType);\r\n            case program_1.ElementKind.PROPERTY:\r\n                var setterPrototype = element.setterPrototype;\r\n                if (setterPrototype) {\r\n                    var setterInstance = setterPrototype.resolve(); // reports\r\n                    if (setterInstance) {\r\n                        assert(setterInstance.parameters && setterInstance.parameters.length == 1);\r\n                        if (!tee) {\r\n                            if (setterInstance.is(program_1.ElementFlags.INSTANCE)) {\r\n                                assert(resolved.targetExpression != null);\r\n                                targetExpr = this.compileExpression(resolved.targetExpression, this.options.isWasm64\r\n                                    ? types_1.Type.usize64\r\n                                    : types_1.Type.usize32, 0 /* NONE */);\r\n                                assert(this.currentType.classType);\r\n                                this.currentType = types_1.Type.void;\r\n                                return this.makeCall(setterInstance, [targetExpr, valueWithCorrectType]);\r\n                            }\r\n                            else {\r\n                                this.currentType = types_1.Type.void;\r\n                                return this.makeCall(setterInstance, [valueWithCorrectType]);\r\n                            }\r\n                        }\r\n                        var getterPrototype = element.getterPrototype;\r\n                        assert(getterPrototype != null);\r\n                        var getterInstance = getterPrototype.resolve(); // reports\r\n                        if (getterInstance) {\r\n                            assert(!getterInstance.parameters || !getterInstance.parameters.length);\r\n                            if (setterInstance.is(program_1.ElementFlags.INSTANCE)) {\r\n                                assert(resolved.targetExpression != null);\r\n                                targetExpr = this.compileExpression(resolved.targetExpression, this.options.isWasm64\r\n                                    ? types_1.Type.usize64\r\n                                    : types_1.Type.usize32, 0 /* NONE */);\r\n                                assert(this.currentType.classType);\r\n                                tempLocal = this.currentFunction.getAndFreeTempLocal(getterInstance.returnType);\r\n                                return this.module.createBlock(null, [\r\n                                    this.makeCall(setterInstance, [\r\n                                        this.module.createTeeLocal(tempLocal.index, targetExpr), valueWithCorrectType\r\n                                    ]),\r\n                                    this.makeCall(getterInstance, [\r\n                                        this.module.createGetLocal(tempLocal.index, tempLocal.type.toNativeType())\r\n                                    ])\r\n                                ], (this.currentType = getterInstance.returnType).toNativeType());\r\n                            }\r\n                            else {\r\n                                return this.module.createBlock(null, [\r\n                                    this.makeCall(setterInstance, [valueWithCorrectType]),\r\n                                    this.makeCall(getterInstance)\r\n                                ], (this.currentType = getterInstance.returnType).toNativeType());\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, expression.range, element.internalName);\r\n                }\r\n                return this.module.createUnreachable();\r\n            case program_1.ElementKind.FUNCTION_PROTOTYPE:\r\n                if (expression.kind == ast_1.NodeKind.ELEMENTACCESS) {\r\n                    assert(resolved.target && resolved.target.kind == program_1.ElementKind.CLASS);\r\n                    var resolvedIndexedGet = element.resolve();\r\n                    if (!resolvedIndexedGet)\r\n                        return this.module.createUnreachable();\r\n                    var indexedSetName = resolved.target.prototype.fnIndexedSet;\r\n                    var indexedSet;\r\n                    if (indexedSetName != null &&\r\n                        resolved.target.members &&\r\n                        (indexedSet = resolved.target.members.get(indexedSetName)) &&\r\n                        indexedSet.kind == program_1.ElementKind.FUNCTION_PROTOTYPE) {\r\n                        var resolvedIndexedSet = indexedSet.resolve();\r\n                        if (!resolvedIndexedSet)\r\n                            return this.module.createUnreachable();\r\n                        targetExpr = this.compileExpression(resolved.targetExpression, this.options.isWasm64\r\n                            ? types_1.Type.usize64\r\n                            : types_1.Type.usize32, 0 /* NONE */);\r\n                        assert(this.currentType.classType);\r\n                        var elementExpr = this.compileExpression(expression.elementExpression, types_1.Type.i32);\r\n                        if (!tee) {\r\n                            this.currentType = resolvedIndexedSet.returnType;\r\n                            return this.makeCall(resolvedIndexedSet, [\r\n                                targetExpr,\r\n                                elementExpr,\r\n                                valueWithCorrectType\r\n                            ]);\r\n                        }\r\n                        this.currentType = resolvedIndexedGet.returnType;\r\n                        tempLocal = this.currentFunction.getAndFreeTempLocal(this.currentType);\r\n                        return this.module.createBlock(null, [\r\n                            this.makeCall(resolvedIndexedSet, [\r\n                                targetExpr,\r\n                                elementExpr,\r\n                                this.module.createTeeLocal(tempLocal.index, valueWithCorrectType)\r\n                            ]),\r\n                            // TODO: could be different from an actual __get (needs 2 temp locals)\r\n                            this.module.createGetLocal(tempLocal.index, tempLocal.type.toNativeType())\r\n                        ], this.currentType.toNativeType());\r\n                    }\r\n                    else {\r\n                        this.error(diagnostics_1.DiagnosticCode.Index_signature_in_type_0_only_permits_reading, expression.range, resolved.target.internalName);\r\n                        return this.module.createUnreachable();\r\n                    }\r\n                }\r\n        }\r\n        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n        return this.module.createUnreachable();\r\n    };\r\n    Compiler.prototype.compileCallExpression = function (expression, contextualType) {\r\n        var resolved = this.program.resolveExpression(expression.expression, this.currentFunction); // reports\r\n        if (!resolved)\r\n            return this.module.createUnreachable();\r\n        var element = resolved.element;\r\n        if (element.kind != program_1.ElementKind.FUNCTION_PROTOTYPE) {\r\n            this.error(diagnostics_1.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, expression.range, element.internalName);\r\n            return this.module.createUnreachable();\r\n        }\r\n        var functionPrototype = element;\r\n        var functionInstance = null;\r\n        // TODO: generalize?\r\n        if (functionPrototype.is(program_1.ElementFlags.BUILTIN)) {\r\n            var resolvedTypeArguments = null;\r\n            if (expression.typeArguments) {\r\n                var k = expression.typeArguments.length;\r\n                resolvedTypeArguments = new Array(k);\r\n                for (var i = 0; i < k; ++i) {\r\n                    var resolvedType = this.program.resolveType(// reports\r\n                    expression.typeArguments[i], this.currentFunction.contextualTypeArguments, true);\r\n                    if (!resolvedType)\r\n                        return this.module.createUnreachable();\r\n                    resolvedTypeArguments[i] = resolvedType;\r\n                }\r\n            }\r\n            var expr = builtins_1.compileCall(this, functionPrototype, resolvedTypeArguments, expression.arguments, contextualType, expression);\r\n            if (!expr) {\r\n                this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                return this.module.createUnreachable();\r\n            }\r\n            return expr;\r\n        }\r\n        // TODO: infer type arguments from parameter types if omitted\r\n        functionInstance = functionPrototype.resolveInclTypeArguments(// reports\r\n        expression.typeArguments, this.currentFunction.contextualTypeArguments, expression);\r\n        if (!functionInstance)\r\n            return this.module.createUnreachable();\r\n        // TODO: generalize? (see above)\r\n        /* if (functionInstance.is(ElementFlags.BUILTIN)) {\r\n          var expr = compileBuiltinCall(\r\n            this,\r\n            functionPrototype,\r\n            functionInstance.typeArguments,\r\n            expression.arguments,\r\n            contextualType,\r\n            expression\r\n          );\r\n          if (!expr) {\r\n            this.error(DiagnosticCode.Operation_not_supported, expression.range);\r\n            return this.module.createUnreachable();\r\n          }\r\n          return expr;\r\n        } */\r\n        var numArguments = expression.arguments.length;\r\n        var numArgumentsInclThis = functionInstance.instanceMethodOf\r\n            ? numArguments + 1\r\n            : numArguments;\r\n        var argumentIndex = 0;\r\n        var args = new Array(numArgumentsInclThis);\r\n        if (functionInstance.instanceMethodOf) {\r\n            assert(resolved.targetExpression != null);\r\n            args[argumentIndex++] = resolved.targetExpression;\r\n        }\r\n        for (i = 0; i < numArguments; ++i) {\r\n            args[argumentIndex++] = expression.arguments[i];\r\n        }\r\n        return this.compileCall(functionInstance, args, expression);\r\n    };\r\n    /**\r\n     * Compiles a call to a function. If an instance method, `this` is the first element in\r\n     * `argumentExpressions` or can be specified explicitly as the last argument.\r\n     */\r\n    Compiler.prototype.compileCall = function (functionInstance, argumentExpressions, reportNode, thisArg) {\r\n        if (thisArg === void 0) { thisArg = 0; }\r\n        // validate and compile arguments\r\n        var parameters = functionInstance.parameters;\r\n        var numParameters = parameters ? parameters.length : 0;\r\n        var numParametersInclThis = functionInstance.instanceMethodOf != null\r\n            ? numParameters + 1\r\n            : numParameters;\r\n        var numArgumentsInclThis = argumentExpressions.length;\r\n        var numArguments = functionInstance.instanceMethodOf != null\r\n            ? numArgumentsInclThis - 1\r\n            : numArgumentsInclThis;\r\n        if (thisArg)\r\n            numArgumentsInclThis++;\r\n        if (numArgumentsInclThis > numParametersInclThis) {\r\n            this.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, numParameters.toString(10), numArguments.toString(10));\r\n            return this.module.createUnreachable();\r\n        }\r\n        var operands = new Array(numParametersInclThis);\r\n        var operandIndex = 0;\r\n        var argumentIndex = 0;\r\n        if (functionInstance.instanceMethodOf) {\r\n            if (thisArg) {\r\n                operands[operandIndex++] = thisArg;\r\n            }\r\n            else {\r\n                operands[operandIndex++] = this.compileExpression(argumentExpressions[argumentIndex++], functionInstance.instanceMethodOf.type);\r\n            }\r\n        }\r\n        if (parameters) {\r\n            for (; operandIndex < numParametersInclThis; ++operandIndex) {\r\n                // argument has been provided\r\n                if (numArgumentsInclThis > operandIndex) {\r\n                    operands[operandIndex] = this.compileExpression(argumentExpressions[argumentIndex++], parameters[operandIndex + numParameters - numParametersInclThis].type);\r\n                    // argument has been omitted\r\n                }\r\n                else {\r\n                    var initializer = parameters[operandIndex + numParameters - numParametersInclThis].initializer;\r\n                    if (initializer) {\r\n                        operands[operandIndex] = this.compileExpression(initializer, parameters[operandIndex + numParameters - numParametersInclThis].type);\r\n                        // FIXME: here, the initializer is compiled in the caller's scope.\r\n                        // a solution could be to use a stub for each possible overload, calling the\r\n                        // full function with optional arguments being part of the stub's body.\r\n                    }\r\n                    else {\r\n                        this.error(diagnostics_1.DiagnosticCode.Expected_at_least_0_arguments_but_got_1, reportNode.range, (operandIndex + numParameters - numParametersInclThis).toString(10), numArguments.toString(10));\r\n                        return this.module.createUnreachable();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.currentType = functionInstance.returnType;\r\n        return this.makeCall(functionInstance, operands);\r\n    };\r\n    /** Makes a call operation as is. */\r\n    Compiler.prototype.makeCall = function (functionInstance, operands) {\r\n        if (operands === void 0) { operands = null; }\r\n        if (!(functionInstance.is(program_1.ElementFlags.COMPILED) || this.compileFunction(functionInstance))) {\r\n            return this.module.createUnreachable();\r\n        }\r\n        // imported function\r\n        if (functionInstance.is(program_1.ElementFlags.DECLARED)) {\r\n            return this.module.createCallImport(functionInstance.internalName, operands, functionInstance.returnType.toNativeType());\r\n        }\r\n        // internal function\r\n        return this.module.createCall(functionInstance.internalName, operands, functionInstance.returnType.toNativeType());\r\n    };\r\n    Compiler.prototype.compileCommaExpression = function (expression, contextualType) {\r\n        var expressions = expression.expressions;\r\n        var k = expressions.length;\r\n        var exprs = new Array(k--);\r\n        for (var i = 0; i < k; ++i) {\r\n            exprs[i] = this.compileExpression(expressions[i], types_1.Type.void); // drop all\r\n        }\r\n        exprs[i] = this.compileExpression(expressions[i], contextualType); // except last\r\n        return this.module.createBlock(null, exprs, this.currentType.toNativeType());\r\n    };\r\n    Compiler.prototype.compileElementAccessExpression = function (expression, contextualType) {\r\n        var resolved = this.program.resolveElementAccess(expression, this.currentFunction); // reports\r\n        if (!resolved)\r\n            return this.module.createUnreachable();\r\n        assert(resolved.element.kind == program_1.ElementKind.FUNCTION_PROTOTYPE &&\r\n            resolved.target &&\r\n            resolved.target.kind == program_1.ElementKind.CLASS);\r\n        var instance = resolved.element.resolve(null, resolved.target.contextualTypeArguments);\r\n        if (!instance)\r\n            return this.module.createUnreachable();\r\n        return this.compileCall(instance, [\r\n            expression.expression,\r\n            expression.elementExpression\r\n        ], expression);\r\n    };\r\n    Compiler.prototype.compileFunctionExpression = function (expression, contextualType) {\r\n        var declaration = expression.declaration;\r\n        var simpleName = (declaration.name.text.length\r\n            ? declaration.name.text\r\n            : \"anonymous\") + \"|\" + this.functionTable.length.toString(10);\r\n        var prototype = new program_1.FunctionPrototype(this.program, simpleName, this.currentFunction.internalName + \"~\" + simpleName, declaration);\r\n        var instance = this.compileFunctionUsingTypeArguments(prototype, [], null, declaration);\r\n        if (!instance)\r\n            return this.module.createUnreachable();\r\n        this.currentType = types_1.Type.u32.asFunction(instance);\r\n        // NOTE that, in order to make this work in every case, the function must be represented by a\r\n        // value, so we add it and rely on the optimizer to figure out where it can be called directly.\r\n        var index = this.addFunctionTableEntry(instance);\r\n        if (index < 0)\r\n            return this.module.createUnreachable();\r\n        return this.module.createI32(index);\r\n    };\r\n    Compiler.prototype.compileIdentifierExpression = function (expression, contextualType) {\r\n        // check special keywords first\r\n        switch (expression.kind) {\r\n            case ast_1.NodeKind.NULL:\r\n                if (this.options.isWasm64) {\r\n                    if (!contextualType.classType) {\r\n                        assert(contextualType.kind == 9 /* USIZE */);\r\n                        this.currentType = types_1.Type.usize64;\r\n                    }\r\n                    return this.module.createI64(0);\r\n                }\r\n                if (!contextualType.classType) {\r\n                    assert(contextualType.kind == 9 /* USIZE */);\r\n                    this.currentType = types_1.Type.usize32;\r\n                }\r\n                return this.module.createI32(0);\r\n            case ast_1.NodeKind.TRUE:\r\n                this.currentType = types_1.Type.bool;\r\n                return this.module.createI32(1);\r\n            case ast_1.NodeKind.FALSE:\r\n                this.currentType = types_1.Type.bool;\r\n                return this.module.createI32(0);\r\n            case ast_1.NodeKind.THIS:\r\n                if (this.currentFunction.instanceMethodOf) {\r\n                    this.currentType = this.currentFunction.instanceMethodOf.type;\r\n                    return this.module.createGetLocal(0, this.currentType.toNativeType());\r\n                }\r\n                this.error(diagnostics_1.DiagnosticCode._this_cannot_be_referenced_in_current_location, expression.range);\r\n                this.currentType = this.options.isWasm64 ? types_1.Type.usize64 : types_1.Type.usize32;\r\n                return this.module.createUnreachable();\r\n            case ast_1.NodeKind.SUPER:\r\n                if (this.currentFunction.instanceMethodOf && this.currentFunction.instanceMethodOf.base) {\r\n                    this.currentType = this.currentFunction.instanceMethodOf.base.type;\r\n                    return this.module.createGetLocal(0, this.currentType.toNativeType());\r\n                }\r\n                this.error(diagnostics_1.DiagnosticCode._super_can_only_be_referenced_in_a_derived_class, expression.range);\r\n                this.currentType = this.options.isWasm64 ? types_1.Type.usize64 : types_1.Type.usize32;\r\n                return this.module.createUnreachable();\r\n        }\r\n        // otherwise resolve\r\n        var resolved = this.program.resolveIdentifier(// reports\r\n        expression, this.currentFunction, this.currentEnum);\r\n        if (!resolved)\r\n            return this.module.createUnreachable();\r\n        var element = resolved.element;\r\n        switch (element.kind) {\r\n            case program_1.ElementKind.LOCAL:\r\n                if (element.is(program_1.ElementFlags.INLINED)) {\r\n                    return this.compileInlineConstant(element, contextualType);\r\n                }\r\n                assert(element.index >= 0);\r\n                this.currentType = element.type;\r\n                return this.module.createGetLocal(element.index, this.currentType.toNativeType());\r\n            case program_1.ElementKind.GLOBAL:\r\n                if (element.is(program_1.ElementFlags.BUILTIN)) {\r\n                    return builtins_1.compileGetConstant(this, element, expression);\r\n                }\r\n                if (!this.compileGlobal(element)) {\r\n                    return this.module.createUnreachable();\r\n                }\r\n                assert(element.type != types_1.Type.void);\r\n                if (element.is(program_1.ElementFlags.INLINED)) {\r\n                    return this.compileInlineConstant(element, contextualType);\r\n                }\r\n                this.currentType = element.type;\r\n                return this.module.createGetGlobal(element.internalName, this.currentType.toNativeType());\r\n            case program_1.ElementKind.ENUMVALUE:// here: if referenced from within the same enum\r\n                if (!element.is(program_1.ElementFlags.COMPILED)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums, expression.range);\r\n                    this.currentType = types_1.Type.i32;\r\n                    return this.module.createUnreachable();\r\n                }\r\n                this.currentType = types_1.Type.i32;\r\n                if (element.is(program_1.ElementFlags.INLINED)) {\r\n                    return this.module.createI32(element.constantValue);\r\n                }\r\n                return this.module.createGetGlobal(element.internalName, module_1.NativeType.I32);\r\n        }\r\n        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n        return this.module.createUnreachable();\r\n    };\r\n    Compiler.prototype.compileLiteralExpression = function (expression, contextualType, implicitNegate) {\r\n        if (implicitNegate === void 0) { implicitNegate = false; }\r\n        switch (expression.literalKind) {\r\n            case 4 /* ARRAY */:\r\n                assert(!implicitNegate);\r\n                var classType = contextualType.classType;\r\n                if (classType &&\r\n                    classType == this.program.elements.get(\"Array\") &&\r\n                    classType.typeArguments && classType.typeArguments.length == 1) {\r\n                    return this.compileStaticArray(classType.typeArguments[0], expression.elementExpressions);\r\n                }\r\n                this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                return this.module.createUnreachable();\r\n            case 0 /* FLOAT */: {\r\n                var floatValue = expression.value;\r\n                if (implicitNegate) {\r\n                    floatValue = -floatValue;\r\n                }\r\n                if (contextualType == types_1.Type.f32) {\r\n                    return this.module.createF32(floatValue);\r\n                }\r\n                this.currentType = types_1.Type.f64;\r\n                return this.module.createF64(floatValue);\r\n            }\r\n            case 1 /* INTEGER */:\r\n                var intValue = expression.value;\r\n                if (implicitNegate) {\r\n                    intValue = i64_sub(i64_new(0), intValue);\r\n                }\r\n                switch (contextualType.kind) {\r\n                    // compile to contextualType if matching\r\n                    case 0 /* I8 */:\r\n                        if (i64_is_i8(intValue)) {\r\n                            return this.module.createI32(i64_low(intValue));\r\n                        }\r\n                        break;\r\n                    case 1 /* I16 */:\r\n                        if (i64_is_i16(intValue)) {\r\n                            return this.module.createI32(i64_low(intValue));\r\n                        }\r\n                        break;\r\n                    case 2 /* I32 */:\r\n                        if (i64_is_i32(intValue)) {\r\n                            return this.module.createI32(i64_low(intValue));\r\n                        }\r\n                        break;\r\n                    case 5 /* U8 */:\r\n                        if (i64_is_u8(intValue)) {\r\n                            return this.module.createI32(i64_low(intValue));\r\n                        }\r\n                        break;\r\n                    case 6 /* U16 */:\r\n                        if (i64_is_u16(intValue)) {\r\n                            return this.module.createI32(i64_low(intValue));\r\n                        }\r\n                        break;\r\n                    case 7 /* U32 */:\r\n                        if (i64_is_u32(intValue)) {\r\n                            return this.module.createI32(i64_low(intValue));\r\n                        }\r\n                        break;\r\n                    case 10 /* BOOL */:\r\n                        if (i64_is_bool(intValue)) {\r\n                            return this.module.createI32(i64_low(intValue));\r\n                        }\r\n                        break;\r\n                    case 4 /* ISIZE */:\r\n                        if (!this.options.isWasm64) {\r\n                            if (i64_is_u32(intValue)) {\r\n                                return this.module.createI32(i64_low(intValue));\r\n                            }\r\n                            break;\r\n                        }\r\n                        return this.module.createI64(i64_low(intValue), i64_high(intValue));\r\n                    case 9 /* USIZE */:\r\n                        if (!this.options.isWasm64) {\r\n                            if (i64_is_u32(intValue)) {\r\n                                return this.module.createI32(i64_low(intValue));\r\n                            }\r\n                            break;\r\n                        }\r\n                        return this.module.createI64(i64_low(intValue), i64_high(intValue));\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        return this.module.createI64(i64_low(intValue), i64_high(intValue));\r\n                    case 11 /* F32 */:\r\n                        if (i64_is_f32(intValue)) {\r\n                            return this.module.createF32(i64_to_f32(intValue));\r\n                        }\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        if (i64_is_f64(intValue)) {\r\n                            return this.module.createF64(i64_to_f64(intValue));\r\n                        }\r\n                        break;\r\n                    case 13 /* VOID */:\r\n                        break;\r\n                    default:\r\n                        assert(false);\r\n                        break;\r\n                }\r\n                // otherwise compile to best fitting native type\r\n                if (i64_is_i32(intValue)) {\r\n                    this.currentType = types_1.Type.i32;\r\n                    return this.module.createI32(i64_low(intValue));\r\n                }\r\n                else {\r\n                    this.currentType = types_1.Type.i64;\r\n                    return this.module.createI64(i64_low(intValue), i64_high(intValue));\r\n                }\r\n            case 2 /* STRING */:\r\n                assert(!implicitNegate);\r\n                return this.compileStaticString(expression.value);\r\n        }\r\n        throw new Error(\"not implemented\");\r\n    };\r\n    Compiler.prototype.compileStaticString = function (stringValue) {\r\n        var stringSegment = this.stringSegments.get(stringValue);\r\n        if (!stringSegment) {\r\n            var stringLength = stringValue.length;\r\n            var stringBuffer = new Uint8Array(4 + stringLength * 2);\r\n            stringBuffer[0] = stringLength & 0xff;\r\n            stringBuffer[1] = (stringLength >>> 8) & 0xff;\r\n            stringBuffer[2] = (stringLength >>> 16) & 0xff;\r\n            stringBuffer[3] = (stringLength >>> 24) & 0xff;\r\n            for (var i = 0; i < stringLength; ++i) {\r\n                stringBuffer[4 + i * 2] = stringValue.charCodeAt(i) & 0xff;\r\n                stringBuffer[5 + i * 2] = (stringValue.charCodeAt(i) >>> 8) & 0xff;\r\n            }\r\n            stringSegment = this.addMemorySegment(stringBuffer, this.options.usizeType.byteSize);\r\n            this.stringSegments.set(stringValue, stringSegment);\r\n        }\r\n        var stringOffset = stringSegment.offset;\r\n        var stringType = this.program.types.get(\"string\");\r\n        this.currentType = stringType ? stringType : this.options.usizeType;\r\n        if (this.options.isWasm64) {\r\n            return this.module.createI64(i64_low(stringOffset), i64_high(stringOffset));\r\n        }\r\n        assert(i64_is_i32(stringOffset));\r\n        return this.module.createI32(i64_low(stringOffset));\r\n    };\r\n    Compiler.prototype.compileStaticArray = function (elementType, expressions) {\r\n        // compile as static if all element expressions are precomputable, otherwise\r\n        // initialize in place.\r\n        var isStatic = true;\r\n        var size = expressions.length;\r\n        var nativeType = elementType.toNativeType();\r\n        var values;\r\n        switch (nativeType) {\r\n            case module_1.NativeType.I32:\r\n                values = changetype(new Int32Array(size));\r\n                break;\r\n            case module_1.NativeType.I64:\r\n                values = changetype(new Array(size));\r\n                break;\r\n            case module_1.NativeType.F32:\r\n                values = changetype(new Float32Array(size));\r\n                break;\r\n            case module_1.NativeType.F64:\r\n                values = changetype(new Float64Array(size));\r\n                break;\r\n            default:\r\n                throw new Error(\"concrete type expected\");\r\n        }\r\n        var exprs = new Array(size);\r\n        var expr;\r\n        for (var i = 0; i < size; ++i) {\r\n            exprs[i] = expressions[i]\r\n                ? this.compileExpression(expressions[i], elementType)\r\n                : elementType.toNativeZero(this.module);\r\n            if (isStatic) {\r\n                expr = this.precomputeExpressionRef(exprs[i]);\r\n                if (_BinaryenExpressionGetId(expr) == module_1.ExpressionId.Const) {\r\n                    assert(_BinaryenExpressionGetType(expr) == nativeType);\r\n                    switch (nativeType) {\r\n                        case module_1.NativeType.I32:\r\n                            changetype(values)[i] = _BinaryenConstGetValueI32(expr);\r\n                            break;\r\n                        case module_1.NativeType.I64:\r\n                            changetype(values)[i] = i64_new(_BinaryenConstGetValueI64Low(expr), _BinaryenConstGetValueI64High(expr));\r\n                            break;\r\n                        case module_1.NativeType.F32:\r\n                            changetype(values)[i] = _BinaryenConstGetValueF32(expr);\r\n                            break;\r\n                        case module_1.NativeType.F64:\r\n                            changetype(values)[i] = _BinaryenConstGetValueF64(expr);\r\n                            break;\r\n                        default:\r\n                            assert(false); // checked above\r\n                    }\r\n                }\r\n                else {\r\n                    // TODO: emit a warning if declared 'const'\r\n                    isStatic = false;\r\n                }\r\n            }\r\n        }\r\n        if (isStatic) {\r\n            // TODO: convert to Uint8Array and create the segment\r\n        }\r\n        else {\r\n            // TODO: initialize in place\r\n        }\r\n        // TODO: alternatively, static elements could go into data segments while\r\n        // dynamic ones are initialized on top? any benefits? (doesn't seem so)\r\n        throw new Error(\"not implemented\");\r\n    };\r\n    Compiler.prototype.compileNewExpression = function (expression, contextualType) {\r\n        var resolved = this.program.resolveExpression(// reports\r\n        expression.expression, this.currentFunction);\r\n        if (resolved) {\r\n            if (resolved.element.kind == program_1.ElementKind.CLASS_PROTOTYPE) {\r\n                var prototype = resolved.element;\r\n                var instance = prototype.resolveInclTypeArguments(// reports\r\n                expression.typeArguments, null, expression);\r\n                if (instance) {\r\n                    var thisExpr = builtins_1.compileAllocate(this, instance, expression);\r\n                    var initializers = new Array();\r\n                    // use a temp local for 'this'\r\n                    var tempLocal = this.currentFunction.getTempLocal(this.options.usizeType);\r\n                    initializers.push(this.module.createSetLocal(tempLocal.index, thisExpr));\r\n                    // apply field initializers\r\n                    if (instance.members) {\r\n                        try {\r\n                            for (var _a = __values(instance.members.values()), _b = _a.next(); !_b.done; _b = _a.next()) {\r\n                                var member = _b.value;\r\n                                if (member.kind == program_1.ElementKind.FIELD) {\r\n                                    var field = member;\r\n                                    var fieldDeclaration = field.prototype.declaration;\r\n                                    if (field.is(program_1.ElementFlags.CONSTANT)) {\r\n                                        assert(false); // there are no built-in fields currently\r\n                                    }\r\n                                    else if (fieldDeclaration && fieldDeclaration.initializer) {\r\n                                        initializers.push(this.module.createStore(field.type.byteSize, this.module.createGetLocal(tempLocal.index, this.options.nativeSizeType), this.compileExpression(fieldDeclaration.initializer, field.type), field.type.toNativeType(), field.memoryOffset));\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n                        finally {\r\n                            try {\r\n                                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\r\n                            }\r\n                            finally { if (e_3) throw e_3.error; }\r\n                        }\r\n                    }\r\n                    // apply constructor\r\n                    var constructorInstance = instance.constructorInstance;\r\n                    if (constructorInstance) {\r\n                        initializers.push(this.compileCall(constructorInstance, expression.arguments, expression, this.module.createGetLocal(tempLocal.index, this.options.nativeSizeType)));\r\n                    }\r\n                    // return 'this'\r\n                    initializers.push(this.module.createGetLocal(tempLocal.index, this.options.nativeSizeType));\r\n                    this.currentFunction.freeTempLocal(tempLocal);\r\n                    thisExpr = this.module.createBlock(null, initializers, this.options.nativeSizeType);\r\n                    this.currentType = instance.type;\r\n                    return thisExpr;\r\n                }\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode.Cannot_use_new_with_an_expression_whose_type_lacks_a_construct_signature, expression.expression.range);\r\n            }\r\n        }\r\n        return this.module.createUnreachable();\r\n        var e_3, _c;\r\n    };\r\n    Compiler.prototype.compileParenthesizedExpression = function (expression, contextualType) {\r\n        // does not change types, just order\r\n        return this.compileExpression(expression.expression, contextualType, 0 /* NONE */);\r\n    };\r\n    Compiler.prototype.compilePropertyAccessExpression = function (propertyAccess, contextualType) {\r\n        var resolved = this.program.resolvePropertyAccess(propertyAccess, this.currentFunction); // reports\r\n        if (!resolved)\r\n            return this.module.createUnreachable();\r\n        var element = resolved.element;\r\n        var targetExpr;\r\n        switch (element.kind) {\r\n            case program_1.ElementKind.GLOBAL:// static property\r\n                if (element.is(program_1.ElementFlags.BUILTIN)) {\r\n                    return builtins_1.compileGetConstant(this, element, propertyAccess);\r\n                }\r\n                if (!this.compileGlobal(element)) {\r\n                    return this.module.createUnreachable();\r\n                }\r\n                assert(element.type != types_1.Type.void);\r\n                if (element.is(program_1.ElementFlags.INLINED)) {\r\n                    return this.compileInlineConstant(element, contextualType);\r\n                }\r\n                this.currentType = element.type;\r\n                return this.module.createGetGlobal(element.internalName, this.currentType.toNativeType());\r\n            case program_1.ElementKind.ENUMVALUE:// enum value\r\n                if (!this.compileEnum(element.enum)) {\r\n                    return this.module.createUnreachable();\r\n                }\r\n                this.currentType = types_1.Type.i32;\r\n                if (element.is(program_1.ElementFlags.INLINED)) {\r\n                    return this.module.createI32(element.constantValue);\r\n                }\r\n                return this.module.createGetGlobal(element.internalName, module_1.NativeType.I32);\r\n            case program_1.ElementKind.FIELD:// instance field\r\n                assert(resolved.target != null);\r\n                assert(resolved.targetExpression != null);\r\n                assert(element.memoryOffset >= 0);\r\n                targetExpr = this.compileExpression(resolved.targetExpression, this.options.usizeType, 0 /* NONE */);\r\n                this.currentType = element.type;\r\n                return this.module.createLoad(element.type.size >> 3, element.type.is(1 /* SIGNED */ | 4 /* INTEGER */), targetExpr, element.type.toNativeType(), element.memoryOffset);\r\n            case program_1.ElementKind.PROPERTY:// instance property (here: getter)\r\n                var getter = element.getterPrototype;\r\n                assert(getter != null);\r\n                var getterInstance = getter.resolve(null); // reports\r\n                if (!getterInstance)\r\n                    return this.module.createUnreachable();\r\n                assert(!getterInstance.parameters || !getterInstance.parameters.length);\r\n                this.currentType = getterInstance.returnType;\r\n                if (getterInstance.is(program_1.ElementFlags.INSTANCE)) {\r\n                    targetExpr = this.compileExpression(resolved.targetExpression, this.options.usizeType, 0 /* NONE */);\r\n                    this.currentType = getterInstance.returnType;\r\n                    return this.makeCall(getterInstance, [targetExpr]);\r\n                }\r\n                else {\r\n                    return this.makeCall(getterInstance);\r\n                }\r\n        }\r\n        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, propertyAccess.range);\r\n        return this.module.createUnreachable();\r\n    };\r\n    Compiler.prototype.compileTernaryExpression = function (expression, contextualType) {\r\n        var condition = makeIsTrueish(this.compileExpression(expression.condition, types_1.Type.u32, 0 /* NONE */), this.currentType, this.module);\r\n        var ifThen = this.compileExpression(expression.ifThen, contextualType);\r\n        var ifElse = this.compileExpression(expression.ifElse, contextualType);\r\n        return this.module.createIf(condition, ifThen, ifElse);\r\n    };\r\n    Compiler.prototype.compileUnaryPostfixExpression = function (expression, contextualType) {\r\n        // make a getter for the expression (also obtains the type)\r\n        var getValue = this.compileExpression(expression.operand, contextualType == types_1.Type.void\r\n            ? types_1.Type.i32\r\n            : contextualType, 0 /* NONE */, false // wrapped below\r\n        );\r\n        var op;\r\n        var nativeType;\r\n        var nativeOne;\r\n        var possiblyOverflows = false;\r\n        switch (expression.operator) {\r\n            case tokenizer_1.Token.PLUS_PLUS:\r\n                if (this.currentType.isReference) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                    return this.module.createUnreachable();\r\n                }\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                        possiblyOverflows = true;\r\n                    default:\r\n                        op = module_1.BinaryOp.AddI32;\r\n                        nativeType = module_1.NativeType.I32;\r\n                        nativeOne = this.module.createI32(1);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                    // TODO: check operator overload\r\n                    case 4 /* ISIZE */:\r\n                        op = this.options.isWasm64\r\n                            ? module_1.BinaryOp.AddI64\r\n                            : module_1.BinaryOp.AddI32;\r\n                        nativeType = this.options.isWasm64\r\n                            ? module_1.NativeType.I64\r\n                            : module_1.NativeType.I32;\r\n                        nativeOne = this.currentType.toNativeOne(this.module);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        op = module_1.BinaryOp.AddI64;\r\n                        nativeType = module_1.NativeType.I64;\r\n                        nativeOne = this.module.createI64(1);\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        op = module_1.BinaryOp.AddF32;\r\n                        nativeType = module_1.NativeType.F32;\r\n                        nativeOne = this.module.createF32(1);\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        op = module_1.BinaryOp.AddF64;\r\n                        nativeType = module_1.NativeType.F64;\r\n                        nativeOne = this.module.createF64(1);\r\n                        break;\r\n                    case 13 /* VOID */:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.MINUS_MINUS:\r\n                if (this.currentType.isReference) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                    return this.module.createUnreachable();\r\n                }\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                        possiblyOverflows = true;\r\n                    default:\r\n                        op = module_1.BinaryOp.SubI32;\r\n                        nativeType = module_1.NativeType.I32;\r\n                        nativeOne = this.module.createI32(1);\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                    // TODO: check operator overload\r\n                    case 4 /* ISIZE */:\r\n                        op = this.options.isWasm64\r\n                            ? module_1.BinaryOp.SubI64\r\n                            : module_1.BinaryOp.SubI32;\r\n                        nativeType = this.options.isWasm64\r\n                            ? module_1.NativeType.I64\r\n                            : module_1.NativeType.I32;\r\n                        nativeOne = this.currentType.toNativeOne(this.module);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        op = module_1.BinaryOp.SubI64;\r\n                        nativeType = module_1.NativeType.I64;\r\n                        nativeOne = this.module.createI64(1);\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        op = module_1.BinaryOp.SubF32;\r\n                        nativeType = module_1.NativeType.F32;\r\n                        nativeOne = this.module.createF32(1);\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        op = module_1.BinaryOp.SubF64;\r\n                        nativeType = module_1.NativeType.F64;\r\n                        nativeOne = this.module.createF64(1);\r\n                        break;\r\n                    case 13 /* VOID */:\r\n                        this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                        throw new Error(\"concrete type expected\");\r\n                }\r\n                break;\r\n            default:\r\n                this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                throw new Error(\"unary postfix operator expected\");\r\n        }\r\n        var setValue;\r\n        var tempLocal = null;\r\n        // simplify if dropped anyway\r\n        if (contextualType == types_1.Type.void) {\r\n            setValue = this.module.createBinary(op, getValue, nativeOne);\r\n            // otherwise use a temp local for the intermediate value\r\n        }\r\n        else {\r\n            tempLocal = this.currentFunction.getTempLocal(this.currentType);\r\n            setValue = this.module.createBinary(op, this.module.createGetLocal(tempLocal.index, nativeType), nativeOne);\r\n        }\r\n        if (possiblyOverflows) {\r\n            assert(this.currentType.is(32 /* SMALL */ | 4 /* INTEGER */));\r\n            setValue = makeSmallIntegerWrap(setValue, this.currentType, this.module);\r\n        }\r\n        setValue = this.compileAssignmentWithValue(expression.operand, setValue, false);\r\n        // ^ sets currentType = void\r\n        if (contextualType == types_1.Type.void) {\r\n            assert(!tempLocal);\r\n            return setValue;\r\n        }\r\n        this.currentType = assert(tempLocal).type;\r\n        this.currentFunction.freeTempLocal(tempLocal);\r\n        return this.module.createBlock(null, [\r\n            this.module.createSetLocal(tempLocal.index, getValue),\r\n            setValue,\r\n            this.module.createGetLocal(tempLocal.index, nativeType)\r\n        ], nativeType);\r\n    };\r\n    Compiler.prototype.compileUnaryPrefixExpression = function (expression, contextualType, wrapSmallIntegers) {\r\n        if (wrapSmallIntegers === void 0) { wrapSmallIntegers = true; }\r\n        var possiblyOverflows = false;\r\n        var compound = false;\r\n        var expr;\r\n        switch (expression.operator) {\r\n            case tokenizer_1.Token.PLUS:\r\n                if (this.currentType.isReference) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                    return this.module.createUnreachable();\r\n                }\r\n                expr = this.compileExpression(expression.operand, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */, false // wrapped below\r\n                );\r\n                possiblyOverflows = this.currentType.is(32 /* SMALL */ | 4 /* INTEGER */); // if operand already did\r\n                break;\r\n            case tokenizer_1.Token.MINUS:\r\n                if (this.currentType.isReference) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                    return this.module.createUnreachable();\r\n                }\r\n                if (expression.operand.kind == ast_1.NodeKind.LITERAL && (expression.operand.literalKind == 1 /* INTEGER */ ||\r\n                    expression.operand.literalKind == 0 /* FLOAT */)) {\r\n                    // implicitly negate integer and float literals. also enables proper checking of literal ranges.\r\n                    expr = this.compileLiteralExpression(expression.operand, contextualType, true);\r\n                    this.addDebugLocation(expr, expression.range); // compileExpression normally does this\r\n                }\r\n                else {\r\n                    expr = this.compileExpression(expression.operand, contextualType == types_1.Type.void\r\n                        ? types_1.Type.i32\r\n                        : contextualType, 0 /* NONE */, false // wrapped below\r\n                    );\r\n                    switch (this.currentType.kind) {\r\n                        case 0 /* I8 */:\r\n                        case 1 /* I16 */:\r\n                        case 5 /* U8 */:\r\n                        case 6 /* U16 */:\r\n                        case 10 /* BOOL */:\r\n                            possiblyOverflows = true; // or if operand already did\r\n                        default:\r\n                            expr = this.module.createBinary(module_1.BinaryOp.SubI32, this.module.createI32(0), expr);\r\n                            break;\r\n                        case 9 /* USIZE */:\r\n                            if (this.currentType.isReference) {\r\n                                this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                                return this.module.createUnreachable();\r\n                            }\r\n                        case 4 /* ISIZE */:\r\n                            expr = this.module.createBinary(this.options.isWasm64\r\n                                ? module_1.BinaryOp.SubI64\r\n                                : module_1.BinaryOp.SubI32, this.currentType.toNativeZero(this.module), expr);\r\n                            break;\r\n                        case 3 /* I64 */:\r\n                        case 8 /* U64 */:\r\n                            expr = this.module.createBinary(module_1.BinaryOp.SubI64, this.module.createI64(0), expr);\r\n                            break;\r\n                        case 11 /* F32 */:\r\n                            expr = this.module.createUnary(module_1.UnaryOp.NegF32, expr);\r\n                            break;\r\n                        case 12 /* F64 */:\r\n                            expr = this.module.createUnary(module_1.UnaryOp.NegF64, expr);\r\n                            break;\r\n                    }\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.PLUS_PLUS:\r\n                if (this.currentType.isReference) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                    return this.module.createUnreachable();\r\n                }\r\n                compound = true;\r\n                expr = this.compileExpression(expression.operand, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */, false // wrapped below\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                        possiblyOverflows = true; // or if operand already did\r\n                    default:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.AddI32, expr, this.module.createI32(1));\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                        if (this.currentType.isReference) {\r\n                            this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                            return this.module.createUnreachable();\r\n                        }\r\n                    // fall-through\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.AddI64\r\n                            : module_1.BinaryOp.AddI32, expr, this.currentType.toNativeOne(this.module));\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.AddI64, expr, this.module.createI64(1));\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.AddF32, expr, this.module.createF32(1));\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.AddF64, expr, this.module.createF64(1));\r\n                        break;\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.MINUS_MINUS:\r\n                if (this.currentType.isReference) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                    return this.module.createUnreachable();\r\n                }\r\n                compound = true;\r\n                expr = this.compileExpression(expression.operand, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */, false // wrapped below\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                        possiblyOverflows = true; // or if operand already did\r\n                    // fall-through\r\n                    default:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.SubI32, expr, this.module.createI32(1));\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                        if (this.currentType.isReference) {\r\n                            this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                            return this.module.createUnreachable();\r\n                        }\r\n                    // fall-through\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.SubI64\r\n                            : module_1.BinaryOp.SubI32, expr, this.currentType.toNativeOne(this.module));\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.SubI64, expr, this.module.createI64(1));\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.SubF32, expr, this.module.createF32(1));\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.SubF64, expr, this.module.createF64(1));\r\n                        break;\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.EXCLAMATION:\r\n                expr = this.compileExpression(expression.operand, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType, 0 /* NONE */, true // must wrap small integers\r\n                );\r\n                expr = makeIsFalseish(expr, this.currentType, this.module);\r\n                this.currentType = types_1.Type.bool;\r\n                break;\r\n            case tokenizer_1.Token.TILDE:\r\n                if (this.currentType.isReference) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                    return this.module.createUnreachable();\r\n                }\r\n                expr = this.compileExpression(expression.operand, contextualType == types_1.Type.void\r\n                    ? types_1.Type.i32\r\n                    : contextualType.is(8 /* FLOAT */)\r\n                        ? types_1.Type.i64\r\n                        : contextualType, contextualType == types_1.Type.void\r\n                    ? 0 /* NONE */\r\n                    : 1 /* IMPLICIT */, false // retains low bits of small integers\r\n                );\r\n                switch (this.currentType.kind) {\r\n                    case 0 /* I8 */:\r\n                    case 1 /* I16 */:\r\n                    case 5 /* U8 */:\r\n                    case 6 /* U16 */:\r\n                    case 10 /* BOOL */:\r\n                        possiblyOverflows = true; // or if operand already did\r\n                    default:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.XorI32, expr, this.module.createI32(-1));\r\n                        break;\r\n                    case 9 /* USIZE */:\r\n                        if (this.currentType.isReference) {\r\n                            this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                            return this.module.createUnreachable();\r\n                        }\r\n                    // fall-through\r\n                    case 4 /* ISIZE */:\r\n                        expr = this.module.createBinary(this.options.isWasm64\r\n                            ? module_1.BinaryOp.XorI64\r\n                            : module_1.BinaryOp.XorI32, expr, this.currentType.toNativeNegOne(this.module));\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        expr = this.module.createBinary(module_1.BinaryOp.XorI64, expr, this.module.createI64(-1, -1));\r\n                        break;\r\n                }\r\n                break;\r\n            case tokenizer_1.Token.TYPEOF:\r\n                // it might make sense to implement typeof in a way that a generic function can detect\r\n                // whether its type argument is a class type or string. that could then be used, for\r\n                // example, to generate hash codes for sets and maps, depending on the kind of type\r\n                // parameter we have. ideally the comparison would not involve actual string comparison and\r\n                // limit available operations to hard-coded string literals.\r\n                this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                throw new Error(\"not implemented\");\r\n            default:\r\n                this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n                throw new Error(\"unary operator expected\");\r\n        }\r\n        if (possiblyOverflows && wrapSmallIntegers) {\r\n            assert(this.currentType.is(32 /* SMALL */ | 4 /* INTEGER */));\r\n            expr = makeSmallIntegerWrap(expr, this.currentType, this.module);\r\n        }\r\n        return compound\r\n            ? this.compileAssignmentWithValue(expression.operand, expr, contextualType != types_1.Type.void)\r\n            : expr;\r\n    };\r\n    Compiler.prototype.addDebugLocation = function (expr, range) {\r\n        if (this.options.sourceMap != null) {\r\n            var source = range.source;\r\n            if (source.debugInfoIndex < 0) {\r\n                source.debugInfoIndex = this.module.addDebugInfoFile(source.normalizedPath);\r\n            }\r\n            range.debugInfoRef = expr;\r\n            if (!this.currentFunction.debugLocations)\r\n                this.currentFunction.debugLocations = [];\r\n            this.currentFunction.debugLocations.push(range);\r\n        }\r\n    };\r\n    return Compiler;\r\n}(diagnostics_1.DiagnosticEmitter));\r\nexports.Compiler = Compiler;\r\n// helpers\r\n/** Wraps a 32-bit integer expression so it evaluates to a valid value of the specified type. */\r\nfunction makeSmallIntegerWrap(expr, type, module) {\r\n    switch (type.kind) {\r\n        case 0 /* I8 */:\r\n            expr = module.createBinary(module_1.BinaryOp.ShrI32, module.createBinary(module_1.BinaryOp.ShlI32, expr, module.createI32(24)), module.createI32(24));\r\n            break;\r\n        case 1 /* I16 */:\r\n            expr = module.createBinary(module_1.BinaryOp.ShrI32, module.createBinary(module_1.BinaryOp.ShlI32, expr, module.createI32(16)), module.createI32(16));\r\n            break;\r\n        case 5 /* U8 */:\r\n            expr = module.createBinary(module_1.BinaryOp.AndI32, expr, module.createI32(0xff));\r\n            break;\r\n        case 6 /* U16 */:\r\n            expr = module.createBinary(module_1.BinaryOp.AndI32, expr, module.createI32(0xffff));\r\n            break;\r\n        case 10 /* BOOL */:\r\n            expr = module.createBinary(module_1.BinaryOp.AndI32, expr, module.createI32(0x1));\r\n            break;\r\n        case 13 /* VOID */:\r\n            throw new Error(\"concrete type expected\");\r\n    }\r\n    return expr;\r\n}\r\nexports.makeSmallIntegerWrap = makeSmallIntegerWrap;\r\n/** Creates a comparison whether an expression is not 'true' in a broader sense. */\r\nfunction makeIsFalseish(expr, type, module) {\r\n    switch (type.kind) {\r\n        default:// any integer up to 32 bits\r\n            expr = module.createUnary(module_1.UnaryOp.EqzI32, expr);\r\n            break;\r\n        case 3 /* I64 */:\r\n        case 8 /* U64 */:\r\n            expr = module.createUnary(module_1.UnaryOp.EqzI64, expr);\r\n            break;\r\n        case 9 /* USIZE */:\r\n        // TODO: strings\r\n        case 4 /* ISIZE */:\r\n            expr = module.createUnary(type.size == 64 ? module_1.UnaryOp.EqzI64 : module_1.UnaryOp.EqzI32, expr);\r\n            break;\r\n        case 11 /* F32 */:\r\n            expr = module.createBinary(module_1.BinaryOp.EqF32, expr, module.createF32(0));\r\n            break;\r\n        case 12 /* F64 */:\r\n            expr = module.createBinary(module_1.BinaryOp.EqF64, expr, module.createF64(0));\r\n            break;\r\n        case 13 /* VOID */:\r\n            throw new Error(\"concrete type expected\");\r\n    }\r\n    return expr;\r\n}\r\nexports.makeIsFalseish = makeIsFalseish;\r\n/** Creates a comparison whether an expression is 'true' in a broader sense. */\r\nfunction makeIsTrueish(expr, type, module) {\r\n    switch (type.kind) {\r\n        case 3 /* I64 */:\r\n        case 8 /* U64 */:\r\n            expr = module.createBinary(module_1.BinaryOp.NeI64, expr, module.createI64(0));\r\n            break;\r\n        case 9 /* USIZE */:\r\n        // TODO: strings\r\n        case 4 /* ISIZE */:\r\n            if (type.size == 64) {\r\n                expr = module.createBinary(module_1.BinaryOp.NeI64, expr, module.createI64(0));\r\n            }\r\n            break;\r\n        case 11 /* F32 */:\r\n            expr = module.createBinary(module_1.BinaryOp.NeF32, expr, module.createF32(0));\r\n            break;\r\n        case 12 /* F64 */:\r\n            expr = module.createBinary(module_1.BinaryOp.NeF64, expr, module.createF64(0));\r\n            break;\r\n        case 13 /* VOID */:\r\n            throw new Error(\"concrete type expected\");\r\n    }\r\n    return expr;\r\n}\r\nexports.makeIsTrueish = makeIsTrueish;\r\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar module_1 = __webpack_require__(0);\r\n/** Indicates the kind of a type. */\r\nvar TypeKind;\r\n(function (TypeKind) {\r\n    // signed integers\r\n    TypeKind[TypeKind[\"I8\"] = 0] = \"I8\";\r\n    TypeKind[TypeKind[\"I16\"] = 1] = \"I16\";\r\n    TypeKind[TypeKind[\"I32\"] = 2] = \"I32\";\r\n    TypeKind[TypeKind[\"I64\"] = 3] = \"I64\";\r\n    TypeKind[TypeKind[\"ISIZE\"] = 4] = \"ISIZE\";\r\n    // unsigned integers\r\n    TypeKind[TypeKind[\"U8\"] = 5] = \"U8\";\r\n    TypeKind[TypeKind[\"U16\"] = 6] = \"U16\";\r\n    TypeKind[TypeKind[\"U32\"] = 7] = \"U32\";\r\n    TypeKind[TypeKind[\"U64\"] = 8] = \"U64\";\r\n    TypeKind[TypeKind[\"USIZE\"] = 9] = \"USIZE\";\r\n    TypeKind[TypeKind[\"BOOL\"] = 10] = \"BOOL\";\r\n    // floats\r\n    TypeKind[TypeKind[\"F32\"] = 11] = \"F32\";\r\n    TypeKind[TypeKind[\"F64\"] = 12] = \"F64\";\r\n    // other\r\n    TypeKind[TypeKind[\"VOID\"] = 13] = \"VOID\";\r\n})(TypeKind = exports.TypeKind || (exports.TypeKind = {}));\r\n/** Indicates capabilities of a type. */\r\nvar TypeFlags;\r\n(function (TypeFlags) {\r\n    TypeFlags[TypeFlags[\"NONE\"] = 0] = \"NONE\";\r\n    /** Is a signed type that can represent negative values. */\r\n    TypeFlags[TypeFlags[\"SIGNED\"] = 1] = \"SIGNED\";\r\n    /** Is an unsigned type that cannot represent negative values. */\r\n    TypeFlags[TypeFlags[\"UNSIGNED\"] = 2] = \"UNSIGNED\";\r\n    /** Is an integer type. */\r\n    TypeFlags[TypeFlags[\"INTEGER\"] = 4] = \"INTEGER\";\r\n    /** Is a floating point type. */\r\n    TypeFlags[TypeFlags[\"FLOAT\"] = 8] = \"FLOAT\";\r\n    /** Is a sized integer type with a target specific bit size. */\r\n    TypeFlags[TypeFlags[\"SIZE\"] = 16] = \"SIZE\";\r\n    /** Is a small type that is emulated in a larger type. */\r\n    TypeFlags[TypeFlags[\"SMALL\"] = 32] = \"SMALL\";\r\n    /** Is a long type larger than 32-bits. */\r\n    TypeFlags[TypeFlags[\"LONG\"] = 64] = \"LONG\";\r\n    /** Is a value type. */\r\n    TypeFlags[TypeFlags[\"VALUE\"] = 128] = \"VALUE\";\r\n    /** Is a reference type. */\r\n    TypeFlags[TypeFlags[\"REFERENCE\"] = 256] = \"REFERENCE\";\r\n    /** Is a nullable type. */\r\n    TypeFlags[TypeFlags[\"NULLABLE\"] = 512] = \"NULLABLE\";\r\n})(TypeFlags = exports.TypeFlags || (exports.TypeFlags = {}));\r\n/** Represents a resolved type. */\r\nvar Type = /** @class */ (function () {\r\n    /** Constructs a new resolved type. */\r\n    function Type(kind, flags, size) {\r\n        /** Respective nullable type, if non-nullable. */\r\n        this.nullableType = null;\r\n        this.kind = kind;\r\n        this.flags = flags;\r\n        this.size = size;\r\n        this.byteSize = ceil(size / 8);\r\n        this.classType = null;\r\n        this.nonNullableType = this;\r\n    }\r\n    /** Computes the sign-extending shift in the target type. */\r\n    Type.prototype.computeSmallIntegerShift = function (targetType) {\r\n        return targetType.size - this.size;\r\n    };\r\n    /** Computes the truncating mask in the target type. */\r\n    Type.prototype.computeSmallIntegerMask = function (targetType) {\r\n        return -1 >>> (targetType.size - this.size);\r\n    };\r\n    /** Tests if this type has the specified capabilities. */\r\n    Type.prototype.is = function (flags) {\r\n        return (this.flags & flags) == flags;\r\n    };\r\n    Object.defineProperty(Type.prototype, \"isClass\", {\r\n        /** Tests if this type is a class type. */\r\n        get: function () { return this.classType != null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Type.prototype, \"isFunction\", {\r\n        /** Tests if this type is a function type. */\r\n        get: function () { return this.functionType != null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Type.prototype, \"isReference\", {\r\n        /** Tests if this type is a reference type. */\r\n        get: function () { return this.classType != null || this.functionType != null; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Composes a class type from this type and a class. */\r\n    Type.prototype.asClass = function (classType) {\r\n        assert(this.kind == 9 /* USIZE */);\r\n        var ret = new Type(this.kind, this.flags & ~128 /* VALUE */ | 256 /* REFERENCE */, this.size);\r\n        ret.classType = classType;\r\n        return ret;\r\n    };\r\n    /** Composes a function type from this type and a function. */\r\n    Type.prototype.asFunction = function (functionType) {\r\n        assert(this.kind == 7 /* U32 */ && !this.isReference);\r\n        var ret = new Type(this.kind, this.flags & ~128 /* VALUE */ | 256 /* REFERENCE */, this.size);\r\n        ret.functionType = functionType;\r\n        return ret;\r\n    };\r\n    /** Composes the respective nullable type of this type. */\r\n    Type.prototype.asNullable = function () {\r\n        assert(this.kind == 9 /* USIZE */);\r\n        if (!this.nullableType) {\r\n            assert(!this.is(512 /* NULLABLE */) && this.isReference);\r\n            this.nullableType = new Type(this.kind, this.flags | 512 /* NULLABLE */, this.size);\r\n            this.nullableType.classType = this.classType;\r\n            this.nullableType.functionType = this.functionType;\r\n        }\r\n        return this.nullableType;\r\n    };\r\n    /** Tests if a value of this type is assignable to a target of the specified type. */\r\n    Type.prototype.isAssignableTo = function (target) {\r\n        var currentClass;\r\n        var targetClass;\r\n        var currentFunction;\r\n        var targetFunction;\r\n        if (this.isReference) {\r\n            if (target.isReference) {\r\n                if (currentClass = this.classType) {\r\n                    if (targetClass = target.classType) {\r\n                        return currentClass.isAssignableTo(targetClass);\r\n                    }\r\n                }\r\n                else if (currentFunction = this.functionType) {\r\n                    if (targetFunction = target.functionType) {\r\n                        return currentFunction.isAssignableTo(targetFunction);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (!target.isReference) {\r\n            switch (this.kind) {\r\n                case 0 /* I8 */:\r\n                    switch (target.kind) {\r\n                        case 0 /* I8 */: // same\r\n                        case 1 /* I16 */: // larger\r\n                        case 2 /* I32 */: // larger\r\n                        case 3 /* I64 */: // larger\r\n                        case 4 /* ISIZE */: // larger\r\n                        case 5 /* U8 */: // signed to unsigned\r\n                        case 6 /* U16 */: // larger\r\n                        case 7 /* U32 */: // larger\r\n                        case 8 /* U64 */: // larger\r\n                        case 9 /* USIZE */: // larger\r\n                        case 11 /* F32 */: // safe\r\n                        case 12 /* F64 */:// safe\r\n                            return true;\r\n                    }\r\n                    break;\r\n                case 1 /* I16 */:\r\n                    switch (target.kind) {\r\n                        case 1 /* I16 */: // same\r\n                        case 2 /* I32 */: // larger\r\n                        case 3 /* I64 */: // larger\r\n                        case 4 /* ISIZE */: // larger\r\n                        case 6 /* U16 */: // signed to unsigned\r\n                        case 7 /* U32 */: // larger\r\n                        case 8 /* U64 */: // larger\r\n                        case 9 /* USIZE */: // larger\r\n                        case 11 /* F32 */: // safe\r\n                        case 12 /* F64 */:// safe\r\n                            return true;\r\n                    }\r\n                    break;\r\n                case 2 /* I32 */:\r\n                    switch (target.kind) {\r\n                        case 2 /* I32 */: // same\r\n                        case 3 /* I64 */: // larger\r\n                        case 4 /* ISIZE */: // same or larger\r\n                        case 7 /* U32 */: // signed to unsigned\r\n                        case 8 /* U64 */: // larger\r\n                        case 9 /* USIZE */: // signed to unsigned or larger\r\n                        case 12 /* F64 */:// safe\r\n                            return true;\r\n                    }\r\n                    break;\r\n                case 3 /* I64 */:\r\n                    switch (target.kind) {\r\n                        case 3 /* I64 */: // same\r\n                        case 8 /* U64 */:// signed to unsigned\r\n                            return true;\r\n                        case 4 /* ISIZE */: // possibly same\r\n                        case 9 /* USIZE */:// possibly signed to unsigned\r\n                            return target.size == 64;\r\n                    }\r\n                    break;\r\n                case 4 /* ISIZE */:\r\n                    switch (target.kind) {\r\n                        case 2 /* I32 */: // possibly same\r\n                        case 7 /* U32 */:// possibly signed to unsigned\r\n                            return this.size == 32;\r\n                        case 3 /* I64 */: // same or larger\r\n                        case 4 /* ISIZE */: // same\r\n                        case 8 /* U64 */: // signed to unsigned or larger\r\n                        case 9 /* USIZE */:// signed to unsigned\r\n                            return true;\r\n                        case 12 /* F64 */:// possibly safe\r\n                            return target.size == 32;\r\n                    }\r\n                    break;\r\n                case 5 /* U8 */:\r\n                    switch (target.kind) {\r\n                        case 1 /* I16 */: // larger\r\n                        case 2 /* I32 */: // larger\r\n                        case 3 /* I64 */: // larger\r\n                        case 4 /* ISIZE */: // larger\r\n                        case 5 /* U8 */: // same\r\n                        case 6 /* U16 */: // larger\r\n                        case 7 /* U32 */: // larger\r\n                        case 8 /* U64 */: // larger\r\n                        case 9 /* USIZE */: // larger\r\n                        case 11 /* F32 */: // safe\r\n                        case 12 /* F64 */:// safe\r\n                            return true;\r\n                    }\r\n                    break;\r\n                case 6 /* U16 */:\r\n                    switch (target.kind) {\r\n                        case 2 /* I32 */: // larger\r\n                        case 3 /* I64 */: // larger\r\n                        case 4 /* ISIZE */: // larger\r\n                        case 6 /* U16 */: // same\r\n                        case 7 /* U32 */: // larger\r\n                        case 8 /* U64 */: // larger\r\n                        case 9 /* USIZE */: // larger\r\n                        case 11 /* F32 */: // safe\r\n                        case 12 /* F64 */:// safe\r\n                            return true;\r\n                    }\r\n                    break;\r\n                case 7 /* U32 */:\r\n                    switch (target.kind) {\r\n                        case 3 /* I64 */: // larger\r\n                        case 7 /* U32 */: // same\r\n                        case 8 /* U64 */: // larger\r\n                        case 9 /* USIZE */: // same or larger\r\n                        case 12 /* F64 */:// safe\r\n                            return true;\r\n                    }\r\n                    break;\r\n                case 8 /* U64 */:\r\n                    switch (target.kind) {\r\n                        case 8 /* U64 */:// same\r\n                            return true;\r\n                        case 9 /* USIZE */:// possibly same\r\n                            return target.size == 64;\r\n                    }\r\n                    break;\r\n                case 9 /* USIZE */:\r\n                    switch (target.kind) {\r\n                        case 7 /* U32 */:// possibly same\r\n                            return this.size == 32;\r\n                        case 8 /* U64 */: // same or larger\r\n                        case 9 /* USIZE */:// same\r\n                            return true;\r\n                        case 12 /* F64 */:// possibly safe\r\n                            return target.size == 32;\r\n                    }\r\n                    break;\r\n                case 10 /* BOOL */:\r\n                    switch (target.kind) {\r\n                        case 0 /* I8 */: // larger\r\n                        case 1 /* I16 */: // larger\r\n                        case 2 /* I32 */: // larger\r\n                        case 3 /* I64 */: // larger\r\n                        case 4 /* ISIZE */: // larger\r\n                        case 5 /* U8 */: // larger\r\n                        case 6 /* U16 */: // larger\r\n                        case 7 /* U32 */: // larger\r\n                        case 8 /* U64 */: // larger\r\n                        case 9 /* USIZE */: // larger\r\n                        case 10 /* BOOL */:// same\r\n                            return true;\r\n                    }\r\n                    break;\r\n                case 11 /* F32 */:\r\n                    switch (target.kind) {\r\n                        case 11 /* F32 */: // same\r\n                        case 12 /* F64 */:// larger\r\n                            return true;\r\n                    }\r\n                    break;\r\n                case 12 /* F64 */:\r\n                    return target.kind == 12 /* F64 */;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /** Converts this type to its TypeScript representation. */\r\n    Type.prototype.toString = function (kindOnly) {\r\n        if (kindOnly === void 0) { kindOnly = false; }\r\n        switch (this.kind) {\r\n            case 0 /* I8 */: return \"i8\";\r\n            case 1 /* I16 */: return \"i16\";\r\n            case 2 /* I32 */: return \"i32\";\r\n            case 3 /* I64 */: return \"i64\";\r\n            case 4 /* ISIZE */: return \"isize\";\r\n            case 5 /* U8 */: return \"u8\";\r\n            case 6 /* U16 */: return \"u16\";\r\n            case 7 /* U32 */: return \"u32\";\r\n            case 8 /* U64 */: return \"u64\";\r\n            case 9 /* USIZE */:\r\n                if (kindOnly)\r\n                    return \"usize\";\r\n                return this.classType\r\n                    ? this.classType.toString()\r\n                    : this.functionType\r\n                        ? this.functionType.toTypeString()\r\n                        : \"usize\";\r\n            case 10 /* BOOL */: return \"bool\";\r\n            case 11 /* F32 */: return \"f32\";\r\n            case 12 /* F64 */: return \"f64\";\r\n            case 13 /* VOID */: return \"void\";\r\n            default:\r\n                assert(false);\r\n                return \"\";\r\n        }\r\n    };\r\n    // Binaryen specific\r\n    /** Converts this type to its respective native type. */\r\n    Type.prototype.toNativeType = function () {\r\n        switch (this.kind) {\r\n            default:\r\n                return module_1.NativeType.I32;\r\n            case 3 /* I64 */:\r\n            case 8 /* U64 */:\r\n                return module_1.NativeType.I64;\r\n            case 4 /* ISIZE */:\r\n            case 9 /* USIZE */:\r\n                return this.size == 64 ? module_1.NativeType.I64 : module_1.NativeType.I32;\r\n            case 11 /* F32 */:\r\n                return module_1.NativeType.F32;\r\n            case 12 /* F64 */:\r\n                return module_1.NativeType.F64;\r\n            case 13 /* VOID */:\r\n                return module_1.NativeType.None;\r\n        }\r\n    };\r\n    /** Converts this type to its native `0` value. */\r\n    Type.prototype.toNativeZero = function (module) {\r\n        switch (this.kind) {\r\n            case 13 /* VOID */:\r\n                assert(false);\r\n            default:\r\n                return module.createI32(0);\r\n            case 4 /* ISIZE */:\r\n            case 9 /* USIZE */:\r\n                if (this.size != 64)\r\n                    return module.createI32(0);\r\n            // fall-through\r\n            case 3 /* I64 */:\r\n            case 8 /* U64 */:\r\n                return module.createI64(0);\r\n            case 11 /* F32 */:\r\n                return module.createF32(0);\r\n            case 12 /* F64 */:\r\n                return module.createF64(0);\r\n        }\r\n    };\r\n    /** Converts this type to its native `1` value. */\r\n    Type.prototype.toNativeOne = function (module) {\r\n        switch (this.kind) {\r\n            case 13 /* VOID */:\r\n                assert(false);\r\n            default:\r\n                return module.createI32(1);\r\n            case 4 /* ISIZE */:\r\n            case 9 /* USIZE */:\r\n                if (this.size != 64)\r\n                    return module.createI32(1);\r\n            // fall-through\r\n            case 3 /* I64 */:\r\n            case 8 /* U64 */:\r\n                return module.createI64(1);\r\n            case 11 /* F32 */:\r\n                return module.createF32(1);\r\n            case 12 /* F64 */:\r\n                return module.createF64(1);\r\n        }\r\n    };\r\n    /** Converts this type to its native `-1` value. */\r\n    Type.prototype.toNativeNegOne = function (module) {\r\n        switch (this.kind) {\r\n            case 13 /* VOID */:\r\n                assert(false);\r\n            default:\r\n                return module.createI32(-1);\r\n            case 4 /* ISIZE */:\r\n            case 9 /* USIZE */:\r\n                if (this.size != 64)\r\n                    return module.createI32(-1);\r\n            // fall-through\r\n            case 3 /* I64 */:\r\n            case 8 /* U64 */:\r\n                return module.createI64(-1, -1);\r\n            case 11 /* F32 */:\r\n                return module.createF32(-1);\r\n            case 12 /* F64 */:\r\n                return module.createF64(-1);\r\n        }\r\n    };\r\n    /** Converts this type to its signature string. */\r\n    Type.prototype.toSignatureString = function () {\r\n        switch (this.kind) {\r\n            default:\r\n                return \"i\";\r\n            case 3 /* I64 */:\r\n            case 8 /* U64 */:\r\n                return \"I\";\r\n            case 4 /* ISIZE */:\r\n            case 9 /* USIZE */:\r\n                return this.size == 64 ? \"I\" : \"i\";\r\n            case 11 /* F32 */:\r\n                return \"f\";\r\n            case 12 /* F64 */:\r\n                return \"F\";\r\n            case 13 /* VOID */:\r\n                return \"v\";\r\n        }\r\n    };\r\n    // Types\r\n    /** An 8-bit signed integer. */\r\n    Type.i8 = new Type(0 /* I8 */, 1 /* SIGNED */ |\r\n        32 /* SMALL */ |\r\n        4 /* INTEGER */ |\r\n        128 /* VALUE */, 8);\r\n    /** A 16-bit signed integer. */\r\n    Type.i16 = new Type(1 /* I16 */, 1 /* SIGNED */ |\r\n        32 /* SMALL */ |\r\n        4 /* INTEGER */ |\r\n        128 /* VALUE */, 16);\r\n    /** A 32-bit signed integer. */\r\n    Type.i32 = new Type(2 /* I32 */, 1 /* SIGNED */ |\r\n        4 /* INTEGER */ |\r\n        128 /* VALUE */, 32);\r\n    /** A 64-bit signed integer. */\r\n    Type.i64 = new Type(3 /* I64 */, 1 /* SIGNED */ |\r\n        64 /* LONG */ |\r\n        4 /* INTEGER */ |\r\n        128 /* VALUE */, 64);\r\n    /** A 32-bit signed size. WASM32 only. */\r\n    Type.isize32 = new Type(4 /* ISIZE */, 1 /* SIGNED */ |\r\n        16 /* SIZE */ |\r\n        4 /* INTEGER */ |\r\n        128 /* VALUE */, 32);\r\n    /** A 64-bit signed size. WASM64 only. */\r\n    Type.isize64 = new Type(4 /* ISIZE */, 1 /* SIGNED */ |\r\n        64 /* LONG */ |\r\n        16 /* SIZE */ |\r\n        4 /* INTEGER */ |\r\n        128 /* VALUE */, 64);\r\n    /** An 8-bit unsigned integer. */\r\n    Type.u8 = new Type(5 /* U8 */, 2 /* UNSIGNED */ |\r\n        32 /* SMALL */ |\r\n        4 /* INTEGER */ |\r\n        128 /* VALUE */, 8);\r\n    /** A 16-bit unsigned integer. */\r\n    Type.u16 = new Type(6 /* U16 */, 2 /* UNSIGNED */ |\r\n        32 /* SMALL */ |\r\n        4 /* INTEGER */ |\r\n        128 /* VALUE */, 16);\r\n    /** A 32-bit unsigned integer. */\r\n    Type.u32 = new Type(7 /* U32 */, 2 /* UNSIGNED */ |\r\n        4 /* INTEGER */ |\r\n        128 /* VALUE */, 32);\r\n    /** A 64-bit unsigned integer. */\r\n    Type.u64 = new Type(8 /* U64 */, 2 /* UNSIGNED */ |\r\n        64 /* LONG */ |\r\n        4 /* INTEGER */ |\r\n        128 /* VALUE */, 64);\r\n    /** A 32-bit unsigned size. WASM32 only. */\r\n    Type.usize32 = new Type(9 /* USIZE */, 2 /* UNSIGNED */ |\r\n        16 /* SIZE */ |\r\n        4 /* INTEGER */ |\r\n        128 /* VALUE */, 32);\r\n    /** A 64-bit unsigned size. WASM64 only. */\r\n    Type.usize64 = new Type(9 /* USIZE */, 2 /* UNSIGNED */ |\r\n        64 /* LONG */ |\r\n        16 /* SIZE */ |\r\n        4 /* INTEGER */ |\r\n        128 /* VALUE */, 64);\r\n    /** A 1-bit unsigned integer. */\r\n    Type.bool = new Type(10 /* BOOL */, 2 /* UNSIGNED */ |\r\n        32 /* SMALL */ |\r\n        4 /* INTEGER */ |\r\n        128 /* VALUE */, 1);\r\n    /** A 32-bit float. */\r\n    Type.f32 = new Type(11 /* F32 */, 1 /* SIGNED */ |\r\n        8 /* FLOAT */ |\r\n        128 /* VALUE */, 32);\r\n    /** A 64-bit float. */\r\n    Type.f64 = new Type(12 /* F64 */, 1 /* SIGNED */ |\r\n        64 /* LONG */ |\r\n        8 /* FLOAT */ |\r\n        128 /* VALUE */, 64);\r\n    /** No return type. */\r\n    Type.void = new Type(13 /* VOID */, 0 /* NONE */, 0);\r\n    return Type;\r\n}());\r\nexports.Type = Type;\r\n/** Converts an array of types to an array of native types. */\r\nfunction typesToNativeTypes(types) {\r\n    var k = types.length;\r\n    var ret = new Array(k);\r\n    for (var i = 0; i < k; ++i) {\r\n        ret[i] = types[i].toNativeType();\r\n    }\r\n    return ret;\r\n}\r\nexports.typesToNativeTypes = typesToNativeTypes;\r\n/** Converts an array of types to its combined string representation. */\r\nfunction typesToString(types) {\r\n    var k = types.length;\r\n    if (!k)\r\n        return \"\";\r\n    var sb = new Array(k);\r\n    for (var i = 0; i < k; ++i) {\r\n        sb[i] = types[i].toString();\r\n    }\r\n    return sb.join(\", \");\r\n}\r\nexports.typesToString = typesToString;\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar program_1 = __webpack_require__(2);\r\nvar tokenizer_1 = __webpack_require__(7);\r\nexports.Token = tokenizer_1.Token;\r\nexports.Range = tokenizer_1.Range;\r\nvar path_1 = __webpack_require__(10);\r\n/** Indicates the kind of a node. */\r\nvar NodeKind;\r\n(function (NodeKind) {\r\n    NodeKind[NodeKind[\"SOURCE\"] = 0] = \"SOURCE\";\r\n    // types\r\n    NodeKind[NodeKind[\"TYPE\"] = 1] = \"TYPE\";\r\n    NodeKind[NodeKind[\"TYPEPARAMETER\"] = 2] = \"TYPEPARAMETER\";\r\n    // expressions\r\n    NodeKind[NodeKind[\"IDENTIFIER\"] = 3] = \"IDENTIFIER\";\r\n    NodeKind[NodeKind[\"ASSERTION\"] = 4] = \"ASSERTION\";\r\n    NodeKind[NodeKind[\"BINARY\"] = 5] = \"BINARY\";\r\n    NodeKind[NodeKind[\"CALL\"] = 6] = \"CALL\";\r\n    NodeKind[NodeKind[\"COMMA\"] = 7] = \"COMMA\";\r\n    NodeKind[NodeKind[\"ELEMENTACCESS\"] = 8] = \"ELEMENTACCESS\";\r\n    NodeKind[NodeKind[\"FALSE\"] = 9] = \"FALSE\";\r\n    NodeKind[NodeKind[\"FUNCTION\"] = 10] = \"FUNCTION\";\r\n    NodeKind[NodeKind[\"FUNCTIONARROW\"] = 11] = \"FUNCTIONARROW\";\r\n    NodeKind[NodeKind[\"LITERAL\"] = 12] = \"LITERAL\";\r\n    NodeKind[NodeKind[\"NEW\"] = 13] = \"NEW\";\r\n    NodeKind[NodeKind[\"NULL\"] = 14] = \"NULL\";\r\n    NodeKind[NodeKind[\"PARENTHESIZED\"] = 15] = \"PARENTHESIZED\";\r\n    NodeKind[NodeKind[\"PROPERTYACCESS\"] = 16] = \"PROPERTYACCESS\";\r\n    NodeKind[NodeKind[\"TERNARY\"] = 17] = \"TERNARY\";\r\n    NodeKind[NodeKind[\"SUPER\"] = 18] = \"SUPER\";\r\n    NodeKind[NodeKind[\"THIS\"] = 19] = \"THIS\";\r\n    NodeKind[NodeKind[\"TRUE\"] = 20] = \"TRUE\";\r\n    NodeKind[NodeKind[\"CONSTRUCTOR\"] = 21] = \"CONSTRUCTOR\";\r\n    NodeKind[NodeKind[\"UNARYPOSTFIX\"] = 22] = \"UNARYPOSTFIX\";\r\n    NodeKind[NodeKind[\"UNARYPREFIX\"] = 23] = \"UNARYPREFIX\";\r\n    // statements\r\n    NodeKind[NodeKind[\"BLOCK\"] = 24] = \"BLOCK\";\r\n    NodeKind[NodeKind[\"BREAK\"] = 25] = \"BREAK\";\r\n    NodeKind[NodeKind[\"CONTINUE\"] = 26] = \"CONTINUE\";\r\n    NodeKind[NodeKind[\"DO\"] = 27] = \"DO\";\r\n    NodeKind[NodeKind[\"EMPTY\"] = 28] = \"EMPTY\";\r\n    NodeKind[NodeKind[\"EXPORT\"] = 29] = \"EXPORT\";\r\n    NodeKind[NodeKind[\"EXPORTIMPORT\"] = 30] = \"EXPORTIMPORT\";\r\n    NodeKind[NodeKind[\"EXPRESSION\"] = 31] = \"EXPRESSION\";\r\n    NodeKind[NodeKind[\"FOR\"] = 32] = \"FOR\";\r\n    NodeKind[NodeKind[\"IF\"] = 33] = \"IF\";\r\n    NodeKind[NodeKind[\"IMPORT\"] = 34] = \"IMPORT\";\r\n    NodeKind[NodeKind[\"RETURN\"] = 35] = \"RETURN\";\r\n    NodeKind[NodeKind[\"SWITCH\"] = 36] = \"SWITCH\";\r\n    NodeKind[NodeKind[\"THROW\"] = 37] = \"THROW\";\r\n    NodeKind[NodeKind[\"TRY\"] = 38] = \"TRY\";\r\n    NodeKind[NodeKind[\"VARIABLE\"] = 39] = \"VARIABLE\";\r\n    NodeKind[NodeKind[\"WHILE\"] = 40] = \"WHILE\";\r\n    // declaration statements\r\n    NodeKind[NodeKind[\"CLASSDECLARATION\"] = 41] = \"CLASSDECLARATION\";\r\n    NodeKind[NodeKind[\"ENUMDECLARATION\"] = 42] = \"ENUMDECLARATION\";\r\n    NodeKind[NodeKind[\"ENUMVALUEDECLARATION\"] = 43] = \"ENUMVALUEDECLARATION\";\r\n    NodeKind[NodeKind[\"FIELDDECLARATION\"] = 44] = \"FIELDDECLARATION\";\r\n    NodeKind[NodeKind[\"FUNCTIONDECLARATION\"] = 45] = \"FUNCTIONDECLARATION\";\r\n    NodeKind[NodeKind[\"IMPORTDECLARATION\"] = 46] = \"IMPORTDECLARATION\";\r\n    NodeKind[NodeKind[\"INTERFACEDECLARATION\"] = 47] = \"INTERFACEDECLARATION\";\r\n    NodeKind[NodeKind[\"METHODDECLARATION\"] = 48] = \"METHODDECLARATION\";\r\n    NodeKind[NodeKind[\"NAMESPACEDECLARATION\"] = 49] = \"NAMESPACEDECLARATION\";\r\n    NodeKind[NodeKind[\"TYPEDECLARATION\"] = 50] = \"TYPEDECLARATION\";\r\n    NodeKind[NodeKind[\"VARIABLEDECLARATION\"] = 51] = \"VARIABLEDECLARATION\";\r\n    // other\r\n    NodeKind[NodeKind[\"DECORATOR\"] = 52] = \"DECORATOR\";\r\n    NodeKind[NodeKind[\"EXPORTMEMBER\"] = 53] = \"EXPORTMEMBER\";\r\n    NodeKind[NodeKind[\"MODIFIER\"] = 54] = \"MODIFIER\";\r\n    NodeKind[NodeKind[\"PARAMETER\"] = 55] = \"PARAMETER\";\r\n    NodeKind[NodeKind[\"SWITCHCASE\"] = 56] = \"SWITCHCASE\";\r\n})(NodeKind = exports.NodeKind || (exports.NodeKind = {}));\r\n/** Base class of all nodes. */\r\nvar Node = /** @class */ (function () {\r\n    function Node() {\r\n        /** Parent node. */\r\n        this.parent = null;\r\n    }\r\n    // types\r\n    Node.createType = function (identifier, typeArguments, isNullable, range) {\r\n        var type = new TypeNode();\r\n        type.range = range;\r\n        type.name = identifier;\r\n        type.typeArguments = typeArguments;\r\n        type.isNullable = isNullable;\r\n        return type;\r\n    };\r\n    // expressions\r\n    Node.createIdentifierExpression = function (name, range) {\r\n        var expr = new IdentifierExpression();\r\n        expr.range = range;\r\n        expr.text = name;\r\n        return expr;\r\n    };\r\n    Node.createArrayLiteralExpression = function (elements, range) {\r\n        var expr = new ArrayLiteralExpression();\r\n        expr.range = range;\r\n        expr.elementExpressions = elements;\r\n        setParentOpt(elements, expr);\r\n        return expr;\r\n    };\r\n    Node.createAssertionExpression = function (assertionKind, expression, toType, range) {\r\n        var expr = new AssertionExpression();\r\n        expr.range = range;\r\n        expr.assertionKind = assertionKind;\r\n        expr.expression = expression;\r\n        expression.parent = expr;\r\n        expr.toType = toType;\r\n        toType.parent = expr;\r\n        return expr;\r\n    };\r\n    Node.createBinaryExpression = function (operator, left, right, range) {\r\n        var expr = new BinaryExpression();\r\n        expr.range = range;\r\n        expr.operator = operator;\r\n        expr.left = left;\r\n        left.parent = expr;\r\n        expr.right = right;\r\n        right.parent = expr;\r\n        return expr;\r\n    };\r\n    Node.createCallExpression = function (expression, typeArgs, args, range) {\r\n        var expr = new CallExpression();\r\n        expr.range = range;\r\n        expr.expression = expression;\r\n        expression.parent = expr;\r\n        expr.typeArguments = typeArgs;\r\n        if (typeArgs)\r\n            setParent(typeArgs, expr);\r\n        expr.arguments = args;\r\n        setParent(args, expr);\r\n        return expr;\r\n    };\r\n    Node.createCommaExpression = function (expressions, range) {\r\n        var expr = new CommaExpression();\r\n        expr.range = range;\r\n        expr.expressions = expressions;\r\n        setParent(expressions, expr);\r\n        return expr;\r\n    };\r\n    Node.createConstructorExpression = function (range) {\r\n        var expr = new ConstructorExpression();\r\n        expr.range = range;\r\n        return expr;\r\n    };\r\n    Node.createElementAccessExpression = function (expression, element, range) {\r\n        var expr = new ElementAccessExpression();\r\n        expr.range = range;\r\n        expr.expression = expression;\r\n        expression.parent = expr;\r\n        expr.elementExpression = element;\r\n        element.parent = expr;\r\n        return expr;\r\n    };\r\n    Node.createFalseExpression = function (range) {\r\n        var expr = new FalseExpression();\r\n        expr.range = range;\r\n        return expr;\r\n    };\r\n    Node.createFloatLiteralExpression = function (value, range) {\r\n        var expr = new FloatLiteralExpression();\r\n        expr.range = range;\r\n        expr.value = value;\r\n        return expr;\r\n    };\r\n    Node.createFunctionExpression = function (declaration, isArrow) {\r\n        if (isArrow === void 0) { isArrow = false; }\r\n        var expr = isArrow\r\n            ? new FunctionArrowExpression()\r\n            : new FunctionExpression();\r\n        expr.range = declaration.range;\r\n        expr.declaration = declaration;\r\n        return expr;\r\n    };\r\n    Node.createIntegerLiteralExpression = function (value, range) {\r\n        var expr = new IntegerLiteralExpression();\r\n        expr.range = range;\r\n        expr.value = value;\r\n        return expr;\r\n    };\r\n    Node.createNewExpression = function (expression, typeArgs, args, range) {\r\n        var expr = new NewExpression();\r\n        expr.range = range;\r\n        expr.expression = expression;\r\n        expression.parent = expr;\r\n        expr.typeArguments = typeArgs;\r\n        if (typeArgs)\r\n            setParent(typeArgs, expr);\r\n        expr.arguments = args;\r\n        setParent(args, expr);\r\n        return expr;\r\n    };\r\n    Node.createNullExpression = function (range) {\r\n        var expr = new NullExpression();\r\n        expr.range = range;\r\n        return expr;\r\n    };\r\n    Node.createParenthesizedExpression = function (expression, range) {\r\n        var expr = new ParenthesizedExpression();\r\n        expr.range = range;\r\n        expr.expression = expression;\r\n        expression.parent = expr;\r\n        return expr;\r\n    };\r\n    Node.createPropertyAccessExpression = function (expression, property, range) {\r\n        var expr = new PropertyAccessExpression();\r\n        expr.range = range;\r\n        expr.expression = expression;\r\n        expression.parent = expr;\r\n        expr.property = property;\r\n        property.parent = expr;\r\n        return expr;\r\n    };\r\n    Node.createRegexpLiteralExpression = function (pattern, flags, range) {\r\n        var expr = new RegexpLiteralExpression();\r\n        expr.range = range;\r\n        expr.pattern = pattern;\r\n        expr.patternFlags = flags;\r\n        return expr;\r\n    };\r\n    Node.createTernaryExpression = function (condition, ifThen, ifElse, range) {\r\n        var expr = new TernaryExpression();\r\n        expr.range = range;\r\n        expr.condition = condition;\r\n        condition.parent = expr;\r\n        expr.ifThen = ifThen;\r\n        ifThen.parent = expr;\r\n        expr.ifElse = ifElse;\r\n        ifElse.parent = expr;\r\n        return expr;\r\n    };\r\n    Node.createStringLiteralExpression = function (value, range) {\r\n        var expr = new StringLiteralExpression();\r\n        expr.range = range;\r\n        expr.value = value;\r\n        return expr;\r\n    };\r\n    Node.createSuperExpression = function (range) {\r\n        var expr = new SuperExpression();\r\n        expr.range = range;\r\n        return expr;\r\n    };\r\n    Node.createThisExpression = function (range) {\r\n        var expr = new ThisExpression();\r\n        expr.range = range;\r\n        return expr;\r\n    };\r\n    Node.createTrueExpression = function (range) {\r\n        var expr = new TrueExpression();\r\n        expr.range = range;\r\n        return expr;\r\n    };\r\n    Node.createUnaryPostfixExpression = function (operator, operand, range) {\r\n        var expr = new UnaryPostfixExpression();\r\n        expr.range = range;\r\n        expr.operator = operator;\r\n        expr.operand = operand;\r\n        operand.parent = expr;\r\n        return expr;\r\n    };\r\n    Node.createUnaryPrefixExpression = function (operator, operand, range) {\r\n        var expr = new UnaryPrefixExpression();\r\n        expr.range = range;\r\n        expr.operator = operator;\r\n        expr.operand = operand;\r\n        operand.parent = expr;\r\n        return expr;\r\n    };\r\n    // statements\r\n    Node.createBlockStatement = function (statements, range) {\r\n        var stmt = new BlockStatement();\r\n        stmt.range = range;\r\n        stmt.statements = statements;\r\n        setParent(statements, stmt);\r\n        return stmt;\r\n    };\r\n    Node.createBreakStatement = function (label, range) {\r\n        var stmt = new BreakStatement();\r\n        stmt.range = range;\r\n        stmt.label = label;\r\n        if (label)\r\n            label.parent = stmt;\r\n        return stmt;\r\n    };\r\n    Node.createClassDeclaration = function (identifier, typeParameters, extendsType, implementsTypes, members, modifiers, decorators, range) {\r\n        var stmt = new ClassDeclaration();\r\n        stmt.range = range;\r\n        stmt.name = identifier;\r\n        identifier.parent = stmt;\r\n        stmt.typeParameters = typeParameters;\r\n        setParent(typeParameters, stmt);\r\n        stmt.extendsType = extendsType;\r\n        if (extendsType)\r\n            extendsType.parent = stmt;\r\n        stmt.implementsTypes = implementsTypes;\r\n        setParent(implementsTypes, stmt);\r\n        stmt.members = members;\r\n        setParent(members, stmt);\r\n        stmt.modifiers = modifiers;\r\n        if (modifiers)\r\n            setParent(modifiers, stmt);\r\n        stmt.decorators = decorators;\r\n        if (decorators)\r\n            setParent(decorators, stmt);\r\n        return stmt;\r\n    };\r\n    Node.createContinueStatement = function (label, range) {\r\n        var stmt = new ContinueStatement();\r\n        stmt.range = range;\r\n        stmt.label = label;\r\n        if (label)\r\n            label.parent = stmt;\r\n        return stmt;\r\n    };\r\n    Node.createDecorator = function (expression, args, range) {\r\n        var stmt = new Decorator();\r\n        stmt.range = range;\r\n        stmt.name = expression;\r\n        expression.parent = stmt;\r\n        stmt.arguments = args;\r\n        if (args)\r\n            setParent(args, stmt);\r\n        if (expression.kind == NodeKind.IDENTIFIER) {\r\n            switch (expression.text) {\r\n                case \"global\":\r\n                    stmt.decoratorKind = 1 /* GLOBAL */;\r\n                    break;\r\n                case \"operator\":\r\n                    stmt.decoratorKind = 2 /* OPERATOR */;\r\n                    break;\r\n                case \"unmanaged\":\r\n                    stmt.decoratorKind = 3 /* UNMANAGED */;\r\n                    break;\r\n                case \"offset\":\r\n                    stmt.decoratorKind = 4 /* OFFSET */;\r\n                    break;\r\n                default:\r\n                    stmt.decoratorKind = 0 /* CUSTOM */;\r\n                    break;\r\n            }\r\n        }\r\n        else {\r\n            stmt.decoratorKind = 0 /* CUSTOM */;\r\n        }\r\n        return stmt;\r\n    };\r\n    Node.createDoStatement = function (statement, condition, range) {\r\n        var stmt = new DoStatement();\r\n        stmt.range = range;\r\n        stmt.statement = statement;\r\n        statement.parent = stmt;\r\n        stmt.condition = condition;\r\n        condition.parent = stmt;\r\n        return stmt;\r\n    };\r\n    Node.createEmptyStatement = function (range) {\r\n        var stmt = new EmptyStatement();\r\n        stmt.range = range;\r\n        return stmt;\r\n    };\r\n    Node.createEnumDeclaration = function (name, members, modifiers, decorators, range) {\r\n        var stmt = new EnumDeclaration();\r\n        stmt.range = range;\r\n        stmt.name = name;\r\n        name.parent = stmt;\r\n        stmt.values = members;\r\n        setParent(members, stmt);\r\n        stmt.modifiers = modifiers;\r\n        if (modifiers)\r\n            setParent(modifiers, stmt);\r\n        stmt.decorators = decorators;\r\n        if (decorators)\r\n            setParent(decorators, stmt);\r\n        return stmt;\r\n    };\r\n    Node.createEnumValueDeclaration = function (name, value, range) {\r\n        var stmt = new EnumValueDeclaration();\r\n        stmt.range = range;\r\n        stmt.name = name;\r\n        name.parent = stmt;\r\n        stmt.value = value;\r\n        if (value)\r\n            value.parent = stmt;\r\n        return stmt;\r\n    };\r\n    Node.createExportStatement = function (members, path, modifiers, range) {\r\n        var stmt = new ExportStatement();\r\n        stmt.range = range;\r\n        stmt.members = members;\r\n        setParent(members, stmt);\r\n        stmt.path = path;\r\n        if (path) {\r\n            var normalizedPath = path_1.normalize(path.value);\r\n            if (path.value.startsWith(\".\")) {\r\n                stmt.normalizedPath = path_1.resolve(normalizedPath, range.source.normalizedPath);\r\n            }\r\n            else {\r\n                stmt.normalizedPath = normalizedPath;\r\n            }\r\n            stmt.internalPath = mangleInternalPath(stmt.normalizedPath);\r\n        }\r\n        else {\r\n            stmt.normalizedPath = null;\r\n            stmt.internalPath = null;\r\n        }\r\n        stmt.modifiers = modifiers;\r\n        if (modifiers)\r\n            setParent(modifiers, stmt);\r\n        return stmt;\r\n    };\r\n    Node.createExportImportStatement = function (name, externalName, range) {\r\n        var stmt = new ExportImportStatement();\r\n        stmt.range = range;\r\n        stmt.name = name;\r\n        name.parent = stmt;\r\n        stmt.externalName = externalName;\r\n        externalName.parent = stmt;\r\n        return stmt;\r\n    };\r\n    Node.createExportMember = function (name, externalName, range) {\r\n        var elem = new ExportMember();\r\n        elem.range = range;\r\n        elem.name = name;\r\n        name.parent = elem;\r\n        if (!externalName) {\r\n            externalName = name;\r\n        }\r\n        else {\r\n            externalName.parent = elem;\r\n        }\r\n        elem.externalName = externalName;\r\n        return elem;\r\n    };\r\n    Node.createExpressionStatement = function (expression) {\r\n        var stmt = new ExpressionStatement();\r\n        stmt.range = expression.range;\r\n        stmt.expression = expression;\r\n        expression.parent = stmt;\r\n        return stmt;\r\n    };\r\n    Node.createIfStatement = function (condition, ifTrue, ifFalse, range) {\r\n        var stmt = new IfStatement();\r\n        stmt.range = range;\r\n        stmt.condition = condition;\r\n        condition.parent = stmt;\r\n        stmt.ifTrue = ifTrue;\r\n        ifTrue.parent = stmt;\r\n        stmt.ifFalse = ifFalse;\r\n        if (ifFalse)\r\n            ifFalse.parent = stmt;\r\n        return stmt;\r\n    };\r\n    Node.createImportStatement = function (decls, path, range) {\r\n        var stmt = new ImportStatement();\r\n        stmt.range = range;\r\n        stmt.declarations = decls;\r\n        if (decls)\r\n            setParent(decls, stmt);\r\n        stmt.namespaceName = null;\r\n        stmt.path = path;\r\n        var normalizedPath = path_1.normalize(path.value);\r\n        if (path.value.startsWith(\".\")) {\r\n            stmt.normalizedPath = path_1.resolve(normalizedPath, range.source.normalizedPath);\r\n        }\r\n        else {\r\n            stmt.normalizedPath = normalizedPath;\r\n        }\r\n        stmt.internalPath = mangleInternalPath(stmt.normalizedPath);\r\n        return stmt;\r\n    };\r\n    Node.createImportStatementWithWildcard = function (identifier, path, range) {\r\n        var stmt = new ImportStatement();\r\n        stmt.range = range;\r\n        stmt.declarations = null;\r\n        stmt.namespaceName = identifier;\r\n        stmt.path = path;\r\n        stmt.normalizedPath = path_1.resolve(path_1.normalize(path.value), range.source.normalizedPath);\r\n        stmt.internalPath = mangleInternalPath(stmt.normalizedPath);\r\n        return stmt;\r\n    };\r\n    Node.createImportDeclaration = function (externalName, name, range) {\r\n        var elem = new ImportDeclaration();\r\n        elem.range = range;\r\n        elem.externalName = externalName;\r\n        externalName.parent = elem;\r\n        if (!name) {\r\n            name = externalName;\r\n        }\r\n        else {\r\n            name.parent = elem;\r\n        }\r\n        elem.name = name;\r\n        return elem;\r\n    };\r\n    Node.createInterfaceDeclaration = function (name, extendsType, members, modifiers, range) {\r\n        var stmt = new InterfaceDeclaration();\r\n        stmt.range = range;\r\n        stmt.name = name;\r\n        name.parent = stmt;\r\n        stmt.extendsType = extendsType;\r\n        if (extendsType)\r\n            extendsType.parent = stmt;\r\n        stmt.members = members;\r\n        setParent(members, stmt);\r\n        stmt.modifiers = modifiers;\r\n        if (modifiers)\r\n            setParent(modifiers, stmt);\r\n        return stmt;\r\n    };\r\n    Node.createFieldDeclaration = function (name, type, initializer, modifiers, decorators, range) {\r\n        var stmt = new FieldDeclaration();\r\n        stmt.range = range;\r\n        stmt.name = name;\r\n        name.parent = stmt;\r\n        stmt.type = type;\r\n        if (type)\r\n            type.parent = stmt;\r\n        stmt.initializer = initializer;\r\n        if (initializer)\r\n            initializer.parent = stmt;\r\n        stmt.modifiers = modifiers;\r\n        if (modifiers)\r\n            setParent(modifiers, stmt);\r\n        stmt.decorators = decorators;\r\n        if (decorators)\r\n            setParent(decorators, stmt);\r\n        return stmt;\r\n    };\r\n    Node.createForStatement = function (initializer, condition, incrementor, statement, range) {\r\n        var stmt = new ForStatement();\r\n        stmt.range = range;\r\n        stmt.initializer = initializer;\r\n        if (initializer)\r\n            initializer.parent = stmt;\r\n        stmt.condition = condition;\r\n        if (condition)\r\n            condition.parent = stmt;\r\n        stmt.incrementor = incrementor;\r\n        if (incrementor)\r\n            incrementor.parent = stmt;\r\n        stmt.statement = statement;\r\n        statement.parent = stmt;\r\n        return stmt;\r\n    };\r\n    Node.createTypeParameter = function (name, extendsType, range) {\r\n        var elem = new TypeParameter();\r\n        elem.range = range;\r\n        elem.name = name;\r\n        name.parent = elem;\r\n        elem.extendsType = extendsType;\r\n        if (extendsType)\r\n            extendsType.parent = elem;\r\n        return elem;\r\n    };\r\n    Node.createParameter = function (name, type, initializer, kind, range) {\r\n        var elem = new Parameter();\r\n        elem.range = range;\r\n        elem.name = name;\r\n        name.parent = elem;\r\n        elem.type = type;\r\n        if (type)\r\n            type.parent = elem;\r\n        elem.initializer = initializer;\r\n        if (initializer)\r\n            initializer.parent = elem;\r\n        elem.parameterKind = kind;\r\n        return elem;\r\n    };\r\n    Node.createFunctionDeclaration = function (name, typeParameters, parameters, returnType, body, modifiers, decorators, range) {\r\n        var stmt = new FunctionDeclaration();\r\n        stmt.range = range;\r\n        stmt.name = name;\r\n        name.parent = stmt;\r\n        stmt.typeParameters = typeParameters;\r\n        if (typeParameters)\r\n            setParent(typeParameters, stmt);\r\n        stmt.parameters = parameters;\r\n        setParent(parameters, stmt);\r\n        stmt.returnType = returnType;\r\n        if (returnType)\r\n            returnType.parent = stmt;\r\n        stmt.body = body;\r\n        if (body)\r\n            body.parent = stmt;\r\n        stmt.modifiers = modifiers;\r\n        if (modifiers)\r\n            setParent(modifiers, stmt);\r\n        stmt.decorators = decorators;\r\n        if (decorators)\r\n            setParent(decorators, stmt);\r\n        return stmt;\r\n    };\r\n    Node.createMethodDeclaration = function (name, typeParameters, parameters, returnType, body, modifiers, decorators, range) {\r\n        var stmt = new MethodDeclaration();\r\n        stmt.range = range;\r\n        stmt.name = name;\r\n        name.parent = stmt;\r\n        stmt.typeParameters = typeParameters;\r\n        if (typeParameters)\r\n            setParent(typeParameters, stmt);\r\n        stmt.parameters = parameters;\r\n        setParent(parameters, stmt);\r\n        stmt.returnType = returnType;\r\n        if (returnType)\r\n            returnType.parent = stmt;\r\n        stmt.body = body;\r\n        if (body)\r\n            body.parent = stmt;\r\n        stmt.modifiers = modifiers;\r\n        if (modifiers)\r\n            setParent(modifiers, stmt);\r\n        stmt.decorators = decorators;\r\n        if (decorators)\r\n            setParent(decorators, stmt);\r\n        return stmt;\r\n    };\r\n    Node.createModifier = function (kind, range) {\r\n        var elem = new Modifier();\r\n        elem.range = range;\r\n        elem.modifierKind = kind;\r\n        return elem;\r\n    };\r\n    Node.createNamespaceDeclaration = function (name, members, modifiers, decorators, range) {\r\n        var stmt = new NamespaceDeclaration();\r\n        stmt.range = range;\r\n        stmt.name = name;\r\n        name.parent = stmt;\r\n        stmt.members = members;\r\n        setParent(members, stmt);\r\n        stmt.modifiers = modifiers;\r\n        if (modifiers)\r\n            setParent(modifiers, stmt);\r\n        stmt.decorators = decorators;\r\n        if (decorators)\r\n            setParent(decorators, stmt);\r\n        return stmt;\r\n    };\r\n    Node.createReturnStatement = function (value, range) {\r\n        var stmt = new ReturnStatement();\r\n        stmt.range = range;\r\n        stmt.value = value;\r\n        if (value)\r\n            value.parent = stmt;\r\n        return stmt;\r\n    };\r\n    Node.createSwitchStatement = function (condition, cases, range) {\r\n        var stmt = new SwitchStatement();\r\n        stmt.range = range;\r\n        stmt.condition = condition;\r\n        condition.parent = stmt;\r\n        stmt.cases = cases;\r\n        setParent(cases, stmt);\r\n        return stmt;\r\n    };\r\n    Node.createSwitchCase = function (label, statements, range) {\r\n        var elem = new SwitchCase();\r\n        elem.range = range;\r\n        elem.label = label;\r\n        if (label)\r\n            label.parent = elem;\r\n        elem.statements = statements;\r\n        setParent(statements, elem);\r\n        return elem;\r\n    };\r\n    Node.createThrowStatement = function (value, range) {\r\n        var stmt = new ThrowStatement();\r\n        stmt.range = range;\r\n        stmt.value = value;\r\n        value.parent = stmt;\r\n        return stmt;\r\n    };\r\n    Node.createTryStatement = function (statements, catchVariable, catchStatements, finallyStatements, range) {\r\n        var stmt = new TryStatement();\r\n        stmt.range = range;\r\n        stmt.statements = statements;\r\n        setParent(statements, stmt);\r\n        stmt.catchVariable = catchVariable;\r\n        if (catchVariable)\r\n            catchVariable.parent = stmt;\r\n        stmt.catchStatements = catchStatements;\r\n        if (catchStatements)\r\n            setParent(catchStatements, stmt);\r\n        stmt.finallyStatements = finallyStatements;\r\n        if (finallyStatements)\r\n            setParent(finallyStatements, stmt);\r\n        return stmt;\r\n    };\r\n    Node.createTypeDeclaration = function (name, alias, modifiers, decorators, range) {\r\n        var stmt = new TypeDeclaration();\r\n        stmt.range = range;\r\n        stmt.name = name;\r\n        name.parent = stmt;\r\n        stmt.alias = alias;\r\n        alias.parent = stmt;\r\n        stmt.modifiers = modifiers;\r\n        if (modifiers)\r\n            setParent(modifiers, stmt);\r\n        stmt.decorators = decorators;\r\n        if (decorators)\r\n            setParent(decorators, stmt);\r\n        return stmt;\r\n    };\r\n    Node.createVariableStatement = function (declarations, modifiers, decorators, range) {\r\n        var stmt = new VariableStatement();\r\n        stmt.range = range;\r\n        stmt.declarations = declarations;\r\n        setParent(declarations, stmt);\r\n        stmt.modifiers = modifiers;\r\n        if (modifiers)\r\n            setParent(modifiers, stmt);\r\n        stmt.decorators = decorators;\r\n        if (decorators)\r\n            setParent(decorators, stmt);\r\n        return stmt;\r\n    };\r\n    Node.createVariableDeclaration = function (name, type, initializer, modifiers, decorators, range) {\r\n        var elem = new VariableDeclaration();\r\n        elem.range = range;\r\n        elem.name = name;\r\n        name.parent = elem;\r\n        elem.type = type;\r\n        if (type)\r\n            type.parent = elem;\r\n        elem.initializer = initializer;\r\n        if (initializer)\r\n            initializer.parent = elem;\r\n        elem.modifiers = modifiers; // inherited from parent VariableStatement\r\n        elem.decorators = decorators; // inherited\r\n        return elem;\r\n    };\r\n    Node.createWhileStatement = function (condition, statement, range) {\r\n        var stmt = new WhileStatement();\r\n        stmt.range = range;\r\n        stmt.condition = condition;\r\n        condition.parent = stmt;\r\n        stmt.statement = statement;\r\n        statement.parent = stmt;\r\n        return stmt;\r\n    };\r\n    return Node;\r\n}());\r\nexports.Node = Node;\r\n// types\r\n/** Represents a type annotation. */\r\nvar TypeNode = /** @class */ (function (_super) {\r\n    __extends(TypeNode, _super);\r\n    function TypeNode() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.TYPE;\r\n        return _this;\r\n    }\r\n    return TypeNode;\r\n}(Node));\r\nexports.TypeNode = TypeNode;\r\n/** Represents a type parameter. */\r\nvar TypeParameter = /** @class */ (function (_super) {\r\n    __extends(TypeParameter, _super);\r\n    function TypeParameter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.TYPEPARAMETER;\r\n        return _this;\r\n    }\r\n    return TypeParameter;\r\n}(Node));\r\nexports.TypeParameter = TypeParameter;\r\n// expressions\r\n/** Base class of all expression nodes. */\r\nvar Expression = /** @class */ (function (_super) {\r\n    __extends(Expression, _super);\r\n    function Expression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return Expression;\r\n}(Node));\r\nexports.Expression = Expression;\r\n/** Represents an identifier expression. */\r\nvar IdentifierExpression = /** @class */ (function (_super) {\r\n    __extends(IdentifierExpression, _super);\r\n    function IdentifierExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.IDENTIFIER;\r\n        return _this;\r\n    }\r\n    return IdentifierExpression;\r\n}(Expression));\r\nexports.IdentifierExpression = IdentifierExpression;\r\n/** Indicates the kind of a literal. */\r\nvar LiteralKind;\r\n(function (LiteralKind) {\r\n    LiteralKind[LiteralKind[\"FLOAT\"] = 0] = \"FLOAT\";\r\n    LiteralKind[LiteralKind[\"INTEGER\"] = 1] = \"INTEGER\";\r\n    LiteralKind[LiteralKind[\"STRING\"] = 2] = \"STRING\";\r\n    LiteralKind[LiteralKind[\"REGEXP\"] = 3] = \"REGEXP\";\r\n    LiteralKind[LiteralKind[\"ARRAY\"] = 4] = \"ARRAY\";\r\n    LiteralKind[LiteralKind[\"OBJECT\"] = 5] = \"OBJECT\";\r\n})(LiteralKind = exports.LiteralKind || (exports.LiteralKind = {}));\r\n/** Base class of all literal expressions. */\r\nvar LiteralExpression = /** @class */ (function (_super) {\r\n    __extends(LiteralExpression, _super);\r\n    function LiteralExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.LITERAL;\r\n        return _this;\r\n    }\r\n    return LiteralExpression;\r\n}(Expression));\r\nexports.LiteralExpression = LiteralExpression;\r\n/** Represents an `[]` literal expression. */\r\nvar ArrayLiteralExpression = /** @class */ (function (_super) {\r\n    __extends(ArrayLiteralExpression, _super);\r\n    function ArrayLiteralExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.literalKind = 4 /* ARRAY */;\r\n        return _this;\r\n    }\r\n    return ArrayLiteralExpression;\r\n}(LiteralExpression));\r\nexports.ArrayLiteralExpression = ArrayLiteralExpression;\r\n/** Indicates the kind of an assertion. */\r\nvar AssertionKind;\r\n(function (AssertionKind) {\r\n    AssertionKind[AssertionKind[\"PREFIX\"] = 0] = \"PREFIX\";\r\n    AssertionKind[AssertionKind[\"AS\"] = 1] = \"AS\";\r\n})(AssertionKind = exports.AssertionKind || (exports.AssertionKind = {}));\r\n/** Represents an assertion expression. */\r\nvar AssertionExpression = /** @class */ (function (_super) {\r\n    __extends(AssertionExpression, _super);\r\n    function AssertionExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.ASSERTION;\r\n        return _this;\r\n    }\r\n    return AssertionExpression;\r\n}(Expression));\r\nexports.AssertionExpression = AssertionExpression;\r\n/** Represents a binary expression. */\r\nvar BinaryExpression = /** @class */ (function (_super) {\r\n    __extends(BinaryExpression, _super);\r\n    function BinaryExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.BINARY;\r\n        return _this;\r\n    }\r\n    return BinaryExpression;\r\n}(Expression));\r\nexports.BinaryExpression = BinaryExpression;\r\n/** Represents a call expression. */\r\nvar CallExpression = /** @class */ (function (_super) {\r\n    __extends(CallExpression, _super);\r\n    function CallExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.CALL;\r\n        return _this;\r\n    }\r\n    return CallExpression;\r\n}(Expression));\r\nexports.CallExpression = CallExpression;\r\n/** Represents a comma expression composed of multiple expressions. */\r\nvar CommaExpression = /** @class */ (function (_super) {\r\n    __extends(CommaExpression, _super);\r\n    function CommaExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.COMMA;\r\n        return _this;\r\n    }\r\n    return CommaExpression;\r\n}(Expression));\r\nexports.CommaExpression = CommaExpression;\r\n/** Represents a `constructor` expression. */\r\nvar ConstructorExpression = /** @class */ (function (_super) {\r\n    __extends(ConstructorExpression, _super);\r\n    function ConstructorExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.CONSTRUCTOR;\r\n        _this.text = \"constructor\";\r\n        return _this;\r\n    }\r\n    return ConstructorExpression;\r\n}(IdentifierExpression));\r\nexports.ConstructorExpression = ConstructorExpression;\r\n/** Represents an element access expression, e.g., array access. */\r\nvar ElementAccessExpression = /** @class */ (function (_super) {\r\n    __extends(ElementAccessExpression, _super);\r\n    function ElementAccessExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.ELEMENTACCESS;\r\n        return _this;\r\n    }\r\n    return ElementAccessExpression;\r\n}(Expression));\r\nexports.ElementAccessExpression = ElementAccessExpression;\r\n/** Represents a float literal expression. */\r\nvar FloatLiteralExpression = /** @class */ (function (_super) {\r\n    __extends(FloatLiteralExpression, _super);\r\n    function FloatLiteralExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.literalKind = 0 /* FLOAT */;\r\n        return _this;\r\n    }\r\n    return FloatLiteralExpression;\r\n}(LiteralExpression));\r\nexports.FloatLiteralExpression = FloatLiteralExpression;\r\n/** Represents a function expression using the 'function' keyword. */\r\nvar FunctionExpression = /** @class */ (function (_super) {\r\n    __extends(FunctionExpression, _super);\r\n    function FunctionExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.FUNCTION;\r\n        return _this;\r\n    }\r\n    return FunctionExpression;\r\n}(Expression));\r\nexports.FunctionExpression = FunctionExpression;\r\n/** Represents an arrow function expression. */\r\nvar FunctionArrowExpression = /** @class */ (function (_super) {\r\n    __extends(FunctionArrowExpression, _super);\r\n    function FunctionArrowExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.FUNCTIONARROW;\r\n        return _this;\r\n    }\r\n    return FunctionArrowExpression;\r\n}(FunctionExpression));\r\nexports.FunctionArrowExpression = FunctionArrowExpression;\r\n/** Represents an integer literal expression. */\r\nvar IntegerLiteralExpression = /** @class */ (function (_super) {\r\n    __extends(IntegerLiteralExpression, _super);\r\n    function IntegerLiteralExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.literalKind = 1 /* INTEGER */;\r\n        return _this;\r\n    }\r\n    return IntegerLiteralExpression;\r\n}(LiteralExpression));\r\nexports.IntegerLiteralExpression = IntegerLiteralExpression;\r\n/** Represents a `new` expression. Like a call but with its own kind. */\r\nvar NewExpression = /** @class */ (function (_super) {\r\n    __extends(NewExpression, _super);\r\n    function NewExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.NEW;\r\n        return _this;\r\n    }\r\n    return NewExpression;\r\n}(CallExpression));\r\nexports.NewExpression = NewExpression;\r\n/** Represents a `null` expression. */\r\nvar NullExpression = /** @class */ (function (_super) {\r\n    __extends(NullExpression, _super);\r\n    function NullExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.NULL;\r\n        _this.text = \"null\";\r\n        return _this;\r\n    }\r\n    return NullExpression;\r\n}(IdentifierExpression));\r\nexports.NullExpression = NullExpression;\r\n/** Represents a parenthesized expression. */\r\nvar ParenthesizedExpression = /** @class */ (function (_super) {\r\n    __extends(ParenthesizedExpression, _super);\r\n    function ParenthesizedExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.PARENTHESIZED;\r\n        return _this;\r\n    }\r\n    return ParenthesizedExpression;\r\n}(Expression));\r\nexports.ParenthesizedExpression = ParenthesizedExpression;\r\n/** Represents a property access expression. */\r\nvar PropertyAccessExpression = /** @class */ (function (_super) {\r\n    __extends(PropertyAccessExpression, _super);\r\n    function PropertyAccessExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.PROPERTYACCESS;\r\n        return _this;\r\n    }\r\n    return PropertyAccessExpression;\r\n}(Expression));\r\nexports.PropertyAccessExpression = PropertyAccessExpression;\r\n/** Represents a regular expression literal expression. */\r\nvar RegexpLiteralExpression = /** @class */ (function (_super) {\r\n    __extends(RegexpLiteralExpression, _super);\r\n    function RegexpLiteralExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.literalKind = 3 /* REGEXP */;\r\n        return _this;\r\n    }\r\n    return RegexpLiteralExpression;\r\n}(LiteralExpression));\r\nexports.RegexpLiteralExpression = RegexpLiteralExpression;\r\n/** Represents a ternary expression, i.e., short if notation. */\r\nvar TernaryExpression = /** @class */ (function (_super) {\r\n    __extends(TernaryExpression, _super);\r\n    function TernaryExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.TERNARY;\r\n        return _this;\r\n    }\r\n    return TernaryExpression;\r\n}(Expression));\r\nexports.TernaryExpression = TernaryExpression;\r\n/** Represents a string literal expression. */\r\nvar StringLiteralExpression = /** @class */ (function (_super) {\r\n    __extends(StringLiteralExpression, _super);\r\n    function StringLiteralExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.literalKind = 2 /* STRING */;\r\n        return _this;\r\n    }\r\n    return StringLiteralExpression;\r\n}(LiteralExpression));\r\nexports.StringLiteralExpression = StringLiteralExpression;\r\n/** Represents a `super` expression. */\r\nvar SuperExpression = /** @class */ (function (_super) {\r\n    __extends(SuperExpression, _super);\r\n    function SuperExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.SUPER;\r\n        _this.text = \"super\";\r\n        return _this;\r\n    }\r\n    return SuperExpression;\r\n}(IdentifierExpression));\r\nexports.SuperExpression = SuperExpression;\r\n/** Represents a `this` expression. */\r\nvar ThisExpression = /** @class */ (function (_super) {\r\n    __extends(ThisExpression, _super);\r\n    function ThisExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.THIS;\r\n        _this.text = \"this\";\r\n        return _this;\r\n    }\r\n    return ThisExpression;\r\n}(IdentifierExpression));\r\nexports.ThisExpression = ThisExpression;\r\n/** Represents a `true` expression. */\r\nvar TrueExpression = /** @class */ (function (_super) {\r\n    __extends(TrueExpression, _super);\r\n    function TrueExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.TRUE;\r\n        _this.text = \"true\";\r\n        return _this;\r\n    }\r\n    return TrueExpression;\r\n}(IdentifierExpression));\r\nexports.TrueExpression = TrueExpression;\r\n/** Represents a `false` expression. */\r\nvar FalseExpression = /** @class */ (function (_super) {\r\n    __extends(FalseExpression, _super);\r\n    function FalseExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.FALSE;\r\n        _this.text = \"false\";\r\n        return _this;\r\n    }\r\n    return FalseExpression;\r\n}(IdentifierExpression));\r\nexports.FalseExpression = FalseExpression;\r\n/** Base class of all unary expressions. */\r\nvar UnaryExpression = /** @class */ (function (_super) {\r\n    __extends(UnaryExpression, _super);\r\n    function UnaryExpression() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return UnaryExpression;\r\n}(Expression));\r\nexports.UnaryExpression = UnaryExpression;\r\n/** Represents a unary postfix expression, e.g. a postfix increment. */\r\nvar UnaryPostfixExpression = /** @class */ (function (_super) {\r\n    __extends(UnaryPostfixExpression, _super);\r\n    function UnaryPostfixExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.UNARYPOSTFIX;\r\n        return _this;\r\n    }\r\n    return UnaryPostfixExpression;\r\n}(UnaryExpression));\r\nexports.UnaryPostfixExpression = UnaryPostfixExpression;\r\n/** Represents a unary prefix expression, e.g. a negation. */\r\nvar UnaryPrefixExpression = /** @class */ (function (_super) {\r\n    __extends(UnaryPrefixExpression, _super);\r\n    function UnaryPrefixExpression() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.UNARYPREFIX;\r\n        return _this;\r\n    }\r\n    return UnaryPrefixExpression;\r\n}(UnaryExpression));\r\nexports.UnaryPrefixExpression = UnaryPrefixExpression;\r\n// statements\r\n/** Indicates the specific kind of a modifier. */\r\nvar ModifierKind;\r\n(function (ModifierKind) {\r\n    ModifierKind[ModifierKind[\"ASYNC\"] = 0] = \"ASYNC\";\r\n    ModifierKind[ModifierKind[\"CONST\"] = 1] = \"CONST\";\r\n    ModifierKind[ModifierKind[\"LET\"] = 2] = \"LET\";\r\n    ModifierKind[ModifierKind[\"DECLARE\"] = 3] = \"DECLARE\";\r\n    ModifierKind[ModifierKind[\"EXPORT\"] = 4] = \"EXPORT\";\r\n    ModifierKind[ModifierKind[\"IMPORT\"] = 5] = \"IMPORT\";\r\n    ModifierKind[ModifierKind[\"STATIC\"] = 6] = \"STATIC\";\r\n    ModifierKind[ModifierKind[\"ABSTRACT\"] = 7] = \"ABSTRACT\";\r\n    ModifierKind[ModifierKind[\"PUBLIC\"] = 8] = \"PUBLIC\";\r\n    ModifierKind[ModifierKind[\"PRIVATE\"] = 9] = \"PRIVATE\";\r\n    ModifierKind[ModifierKind[\"PROTECTED\"] = 10] = \"PROTECTED\";\r\n    ModifierKind[ModifierKind[\"READONLY\"] = 11] = \"READONLY\";\r\n    ModifierKind[ModifierKind[\"GET\"] = 12] = \"GET\";\r\n    ModifierKind[ModifierKind[\"SET\"] = 13] = \"SET\";\r\n})(ModifierKind = exports.ModifierKind || (exports.ModifierKind = {}));\r\n/** Base class of all statement nodes. */\r\nvar Statement = /** @class */ (function (_super) {\r\n    __extends(Statement, _super);\r\n    function Statement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return Statement;\r\n}(Node));\r\nexports.Statement = Statement;\r\n/** Indicates the specific kind of a source. */\r\nvar SourceKind;\r\n(function (SourceKind) {\r\n    /** Default source. Usually imported from an entry file. */\r\n    SourceKind[SourceKind[\"DEFAULT\"] = 0] = \"DEFAULT\";\r\n    /** Entry file. */\r\n    SourceKind[SourceKind[\"ENTRY\"] = 1] = \"ENTRY\";\r\n    /** Library file. */\r\n    SourceKind[SourceKind[\"LIBRARY\"] = 2] = \"LIBRARY\";\r\n})(SourceKind = exports.SourceKind || (exports.SourceKind = {}));\r\n/** A top-level source node. */\r\nvar Source = /** @class */ (function (_super) {\r\n    __extends(Source, _super);\r\n    /** Constructs a new source node. */\r\n    function Source(normalizedPath, text, kind) {\r\n        var _this = _super.call(this) || this;\r\n        _this.kind = NodeKind.SOURCE;\r\n        _this.parent = null;\r\n        /** Tokenizer reference. */\r\n        _this.tokenizer = null;\r\n        /** Source map index. */\r\n        _this.debugInfoIndex = -1;\r\n        _this.sourceKind = kind;\r\n        _this.normalizedPath = normalizedPath;\r\n        _this.internalPath = mangleInternalPath(_this.normalizedPath);\r\n        _this.statements = new Array();\r\n        _this.range = new tokenizer_1.Range(_this, 0, text.length);\r\n        _this.text = text;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(Source.prototype, \"isEntry\", {\r\n        /** Tests if this source is an entry file. */\r\n        get: function () { return this.sourceKind == SourceKind.ENTRY; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Source.prototype, \"isLibrary\", {\r\n        /** Tests if this source is a stdlib file. */\r\n        get: function () { return this.sourceKind == SourceKind.LIBRARY; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return Source;\r\n}(Node));\r\nexports.Source = Source;\r\n/** Base class of all declaration statements. */\r\nvar DeclarationStatement = /** @class */ (function (_super) {\r\n    __extends(DeclarationStatement, _super);\r\n    function DeclarationStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /** Array of decorators. */\r\n        _this.decorators = null;\r\n        _this.cachedProgramLevelInternalName = null;\r\n        _this.cachedFileLevelInternalName = null;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(DeclarationStatement.prototype, \"programLevelInternalName\", {\r\n        /** Gets the mangled program-level internal name of this declaration. */\r\n        get: function () {\r\n            if (!this.cachedProgramLevelInternalName) {\r\n                this.cachedProgramLevelInternalName = mangleInternalName(this, true);\r\n            }\r\n            return this.cachedProgramLevelInternalName;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DeclarationStatement.prototype, \"fileLevelInternalName\", {\r\n        /** Gets the mangled file-level internal name of this declaration. */\r\n        get: function () {\r\n            if (!this.cachedFileLevelInternalName) {\r\n                this.cachedFileLevelInternalName = mangleInternalName(this, false);\r\n            }\r\n            return this.cachedFileLevelInternalName;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DeclarationStatement.prototype, \"isTopLevel\", {\r\n        /** Tests if this is a top-level declaration within its source file. */\r\n        get: function () {\r\n            var parent = this.parent;\r\n            if (!parent) {\r\n                return false;\r\n            }\r\n            if (parent.kind == NodeKind.VARIABLE && !(parent = parent.parent)) {\r\n                return false;\r\n            }\r\n            return parent.kind == NodeKind.SOURCE;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(DeclarationStatement.prototype, \"isTopLevelExport\", {\r\n        /** Tests if this declaration is a top-level export within its source file. */\r\n        get: function () {\r\n            var parent = this.parent;\r\n            if (!parent || (parent.kind == NodeKind.VARIABLE && !(parent = parent.parent))) {\r\n                return false;\r\n            }\r\n            if (parent.kind == NodeKind.NAMESPACEDECLARATION) {\r\n                return (hasModifier(ModifierKind.EXPORT, this.modifiers) &&\r\n                    parent.isTopLevelExport);\r\n            }\r\n            if (parent.kind == NodeKind.CLASSDECLARATION) {\r\n                return (hasModifier(ModifierKind.STATIC, this.modifiers) &&\r\n                    parent.isTopLevelExport);\r\n            }\r\n            return (parent.kind == NodeKind.SOURCE &&\r\n                hasModifier(ModifierKind.EXPORT, this.modifiers));\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Tests if this declaration needs an explicit export. */\r\n    DeclarationStatement.prototype.needsExplicitExport = function (member) {\r\n        // This is necessary because module-level exports are automatically created\r\n        // for top level declarations of all sorts. This function essentially tests\r\n        // that there isn't a otherwise duplicate top-level export already.\r\n        return (member.name.text != member.externalName.text || // if aliased\r\n            this.range.source != member.range.source || // if a re-export\r\n            !this.isTopLevelExport // if not top-level\r\n        );\r\n    };\r\n    return DeclarationStatement;\r\n}(Statement));\r\nexports.DeclarationStatement = DeclarationStatement;\r\n/** Base class of all variable-like declaration statements. */\r\nvar VariableLikeDeclarationStatement = /** @class */ (function (_super) {\r\n    __extends(VariableLikeDeclarationStatement, _super);\r\n    function VariableLikeDeclarationStatement() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    return VariableLikeDeclarationStatement;\r\n}(DeclarationStatement));\r\nexports.VariableLikeDeclarationStatement = VariableLikeDeclarationStatement;\r\n/** Represents a block statement. */\r\nvar BlockStatement = /** @class */ (function (_super) {\r\n    __extends(BlockStatement, _super);\r\n    function BlockStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.BLOCK;\r\n        return _this;\r\n    }\r\n    return BlockStatement;\r\n}(Statement));\r\nexports.BlockStatement = BlockStatement;\r\n/** Represents a `break` statement. */\r\nvar BreakStatement = /** @class */ (function (_super) {\r\n    __extends(BreakStatement, _super);\r\n    function BreakStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.BREAK;\r\n        return _this;\r\n    }\r\n    return BreakStatement;\r\n}(Statement));\r\nexports.BreakStatement = BreakStatement;\r\n/** Represents a `class` declaration. */\r\nvar ClassDeclaration = /** @class */ (function (_super) {\r\n    __extends(ClassDeclaration, _super);\r\n    function ClassDeclaration() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.CLASSDECLARATION;\r\n        return _this;\r\n    }\r\n    return ClassDeclaration;\r\n}(DeclarationStatement));\r\nexports.ClassDeclaration = ClassDeclaration;\r\n/** Represents a `continue` statement. */\r\nvar ContinueStatement = /** @class */ (function (_super) {\r\n    __extends(ContinueStatement, _super);\r\n    function ContinueStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.CONTINUE;\r\n        return _this;\r\n    }\r\n    return ContinueStatement;\r\n}(Statement));\r\nexports.ContinueStatement = ContinueStatement;\r\n/** Built-in decorator kinds. */\r\nvar DecoratorKind;\r\n(function (DecoratorKind) {\r\n    DecoratorKind[DecoratorKind[\"CUSTOM\"] = 0] = \"CUSTOM\";\r\n    DecoratorKind[DecoratorKind[\"GLOBAL\"] = 1] = \"GLOBAL\";\r\n    DecoratorKind[DecoratorKind[\"OPERATOR\"] = 2] = \"OPERATOR\";\r\n    DecoratorKind[DecoratorKind[\"UNMANAGED\"] = 3] = \"UNMANAGED\";\r\n    DecoratorKind[DecoratorKind[\"OFFSET\"] = 4] = \"OFFSET\";\r\n})(DecoratorKind = exports.DecoratorKind || (exports.DecoratorKind = {}));\r\n/** Depresents a decorator. */\r\nvar Decorator = /** @class */ (function (_super) {\r\n    __extends(Decorator, _super);\r\n    function Decorator() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.DECORATOR;\r\n        return _this;\r\n    }\r\n    return Decorator;\r\n}(Statement));\r\nexports.Decorator = Decorator;\r\n/** Represents a `do` statement. */\r\nvar DoStatement = /** @class */ (function (_super) {\r\n    __extends(DoStatement, _super);\r\n    function DoStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.DO;\r\n        return _this;\r\n    }\r\n    return DoStatement;\r\n}(Statement));\r\nexports.DoStatement = DoStatement;\r\n/** Represents an empty statement, i.e., a semicolon terminating nothing. */\r\nvar EmptyStatement = /** @class */ (function (_super) {\r\n    __extends(EmptyStatement, _super);\r\n    function EmptyStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.EMPTY;\r\n        return _this;\r\n    }\r\n    return EmptyStatement;\r\n}(Statement));\r\nexports.EmptyStatement = EmptyStatement;\r\n/** Represents an `enum` declaration. */\r\nvar EnumDeclaration = /** @class */ (function (_super) {\r\n    __extends(EnumDeclaration, _super);\r\n    function EnumDeclaration() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.ENUMDECLARATION;\r\n        return _this;\r\n    }\r\n    return EnumDeclaration;\r\n}(DeclarationStatement));\r\nexports.EnumDeclaration = EnumDeclaration;\r\n/** Represents a value of an `enum` declaration. */\r\nvar EnumValueDeclaration = /** @class */ (function (_super) {\r\n    __extends(EnumValueDeclaration, _super);\r\n    function EnumValueDeclaration() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.ENUMVALUEDECLARATION;\r\n        _this.modifiers = null;\r\n        return _this;\r\n    }\r\n    return EnumValueDeclaration;\r\n}(DeclarationStatement));\r\nexports.EnumValueDeclaration = EnumValueDeclaration;\r\n/** Represents an `export import` statement of an interface. */\r\nvar ExportImportStatement = /** @class */ (function (_super) {\r\n    __extends(ExportImportStatement, _super);\r\n    function ExportImportStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.EXPORTIMPORT;\r\n        return _this;\r\n    }\r\n    return ExportImportStatement;\r\n}(Node));\r\nexports.ExportImportStatement = ExportImportStatement;\r\n/** Represents a member of an `export` statement. */\r\nvar ExportMember = /** @class */ (function (_super) {\r\n    __extends(ExportMember, _super);\r\n    function ExportMember() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.EXPORTMEMBER;\r\n        return _this;\r\n    }\r\n    return ExportMember;\r\n}(Node));\r\nexports.ExportMember = ExportMember;\r\n/** Represents an `export` statement. */\r\nvar ExportStatement = /** @class */ (function (_super) {\r\n    __extends(ExportStatement, _super);\r\n    function ExportStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.EXPORT;\r\n        return _this;\r\n    }\r\n    return ExportStatement;\r\n}(Statement));\r\nexports.ExportStatement = ExportStatement;\r\n/** Represents an expression that is used as a statement. */\r\nvar ExpressionStatement = /** @class */ (function (_super) {\r\n    __extends(ExpressionStatement, _super);\r\n    function ExpressionStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.EXPRESSION;\r\n        return _this;\r\n    }\r\n    return ExpressionStatement;\r\n}(Statement));\r\nexports.ExpressionStatement = ExpressionStatement;\r\n/** Represents a field declaration within a `class`. */\r\nvar FieldDeclaration = /** @class */ (function (_super) {\r\n    __extends(FieldDeclaration, _super);\r\n    function FieldDeclaration() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.FIELDDECLARATION;\r\n        return _this;\r\n    }\r\n    return FieldDeclaration;\r\n}(VariableLikeDeclarationStatement));\r\nexports.FieldDeclaration = FieldDeclaration;\r\n/** Represents a `for` statement. */\r\nvar ForStatement = /** @class */ (function (_super) {\r\n    __extends(ForStatement, _super);\r\n    function ForStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.FOR;\r\n        return _this;\r\n    }\r\n    return ForStatement;\r\n}(Statement));\r\nexports.ForStatement = ForStatement;\r\n/** Represents a `function` declaration. */\r\nvar FunctionDeclaration = /** @class */ (function (_super) {\r\n    __extends(FunctionDeclaration, _super);\r\n    function FunctionDeclaration() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.FUNCTIONDECLARATION;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(FunctionDeclaration.prototype, \"isGeneric\", {\r\n        get: function () {\r\n            return this.typeParameters != null && this.typeParameters.length > 0;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return FunctionDeclaration;\r\n}(DeclarationStatement));\r\nexports.FunctionDeclaration = FunctionDeclaration;\r\n/** Represents an `if` statement. */\r\nvar IfStatement = /** @class */ (function (_super) {\r\n    __extends(IfStatement, _super);\r\n    function IfStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.IF;\r\n        return _this;\r\n    }\r\n    return IfStatement;\r\n}(Statement));\r\nexports.IfStatement = IfStatement;\r\n/** Represents an `import` declaration part of an {@link ImportStatement}. */\r\nvar ImportDeclaration = /** @class */ (function (_super) {\r\n    __extends(ImportDeclaration, _super);\r\n    function ImportDeclaration() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.IMPORTDECLARATION;\r\n        _this.modifiers = null;\r\n        return _this;\r\n    }\r\n    return ImportDeclaration;\r\n}(DeclarationStatement));\r\nexports.ImportDeclaration = ImportDeclaration;\r\n/** Represents an `import` statement. */\r\nvar ImportStatement = /** @class */ (function (_super) {\r\n    __extends(ImportStatement, _super);\r\n    function ImportStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.IMPORT;\r\n        return _this;\r\n    }\r\n    return ImportStatement;\r\n}(Statement));\r\nexports.ImportStatement = ImportStatement;\r\n/** Represents an `interfarce` declaration. */\r\nvar InterfaceDeclaration = /** @class */ (function (_super) {\r\n    __extends(InterfaceDeclaration, _super);\r\n    function InterfaceDeclaration() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.INTERFACEDECLARATION;\r\n        return _this;\r\n    }\r\n    return InterfaceDeclaration;\r\n}(ClassDeclaration));\r\nexports.InterfaceDeclaration = InterfaceDeclaration;\r\n/** Represents a method declaration within a `class`. */\r\nvar MethodDeclaration = /** @class */ (function (_super) {\r\n    __extends(MethodDeclaration, _super);\r\n    function MethodDeclaration() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.METHODDECLARATION;\r\n        return _this;\r\n    }\r\n    return MethodDeclaration;\r\n}(FunctionDeclaration));\r\nexports.MethodDeclaration = MethodDeclaration;\r\n/** Represents a `namespace` declaration. */\r\nvar NamespaceDeclaration = /** @class */ (function (_super) {\r\n    __extends(NamespaceDeclaration, _super);\r\n    function NamespaceDeclaration() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.NAMESPACEDECLARATION;\r\n        return _this;\r\n    }\r\n    return NamespaceDeclaration;\r\n}(DeclarationStatement));\r\nexports.NamespaceDeclaration = NamespaceDeclaration;\r\n/** Represents the kind of a parameter. */\r\nvar ParameterKind;\r\n(function (ParameterKind) {\r\n    /** No specific flags. */\r\n    ParameterKind[ParameterKind[\"DEFAULT\"] = 0] = \"DEFAULT\";\r\n    /** Is an optional parameter. */\r\n    ParameterKind[ParameterKind[\"OPTIONAL\"] = 1] = \"OPTIONAL\";\r\n    /** Is a rest parameter. */\r\n    ParameterKind[ParameterKind[\"REST\"] = 2] = \"REST\";\r\n})(ParameterKind = exports.ParameterKind || (exports.ParameterKind = {}));\r\n/** Represents a function parameter. */\r\nvar Parameter = /** @class */ (function (_super) {\r\n    __extends(Parameter, _super);\r\n    function Parameter() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.PARAMETER;\r\n        return _this;\r\n    }\r\n    return Parameter;\r\n}(Node));\r\nexports.Parameter = Parameter;\r\n/** Represents a single modifier. */\r\nvar Modifier = /** @class */ (function (_super) {\r\n    __extends(Modifier, _super);\r\n    function Modifier() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.MODIFIER;\r\n        return _this;\r\n    }\r\n    return Modifier;\r\n}(Node));\r\nexports.Modifier = Modifier;\r\n/** Represents a `return` statement. */\r\nvar ReturnStatement = /** @class */ (function (_super) {\r\n    __extends(ReturnStatement, _super);\r\n    function ReturnStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.RETURN;\r\n        return _this;\r\n    }\r\n    return ReturnStatement;\r\n}(Statement));\r\nexports.ReturnStatement = ReturnStatement;\r\n/** Represents a single `case` within a `switch` statement. */\r\nvar SwitchCase = /** @class */ (function (_super) {\r\n    __extends(SwitchCase, _super);\r\n    function SwitchCase() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.SWITCHCASE;\r\n        return _this;\r\n    }\r\n    return SwitchCase;\r\n}(Node));\r\nexports.SwitchCase = SwitchCase;\r\n/** Represents a `switch` statement. */\r\nvar SwitchStatement = /** @class */ (function (_super) {\r\n    __extends(SwitchStatement, _super);\r\n    function SwitchStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.SWITCH;\r\n        return _this;\r\n    }\r\n    return SwitchStatement;\r\n}(Statement));\r\nexports.SwitchStatement = SwitchStatement;\r\n/** Represents a `throw` statement. */\r\nvar ThrowStatement = /** @class */ (function (_super) {\r\n    __extends(ThrowStatement, _super);\r\n    function ThrowStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.THROW;\r\n        return _this;\r\n    }\r\n    return ThrowStatement;\r\n}(Statement));\r\nexports.ThrowStatement = ThrowStatement;\r\n/** Represents a `try` statement. */\r\nvar TryStatement = /** @class */ (function (_super) {\r\n    __extends(TryStatement, _super);\r\n    function TryStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.TRY;\r\n        return _this;\r\n    }\r\n    return TryStatement;\r\n}(Statement));\r\nexports.TryStatement = TryStatement;\r\n/** Represents a `type` declaration. */\r\nvar TypeDeclaration = /** @class */ (function (_super) {\r\n    __extends(TypeDeclaration, _super);\r\n    function TypeDeclaration() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.TYPEDECLARATION;\r\n        return _this;\r\n    }\r\n    return TypeDeclaration;\r\n}(DeclarationStatement));\r\nexports.TypeDeclaration = TypeDeclaration;\r\n/** Represents a variable declaration part of a {@link VariableStatement}. */\r\nvar VariableDeclaration = /** @class */ (function (_super) {\r\n    __extends(VariableDeclaration, _super);\r\n    function VariableDeclaration() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.VARIABLEDECLARATION;\r\n        return _this;\r\n    }\r\n    return VariableDeclaration;\r\n}(VariableLikeDeclarationStatement));\r\nexports.VariableDeclaration = VariableDeclaration;\r\n/** Represents a variable statement wrapping {@link VariableDeclaration}s. */\r\nvar VariableStatement = /** @class */ (function (_super) {\r\n    __extends(VariableStatement, _super);\r\n    function VariableStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.VARIABLE;\r\n        return _this;\r\n    }\r\n    return VariableStatement;\r\n}(Statement));\r\nexports.VariableStatement = VariableStatement;\r\n/** Represents a `while` statement. */\r\nvar WhileStatement = /** @class */ (function (_super) {\r\n    __extends(WhileStatement, _super);\r\n    function WhileStatement() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        _this.kind = NodeKind.WHILE;\r\n        return _this;\r\n    }\r\n    return WhileStatement;\r\n}(Statement));\r\nexports.WhileStatement = WhileStatement;\r\n/** Cached unused modifiers for reuse. */\r\nvar reusableModifiers = null;\r\nfunction setReusableModifiers(modifiers) {\r\n    reusableModifiers = modifiers;\r\n}\r\nexports.setReusableModifiers = setReusableModifiers;\r\n/** Creates a new modifiers array. */\r\nfunction createModifiers() {\r\n    var ret;\r\n    if (reusableModifiers != null) {\r\n        ret = reusableModifiers;\r\n        reusableModifiers = null;\r\n    }\r\n    else {\r\n        ret = [];\r\n    }\r\n    ret.length = 0;\r\n    return ret;\r\n}\r\nexports.createModifiers = createModifiers;\r\n// Utility\r\n/** Adds a modifier to a set of modifiers. Creates a new set if `null`. */\r\nfunction addModifier(modifier, modifiers) {\r\n    if (modifiers == null)\r\n        modifiers = createModifiers();\r\n    modifiers.push(modifier);\r\n    return modifiers;\r\n}\r\nexports.addModifier = addModifier;\r\n/** Gets a specific modifier from the specified set of modifiers. */\r\nfunction getModifier(kind, modifiers) {\r\n    if (modifiers) {\r\n        for (var i = 0, k = modifiers.length; i < k; ++i) {\r\n            if (modifiers[i].modifierKind == kind) {\r\n                return modifiers[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexports.getModifier = getModifier;\r\n/** Tests whether a modifier exists in the specified set of modifiers. */\r\nfunction hasModifier(kind, modifiers) {\r\n    return getModifier(kind, modifiers) != null;\r\n}\r\nexports.hasModifier = hasModifier;\r\n/** Gets the first decorator by name within at set of decorators, if present. */\r\nfunction getFirstDecorator(name, decorators) {\r\n    if (decorators) {\r\n        for (var i = 0, k = decorators.length; i < k; ++i) {\r\n            var decorator = decorators[i];\r\n            var expression = decorator.name;\r\n            if (expression.kind == NodeKind.IDENTIFIER && expression.text == name) {\r\n                return decorator;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nexports.getFirstDecorator = getFirstDecorator;\r\n/** Tests if a specific decorator is present within the specified decorators. */\r\nfunction hasDecorator(name, decorators) {\r\n    return getFirstDecorator(name, decorators) != null;\r\n}\r\nexports.hasDecorator = hasDecorator;\r\n/** Mangles a declaration's name to an internal name. */\r\nfunction mangleInternalName(declaration, asGlobal) {\r\n    if (asGlobal === void 0) { asGlobal = false; }\r\n    var name = declaration.name.text;\r\n    var parent = declaration.parent;\r\n    if (!parent)\r\n        return name;\r\n    if (declaration.kind == NodeKind.VARIABLEDECLARATION &&\r\n        parent.kind == NodeKind.VARIABLE) {\r\n        if (!(parent = parent.parent))\r\n            return name;\r\n    }\r\n    if (parent.kind == NodeKind.CLASSDECLARATION) {\r\n        return mangleInternalName(parent, asGlobal) + (hasModifier(ModifierKind.STATIC, declaration.modifiers)\r\n            ? program_1.STATIC_DELIMITER\r\n            : program_1.INSTANCE_DELIMITER) + name;\r\n    }\r\n    if (parent.kind == NodeKind.NAMESPACEDECLARATION ||\r\n        parent.kind == NodeKind.ENUMDECLARATION) {\r\n        return mangleInternalName(parent, asGlobal) +\r\n            program_1.STATIC_DELIMITER + name;\r\n    }\r\n    return asGlobal\r\n        ? name\r\n        : declaration.range.source.internalPath + program_1.PATH_DELIMITER + name;\r\n}\r\nexports.mangleInternalName = mangleInternalName;\r\n/** Mangles an external to an internal path. */\r\nfunction mangleInternalPath(path) {\r\n    if (path.endsWith(\".ts\"))\r\n        path = path.substring(0, path.length - 3);\r\n    return path;\r\n}\r\nexports.mangleInternalPath = mangleInternalPath;\r\n// Helpers\r\nfunction setParent(nodes, parent) {\r\n    for (var i = 0, k = nodes.length; i < k; ++i) {\r\n        nodes[i].parent = parent;\r\n    }\r\n}\r\nfunction setParentOpt(nodes, parent) {\r\n    for (var i = 0, k = nodes.length; i < k; ++i) {\r\n        var node = nodes[i];\r\n        if (node)\r\n            node.parent = parent;\r\n    }\r\n}\r\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n/*\r\n\r\n This is a modified version of TypeScript's scanner that doesn't perform as much bookkeeping, simply\r\n skips over trivia and provides a more general mark/reset mechanism for the parser to utilize on\r\n ambiguous tokens.\r\n\r\n next()                 advances the token\r\n peek()                 peeks for the next token\r\n skip(token)            skips over a token if possible\r\n mark()                 marks at current token\r\n reset()                resets to marked state\r\n range()                gets the range of the current token\r\n\r\n readFloat()            on FLOATLITERAL\r\n readIdentifier()       on IDENTIFIER\r\n readInteger()          on INTEGERLITERAL\r\n readString()           on STRINGLITERAL\r\n\r\n*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar diagnostics_1 = __webpack_require__(1);\r\nvar charcode_1 = __webpack_require__(9);\r\n/** Named token types. */\r\nvar Token;\r\n(function (Token) {\r\n    // keywords\r\n    // discarded: ANY, BOOLEAN, NEVER, NUMBER, STRING, SYMBOL, UNDEFINED, LESSTHAN_SLASH\r\n    Token[Token[\"ABSTRACT\"] = 0] = \"ABSTRACT\";\r\n    Token[Token[\"AS\"] = 1] = \"AS\";\r\n    Token[Token[\"ASYNC\"] = 2] = \"ASYNC\";\r\n    Token[Token[\"AWAIT\"] = 3] = \"AWAIT\";\r\n    Token[Token[\"BREAK\"] = 4] = \"BREAK\";\r\n    Token[Token[\"CASE\"] = 5] = \"CASE\";\r\n    Token[Token[\"CATCH\"] = 6] = \"CATCH\";\r\n    Token[Token[\"CLASS\"] = 7] = \"CLASS\";\r\n    Token[Token[\"CONST\"] = 8] = \"CONST\";\r\n    Token[Token[\"CONTINUE\"] = 9] = \"CONTINUE\";\r\n    Token[Token[\"CONSTRUCTOR\"] = 10] = \"CONSTRUCTOR\";\r\n    Token[Token[\"DEBUGGER\"] = 11] = \"DEBUGGER\";\r\n    Token[Token[\"DECLARE\"] = 12] = \"DECLARE\";\r\n    Token[Token[\"DEFAULT\"] = 13] = \"DEFAULT\";\r\n    Token[Token[\"DELETE\"] = 14] = \"DELETE\";\r\n    Token[Token[\"DO\"] = 15] = \"DO\";\r\n    Token[Token[\"ELSE\"] = 16] = \"ELSE\";\r\n    Token[Token[\"ENUM\"] = 17] = \"ENUM\";\r\n    Token[Token[\"EXPORT\"] = 18] = \"EXPORT\";\r\n    Token[Token[\"EXTENDS\"] = 19] = \"EXTENDS\";\r\n    Token[Token[\"FALSE\"] = 20] = \"FALSE\";\r\n    Token[Token[\"FINALLY\"] = 21] = \"FINALLY\";\r\n    Token[Token[\"FOR\"] = 22] = \"FOR\";\r\n    Token[Token[\"FROM\"] = 23] = \"FROM\";\r\n    Token[Token[\"FUNCTION\"] = 24] = \"FUNCTION\";\r\n    Token[Token[\"GET\"] = 25] = \"GET\";\r\n    Token[Token[\"IF\"] = 26] = \"IF\";\r\n    Token[Token[\"IMPLEMENTS\"] = 27] = \"IMPLEMENTS\";\r\n    Token[Token[\"IMPORT\"] = 28] = \"IMPORT\";\r\n    Token[Token[\"IN\"] = 29] = \"IN\";\r\n    Token[Token[\"INSTANCEOF\"] = 30] = \"INSTANCEOF\";\r\n    Token[Token[\"INTERFACE\"] = 31] = \"INTERFACE\";\r\n    Token[Token[\"IS\"] = 32] = \"IS\";\r\n    Token[Token[\"KEYOF\"] = 33] = \"KEYOF\";\r\n    Token[Token[\"LET\"] = 34] = \"LET\";\r\n    Token[Token[\"MODULE\"] = 35] = \"MODULE\";\r\n    Token[Token[\"NAMESPACE\"] = 36] = \"NAMESPACE\";\r\n    Token[Token[\"NEW\"] = 37] = \"NEW\";\r\n    Token[Token[\"NULL\"] = 38] = \"NULL\";\r\n    Token[Token[\"OF\"] = 39] = \"OF\";\r\n    Token[Token[\"PACKAGE\"] = 40] = \"PACKAGE\";\r\n    Token[Token[\"PRIVATE\"] = 41] = \"PRIVATE\";\r\n    Token[Token[\"PROTECTED\"] = 42] = \"PROTECTED\";\r\n    Token[Token[\"PUBLIC\"] = 43] = \"PUBLIC\";\r\n    Token[Token[\"READONLY\"] = 44] = \"READONLY\";\r\n    Token[Token[\"RETURN\"] = 45] = \"RETURN\";\r\n    Token[Token[\"SET\"] = 46] = \"SET\";\r\n    Token[Token[\"STATIC\"] = 47] = \"STATIC\";\r\n    Token[Token[\"SUPER\"] = 48] = \"SUPER\";\r\n    Token[Token[\"SWITCH\"] = 49] = \"SWITCH\";\r\n    Token[Token[\"THIS\"] = 50] = \"THIS\";\r\n    Token[Token[\"THROW\"] = 51] = \"THROW\";\r\n    Token[Token[\"TRUE\"] = 52] = \"TRUE\";\r\n    Token[Token[\"TRY\"] = 53] = \"TRY\";\r\n    Token[Token[\"TYPE\"] = 54] = \"TYPE\";\r\n    Token[Token[\"TYPEOF\"] = 55] = \"TYPEOF\";\r\n    Token[Token[\"VAR\"] = 56] = \"VAR\";\r\n    Token[Token[\"VOID\"] = 57] = \"VOID\";\r\n    Token[Token[\"WHILE\"] = 58] = \"WHILE\";\r\n    Token[Token[\"WITH\"] = 59] = \"WITH\";\r\n    Token[Token[\"YIELD\"] = 60] = \"YIELD\";\r\n    // punctuation\r\n    Token[Token[\"OPENBRACE\"] = 61] = \"OPENBRACE\";\r\n    Token[Token[\"CLOSEBRACE\"] = 62] = \"CLOSEBRACE\";\r\n    Token[Token[\"OPENPAREN\"] = 63] = \"OPENPAREN\";\r\n    Token[Token[\"CLOSEPAREN\"] = 64] = \"CLOSEPAREN\";\r\n    Token[Token[\"OPENBRACKET\"] = 65] = \"OPENBRACKET\";\r\n    Token[Token[\"CLOSEBRACKET\"] = 66] = \"CLOSEBRACKET\";\r\n    Token[Token[\"DOT\"] = 67] = \"DOT\";\r\n    Token[Token[\"DOT_DOT_DOT\"] = 68] = \"DOT_DOT_DOT\";\r\n    Token[Token[\"SEMICOLON\"] = 69] = \"SEMICOLON\";\r\n    Token[Token[\"COMMA\"] = 70] = \"COMMA\";\r\n    Token[Token[\"LESSTHAN\"] = 71] = \"LESSTHAN\";\r\n    Token[Token[\"GREATERTHAN\"] = 72] = \"GREATERTHAN\";\r\n    Token[Token[\"LESSTHAN_EQUALS\"] = 73] = \"LESSTHAN_EQUALS\";\r\n    Token[Token[\"GREATERTHAN_EQUALS\"] = 74] = \"GREATERTHAN_EQUALS\";\r\n    Token[Token[\"EQUALS_EQUALS\"] = 75] = \"EQUALS_EQUALS\";\r\n    Token[Token[\"EXCLAMATION_EQUALS\"] = 76] = \"EXCLAMATION_EQUALS\";\r\n    Token[Token[\"EQUALS_EQUALS_EQUALS\"] = 77] = \"EQUALS_EQUALS_EQUALS\";\r\n    Token[Token[\"EXCLAMATION_EQUALS_EQUALS\"] = 78] = \"EXCLAMATION_EQUALS_EQUALS\";\r\n    Token[Token[\"EQUALS_GREATERTHAN\"] = 79] = \"EQUALS_GREATERTHAN\";\r\n    Token[Token[\"PLUS\"] = 80] = \"PLUS\";\r\n    Token[Token[\"MINUS\"] = 81] = \"MINUS\";\r\n    Token[Token[\"ASTERISK_ASTERISK\"] = 82] = \"ASTERISK_ASTERISK\";\r\n    Token[Token[\"ASTERISK\"] = 83] = \"ASTERISK\";\r\n    Token[Token[\"SLASH\"] = 84] = \"SLASH\";\r\n    Token[Token[\"PERCENT\"] = 85] = \"PERCENT\";\r\n    Token[Token[\"PLUS_PLUS\"] = 86] = \"PLUS_PLUS\";\r\n    Token[Token[\"MINUS_MINUS\"] = 87] = \"MINUS_MINUS\";\r\n    Token[Token[\"LESSTHAN_LESSTHAN\"] = 88] = \"LESSTHAN_LESSTHAN\";\r\n    Token[Token[\"GREATERTHAN_GREATERTHAN\"] = 89] = \"GREATERTHAN_GREATERTHAN\";\r\n    Token[Token[\"GREATERTHAN_GREATERTHAN_GREATERTHAN\"] = 90] = \"GREATERTHAN_GREATERTHAN_GREATERTHAN\";\r\n    Token[Token[\"AMPERSAND\"] = 91] = \"AMPERSAND\";\r\n    Token[Token[\"BAR\"] = 92] = \"BAR\";\r\n    Token[Token[\"CARET\"] = 93] = \"CARET\";\r\n    Token[Token[\"EXCLAMATION\"] = 94] = \"EXCLAMATION\";\r\n    Token[Token[\"TILDE\"] = 95] = \"TILDE\";\r\n    Token[Token[\"AMPERSAND_AMPERSAND\"] = 96] = \"AMPERSAND_AMPERSAND\";\r\n    Token[Token[\"BAR_BAR\"] = 97] = \"BAR_BAR\";\r\n    Token[Token[\"QUESTION\"] = 98] = \"QUESTION\";\r\n    Token[Token[\"COLON\"] = 99] = \"COLON\";\r\n    Token[Token[\"EQUALS\"] = 100] = \"EQUALS\";\r\n    Token[Token[\"PLUS_EQUALS\"] = 101] = \"PLUS_EQUALS\";\r\n    Token[Token[\"MINUS_EQUALS\"] = 102] = \"MINUS_EQUALS\";\r\n    Token[Token[\"ASTERISK_EQUALS\"] = 103] = \"ASTERISK_EQUALS\";\r\n    Token[Token[\"ASTERISK_ASTERISK_EQUALS\"] = 104] = \"ASTERISK_ASTERISK_EQUALS\";\r\n    Token[Token[\"SLASH_EQUALS\"] = 105] = \"SLASH_EQUALS\";\r\n    Token[Token[\"PERCENT_EQUALS\"] = 106] = \"PERCENT_EQUALS\";\r\n    Token[Token[\"LESSTHAN_LESSTHAN_EQUALS\"] = 107] = \"LESSTHAN_LESSTHAN_EQUALS\";\r\n    Token[Token[\"GREATERTHAN_GREATERTHAN_EQUALS\"] = 108] = \"GREATERTHAN_GREATERTHAN_EQUALS\";\r\n    Token[Token[\"GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS\"] = 109] = \"GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS\";\r\n    Token[Token[\"AMPERSAND_EQUALS\"] = 110] = \"AMPERSAND_EQUALS\";\r\n    Token[Token[\"BAR_EQUALS\"] = 111] = \"BAR_EQUALS\";\r\n    Token[Token[\"CARET_EQUALS\"] = 112] = \"CARET_EQUALS\";\r\n    Token[Token[\"AT\"] = 113] = \"AT\";\r\n    // literals\r\n    Token[Token[\"IDENTIFIER\"] = 114] = \"IDENTIFIER\";\r\n    Token[Token[\"STRINGLITERAL\"] = 115] = \"STRINGLITERAL\";\r\n    Token[Token[\"INTEGERLITERAL\"] = 116] = \"INTEGERLITERAL\";\r\n    Token[Token[\"FLOATLITERAL\"] = 117] = \"FLOATLITERAL\";\r\n    // meta\r\n    Token[Token[\"INVALID\"] = 118] = \"INVALID\";\r\n    Token[Token[\"ENDOFFILE\"] = 119] = \"ENDOFFILE\";\r\n})(Token = exports.Token || (exports.Token = {}));\r\n(function (Token) {\r\n    function fromKeyword(text) {\r\n        switch (text) {\r\n            case \"abstract\": return Token.ABSTRACT;\r\n            case \"as\": return Token.AS;\r\n            case \"async\": return Token.ASYNC;\r\n            case \"await\": return Token.AWAIT;\r\n            case \"break\": return Token.BREAK;\r\n            case \"case\": return Token.CASE;\r\n            case \"catch\": return Token.CATCH;\r\n            case \"class\": return Token.CLASS;\r\n            case \"continue\": return Token.CONTINUE;\r\n            case \"const\": return Token.CONST;\r\n            case \"constructor\": return Token.CONSTRUCTOR;\r\n            case \"debugger\": return Token.DEBUGGER;\r\n            case \"declare\": return Token.DECLARE;\r\n            case \"default\": return Token.DEFAULT;\r\n            case \"delete\": return Token.DELETE;\r\n            case \"do\": return Token.DO;\r\n            case \"else\": return Token.ELSE;\r\n            case \"enum\": return Token.ENUM;\r\n            case \"export\": return Token.EXPORT;\r\n            case \"extends\": return Token.EXTENDS;\r\n            case \"false\": return Token.FALSE;\r\n            case \"finally\": return Token.FINALLY;\r\n            case \"for\": return Token.FOR;\r\n            case \"from\": return Token.FROM;\r\n            case \"function\": return Token.FUNCTION;\r\n            case \"get\": return Token.GET;\r\n            case \"if\": return Token.IF;\r\n            case \"implements\": return Token.IMPLEMENTS;\r\n            case \"import\": return Token.IMPORT;\r\n            case \"in\": return Token.IN;\r\n            case \"instanceof\": return Token.INSTANCEOF;\r\n            case \"interface\": return Token.INTERFACE;\r\n            case \"is\": return Token.IS;\r\n            case \"keyof\": return Token.KEYOF;\r\n            case \"let\": return Token.LET;\r\n            case \"module\": return Token.MODULE;\r\n            case \"namespace\": return Token.NAMESPACE;\r\n            case \"new\": return Token.NEW;\r\n            case \"null\": return Token.NULL;\r\n            case \"of\": return Token.OF;\r\n            case \"package\": return Token.PACKAGE;\r\n            case \"private\": return Token.PRIVATE;\r\n            case \"protected\": return Token.PROTECTED;\r\n            case \"public\": return Token.PUBLIC;\r\n            case \"readonly\": return Token.READONLY;\r\n            case \"return\": return Token.RETURN;\r\n            case \"set\": return Token.SET;\r\n            case \"static\": return Token.STATIC;\r\n            case \"super\": return Token.SUPER;\r\n            case \"switch\": return Token.SWITCH;\r\n            case \"this\": return Token.THIS;\r\n            case \"throw\": return Token.THROW;\r\n            case \"true\": return Token.TRUE;\r\n            case \"try\": return Token.TRY;\r\n            case \"type\": return Token.TYPE;\r\n            case \"typeof\": return Token.TYPEOF;\r\n            case \"var\": return Token.VAR;\r\n            case \"void\": return Token.VOID;\r\n            case \"while\": return Token.WHILE;\r\n            case \"with\": return Token.WITH;\r\n            case \"yield\": return Token.YIELD;\r\n            default: return Token.INVALID;\r\n        }\r\n    }\r\n    Token.fromKeyword = fromKeyword;\r\n    function isAlsoIdentifier(token) {\r\n        switch (token) {\r\n            case Token.ABSTRACT:\r\n            case Token.AS:\r\n            case Token.CONSTRUCTOR:\r\n            case Token.DECLARE:\r\n            case Token.DELETE:\r\n            case Token.FROM:\r\n            case Token.GET:\r\n            case Token.IS:\r\n            case Token.KEYOF:\r\n            case Token.MODULE:\r\n            case Token.NAMESPACE:\r\n            case Token.READONLY:\r\n            case Token.SET:\r\n            case Token.TYPE:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    Token.isAlsoIdentifier = isAlsoIdentifier;\r\n    function operatorToString(token) {\r\n        switch (token) {\r\n            case Token.DELETE: return \"delete\";\r\n            case Token.IN: return \"in\";\r\n            case Token.INSTANCEOF: return \"instanceof\";\r\n            case Token.NEW: return \"new\";\r\n            case Token.TYPEOF: return \"typeof\";\r\n            case Token.VOID: return \"void\";\r\n            case Token.YIELD: return \"yield\";\r\n            case Token.DOT_DOT_DOT: return \"...\";\r\n            case Token.COMMA: return \",\";\r\n            case Token.LESSTHAN: return \"<\";\r\n            case Token.GREATERTHAN: return \">\";\r\n            case Token.LESSTHAN_EQUALS: return \"<=\";\r\n            case Token.GREATERTHAN_EQUALS: return \">=\";\r\n            case Token.EQUALS_EQUALS: return \"==\";\r\n            case Token.EXCLAMATION_EQUALS: return \"!=\";\r\n            case Token.EQUALS_EQUALS_EQUALS: return \"===\";\r\n            case Token.EXCLAMATION_EQUALS_EQUALS: return \"!==\";\r\n            case Token.PLUS: return \"+\";\r\n            case Token.MINUS: return \"-\";\r\n            case Token.ASTERISK_ASTERISK: return \"**\";\r\n            case Token.ASTERISK: return \"*\";\r\n            case Token.SLASH: return \"/\";\r\n            case Token.PERCENT: return \"%\";\r\n            case Token.PLUS_PLUS: return \"++\";\r\n            case Token.MINUS_MINUS: return \"--\";\r\n            case Token.LESSTHAN_LESSTHAN: return \"<<\";\r\n            case Token.GREATERTHAN_GREATERTHAN: return \">>\";\r\n            case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return \">>>\";\r\n            case Token.AMPERSAND: return \"&\";\r\n            case Token.BAR: return \"|\";\r\n            case Token.CARET: return \"^\";\r\n            case Token.EXCLAMATION: return \"!\";\r\n            case Token.TILDE: return \"~\";\r\n            case Token.AMPERSAND_AMPERSAND: return \"&&\";\r\n            case Token.BAR_BAR: return \"||\";\r\n            case Token.EQUALS: return \"=\";\r\n            case Token.PLUS_EQUALS: return \"+=\";\r\n            case Token.MINUS_EQUALS: return \"-=\";\r\n            case Token.ASTERISK_EQUALS: return \"*=\";\r\n            case Token.ASTERISK_ASTERISK_EQUALS: return \"**=\";\r\n            case Token.SLASH_EQUALS: return \"/=\";\r\n            case Token.PERCENT_EQUALS: return \"%=\";\r\n            case Token.LESSTHAN_LESSTHAN_EQUALS: return \"<<=\";\r\n            case Token.GREATERTHAN_GREATERTHAN_EQUALS: return \">>=\";\r\n            case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return \">>>=\";\r\n            case Token.AMPERSAND_EQUALS: return \"&=\";\r\n            case Token.BAR_EQUALS: return \"|=\";\r\n            case Token.CARET_EQUALS: return \"^=\";\r\n            default:\r\n                assert(false);\r\n                return \"\";\r\n        }\r\n    }\r\n    Token.operatorToString = operatorToString;\r\n})(Token = exports.Token || (exports.Token = {}));\r\nvar Range = /** @class */ (function () {\r\n    // TODO: set these while tokenizing\r\n    // line: i32;\r\n    // column: i32;\r\n    function Range(source, start, end) {\r\n        this.debugInfoRef = 0;\r\n        this.source = source;\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n    Range.join = function (a, b) {\r\n        if (a.source != b.source)\r\n            throw new Error(\"source mismatch\");\r\n        return new Range(a.source, a.start < b.start ? a.start : b.start, a.end > b.end ? a.end : b.end);\r\n    };\r\n    Object.defineProperty(Range.prototype, \"atStart\", {\r\n        get: function () {\r\n            return new Range(this.source, this.start, this.start);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Range.prototype, \"atEnd\", {\r\n        get: function () {\r\n            return new Range(this.source, this.end, this.end);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Range.prototype, \"line\", {\r\n        get: function () {\r\n            var text = this.source.text;\r\n            var pos = this.start;\r\n            var line = 1;\r\n            while (pos-- > 0) {\r\n                if (text.charCodeAt(pos) == 10 /* LINEFEED */) {\r\n                    line++;\r\n                }\r\n            }\r\n            return line;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Range.prototype, \"column\", {\r\n        get: function () {\r\n            var text = this.source.text;\r\n            var pos = this.start;\r\n            var column = 0;\r\n            while (pos-- > 0) {\r\n                if (text.charCodeAt(pos) == 10 /* LINEFEED */)\r\n                    break;\r\n                column++;\r\n            }\r\n            return column;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Range.prototype.toString = function () {\r\n        return this.source.text.substring(this.start, this.end);\r\n    };\r\n    return Range;\r\n}());\r\nexports.Range = Range;\r\nvar Tokenizer = /** @class */ (function (_super) {\r\n    __extends(Tokenizer, _super);\r\n    function Tokenizer(source, diagnostics) {\r\n        if (diagnostics === void 0) { diagnostics = null; }\r\n        var _this = _super.call(this, diagnostics) || this;\r\n        _this.end = 0;\r\n        _this.pos = 0;\r\n        _this.token = -1;\r\n        _this.tokenPos = 0;\r\n        _this.markedPos = 0;\r\n        _this.markedToken = -1;\r\n        _this.markedTokenPos = 0;\r\n        _this.nextToken = -1;\r\n        _this.nextTokenOnNewLine = false;\r\n        _this.source = source;\r\n        _this.pos = 0;\r\n        _this.end = source.text.length;\r\n        _this.diagnostics = diagnostics ? diagnostics : new Array();\r\n        var text = source.text;\r\n        // skip bom\r\n        if (_this.pos < _this.end &&\r\n            text.charCodeAt(_this.pos) == 65279 /* BYTEORDERMARK */) {\r\n            ++_this.pos;\r\n        }\r\n        // skip shebang\r\n        if (_this.pos + 1 < _this.end &&\r\n            text.charCodeAt(_this.pos) == 35 /* HASH */ &&\r\n            text.charCodeAt(_this.pos + 1) == 33 /* EXCLAMATION */) {\r\n            _this.pos += 2;\r\n            while (_this.pos < _this.end &&\r\n                text.charCodeAt(_this.pos) != 10 /* LINEFEED */) {\r\n                ++_this.pos;\r\n            }\r\n            // 'next' now starts at lf or eof\r\n        }\r\n        return _this;\r\n    }\r\n    Tokenizer.prototype.next = function (preferIdentifier) {\r\n        if (preferIdentifier === void 0) { preferIdentifier = false; }\r\n        this.nextToken = -1;\r\n        return this.token = this.unsafeNext(preferIdentifier);\r\n    };\r\n    Tokenizer.prototype.unsafeNext = function (preferIdentifier, maxTokenLength) {\r\n        if (preferIdentifier === void 0) { preferIdentifier = false; }\r\n        if (maxTokenLength === void 0) { maxTokenLength = i32.MAX_VALUE; }\r\n        var text = this.source.text;\r\n        while (this.pos < this.end) {\r\n            this.tokenPos = this.pos;\r\n            var c = text.charCodeAt(this.pos);\r\n            switch (c) {\r\n                case 13 /* CARRIAGERETURN */:\r\n                    if (++this.pos < this.end &&\r\n                        text.charCodeAt(this.pos) == 10 /* LINEFEED */) {\r\n                        ++this.pos;\r\n                    }\r\n                    break;\r\n                case 10 /* LINEFEED */:\r\n                case 9 /* TAB */:\r\n                case 11 /* VERTICALTAB */:\r\n                case 12 /* FORMFEED */:\r\n                case 32 /* SPACE */:\r\n                    ++this.pos;\r\n                    break;\r\n                case 33 /* EXCLAMATION */:\r\n                    ++this.pos;\r\n                    if (maxTokenLength > 1 && this.pos < this.end &&\r\n                        text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                        ++this.pos;\r\n                        if (maxTokenLength > 2 && this.pos < this.end &&\r\n                            text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                            ++this.pos;\r\n                            return Token.EXCLAMATION_EQUALS_EQUALS;\r\n                        }\r\n                        return Token.EXCLAMATION_EQUALS;\r\n                    }\r\n                    return Token.EXCLAMATION;\r\n                case 34 /* DOUBLEQUOTE */:\r\n                case 39 /* SINGLEQUOTE */:\r\n                case 96 /* BACKTICK */:// TODO\r\n                    return Token.STRINGLITERAL; // expects a call to readString\r\n                case 37 /* PERCENT */:\r\n                    ++this.pos;\r\n                    if (maxTokenLength > 1 && this.pos < this.end &&\r\n                        text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                        ++this.pos;\r\n                        return Token.PERCENT_EQUALS;\r\n                    }\r\n                    return Token.PERCENT;\r\n                case 38 /* AMPERSAND */:\r\n                    ++this.pos;\r\n                    if (maxTokenLength > 1 && this.pos < this.end) {\r\n                        if (text.charCodeAt(this.pos) == 38 /* AMPERSAND */) {\r\n                            ++this.pos;\r\n                            return Token.AMPERSAND_AMPERSAND;\r\n                        }\r\n                        if (text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                            ++this.pos;\r\n                            return Token.AMPERSAND_EQUALS;\r\n                        }\r\n                    }\r\n                    return Token.AMPERSAND;\r\n                case 40 /* OPENPAREN */:\r\n                    ++this.pos;\r\n                    return Token.OPENPAREN;\r\n                case 41 /* CLOSEPAREN */:\r\n                    ++this.pos;\r\n                    return Token.CLOSEPAREN;\r\n                case 42 /* ASTERISK */:\r\n                    ++this.pos;\r\n                    if (maxTokenLength > 1 && this.pos < this.end) {\r\n                        if (text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                            ++this.pos;\r\n                            return Token.ASTERISK_EQUALS;\r\n                        }\r\n                        if (text.charCodeAt(this.pos) == 42 /* ASTERISK */) {\r\n                            ++this.pos;\r\n                            if (maxTokenLength > 2 && this.pos < this.end &&\r\n                                text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                                ++this.pos;\r\n                                return Token.ASTERISK_ASTERISK_EQUALS;\r\n                            }\r\n                            return Token.ASTERISK_ASTERISK;\r\n                        }\r\n                    }\r\n                    return Token.ASTERISK;\r\n                case 43 /* PLUS */:\r\n                    ++this.pos;\r\n                    if (maxTokenLength > 1 && this.pos < this.end) {\r\n                        if (text.charCodeAt(this.pos) == 43 /* PLUS */) {\r\n                            ++this.pos;\r\n                            return Token.PLUS_PLUS;\r\n                        }\r\n                        if (text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                            ++this.pos;\r\n                            return Token.PLUS_EQUALS;\r\n                        }\r\n                    }\r\n                    return Token.PLUS;\r\n                case 44 /* COMMA */:\r\n                    ++this.pos;\r\n                    return Token.COMMA;\r\n                case 45 /* MINUS */:\r\n                    ++this.pos;\r\n                    if (maxTokenLength > 1 && this.pos < this.end) {\r\n                        if (text.charCodeAt(this.pos) == 45 /* MINUS */) {\r\n                            ++this.pos;\r\n                            return Token.MINUS_MINUS;\r\n                        }\r\n                        if (text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                            ++this.pos;\r\n                            return Token.MINUS_EQUALS;\r\n                        }\r\n                    }\r\n                    return Token.MINUS;\r\n                case 46 /* DOT */:\r\n                    ++this.pos;\r\n                    if (maxTokenLength > 1 && this.pos < this.end) {\r\n                        if (charcode_1.isDecimalDigit(text.charCodeAt(this.pos))) {\r\n                            --this.pos;\r\n                            return Token.FLOATLITERAL; // expects a call to readFloat\r\n                        }\r\n                        if (maxTokenLength > 2 && this.pos + 1 < this.end &&\r\n                            text.charCodeAt(this.pos) == 46 /* DOT */ &&\r\n                            text.charCodeAt(this.pos + 1) == 46 /* DOT */) {\r\n                            this.pos += 2;\r\n                            return Token.DOT_DOT_DOT;\r\n                        }\r\n                    }\r\n                    return Token.DOT;\r\n                case 47 /* SLASH */:\r\n                    ++this.pos;\r\n                    if (maxTokenLength > 1 && this.pos < this.end) {\r\n                        if (text.charCodeAt(this.pos) == 47 /* SLASH */) {\r\n                            // TODO: triple-slash?\r\n                            // if (\r\n                            //   this.pos + 1 < this.end &&\r\n                            //   text.charCodeAt(this.pos + 1) == CharCode.SLASH\r\n                            // ) {\r\n                            // }\r\n                            while (++this.pos < this.end) {\r\n                                if (charcode_1.isLineBreak(text.charCodeAt(this.pos)))\r\n                                    break;\r\n                            }\r\n                            continue;\r\n                        }\r\n                        if (text.charCodeAt(this.pos) == 42 /* ASTERISK */) {\r\n                            var closed = false;\r\n                            while (++this.pos < this.end) {\r\n                                c = text.charCodeAt(this.pos);\r\n                                if (c == 42 /* ASTERISK */ &&\r\n                                    this.pos + 1 < this.end &&\r\n                                    text.charCodeAt(this.pos + 1) == 47 /* SLASH */) {\r\n                                    this.pos += 2;\r\n                                    closed = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                            if (!closed) {\r\n                                this.error(diagnostics_1.DiagnosticCode._0_expected, this.range(this.pos), \"*/\");\r\n                            }\r\n                            continue;\r\n                        }\r\n                        if (text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                            ++this.pos;\r\n                            return Token.SLASH_EQUALS;\r\n                        }\r\n                    }\r\n                    return Token.SLASH;\r\n                case 48 /* _0 */:\r\n                case 49 /* _1 */:\r\n                case 50 /* _2 */:\r\n                case 51 /* _3 */:\r\n                case 52 /* _4 */:\r\n                case 53 /* _5 */:\r\n                case 54 /* _6 */:\r\n                case 55 /* _7 */:\r\n                case 56 /* _8 */:\r\n                case 57 /* _9 */:\r\n                    return this.testInteger()\r\n                        ? Token.INTEGERLITERAL // expects a call to readInteger\r\n                        : Token.FLOATLITERAL; // expects a call to readFloat\r\n                case 58 /* COLON */:\r\n                    ++this.pos;\r\n                    return Token.COLON;\r\n                case 59 /* SEMICOLON */:\r\n                    ++this.pos;\r\n                    return Token.SEMICOLON;\r\n                case 60 /* LESSTHAN */:\r\n                    ++this.pos;\r\n                    if (maxTokenLength > 1 && this.pos < this.end) {\r\n                        if (text.charCodeAt(this.pos) == 60 /* LESSTHAN */) {\r\n                            ++this.pos;\r\n                            if (maxTokenLength > 2 &&\r\n                                this.pos < this.end &&\r\n                                text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                                ++this.pos;\r\n                                return Token.LESSTHAN_LESSTHAN_EQUALS;\r\n                            }\r\n                            return Token.LESSTHAN_LESSTHAN;\r\n                        }\r\n                        if (text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                            ++this.pos;\r\n                            return Token.LESSTHAN_EQUALS;\r\n                        }\r\n                    }\r\n                    return Token.LESSTHAN;\r\n                case 61 /* EQUALS */:\r\n                    ++this.pos;\r\n                    if (maxTokenLength > 1 && this.pos < this.end) {\r\n                        if (text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                            ++this.pos;\r\n                            if (maxTokenLength > 2 &&\r\n                                this.pos < this.end &&\r\n                                text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                                ++this.pos;\r\n                                return Token.EQUALS_EQUALS_EQUALS;\r\n                            }\r\n                            return Token.EQUALS_EQUALS;\r\n                        }\r\n                        if (text.charCodeAt(this.pos) == 62 /* GREATERTHAN */) {\r\n                            ++this.pos;\r\n                            return Token.EQUALS_GREATERTHAN;\r\n                        }\r\n                    }\r\n                    return Token.EQUALS;\r\n                case 62 /* GREATERTHAN */:\r\n                    ++this.pos;\r\n                    if (maxTokenLength > 1 && this.pos < this.end) {\r\n                        if (text.charCodeAt(this.pos) == 62 /* GREATERTHAN */) {\r\n                            ++this.pos;\r\n                            if (maxTokenLength > 2 && this.pos < this.end) {\r\n                                if (text.charCodeAt(this.pos) == 62 /* GREATERTHAN */) {\r\n                                    ++this.pos;\r\n                                    if (maxTokenLength > 3 && this.pos < this.end &&\r\n                                        text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                                        ++this.pos;\r\n                                        return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS;\r\n                                    }\r\n                                    return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN;\r\n                                }\r\n                                if (text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                                    ++this.pos;\r\n                                    return Token.GREATERTHAN_GREATERTHAN_EQUALS;\r\n                                }\r\n                            }\r\n                            return Token.GREATERTHAN_GREATERTHAN;\r\n                        }\r\n                        if (text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                            ++this.pos;\r\n                            return Token.GREATERTHAN_EQUALS;\r\n                        }\r\n                    }\r\n                    return Token.GREATERTHAN;\r\n                case 63 /* QUESTION */:\r\n                    ++this.pos;\r\n                    return Token.QUESTION;\r\n                case 91 /* OPENBRACKET */:\r\n                    ++this.pos;\r\n                    return Token.OPENBRACKET;\r\n                case 93 /* CLOSEBRACKET */:\r\n                    ++this.pos;\r\n                    return Token.CLOSEBRACKET;\r\n                case 94 /* CARET */:\r\n                    ++this.pos;\r\n                    if (maxTokenLength > 1 && this.pos < this.end &&\r\n                        text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                        ++this.pos;\r\n                        return Token.CARET_EQUALS;\r\n                    }\r\n                    return Token.CARET;\r\n                case 123 /* OPENBRACE */:\r\n                    ++this.pos;\r\n                    return Token.OPENBRACE;\r\n                case 124 /* BAR */:\r\n                    ++this.pos;\r\n                    if (maxTokenLength > 1 && this.pos < this.end) {\r\n                        if (text.charCodeAt(this.pos) == 124 /* BAR */) {\r\n                            ++this.pos;\r\n                            return Token.BAR_BAR;\r\n                        }\r\n                        if (text.charCodeAt(this.pos) == 61 /* EQUALS */) {\r\n                            ++this.pos;\r\n                            return Token.BAR_EQUALS;\r\n                        }\r\n                    }\r\n                    return Token.BAR;\r\n                case 125 /* CLOSEBRACE */:\r\n                    ++this.pos;\r\n                    return Token.CLOSEBRACE;\r\n                case 126 /* TILDE */:\r\n                    ++this.pos;\r\n                    return Token.TILDE;\r\n                case 64 /* AT */:\r\n                    ++this.pos;\r\n                    return Token.AT;\r\n                default:\r\n                    if (charcode_1.isIdentifierStart(c)) {\r\n                        if (charcode_1.isKeywordCharacter(c)) {\r\n                            var posBefore = this.pos;\r\n                            while (++this.pos < this.end &&\r\n                                charcode_1.isIdentifierPart(c = text.charCodeAt(this.pos))) {\r\n                                if (!charcode_1.isKeywordCharacter(c)) {\r\n                                    this.pos = posBefore;\r\n                                    return Token.IDENTIFIER;\r\n                                }\r\n                            }\r\n                            var keywordText = text.substring(posBefore, this.pos);\r\n                            var keywordToken = Token.fromKeyword(keywordText);\r\n                            if (keywordToken != Token.INVALID &&\r\n                                !(preferIdentifier && Token.isAlsoIdentifier(keywordToken))) {\r\n                                return keywordToken;\r\n                            }\r\n                            this.pos = posBefore;\r\n                        }\r\n                        return Token.IDENTIFIER; // expects a call to readIdentifier\r\n                    }\r\n                    else if (charcode_1.isWhiteSpace(c)) {\r\n                        ++this.pos;\r\n                        break;\r\n                    }\r\n                    this.error(diagnostics_1.DiagnosticCode.Invalid_character, this.range(this.pos, this.pos + 1));\r\n                    ++this.pos;\r\n                    return Token.INVALID;\r\n            }\r\n        }\r\n        return Token.ENDOFFILE;\r\n    };\r\n    Tokenizer.prototype.peek = function (checkOnNewLine, preferIdentifier, maxCompoundLength) {\r\n        if (checkOnNewLine === void 0) { checkOnNewLine = false; }\r\n        if (preferIdentifier === void 0) { preferIdentifier = false; }\r\n        if (maxCompoundLength === void 0) { maxCompoundLength = i32.MAX_VALUE; }\r\n        var text = this.source.text;\r\n        if (this.nextToken < 0) {\r\n            var posBefore = this.pos;\r\n            var tokenBefore = this.token;\r\n            var tokenPosBefore = this.tokenPos;\r\n            this.nextToken = this.unsafeNext(preferIdentifier, maxCompoundLength);\r\n            if (checkOnNewLine) {\r\n                this.nextTokenOnNewLine = false;\r\n                while (--this.tokenPos > posBefore) {\r\n                    if (charcode_1.isLineBreak(text.charCodeAt(this.tokenPos))) {\r\n                        this.nextTokenOnNewLine = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            this.pos = posBefore;\r\n            this.token = tokenBefore;\r\n            this.tokenPos = tokenPosBefore;\r\n        }\r\n        return this.nextToken;\r\n    };\r\n    Tokenizer.prototype.skip = function (token) {\r\n        var posBefore = this.pos;\r\n        var tokenBefore = this.token;\r\n        var tokenPosBefore = this.tokenPos;\r\n        var maxCompoundLength = i32.MAX_VALUE;\r\n        switch (token) {\r\n            case Token.GREATERTHAN:// where parsing type arguments\r\n                maxCompoundLength = 1;\r\n                break;\r\n        }\r\n        this.token = this.unsafeNext(token == Token.IDENTIFIER, maxCompoundLength);\r\n        if (this.token == token) {\r\n            this.nextToken = -1;\r\n            return true;\r\n        }\r\n        else {\r\n            this.pos = posBefore;\r\n            this.token = tokenBefore;\r\n            this.tokenPos = tokenPosBefore;\r\n            return false;\r\n        }\r\n    };\r\n    // skipUntil(token1: Token, token2: Token = -1): bool {\r\n    //   var next: Token;\r\n    //   do {\r\n    //     if ((next = this.peek()) == Token.ENDOFFILE)\r\n    //       return false;\r\n    //     if (next == token1 || next == token2)\r\n    //       return true;\r\n    //     this.next();\r\n    //   } while (true);\r\n    // }\r\n    Tokenizer.prototype.mark = function () {\r\n        this.markedPos = this.pos;\r\n        this.markedToken = this.token;\r\n        this.markedTokenPos = this.tokenPos;\r\n    };\r\n    Tokenizer.prototype.reset = function () {\r\n        this.pos = this.markedPos;\r\n        this.token = this.markedToken;\r\n        this.tokenPos = this.markedTokenPos;\r\n        this.nextToken = -1;\r\n    };\r\n    Tokenizer.prototype.range = function (start, end) {\r\n        if (start === void 0) { start = -1; }\r\n        if (end === void 0) { end = -1; }\r\n        if (start < 0) {\r\n            start = this.tokenPos;\r\n            end = this.pos;\r\n        }\r\n        else if (end < 0) {\r\n            end = start;\r\n        }\r\n        return new Range(this.source, start, end);\r\n    };\r\n    Tokenizer.prototype.readIdentifier = function () {\r\n        var text = this.source.text;\r\n        var start = this.pos;\r\n        while (++this.pos < this.end &&\r\n            charcode_1.isIdentifierPart(text.charCodeAt(this.pos)))\r\n            ;\r\n        return text.substring(start, this.pos);\r\n    };\r\n    Tokenizer.prototype.readString = function () {\r\n        var text = this.source.text;\r\n        var quote = text.charCodeAt(this.pos++);\r\n        var start = this.pos;\r\n        var result = \"\";\r\n        while (true) {\r\n            if (this.pos >= this.end) {\r\n                result += text.substring(start, this.pos);\r\n                this.error(diagnostics_1.DiagnosticCode.Unterminated_string_literal, this.range(start - 1, this.end));\r\n                break;\r\n            }\r\n            var c = text.charCodeAt(this.pos);\r\n            if (c == quote) {\r\n                result += text.substring(start, this.pos++);\r\n                break;\r\n            }\r\n            if (c == 92 /* BACKSLASH */) {\r\n                result += text.substring(start, this.pos);\r\n                result += this.readEscapeSequence();\r\n                start = this.pos;\r\n                continue;\r\n            }\r\n            if (charcode_1.isLineBreak(c)) {\r\n                result += text.substring(start, this.pos);\r\n                this.error(diagnostics_1.DiagnosticCode.Unterminated_string_literal, this.range(start - 1, this.pos));\r\n                break;\r\n            }\r\n            ++this.pos;\r\n        }\r\n        return result;\r\n    };\r\n    Tokenizer.prototype.readEscapeSequence = function () {\r\n        if (++this.pos >= this.end) {\r\n            this.error(diagnostics_1.DiagnosticCode.Unexpected_end_of_text, this.range(this.end));\r\n            return \"\";\r\n        }\r\n        var text = this.source.text;\r\n        var c = text.charCodeAt(this.pos++);\r\n        switch (c) {\r\n            case 48 /* _0 */:\r\n                return \"\\0\";\r\n            case 98 /* b */:\r\n                return \"\\b\";\r\n            case 116 /* t */:\r\n                return \"\\t\";\r\n            case 110 /* n */:\r\n                return \"\\n\";\r\n            case 118 /* v */:\r\n                return \"\\v\";\r\n            case 102 /* f */:\r\n                return \"\\f\";\r\n            case 114 /* r */:\r\n                return \"\\r\";\r\n            case 39 /* SINGLEQUOTE */:\r\n                return \"'\";\r\n            case 34 /* DOUBLEQUOTE */:\r\n                return \"\\\"\";\r\n            case 117 /* u */: {\r\n                if (this.pos < this.end &&\r\n                    text.charCodeAt(this.pos) == 123 /* OPENBRACE */) {\r\n                    ++this.pos;\r\n                    return this.readExtendedUnicodeEscape(); // \\u{DDDDDDDD}\r\n                }\r\n                return this.readUnicodeEscape(); // \\uDDDD\r\n            }\r\n            case 13 /* CARRIAGERETURN */:\r\n                if (this.pos < this.end &&\r\n                    text.charCodeAt(this.pos) == 10 /* LINEFEED */) {\r\n                    ++this.pos;\r\n                }\r\n            // fall through\r\n            case 10 /* LINEFEED */:\r\n            case 8232 /* LINESEPARATOR */:\r\n            case 8233 /* PARAGRAPHSEPARATOR */:\r\n                return \"\";\r\n            default:\r\n                return String.fromCharCode(c);\r\n        }\r\n    };\r\n    Tokenizer.prototype.readRegexpPattern = function () {\r\n        var text = this.source.text;\r\n        var start = this.pos;\r\n        var escaped = false;\r\n        while (true) {\r\n            if (this.pos >= this.end) {\r\n                this.error(diagnostics_1.DiagnosticCode.Unterminated_regular_expression_literal, this.range(start, this.end));\r\n                break;\r\n            }\r\n            if (text.charCodeAt(this.pos) == 92 /* BACKSLASH */) {\r\n                ++this.pos;\r\n                escaped = true;\r\n                continue;\r\n            }\r\n            var c = text.charCodeAt(this.pos);\r\n            if (c == 47 /* SLASH */ && !escaped)\r\n                break;\r\n            if (charcode_1.isLineBreak(c)) {\r\n                this.error(diagnostics_1.DiagnosticCode.Unterminated_regular_expression_literal, this.range(start, this.pos));\r\n                break;\r\n            }\r\n            ++this.pos;\r\n            escaped = false;\r\n        }\r\n        return text.substring(start, this.pos);\r\n    };\r\n    Tokenizer.prototype.readRegexpFlags = function () {\r\n        var text = this.source.text;\r\n        var start = this.pos;\r\n        var flags = 0;\r\n        while (this.pos < this.end) {\r\n            var c = text.charCodeAt(this.pos);\r\n            if (!charcode_1.isIdentifierPart(c))\r\n                break;\r\n            ++this.pos;\r\n            // make sure each supported flag is unique\r\n            switch (c) {\r\n                case 103 /* g */:\r\n                    flags |= flags & 1 ? -1 : 1;\r\n                    break;\r\n                case 105 /* i */:\r\n                    flags |= flags & 2 ? -1 : 2;\r\n                    break;\r\n                case 109 /* m */:\r\n                    flags |= flags & 4 ? -1 : 4;\r\n                    break;\r\n                default:\r\n                    flags = -1;\r\n                    break;\r\n            }\r\n        }\r\n        if (flags == -1) {\r\n            this.error(diagnostics_1.DiagnosticCode.Invalid_regular_expression_flags, this.range(start, this.pos));\r\n        }\r\n        return text.substring(start, this.pos);\r\n    };\r\n    Tokenizer.prototype.testInteger = function () {\r\n        var text = this.source.text;\r\n        if (text.charCodeAt(this.pos) == 48 /* _0 */ && this.pos + 1 < this.end) {\r\n            switch (text.charCodeAt(this.pos + 2)) {\r\n                case 88 /* X */:\r\n                case 120 /* x */:\r\n                case 66 /* B */:\r\n                case 98 /* b */:\r\n                case 79 /* O */:\r\n                case 111 /* o */:\r\n                    return true;\r\n            }\r\n        }\r\n        var pos = this.pos;\r\n        while (pos < this.end) {\r\n            var c = text.charCodeAt(pos);\r\n            if (c == 46 /* DOT */ || c == 69 /* E */ || c == 101 /* e */) {\r\n                return false;\r\n            }\r\n            if (c < 48 /* _0 */ || c > 57 /* _9 */)\r\n                break;\r\n            pos++;\r\n        }\r\n        return true;\r\n    };\r\n    Tokenizer.prototype.readInteger = function () {\r\n        var text = this.source.text;\r\n        if (text.charCodeAt(this.pos) == 48 /* _0 */ && this.pos + 2 < this.end) {\r\n            switch (text.charCodeAt(this.pos + 1)) {\r\n                case 88 /* X */:\r\n                case 120 /* x */:\r\n                    this.pos += 2;\r\n                    return this.readHexInteger();\r\n                case 66 /* B */:\r\n                case 98 /* b */:\r\n                    this.pos += 2;\r\n                    return this.readBinaryInteger();\r\n                case 79 /* O */:\r\n                case 111 /* o */:\r\n                    this.pos += 2;\r\n                    return this.readOctalInteger();\r\n            }\r\n            if (charcode_1.isOctalDigit(text.charCodeAt(this.pos + 1))) {\r\n                var start = this.pos;\r\n                ++this.pos;\r\n                var value = this.readOctalInteger();\r\n                this.error(diagnostics_1.DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode, this.range(start, this.pos));\r\n                return value;\r\n            }\r\n        }\r\n        return this.readDecimalInteger();\r\n    };\r\n    Tokenizer.prototype.readHexInteger = function () {\r\n        var text = this.source.text;\r\n        var start = this.pos;\r\n        var value = i64_new(0, 0);\r\n        var i64_16 = i64_new(16, 0);\r\n        while (this.pos < this.end) {\r\n            var c = text.charCodeAt(this.pos);\r\n            if (c >= 48 /* _0 */ && c <= 57 /* _9 */) {\r\n                // value = value * 16 + c - CharCode._0;\r\n                value = i64_add(i64_mul(value, i64_16), i64_new(c - 48 /* _0 */, 0));\r\n            }\r\n            else if (c >= 65 /* A */ && c <= 70 /* F */) {\r\n                // value = value * 16 + 10 + c - CharCode.A;\r\n                value = i64_add(i64_mul(value, i64_16), i64_new(10 + c - 65 /* A */, 0));\r\n            }\r\n            else if (c >= 97 /* a */ && c <= 102 /* f */) {\r\n                // value = value * 16 + 10 + c - CharCode.a;\r\n                value = i64_add(i64_mul(value, i64_16), i64_new(10 + c - 97 /* a */, 0));\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            ++this.pos;\r\n        }\r\n        if (this.pos == start) {\r\n            this.error(diagnostics_1.DiagnosticCode.Hexadecimal_digit_expected, this.range(start));\r\n        }\r\n        return value;\r\n    };\r\n    Tokenizer.prototype.readDecimalInteger = function () {\r\n        var text = this.source.text;\r\n        var start = this.pos;\r\n        var value = i64_new(0, 0);\r\n        var i64_10 = i64_new(10, 0);\r\n        while (this.pos < this.end) {\r\n            var c = text.charCodeAt(this.pos);\r\n            if (c >= 48 /* _0 */ && c <= 57 /* _9 */) {\r\n                // value = value * 10 + c - CharCode._0;\r\n                value = i64_add(i64_mul(value, i64_10), i64_new(c - 48 /* _0 */, 0));\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            ++this.pos;\r\n        }\r\n        if (this.pos == start) {\r\n            this.error(diagnostics_1.DiagnosticCode.Digit_expected, this.range(start));\r\n        }\r\n        return value;\r\n    };\r\n    Tokenizer.prototype.readOctalInteger = function () {\r\n        var text = this.source.text;\r\n        var start = this.pos;\r\n        var value = i64_new(0, 0);\r\n        var i64_8 = i64_new(8, 0);\r\n        while (this.pos < this.end) {\r\n            var c = text.charCodeAt(this.pos);\r\n            if (c >= 48 /* _0 */ && c <= 55 /* _7 */) {\r\n                // value = value * 8 + c - CharCode._0;\r\n                value = i64_add(i64_mul(value, i64_8), i64_new(c - 48 /* _0 */, 0));\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            ++this.pos;\r\n        }\r\n        if (this.pos == start) {\r\n            this.error(diagnostics_1.DiagnosticCode.Octal_digit_expected, this.range(start));\r\n        }\r\n        return value;\r\n    };\r\n    Tokenizer.prototype.readBinaryInteger = function () {\r\n        var text = this.source.text;\r\n        var start = this.pos;\r\n        var value = i64_new(0, 0);\r\n        var i64_2 = i64_new(2, 0);\r\n        var i64_1 = i64_new(1, 0);\r\n        while (this.pos < this.end) {\r\n            var c = text.charCodeAt(this.pos);\r\n            if (c == 48 /* _0 */) {\r\n                // value = value * 2;\r\n                value = i64_mul(value, i64_2);\r\n            }\r\n            else if (c == 49 /* _1 */) {\r\n                // value = value * 2 + 1;\r\n                value = i64_add(i64_mul(value, i64_2), i64_1);\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            ++this.pos;\r\n        }\r\n        if (this.pos == start) {\r\n            this.error(diagnostics_1.DiagnosticCode.Binary_digit_expected, this.range(start));\r\n        }\r\n        return value;\r\n    };\r\n    Tokenizer.prototype.readFloat = function () {\r\n        var start = this.pos;\r\n        var text = this.source.text;\r\n        while (this.pos < this.end && charcode_1.isDecimalDigit(text.charCodeAt(this.pos))) {\r\n            ++this.pos;\r\n        }\r\n        if (this.pos < this.end && text.charCodeAt(this.pos) == 46 /* DOT */) {\r\n            ++this.pos;\r\n            while (this.pos < this.end && charcode_1.isDecimalDigit(text.charCodeAt(this.pos))) {\r\n                ++this.pos;\r\n            }\r\n        }\r\n        if (this.pos < this.end) {\r\n            var c = text.charCodeAt(this.pos);\r\n            if (c == 69 /* E */ || c == 101 /* e */) {\r\n                if (++this.pos < this.end && (text.charCodeAt(this.pos) == 45 /* MINUS */ ||\r\n                    text.charCodeAt(this.pos) == 43 /* PLUS */) &&\r\n                    charcode_1.isDecimalDigit(text.charCodeAt(this.pos + 1))) {\r\n                    ++this.pos;\r\n                }\r\n                while (this.pos < this.end && charcode_1.isDecimalDigit(text.charCodeAt(this.pos))) {\r\n                    ++this.pos;\r\n                }\r\n            }\r\n        }\r\n        return parseFloat(text.substring(start, this.pos));\r\n    };\r\n    Tokenizer.prototype.readUnicodeEscape = function () {\r\n        var remain = 4;\r\n        var value = 0;\r\n        var text = this.source.text;\r\n        while (this.pos < this.end) {\r\n            var c = text.charCodeAt(this.pos++);\r\n            if (c >= 48 /* _0 */ && c <= 57 /* _9 */) {\r\n                value = value * 16 + c - 48 /* _0 */;\r\n            }\r\n            else if (c >= 65 /* A */ && c <= 70 /* F */) {\r\n                value = value * 16 + 10 + c - 65 /* A */;\r\n            }\r\n            else if (c >= 97 /* a */ && c <= 102 /* f */) {\r\n                value = value * 16 + 10 + c - 97 /* a */;\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode.Hexadecimal_digit_expected, this.range(this.pos - 1, this.pos));\r\n                return \"\";\r\n            }\r\n            if (--remain == 0)\r\n                break;\r\n        }\r\n        if (remain) {\r\n            this.error(diagnostics_1.DiagnosticCode.Unexpected_end_of_text, this.range(this.pos));\r\n            return \"\";\r\n        }\r\n        return String.fromCharCode(value);\r\n    };\r\n    Tokenizer.prototype.readExtendedUnicodeEscape = function () {\r\n        var start = this.pos;\r\n        var value = this.readHexInteger();\r\n        var value32 = i64_low(value);\r\n        var invalid = false;\r\n        assert(!i64_high(value));\r\n        if (value32 > 0x10FFFF) {\r\n            this.error(diagnostics_1.DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive, this.range(start, this.pos));\r\n            invalid = true;\r\n        }\r\n        var text = this.source.text;\r\n        if (this.pos >= this.end) {\r\n            this.error(diagnostics_1.DiagnosticCode.Unexpected_end_of_text, this.range(start, this.end));\r\n            invalid = true;\r\n        }\r\n        else if (text.charCodeAt(this.pos) == 125 /* CLOSEBRACE */) {\r\n            ++this.pos;\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode.Unterminated_Unicode_escape_sequence, this.range(start, this.pos));\r\n            invalid = true;\r\n        }\r\n        if (invalid)\r\n            return \"\";\r\n        return value32 < 65536\r\n            ? String.fromCharCode(value32)\r\n            : String.fromCharCode((((value32 - 65536) / 1024 | 0) + 0xD800), ((value32 - 65536) % 1024 + 0xDC00));\r\n    };\r\n    Tokenizer.prototype.finish = function () {\r\n    };\r\n    return Tokenizer;\r\n}(diagnostics_1.DiagnosticEmitter));\r\nexports.Tokenizer = Tokenizer;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n// code below is generated from diagnosticsMessages.json by scripts/build-diagnostics\r\n/* tslint:disable:max-line-length */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar DiagnosticCode;\r\n(function (DiagnosticCode) {\r\n    DiagnosticCode[DiagnosticCode[\"Operation_not_supported\"] = 100] = \"Operation_not_supported\";\r\n    DiagnosticCode[DiagnosticCode[\"Operation_is_unsafe\"] = 101] = \"Operation_is_unsafe\";\r\n    DiagnosticCode[DiagnosticCode[\"Conversion_from_type_0_to_1_requires_an_explicit_cast\"] = 200] = \"Conversion_from_type_0_to_1_requires_an_explicit_cast\";\r\n    DiagnosticCode[DiagnosticCode[\"Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit\"] = 201] = \"Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit\";\r\n    DiagnosticCode[DiagnosticCode[\"Type_0_cannot_be_changed_to_type_1\"] = 202] = \"Type_0_cannot_be_changed_to_type_1\";\r\n    DiagnosticCode[DiagnosticCode[\"Type_0_cannot_be_reinterpreted_as_type_1\"] = 203] = \"Type_0_cannot_be_reinterpreted_as_type_1\";\r\n    DiagnosticCode[DiagnosticCode[\"Basic_type_0_cannot_be_nullable\"] = 204] = \"Basic_type_0_cannot_be_nullable\";\r\n    DiagnosticCode[DiagnosticCode[\"Cannot_export_a_mutable_global\"] = 205] = \"Cannot_export_a_mutable_global\";\r\n    DiagnosticCode[DiagnosticCode[\"Compiling_constant_with_non_constant_initializer_as_mutable\"] = 206] = \"Compiling_constant_with_non_constant_initializer_as_mutable\";\r\n    DiagnosticCode[DiagnosticCode[\"Structs_cannot_extend_classes_and_vice_versa\"] = 207] = \"Structs_cannot_extend_classes_and_vice_versa\";\r\n    DiagnosticCode[DiagnosticCode[\"Structs_cannot_implement_interfaces\"] = 208] = \"Structs_cannot_implement_interfaces\";\r\n    DiagnosticCode[DiagnosticCode[\"Invalid_regular_expression_flags\"] = 209] = \"Invalid_regular_expression_flags\";\r\n    DiagnosticCode[DiagnosticCode[\"Implementation_0_must_match_the_signature_1\"] = 210] = \"Implementation_0_must_match_the_signature_1\";\r\n    DiagnosticCode[DiagnosticCode[\"Unterminated_string_literal\"] = 1002] = \"Unterminated_string_literal\";\r\n    DiagnosticCode[DiagnosticCode[\"Identifier_expected\"] = 1003] = \"Identifier_expected\";\r\n    DiagnosticCode[DiagnosticCode[\"_0_expected\"] = 1005] = \"_0_expected\";\r\n    DiagnosticCode[DiagnosticCode[\"A_file_cannot_have_a_reference_to_itself\"] = 1006] = \"A_file_cannot_have_a_reference_to_itself\";\r\n    DiagnosticCode[DiagnosticCode[\"Trailing_comma_not_allowed\"] = 1009] = \"Trailing_comma_not_allowed\";\r\n    DiagnosticCode[DiagnosticCode[\"Unexpected_token\"] = 1012] = \"Unexpected_token\";\r\n    DiagnosticCode[DiagnosticCode[\"A_rest_parameter_must_be_last_in_a_parameter_list\"] = 1014] = \"A_rest_parameter_must_be_last_in_a_parameter_list\";\r\n    DiagnosticCode[DiagnosticCode[\"Parameter_cannot_have_question_mark_and_initializer\"] = 1015] = \"Parameter_cannot_have_question_mark_and_initializer\";\r\n    DiagnosticCode[DiagnosticCode[\"A_required_parameter_cannot_follow_an_optional_parameter\"] = 1016] = \"A_required_parameter_cannot_follow_an_optional_parameter\";\r\n    DiagnosticCode[DiagnosticCode[\"Enum_member_must_have_initializer\"] = 1061] = \"Enum_member_must_have_initializer\";\r\n    DiagnosticCode[DiagnosticCode[\"Statements_are_not_allowed_in_ambient_contexts\"] = 1036] = \"Statements_are_not_allowed_in_ambient_contexts\";\r\n    DiagnosticCode[DiagnosticCode[\"Initializers_are_not_allowed_in_ambient_contexts\"] = 1039] = \"Initializers_are_not_allowed_in_ambient_contexts\";\r\n    DiagnosticCode[DiagnosticCode[\"_0_modifier_cannot_be_used_here\"] = 1042] = \"_0_modifier_cannot_be_used_here\";\r\n    DiagnosticCode[DiagnosticCode[\"A_rest_parameter_cannot_be_optional\"] = 1047] = \"A_rest_parameter_cannot_be_optional\";\r\n    DiagnosticCode[DiagnosticCode[\"A_rest_parameter_cannot_have_an_initializer\"] = 1048] = \"A_rest_parameter_cannot_have_an_initializer\";\r\n    DiagnosticCode[DiagnosticCode[\"A_set_accessor_must_have_exactly_one_parameter\"] = 1049] = \"A_set_accessor_must_have_exactly_one_parameter\";\r\n    DiagnosticCode[DiagnosticCode[\"A_set_accessor_parameter_cannot_have_an_initializer\"] = 1052] = \"A_set_accessor_parameter_cannot_have_an_initializer\";\r\n    DiagnosticCode[DiagnosticCode[\"A_get_accessor_cannot_have_parameters\"] = 1054] = \"A_get_accessor_cannot_have_parameters\";\r\n    DiagnosticCode[DiagnosticCode[\"Type_parameters_cannot_appear_on_a_constructor_declaration\"] = 1092] = \"Type_parameters_cannot_appear_on_a_constructor_declaration\";\r\n    DiagnosticCode[DiagnosticCode[\"Type_annotation_cannot_appear_on_a_constructor_declaration\"] = 1093] = \"Type_annotation_cannot_appear_on_a_constructor_declaration\";\r\n    DiagnosticCode[DiagnosticCode[\"An_accessor_cannot_have_type_parameters\"] = 1094] = \"An_accessor_cannot_have_type_parameters\";\r\n    DiagnosticCode[DiagnosticCode[\"A_set_accessor_cannot_have_a_return_type_annotation\"] = 1095] = \"A_set_accessor_cannot_have_a_return_type_annotation\";\r\n    DiagnosticCode[DiagnosticCode[\"Type_parameter_list_cannot_be_empty\"] = 1098] = \"Type_parameter_list_cannot_be_empty\";\r\n    DiagnosticCode[DiagnosticCode[\"A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement\"] = 1104] = \"A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement\";\r\n    DiagnosticCode[DiagnosticCode[\"A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement\"] = 1105] = \"A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement\";\r\n    DiagnosticCode[DiagnosticCode[\"A_return_statement_can_only_be_used_within_a_function_body\"] = 1108] = \"A_return_statement_can_only_be_used_within_a_function_body\";\r\n    DiagnosticCode[DiagnosticCode[\"Expression_expected\"] = 1109] = \"Expression_expected\";\r\n    DiagnosticCode[DiagnosticCode[\"Type_expected\"] = 1110] = \"Type_expected\";\r\n    DiagnosticCode[DiagnosticCode[\"A_default_clause_cannot_appear_more_than_once_in_a_switch_statement\"] = 1113] = \"A_default_clause_cannot_appear_more_than_once_in_a_switch_statement\";\r\n    DiagnosticCode[DiagnosticCode[\"Duplicate_label_0\"] = 1114] = \"Duplicate_label_0\";\r\n    DiagnosticCode[DiagnosticCode[\"Octal_literals_are_not_allowed_in_strict_mode\"] = 1121] = \"Octal_literals_are_not_allowed_in_strict_mode\";\r\n    DiagnosticCode[DiagnosticCode[\"Digit_expected\"] = 1124] = \"Digit_expected\";\r\n    DiagnosticCode[DiagnosticCode[\"Hexadecimal_digit_expected\"] = 1125] = \"Hexadecimal_digit_expected\";\r\n    DiagnosticCode[DiagnosticCode[\"Unexpected_end_of_text\"] = 1126] = \"Unexpected_end_of_text\";\r\n    DiagnosticCode[DiagnosticCode[\"Invalid_character\"] = 1127] = \"Invalid_character\";\r\n    DiagnosticCode[DiagnosticCode[\"_case_or_default_expected\"] = 1130] = \"_case_or_default_expected\";\r\n    DiagnosticCode[DiagnosticCode[\"Type_argument_expected\"] = 1140] = \"Type_argument_expected\";\r\n    DiagnosticCode[DiagnosticCode[\"String_literal_expected\"] = 1141] = \"String_literal_expected\";\r\n    DiagnosticCode[DiagnosticCode[\"Line_break_not_permitted_here\"] = 1142] = \"Line_break_not_permitted_here\";\r\n    DiagnosticCode[DiagnosticCode[\"Declaration_expected\"] = 1146] = \"Declaration_expected\";\r\n    DiagnosticCode[DiagnosticCode[\"_const_declarations_must_be_initialized\"] = 1155] = \"_const_declarations_must_be_initialized\";\r\n    DiagnosticCode[DiagnosticCode[\"Unterminated_regular_expression_literal\"] = 1161] = \"Unterminated_regular_expression_literal\";\r\n    DiagnosticCode[DiagnosticCode[\"Binary_digit_expected\"] = 1177] = \"Binary_digit_expected\";\r\n    DiagnosticCode[DiagnosticCode[\"Octal_digit_expected\"] = 1178] = \"Octal_digit_expected\";\r\n    DiagnosticCode[DiagnosticCode[\"An_implementation_cannot_be_declared_in_ambient_contexts\"] = 1183] = \"An_implementation_cannot_be_declared_in_ambient_contexts\";\r\n    DiagnosticCode[DiagnosticCode[\"An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive\"] = 1198] = \"An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive\";\r\n    DiagnosticCode[DiagnosticCode[\"Unterminated_Unicode_escape_sequence\"] = 1199] = \"Unterminated_Unicode_escape_sequence\";\r\n    DiagnosticCode[DiagnosticCode[\"Decorators_are_not_valid_here\"] = 1206] = \"Decorators_are_not_valid_here\";\r\n    DiagnosticCode[DiagnosticCode[\"_abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration\"] = 1242] = \"_abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration\";\r\n    DiagnosticCode[DiagnosticCode[\"A_class_may_only_extend_another_class\"] = 1311] = \"A_class_may_only_extend_another_class\";\r\n    DiagnosticCode[DiagnosticCode[\"Duplicate_identifier_0\"] = 2300] = \"Duplicate_identifier_0\";\r\n    DiagnosticCode[DiagnosticCode[\"Cannot_find_name_0\"] = 2304] = \"Cannot_find_name_0\";\r\n    DiagnosticCode[DiagnosticCode[\"Module_0_has_no_exported_member_1\"] = 2305] = \"Module_0_has_no_exported_member_1\";\r\n    DiagnosticCode[DiagnosticCode[\"Generic_type_0_requires_1_type_argument_s\"] = 2314] = \"Generic_type_0_requires_1_type_argument_s\";\r\n    DiagnosticCode[DiagnosticCode[\"Type_0_is_not_generic\"] = 2315] = \"Type_0_is_not_generic\";\r\n    DiagnosticCode[DiagnosticCode[\"Type_0_is_not_assignable_to_type_1\"] = 2322] = \"Type_0_is_not_assignable_to_type_1\";\r\n    DiagnosticCode[DiagnosticCode[\"Index_signature_is_missing_in_type_0\"] = 2329] = \"Index_signature_is_missing_in_type_0\";\r\n    DiagnosticCode[DiagnosticCode[\"_this_cannot_be_referenced_in_current_location\"] = 2332] = \"_this_cannot_be_referenced_in_current_location\";\r\n    DiagnosticCode[DiagnosticCode[\"_super_can_only_be_referenced_in_a_derived_class\"] = 2335] = \"_super_can_only_be_referenced_in_a_derived_class\";\r\n    DiagnosticCode[DiagnosticCode[\"Property_0_does_not_exist_on_type_1\"] = 2339] = \"Property_0_does_not_exist_on_type_1\";\r\n    DiagnosticCode[DiagnosticCode[\"Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures\"] = 2349] = \"Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures\";\r\n    DiagnosticCode[DiagnosticCode[\"Cannot_use_new_with_an_expression_whose_type_lacks_a_construct_signature\"] = 2351] = \"Cannot_use_new_with_an_expression_whose_type_lacks_a_construct_signature\";\r\n    DiagnosticCode[DiagnosticCode[\"A_function_whose_declared_type_is_not_void_must_return_a_value\"] = 2355] = \"A_function_whose_declared_type_is_not_void_must_return_a_value\";\r\n    DiagnosticCode[DiagnosticCode[\"The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access\"] = 2357] = \"The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access\";\r\n    DiagnosticCode[DiagnosticCode[\"The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access\"] = 2364] = \"The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access\";\r\n    DiagnosticCode[DiagnosticCode[\"Operator_0_cannot_be_applied_to_types_1_and_2\"] = 2365] = \"Operator_0_cannot_be_applied_to_types_1_and_2\";\r\n    DiagnosticCode[DiagnosticCode[\"_get_and_set_accessor_must_have_the_same_type\"] = 2380] = \"_get_and_set_accessor_must_have_the_same_type\";\r\n    DiagnosticCode[DiagnosticCode[\"Constructor_implementation_is_missing\"] = 2390] = \"Constructor_implementation_is_missing\";\r\n    DiagnosticCode[DiagnosticCode[\"Function_implementation_is_missing_or_not_immediately_following_the_declaration\"] = 2391] = \"Function_implementation_is_missing_or_not_immediately_following_the_declaration\";\r\n    DiagnosticCode[DiagnosticCode[\"Multiple_constructor_implementations_are_not_allowed\"] = 2392] = \"Multiple_constructor_implementations_are_not_allowed\";\r\n    DiagnosticCode[DiagnosticCode[\"Duplicate_function_implementation\"] = 2393] = \"Duplicate_function_implementation\";\r\n    DiagnosticCode[DiagnosticCode[\"The_0_operator_cannot_be_applied_to_type_1\"] = 2469] = \"The_0_operator_cannot_be_applied_to_type_1\";\r\n    DiagnosticCode[DiagnosticCode[\"Export_declaration_conflicts_with_exported_declaration_of_0\"] = 2484] = \"Export_declaration_conflicts_with_exported_declaration_of_0\";\r\n    DiagnosticCode[DiagnosticCode[\"Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property\"] = 2540] = \"Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property\";\r\n    DiagnosticCode[DiagnosticCode[\"The_target_of_an_assignment_must_be_a_variable_or_a_property_access\"] = 2541] = \"The_target_of_an_assignment_must_be_a_variable_or_a_property_access\";\r\n    DiagnosticCode[DiagnosticCode[\"Index_signature_in_type_0_only_permits_reading\"] = 2542] = \"Index_signature_in_type_0_only_permits_reading\";\r\n    DiagnosticCode[DiagnosticCode[\"Expected_0_arguments_but_got_1\"] = 2554] = \"Expected_0_arguments_but_got_1\";\r\n    DiagnosticCode[DiagnosticCode[\"Expected_at_least_0_arguments_but_got_1\"] = 2555] = \"Expected_at_least_0_arguments_but_got_1\";\r\n    DiagnosticCode[DiagnosticCode[\"Expected_0_type_arguments_but_got_1\"] = 2558] = \"Expected_0_type_arguments_but_got_1\";\r\n    DiagnosticCode[DiagnosticCode[\"A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums\"] = 2651] = \"A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums\";\r\n    DiagnosticCode[DiagnosticCode[\"Namespace_0_has_no_exported_member_1\"] = 2694] = \"Namespace_0_has_no_exported_member_1\";\r\n    DiagnosticCode[DiagnosticCode[\"File_0_not_found\"] = 6054] = \"File_0_not_found\";\r\n})(DiagnosticCode = exports.DiagnosticCode || (exports.DiagnosticCode = {}));\r\nfunction diagnosticCodeToString(code) {\r\n    switch (code) {\r\n        case 100: return \"Operation not supported.\";\r\n        case 101: return \"Operation is unsafe.\";\r\n        case 200: return \"Conversion from type '{0}' to '{1}' requires an explicit cast.\";\r\n        case 201: return \"Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.\";\r\n        case 202: return \"Type '{0}' cannot be changed to type '{1}'.\";\r\n        case 203: return \"Type '{0}' cannot be reinterpreted as type '{1}'.\";\r\n        case 204: return \"Basic type '{0}' cannot be nullable.\";\r\n        case 205: return \"Cannot export a mutable global.\";\r\n        case 206: return \"Compiling constant with non-constant initializer as mutable.\";\r\n        case 207: return \"Structs cannot extend classes and vice-versa.\";\r\n        case 208: return \"Structs cannot implement interfaces.\";\r\n        case 209: return \"Invalid regular expression flags.\";\r\n        case 210: return \"Implementation '{0}' must match the signature '{1}'.\";\r\n        case 1002: return \"Unterminated string literal.\";\r\n        case 1003: return \"Identifier expected.\";\r\n        case 1005: return \"'{0}' expected.\";\r\n        case 1006: return \"A file cannot have a reference to itself.\";\r\n        case 1009: return \"Trailing comma not allowed.\";\r\n        case 1012: return \"Unexpected token.\";\r\n        case 1014: return \"A rest parameter must be last in a parameter list.\";\r\n        case 1015: return \"Parameter cannot have question mark and initializer.\";\r\n        case 1016: return \"A required parameter cannot follow an optional parameter.\";\r\n        case 1061: return \"Enum member must have initializer.\";\r\n        case 1036: return \"Statements are not allowed in ambient contexts.\";\r\n        case 1039: return \"Initializers are not allowed in ambient contexts.\";\r\n        case 1042: return \"'{0}' modifier cannot be used here.\";\r\n        case 1047: return \"A rest parameter cannot be optional.\";\r\n        case 1048: return \"A rest parameter cannot have an initializer.\";\r\n        case 1049: return \"A 'set' accessor must have exactly one parameter.\";\r\n        case 1052: return \"A 'set' accessor parameter cannot have an initializer.\";\r\n        case 1054: return \"A 'get' accessor cannot have parameters.\";\r\n        case 1092: return \"Type parameters cannot appear on a constructor declaration.\";\r\n        case 1093: return \"Type annotation cannot appear on a constructor declaration.\";\r\n        case 1094: return \"An accessor cannot have type parameters.\";\r\n        case 1095: return \"A 'set' accessor cannot have a return type annotation.\";\r\n        case 1098: return \"Type parameter list cannot be empty.\";\r\n        case 1104: return \"A 'continue' statement can only be used within an enclosing iteration statement.\";\r\n        case 1105: return \"A 'break' statement can only be used within an enclosing iteration or switch statement.\";\r\n        case 1108: return \"A 'return' statement can only be used within a function body.\";\r\n        case 1109: return \"Expression expected.\";\r\n        case 1110: return \"Type expected.\";\r\n        case 1113: return \"A 'default' clause cannot appear more than once in a 'switch' statement.\";\r\n        case 1114: return \"Duplicate label '{0}'.\";\r\n        case 1121: return \"Octal literals are not allowed in strict mode.\";\r\n        case 1124: return \"Digit expected.\";\r\n        case 1125: return \"Hexadecimal digit expected.\";\r\n        case 1126: return \"Unexpected end of text.\";\r\n        case 1127: return \"Invalid character.\";\r\n        case 1130: return \"'case' or 'default' expected.\";\r\n        case 1140: return \"Type argument expected.\";\r\n        case 1141: return \"String literal expected.\";\r\n        case 1142: return \"Line break not permitted here.\";\r\n        case 1146: return \"Declaration expected.\";\r\n        case 1155: return \"'const' declarations must be initialized.\";\r\n        case 1161: return \"Unterminated regular expression literal.\";\r\n        case 1177: return \"Binary digit expected.\";\r\n        case 1178: return \"Octal digit expected.\";\r\n        case 1183: return \"An implementation cannot be declared in ambient contexts.\";\r\n        case 1198: return \"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.\";\r\n        case 1199: return \"Unterminated Unicode escape sequence.\";\r\n        case 1206: return \"Decorators are not valid here.\";\r\n        case 1242: return \"'abstract' modifier can only appear on a class, method, or property declaration.\";\r\n        case 1311: return \"A class may only extend another class.\";\r\n        case 2300: return \"Duplicate identifier '{0}'.\";\r\n        case 2304: return \"Cannot find name '{0}'.\";\r\n        case 2305: return \"Module '{0}' has no exported member '{1}'.\";\r\n        case 2314: return \"Generic type '{0}' requires {1} type argument(s).\";\r\n        case 2315: return \"Type '{0}' is not generic.\";\r\n        case 2322: return \"Type '{0}' is not assignable to type '{1}'.\";\r\n        case 2329: return \"Index signature is missing in type '{0}'.\";\r\n        case 2332: return \"'this' cannot be referenced in current location.\";\r\n        case 2335: return \"'super' can only be referenced in a derived class.\";\r\n        case 2339: return \"Property '{0}' does not exist on type '{1}'.\";\r\n        case 2349: return \"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.\";\r\n        case 2351: return \"Cannot use 'new' with an expression whose type lacks a construct signature.\";\r\n        case 2355: return \"A function whose declared type is not 'void' must return a value.\";\r\n        case 2357: return \"The operand of an increment or decrement operator must be a variable or a property access.\";\r\n        case 2364: return \"The left-hand side of an assignment expression must be a variable or a property access.\";\r\n        case 2365: return \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\";\r\n        case 2380: return \"'get' and 'set' accessor must have the same type.\";\r\n        case 2390: return \"Constructor implementation is missing.\";\r\n        case 2391: return \"Function implementation is missing or not immediately following the declaration.\";\r\n        case 2392: return \"Multiple constructor implementations are not allowed.\";\r\n        case 2393: return \"Duplicate function implementation.\";\r\n        case 2469: return \"The '{0}' operator cannot be applied to type '{1}'.\";\r\n        case 2484: return \"Export declaration conflicts with exported declaration of '{0}'.\";\r\n        case 2540: return \"Cannot assign to '{0}' because it is a constant or a read-only property.\";\r\n        case 2541: return \"The target of an assignment must be a variable or a property access.\";\r\n        case 2542: return \"Index signature in type '{0}' only permits reading.\";\r\n        case 2554: return \"Expected {0} arguments, but got {1}.\";\r\n        case 2555: return \"Expected at least {0} arguments, but got {1}.\";\r\n        case 2558: return \"Expected {0} type arguments, but got {1}.\";\r\n        case 2651: return \"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.\";\r\n        case 2694: return \"Namespace '{0}' has no exported member '{1}'.\";\r\n        case 6054: return \"File '{0}' not found.\";\r\n        default: return \"\";\r\n    }\r\n}\r\nexports.diagnosticCodeToString = diagnosticCodeToString;\r\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n/** An enum of named character codes. */\r\nvar CharCode;\r\n(function (CharCode) {\r\n    CharCode[CharCode[\"NULL\"] = 0] = \"NULL\";\r\n    CharCode[CharCode[\"LINEFEED\"] = 10] = \"LINEFEED\";\r\n    CharCode[CharCode[\"CARRIAGERETURN\"] = 13] = \"CARRIAGERETURN\";\r\n    CharCode[CharCode[\"LINESEPARATOR\"] = 8232] = \"LINESEPARATOR\";\r\n    CharCode[CharCode[\"PARAGRAPHSEPARATOR\"] = 8233] = \"PARAGRAPHSEPARATOR\";\r\n    CharCode[CharCode[\"NEXTLINE\"] = 133] = \"NEXTLINE\";\r\n    CharCode[CharCode[\"SPACE\"] = 32] = \"SPACE\";\r\n    CharCode[CharCode[\"NONBREAKINGSPACE\"] = 160] = \"NONBREAKINGSPACE\";\r\n    CharCode[CharCode[\"ENQUAD\"] = 8192] = \"ENQUAD\";\r\n    CharCode[CharCode[\"EMQUAD\"] = 8193] = \"EMQUAD\";\r\n    CharCode[CharCode[\"ENSPACE\"] = 8194] = \"ENSPACE\";\r\n    CharCode[CharCode[\"EMSPACE\"] = 8195] = \"EMSPACE\";\r\n    CharCode[CharCode[\"THREEPEREMSPACE\"] = 8196] = \"THREEPEREMSPACE\";\r\n    CharCode[CharCode[\"FOURPEREMSPACE\"] = 8197] = \"FOURPEREMSPACE\";\r\n    CharCode[CharCode[\"SIXPEREMSPACE\"] = 8198] = \"SIXPEREMSPACE\";\r\n    CharCode[CharCode[\"FIGURESPACE\"] = 8199] = \"FIGURESPACE\";\r\n    CharCode[CharCode[\"PUNCTUATIONSPACE\"] = 8200] = \"PUNCTUATIONSPACE\";\r\n    CharCode[CharCode[\"THINSPACE\"] = 8201] = \"THINSPACE\";\r\n    CharCode[CharCode[\"HAIRSPACE\"] = 8202] = \"HAIRSPACE\";\r\n    CharCode[CharCode[\"ZEROWIDTHSPACE\"] = 8203] = \"ZEROWIDTHSPACE\";\r\n    CharCode[CharCode[\"NARROWNOBREAKSPACE\"] = 8239] = \"NARROWNOBREAKSPACE\";\r\n    CharCode[CharCode[\"IDEOGRAPHICSPACE\"] = 12288] = \"IDEOGRAPHICSPACE\";\r\n    CharCode[CharCode[\"MATHEMATICALSPACE\"] = 8287] = \"MATHEMATICALSPACE\";\r\n    CharCode[CharCode[\"OGHAM\"] = 5760] = \"OGHAM\";\r\n    CharCode[CharCode[\"_\"] = 95] = \"_\";\r\n    CharCode[CharCode[\"_0\"] = 48] = \"_0\";\r\n    CharCode[CharCode[\"_1\"] = 49] = \"_1\";\r\n    CharCode[CharCode[\"_2\"] = 50] = \"_2\";\r\n    CharCode[CharCode[\"_3\"] = 51] = \"_3\";\r\n    CharCode[CharCode[\"_4\"] = 52] = \"_4\";\r\n    CharCode[CharCode[\"_5\"] = 53] = \"_5\";\r\n    CharCode[CharCode[\"_6\"] = 54] = \"_6\";\r\n    CharCode[CharCode[\"_7\"] = 55] = \"_7\";\r\n    CharCode[CharCode[\"_8\"] = 56] = \"_8\";\r\n    CharCode[CharCode[\"_9\"] = 57] = \"_9\";\r\n    CharCode[CharCode[\"a\"] = 97] = \"a\";\r\n    CharCode[CharCode[\"b\"] = 98] = \"b\";\r\n    CharCode[CharCode[\"c\"] = 99] = \"c\";\r\n    CharCode[CharCode[\"d\"] = 100] = \"d\";\r\n    CharCode[CharCode[\"e\"] = 101] = \"e\";\r\n    CharCode[CharCode[\"f\"] = 102] = \"f\";\r\n    CharCode[CharCode[\"g\"] = 103] = \"g\";\r\n    CharCode[CharCode[\"h\"] = 104] = \"h\";\r\n    CharCode[CharCode[\"i\"] = 105] = \"i\";\r\n    CharCode[CharCode[\"j\"] = 106] = \"j\";\r\n    CharCode[CharCode[\"k\"] = 107] = \"k\";\r\n    CharCode[CharCode[\"l\"] = 108] = \"l\";\r\n    CharCode[CharCode[\"m\"] = 109] = \"m\";\r\n    CharCode[CharCode[\"n\"] = 110] = \"n\";\r\n    CharCode[CharCode[\"o\"] = 111] = \"o\";\r\n    CharCode[CharCode[\"p\"] = 112] = \"p\";\r\n    CharCode[CharCode[\"q\"] = 113] = \"q\";\r\n    CharCode[CharCode[\"r\"] = 114] = \"r\";\r\n    CharCode[CharCode[\"s\"] = 115] = \"s\";\r\n    CharCode[CharCode[\"t\"] = 116] = \"t\";\r\n    CharCode[CharCode[\"u\"] = 117] = \"u\";\r\n    CharCode[CharCode[\"v\"] = 118] = \"v\";\r\n    CharCode[CharCode[\"w\"] = 119] = \"w\";\r\n    CharCode[CharCode[\"x\"] = 120] = \"x\";\r\n    CharCode[CharCode[\"y\"] = 121] = \"y\";\r\n    CharCode[CharCode[\"z\"] = 122] = \"z\";\r\n    CharCode[CharCode[\"A\"] = 65] = \"A\";\r\n    CharCode[CharCode[\"B\"] = 66] = \"B\";\r\n    CharCode[CharCode[\"C\"] = 67] = \"C\";\r\n    CharCode[CharCode[\"D\"] = 68] = \"D\";\r\n    CharCode[CharCode[\"E\"] = 69] = \"E\";\r\n    CharCode[CharCode[\"F\"] = 70] = \"F\";\r\n    CharCode[CharCode[\"G\"] = 71] = \"G\";\r\n    CharCode[CharCode[\"H\"] = 72] = \"H\";\r\n    CharCode[CharCode[\"I\"] = 73] = \"I\";\r\n    CharCode[CharCode[\"J\"] = 74] = \"J\";\r\n    CharCode[CharCode[\"K\"] = 75] = \"K\";\r\n    CharCode[CharCode[\"L\"] = 76] = \"L\";\r\n    CharCode[CharCode[\"M\"] = 77] = \"M\";\r\n    CharCode[CharCode[\"N\"] = 78] = \"N\";\r\n    CharCode[CharCode[\"O\"] = 79] = \"O\";\r\n    CharCode[CharCode[\"P\"] = 80] = \"P\";\r\n    CharCode[CharCode[\"Q\"] = 81] = \"Q\";\r\n    CharCode[CharCode[\"R\"] = 82] = \"R\";\r\n    CharCode[CharCode[\"S\"] = 83] = \"S\";\r\n    CharCode[CharCode[\"T\"] = 84] = \"T\";\r\n    CharCode[CharCode[\"U\"] = 85] = \"U\";\r\n    CharCode[CharCode[\"V\"] = 86] = \"V\";\r\n    CharCode[CharCode[\"W\"] = 87] = \"W\";\r\n    CharCode[CharCode[\"X\"] = 88] = \"X\";\r\n    CharCode[CharCode[\"Y\"] = 89] = \"Y\";\r\n    CharCode[CharCode[\"Z\"] = 90] = \"Z\";\r\n    CharCode[CharCode[\"AMPERSAND\"] = 38] = \"AMPERSAND\";\r\n    CharCode[CharCode[\"ASTERISK\"] = 42] = \"ASTERISK\";\r\n    CharCode[CharCode[\"AT\"] = 64] = \"AT\";\r\n    CharCode[CharCode[\"BACKSLASH\"] = 92] = \"BACKSLASH\";\r\n    CharCode[CharCode[\"BACKTICK\"] = 96] = \"BACKTICK\";\r\n    CharCode[CharCode[\"BAR\"] = 124] = \"BAR\";\r\n    CharCode[CharCode[\"CARET\"] = 94] = \"CARET\";\r\n    CharCode[CharCode[\"CLOSEBRACE\"] = 125] = \"CLOSEBRACE\";\r\n    CharCode[CharCode[\"CLOSEBRACKET\"] = 93] = \"CLOSEBRACKET\";\r\n    CharCode[CharCode[\"CLOSEPAREN\"] = 41] = \"CLOSEPAREN\";\r\n    CharCode[CharCode[\"COLON\"] = 58] = \"COLON\";\r\n    CharCode[CharCode[\"COMMA\"] = 44] = \"COMMA\";\r\n    CharCode[CharCode[\"DOLLAR\"] = 36] = \"DOLLAR\";\r\n    CharCode[CharCode[\"DOT\"] = 46] = \"DOT\";\r\n    CharCode[CharCode[\"DOUBLEQUOTE\"] = 34] = \"DOUBLEQUOTE\";\r\n    CharCode[CharCode[\"EQUALS\"] = 61] = \"EQUALS\";\r\n    CharCode[CharCode[\"EXCLAMATION\"] = 33] = \"EXCLAMATION\";\r\n    CharCode[CharCode[\"GREATERTHAN\"] = 62] = \"GREATERTHAN\";\r\n    CharCode[CharCode[\"HASH\"] = 35] = \"HASH\";\r\n    CharCode[CharCode[\"LESSTHAN\"] = 60] = \"LESSTHAN\";\r\n    CharCode[CharCode[\"MINUS\"] = 45] = \"MINUS\";\r\n    CharCode[CharCode[\"OPENBRACE\"] = 123] = \"OPENBRACE\";\r\n    CharCode[CharCode[\"OPENBRACKET\"] = 91] = \"OPENBRACKET\";\r\n    CharCode[CharCode[\"OPENPAREN\"] = 40] = \"OPENPAREN\";\r\n    CharCode[CharCode[\"PERCENT\"] = 37] = \"PERCENT\";\r\n    CharCode[CharCode[\"PLUS\"] = 43] = \"PLUS\";\r\n    CharCode[CharCode[\"QUESTION\"] = 63] = \"QUESTION\";\r\n    CharCode[CharCode[\"SEMICOLON\"] = 59] = \"SEMICOLON\";\r\n    CharCode[CharCode[\"SINGLEQUOTE\"] = 39] = \"SINGLEQUOTE\";\r\n    CharCode[CharCode[\"SLASH\"] = 47] = \"SLASH\";\r\n    CharCode[CharCode[\"TILDE\"] = 126] = \"TILDE\";\r\n    CharCode[CharCode[\"BACKSPACE\"] = 8] = \"BACKSPACE\";\r\n    CharCode[CharCode[\"FORMFEED\"] = 12] = \"FORMFEED\";\r\n    CharCode[CharCode[\"BYTEORDERMARK\"] = 65279] = \"BYTEORDERMARK\";\r\n    CharCode[CharCode[\"TAB\"] = 9] = \"TAB\";\r\n    CharCode[CharCode[\"VERTICALTAB\"] = 11] = \"VERTICALTAB\";\r\n})(CharCode = exports.CharCode || (exports.CharCode = {}));\r\n/** Tests if the specified character code is some sort of line break. */\r\nfunction isLineBreak(c) {\r\n    switch (c) {\r\n        case 10 /* LINEFEED */:\r\n        case 13 /* CARRIAGERETURN */:\r\n        case 8232 /* LINESEPARATOR */:\r\n        case 8233 /* PARAGRAPHSEPARATOR */:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nexports.isLineBreak = isLineBreak;\r\n/** Tests if the specified character code is some sort of white space. */\r\nfunction isWhiteSpace(c) {\r\n    switch (c) {\r\n        case 32 /* SPACE */:\r\n        case 9 /* TAB */:\r\n        case 11 /* VERTICALTAB */:\r\n        case 12 /* FORMFEED */:\r\n        case 160 /* NONBREAKINGSPACE */:\r\n        case 133 /* NEXTLINE */:\r\n        case 5760 /* OGHAM */:\r\n        case 8239 /* NARROWNOBREAKSPACE */:\r\n        case 8287 /* MATHEMATICALSPACE */:\r\n        case 12288 /* IDEOGRAPHICSPACE */:\r\n        case 65279 /* BYTEORDERMARK */:\r\n            return true;\r\n        default:\r\n            return c >= 8192 /* ENQUAD */ && c <= 8203 /* ZEROWIDTHSPACE */;\r\n    }\r\n}\r\nexports.isWhiteSpace = isWhiteSpace;\r\n/** Tests if the specified character code is a decimal digit. */\r\nfunction isDecimalDigit(c) {\r\n    return c >= 48 /* _0 */ && c <= 57 /* _9 */;\r\n}\r\nexports.isDecimalDigit = isDecimalDigit;\r\n/** Tests if the specified character code is an octal digit. */\r\nfunction isOctalDigit(c) {\r\n    return c >= 48 /* _0 */ && c <= 55 /* _7 */;\r\n}\r\nexports.isOctalDigit = isOctalDigit;\r\n/** Tests if the specified character code is a valid start of an identifier. */\r\nfunction isIdentifierStart(c) {\r\n    return c >= 65 /* A */ && c <= 90 /* Z */\r\n        || c >= 97 /* a */ && c <= 122 /* z */\r\n        || c == 36 /* DOLLAR */\r\n        || c == 95 /* _ */\r\n        || c > 0x7f && isUnicodeIdentifierStart(c);\r\n}\r\nexports.isIdentifierStart = isIdentifierStart;\r\n/** Tests if the specified character code is a valid keyword character. */\r\nfunction isKeywordCharacter(c) {\r\n    return c >= 97 /* a */ && c <= 122 /* z */;\r\n}\r\nexports.isKeywordCharacter = isKeywordCharacter;\r\n/** Tests if the specified character code is a valid part of an identifier. */\r\nfunction isIdentifierPart(c) {\r\n    return c >= 65 /* A */ && c <= 90 /* Z */\r\n        || c >= 97 /* a */ && c <= 122 /* z */\r\n        || c >= 48 /* _0 */ && c <= 57 /* _9 */\r\n        || c == 36 /* DOLLAR */\r\n        || c == 95 /* _ */\r\n        || c > 0x7f && isUnicodeIdentifierPart(c);\r\n}\r\nexports.isIdentifierPart = isIdentifierPart;\r\n// storing as u16 to save memory\r\nvar unicodeIdentifierStart = [\r\n    170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\r\n    740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906,\r\n    908, 908, 910, 929, 931,\r\n    1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514,\r\n    1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774,\r\n    1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969,\r\n    1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088,\r\n    2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384,\r\n    2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474,\r\n    2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,\r\n    2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613,\r\n    2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705,\r\n    2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784,\r\n    2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873,\r\n    2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958,\r\n    2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986,\r\n    2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125,\r\n    3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240,\r\n    3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333,\r\n    3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,\r\n    3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634,\r\n    3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725,\r\n    3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757,\r\n    3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840,\r\n    3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186,\r\n    4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293,\r\n    4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696,\r\n    4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798,\r\n    4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992,\r\n    5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872,\r\n    5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016,\r\n    6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389,\r\n    6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688,\r\n    6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141,\r\n    7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424,\r\n    7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025,\r\n    8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130,\r\n    8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,\r\n    8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469,\r\n    8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505,\r\n    8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584,\r\n    11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520,\r\n    11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670,\r\n    11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720,\r\n    11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329,\r\n    12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540,\r\n    12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893,\r\n    19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538,\r\n    42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888,\r\n    42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015,\r\n    43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,\r\n    43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520,\r\n    43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695,\r\n    43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739,\r\n    43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798,\r\n    43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243,\r\n    55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285,\r\n    64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323,\r\n    64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,\r\n    65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474,\r\n    65479, 65482, 65487, 65490, 65495, 65498, 65500,\r\n];\r\nvar unicodeIdentifierPart = [\r\n    170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\r\n    740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906,\r\n    908, 908, 910, 929, 931,\r\n    1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415,\r\n    1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520,\r\n    1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788,\r\n    1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112,\r\n    2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423,\r\n    2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482,\r\n    2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525,\r\n    2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602,\r\n    2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632,\r\n    2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693,\r\n    2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757,\r\n    2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821,\r\n    2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884,\r\n    2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929,\r\n    2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972,\r\n    2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018,\r\n    3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088,\r\n    3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157,\r\n    3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216,\r\n    3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285,\r\n    3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340,\r\n    3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424,\r\n    3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515,\r\n    3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570,\r\n    3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720,\r\n    3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751,\r\n    3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789,\r\n    3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895,\r\n    3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028,\r\n    4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304,\r\n    4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744,\r\n    4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808,\r\n    4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108,\r\n    5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902,\r\n    5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099,\r\n    6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272,\r\n    6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516,\r\n    6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783,\r\n    6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155,\r\n    7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676,\r\n    7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027,\r\n    8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134,\r\n    8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205,\r\n    8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417,\r\n    8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477,\r\n    8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517,\r\n    8521, 8526, 8526, 8544, 8584,\r\n    11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559,\r\n    11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686,\r\n    11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728,\r\n    11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335,\r\n    12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449,\r\n    12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799,\r\n    13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512,\r\n    42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783,\r\n    42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072,\r\n    43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309,\r\n    43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584,\r\n    43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741,\r\n    43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808,\r\n    43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203,\r\n    55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275,\r\n    64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321,\r\n    64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008,\r\n    65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140,\r\n    65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382,\r\n    65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,\r\n];\r\nfunction lookupInUnicodeMap(code, map) {\r\n    if (code < map[0])\r\n        return false;\r\n    var lo = 0;\r\n    var hi = map.length;\r\n    var mid;\r\n    while (lo + 1 < hi) {\r\n        mid = lo + (hi - lo) / 2;\r\n        mid -= mid % 2;\r\n        if (map[mid] <= code && code <= map[mid + 1]) {\r\n            return true;\r\n        }\r\n        if (code < map[mid]) {\r\n            hi = mid;\r\n        }\r\n        else {\r\n            lo = mid + 2;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction isUnicodeIdentifierStart(code) {\r\n    return code < 0 || code > 0xffff ? false\r\n        : lookupInUnicodeMap(code, unicodeIdentifierStart);\r\n}\r\nfunction isUnicodeIdentifierPart(code) {\r\n    return code < 0 || code > 0xffff ? false\r\n        : lookupInUnicodeMap(code, unicodeIdentifierPart);\r\n}\r\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar separator = 47 /* SLASH */;\r\n/**\r\n * Normalizes the specified path, removing interior placeholders.\r\n * Expects a posix-compatible relative path (not Windows compatible).\r\n */\r\nfunction normalize(path) {\r\n    var pos = 0;\r\n    var len = path.length;\r\n    // trim leading './'\r\n    while (pos + 1 < len &&\r\n        path.charCodeAt(pos) == 46 /* DOT */ &&\r\n        path.charCodeAt(pos + 1) == separator) {\r\n        pos += 2;\r\n    }\r\n    if (pos > 0 || len < path.length) {\r\n        path = path.substring(pos, len);\r\n        len -= pos;\r\n        pos = 0;\r\n    }\r\n    var atEnd;\r\n    while (pos + 1 < len) {\r\n        atEnd = false;\r\n        // we are only interested in '/.' sequences ...\r\n        if (path.charCodeAt(pos) == separator &&\r\n            path.charCodeAt(pos + 1) == 46 /* DOT */) {\r\n            // '/.' ( '/' | $ )\r\n            atEnd = pos + 2 == len;\r\n            if (atEnd ||\r\n                pos + 2 < len &&\r\n                    path.charCodeAt(pos + 2) == separator) {\r\n                path = atEnd\r\n                    ? path.substring(0, pos)\r\n                    : path.substring(0, pos) + path.substring(pos + 2);\r\n                len -= 2;\r\n                continue;\r\n            }\r\n            // '/.' ( './' | '.' $ )\r\n            atEnd = pos + 3 == len;\r\n            if (atEnd && path.charCodeAt(pos + 2) == 46 /* DOT */ ||\r\n                pos + 3 < len &&\r\n                    path.charCodeAt(pos + 2) == 46 /* DOT */ &&\r\n                    path.charCodeAt(pos + 3) == separator) {\r\n                // find preceeding '/'\r\n                var ipos = pos;\r\n                while (--ipos >= 0) {\r\n                    if (path.charCodeAt(ipos) == separator) {\r\n                        if (pos - ipos != 3 ||\r\n                            path.charCodeAt(ipos + 1) != 46 /* DOT */ ||\r\n                            path.charCodeAt(ipos + 2) != 46 /* DOT */) {\r\n                            path = atEnd\r\n                                ? path.substring(0, ipos)\r\n                                : path.substring(0, ipos) + path.substring(pos + 3);\r\n                            len -= pos + 3 - ipos;\r\n                            pos = ipos - 1; // incremented again at end of loop\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                // if there's no preceeding '/', trim start if non-empty\r\n                if (ipos < 0 && pos > 0) {\r\n                    if (pos != 2 ||\r\n                        path.charCodeAt(0) != 46 /* DOT */ ||\r\n                        path.charCodeAt(1) != 46 /* DOT */) {\r\n                        path = path.substring(pos + 4);\r\n                        len = path.length;\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        pos++;\r\n    }\r\n    return len > 0 ? path : \".\";\r\n}\r\nexports.normalize = normalize;\r\n/** Resolves the specified path relative to the specified origin. */\r\nfunction resolve(normalizedPath, origin) {\r\n    if (normalizedPath.startsWith(\"std/\")) {\r\n        return normalizedPath;\r\n    }\r\n    return normalize(dirname(origin) + String.fromCharCode(separator) + normalizedPath);\r\n}\r\nexports.resolve = resolve;\r\n/** Obtains the directory portion of a normalized path. */\r\nfunction dirname(normalizedPath) {\r\n    var pos = normalizedPath.length;\r\n    while (--pos > 0) {\r\n        if (normalizedPath.charCodeAt(pos) == separator) {\r\n            return normalizedPath.substring(0, pos);\r\n        }\r\n    }\r\n    return \".\";\r\n}\r\nexports.dirname = dirname;\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(12);\nmodule.exports = __webpack_require__(19);\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__webpack_require__(13);\r\n__webpack_require__(14);\r\n__webpack_require__(17);\r\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var globalScope = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || self;\r\n\r\nObject.defineProperties(\r\n  globalScope[\"i8\"] = function i8(value) { return value << 24 >> 24; }\r\n, {\r\n  \"MIN_VALUE\": { value: -128, writable: false },\r\n  \"MAX_VALUE\": { value: 127, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"i16\"] = function i16(value) { return value << 16 >> 16; }\r\n, {\r\n  \"MIN_VALUE\": { value: -32768, writable: false },\r\n  \"MAX_VALUE\": { value: 32767, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"i32\"] = globalScope[\"isize\"] = function i32(value) { return value | 0; }\r\n, {\r\n  \"MIN_VALUE\": { value: -2147483648, writable: false },\r\n  \"MAX_VALUE\": { value: 2147483647, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"u8\"] = function u8(value) { return value & 0xff; }\r\n, {\r\n  \"MIN_VALUE\": { value: 0, writable: false },\r\n  \"MAX_VALUE\": { value: 255, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"u16\"] = function u16(value) { return value & 0xffff; }\r\n, {\r\n  \"MIN_VALUE\": { value: 0, writable: false },\r\n  \"MAX_VALUE\": { value: 65535, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"u32\"] = globalScope[\"usize\"] = function u32(value) { return value >>> 0; }\r\n, {\r\n  \"MIN_VALUE\": { value: 0, writable: false },\r\n  \"MAX_VALUE\": { value: 4294967295, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"bool\"] = function bool(value) { return !!value; }\r\n, {\r\n  \"MIN_VALUE\": { value: 0, writable: false },\r\n  \"MAX_VALUE\": { value: 1, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"f32\"] = function f32(value) { return Math.fround(value); }\r\n, {\r\n  \"MIN_VALUE\": { value: Math.fround(-3.40282347e+38), writable: false },\r\n  \"MAX_VALUE\": { value: Math.fround(3.40282347e+38), writable: false },\r\n  \"MIN_SAFE_INTEGER\": { value: -16777215, writable: false },\r\n  \"MAX_SAFE_INTEGER\": { value: 16777215, writable: false },\r\n  \"EPSILON\": { value: Math.fround(1.19209290e-07), writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"f64\"] = function f64(value) { return +value; }\r\n, {\r\n  \"MIN_VALUE\": { value: -1.7976931348623157e+308, writable: false },\r\n  \"MAX_VALUE\": { value: 1.7976931348623157e+308, writable: false },\r\n  \"MIN_SAFE_INTEGER\": { value: -9007199254740991, writable: false },\r\n  \"MAX_SAFE_INTEGER\": { value: 9007199254740991, writable: false },\r\n  \"EPSILON\": { value: 2.2204460492503131e-16, writable: false }\r\n});\r\n\r\nglobalScope[\"clz\"] = Math.clz32;\r\n\r\nglobalScope[\"abs\"] = Math.abs;\r\n\r\nglobalScope[\"max\"] = Math.max;\r\n\r\nglobalScope[\"min\"] = Math.min;\r\n\r\nglobalScope[\"ceil\"] = Math.ceil;\r\n\r\nglobalScope[\"floor\"] = Math.floor;\r\n\r\nglobalScope[\"select\"] = function select(ifTrue, ifFalse, condition) {\r\n  return condition ? ifTrue : ifFalse;\r\n};\r\n\r\nglobalScope[\"sqrt\"] = Math.sqrt;\r\n\r\nglobalScope[\"trunc\"] = Math.trunc;\r\n\r\nglobalScope[\"bswap\"] = function bswap(value) {\r\n  var a = value >> 8 & 0x00FF00FF;\r\n  var b = (value & 0x00FF00FF) << 8;\r\n  value = a | b;\r\n  a = value >> 16 & 0x0000FFFF;\r\n  b = (value & 0x0000FFFF) << 16;\r\n  return a | b;\r\n};\r\n\r\nglobalScope[\"bswap16\"] = function bswap16(value) {\r\n  return ((value << 8) & 0xFF00) | ((value >> 8) & 0x00FF) | (value & 0xFFFF0000);\r\n};\r\n\r\nfunction UnreachableError() {\r\n  if (Error.captureStackTrace) {\r\n    Error.captureStackTrace(this, UnreachableError);\r\n  } else {\r\n    this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\r\n  }\r\n}\r\nUnreachableError.prototype = Object.create(Error.prototype);\r\nUnreachableError.prototype.name = \"UnreachableError\";\r\nUnreachableError.prototype.message = \"unreachable\";\r\n\r\nglobalScope[\"unreachable\"] = function unreachable() {\r\n  throw new UnreachableError();\r\n};\r\n\r\nfunction AssertionError(message) {\r\n  this.message = message || \"assertion failed\";\r\n  if (Error.captureStackTrace) {\r\n    Error.captureStackTrace(this, AssertionError);\r\n  } else {\r\n    this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\r\n  }\r\n}\r\nAssertionError.prototype = Object.create(Error.prototype);\r\nAssertionError.prototype.name = \"AssertionError\";\r\n\r\nglobalScope[\"assert\"] = function assert(isTrueish, message) {\r\n  if (isTrueish) return isTrueish;\r\n  throw new AssertionError(message);\r\n};\r\n\r\nglobalScope[\"changetype\"] = function changetype(value) {\r\n  return value;\r\n};\r\n\r\nglobalScope[\"parseI32\"] = function parseI32(str, radix) {\r\n  return parseInt(str, undefined) | 0;\r\n};\r\n\r\nString[\"fromCharCodes\"] = function fromCharCodes(arr) {\r\n  return String.fromCharCode.apply(String, arr);\r\n};\r\n\r\nString[\"fromCodePoints\"] = function fromCodePoints(arr) {\r\n  return String.fromCodePoint.apply(String, arr);\r\n};\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {// Copy Binaryen exports to global scope\r\n\r\nconst binaryen = global.Binaryen || __webpack_require__(15);\r\n\r\nfor (var key in binaryen)\r\n  if (key.startsWith(\"_Binaryen\") || key.startsWith(\"_Relooper\"))\r\n    global[key] = binaryen[key];\r\n\r\n// Utilize Binaryen's heap\r\n\r\nglobal.allocate_memory = function(size) {\r\n  if (!size) return 0; // should be safe in our case\r\n  return binaryen._malloc(size);\r\n};\r\n\r\nglobal.free_memory = function(ptr) {\r\n  if (ptr) binaryen._free(ptr);\r\n};\r\n\r\nglobal.move_memory = function(dest, src, n) {\r\n  return binaryen._memmove(dest, src, n);\r\n};\r\n\r\nglobal.store = function(ptr, val) {\r\n  binaryen.HEAPU8[ptr] = val;\r\n};\r\n\r\nglobal.load = function(ptr) {\r\n  return binaryen.HEAPU8[ptr];\r\n};\r\n\r\n// Implement module stubs\r\n\r\nconst Module = __webpack_require__(0).Module;\r\n\r\nModule.prototype.toText = function toText() {\r\n  var previousPrint = binaryen.print;\r\n  var ret = \"\";\r\n  binaryen.print = function(x) { ret += x + \"\\n\" };\r\n  _BinaryenModulePrint(this.ref);\r\n  binaryen.print = previousPrint;\r\n  return ret;\r\n};\r\n\r\nModule.prototype.toAsmjs = function toAsmjs() {\r\n  var previousPrint = binaryen.print;\r\n  var ret = \"\";\r\n  binaryen.print = function(x) { ret += x + \"\\n\" };\r\n  _BinaryenModulePrintAsmjs(this.ref);\r\n  binaryen.print = previousPrint;\r\n  return ret;\r\n};\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_15__;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar compiler_1 = __webpack_require__(4);\r\nvar diagnostics_1 = __webpack_require__(1);\r\nvar types_1 = __webpack_require__(5);\r\nvar module_1 = __webpack_require__(0);\r\nvar program_1 = __webpack_require__(2);\r\n/** Compiles a get of a built-in global. */\r\nfunction compileGetConstant(compiler, global, reportNode) {\r\n    switch (global.internalName) {\r\n        case \"NaN\":// context-sensitive\r\n            if (compiler.currentType == types_1.Type.f32) {\r\n                return compiler.module.createF32(NaN);\r\n            }\r\n            else {\r\n                compiler.currentType = types_1.Type.f64;\r\n                return compiler.module.createF64(NaN);\r\n            }\r\n        case \"Infinity\":// context-sensitive\r\n            if (compiler.currentType == types_1.Type.f32) {\r\n                return compiler.module.createF32(Infinity);\r\n            }\r\n            else {\r\n                compiler.currentType = types_1.Type.f64;\r\n                return compiler.module.createF64(Infinity);\r\n            }\r\n        case \"HEAP_BASE\":// never inlined for linking purposes\r\n            compiler.currentType = compiler.options.usizeType;\r\n            return compiler.module.createGetGlobal(\"HEAP_BASE\", compiler.currentType.toNativeType());\r\n    }\r\n    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n    return compiler.module.createUnreachable();\r\n}\r\nexports.compileGetConstant = compileGetConstant;\r\n/** Compiles a call to a built-in function. */\r\nfunction compileCall(compiler, prototype, typeArguments, operands, contextualType, reportNode) {\r\n    var module = compiler.module;\r\n    var arg0, arg1, arg2, ret;\r\n    var tempLocal0, tempLocal1;\r\n    var type, offset;\r\n    // NOTE that some implementations below make use of the select expression where straight-forward.\r\n    // whether worth or not should probably be tested once/ it's known if/how embedders handle it.\r\n    // search: createSelect\r\n    switch (prototype.internalName) {\r\n        // math\r\n        case \"isNaN\":// isNaN<T?>(value: T) -> bool\r\n            compiler.currentType = types_1.Type.bool;\r\n            if (operands.length != 1) {\r\n                if (typeArguments && typeArguments.length != 1) {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.f64, 0 /* NONE */);\r\n            }\r\n            switch (compiler.currentType.kind) {\r\n                case 11 /* F32 */:\r\n                    tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.f32);\r\n                    ret = module.createBinary(module_1.BinaryOp.NeF32, module.createTeeLocal(tempLocal0.index, arg0), module.createGetLocal(tempLocal0.index, module_1.NativeType.F32));\r\n                    break;\r\n                case 12 /* F64 */:\r\n                    tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.f64);\r\n                    ret = module.createBinary(module_1.BinaryOp.NeF64, module.createTeeLocal(tempLocal0.index, arg0), module.createGetLocal(tempLocal0.index, module_1.NativeType.F64));\r\n                    break;\r\n                case 13 /* VOID */:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n                default:// every other type is never NaN\r\n                    ret = module.createI32(0);\r\n                    break;\r\n            }\r\n            compiler.currentType = types_1.Type.bool;\r\n            return ret;\r\n        case \"isFinite\":// isFinite<T?>(value: T) -> bool\r\n            compiler.currentType = types_1.Type.bool;\r\n            if (operands.length != 1) {\r\n                if (typeArguments && typeArguments.length != 1) {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.f64, 0 /* NONE */);\r\n            }\r\n            switch (compiler.currentType.kind) {\r\n                case 11 /* F32 */:\r\n                    tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.f32);\r\n                    ret = module.createSelect(module.createBinary(module_1.BinaryOp.NeF32, module.createUnary(module_1.UnaryOp.AbsF32, module.createTeeLocal(tempLocal0.index, arg0)), module.createF32(Infinity)), module.createI32(0), module.createBinary(module_1.BinaryOp.EqF32, module.createGetLocal(tempLocal0.index, module_1.NativeType.F32), module.createGetLocal(tempLocal0.index, module_1.NativeType.F32)));\r\n                    break;\r\n                case 12 /* F64 */:\r\n                    tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.f64);\r\n                    ret = module.createSelect(module.createBinary(module_1.BinaryOp.NeF64, module.createUnary(module_1.UnaryOp.AbsF64, module.createTeeLocal(tempLocal0.index, arg0)), module.createF64(Infinity)), module.createI32(0), module.createBinary(module_1.BinaryOp.EqF64, module.createGetLocal(tempLocal0.index, module_1.NativeType.F64), module.createGetLocal(tempLocal0.index, module_1.NativeType.F64)));\r\n                    break;\r\n                case 13 /* VOID */:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n                default:// every other type is always finite\r\n                    ret = module.createI32(1);\r\n                    break;\r\n            }\r\n            compiler.currentType = types_1.Type.bool;\r\n            return ret;\r\n        case \"clz\":// clz<T?>(value: T) -> T\r\n            if (operands.length != 1) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.i32, 0 /* NONE */);\r\n            }\r\n            switch (compiler.currentType.kind) {\r\n                default:// any integer up to 32-bits incl. bool\r\n                    ret = module.createUnary(module_1.UnaryOp.ClzI32, arg0);\r\n                    break;\r\n                case 9 /* USIZE */:\r\n                    if (compiler.currentType.isReference) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = module.createUnreachable();\r\n                        break;\r\n                    }\r\n                // fall-through\r\n                case 4 /* ISIZE */:\r\n                    ret = module.createUnary(compiler.options.isWasm64\r\n                        ? module_1.UnaryOp.ClzI64\r\n                        : module_1.UnaryOp.ClzI32, arg0);\r\n                    break;\r\n                case 3 /* I64 */:\r\n                case 8 /* U64 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.ClzI64, arg0);\r\n                    break;\r\n                case 11 /* F32 */:\r\n                case 12 /* F64 */:\r\n                case 13 /* VOID */:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"ctz\":// ctz<T?>(value: T) -> T\r\n            if (operands.length != 1) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.i32, 0 /* NONE */);\r\n            }\r\n            switch (compiler.currentType.kind) {\r\n                default:// any integer up to 32-bits incl. bool\r\n                    ret = module.createUnary(module_1.UnaryOp.CtzI32, arg0);\r\n                    break;\r\n                case 9 /* USIZE */:\r\n                    if (compiler.currentType.isReference) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = module.createUnreachable();\r\n                        break;\r\n                    }\r\n                // fall-through\r\n                case 4 /* ISIZE */:\r\n                    ret = module.createUnary(compiler.options.isWasm64\r\n                        ? module_1.UnaryOp.CtzI64\r\n                        : module_1.UnaryOp.CtzI32, arg0);\r\n                    break;\r\n                case 3 /* I64 */:\r\n                case 8 /* U64 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.CtzI64, arg0);\r\n                    break;\r\n                case 11 /* F32 */:\r\n                case 12 /* F64 */:\r\n                case 13 /* VOID */:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"popcnt\":// popcnt<T?>(value: T) -> T\r\n            if (operands.length != 1) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.i32, 0 /* NONE */);\r\n            }\r\n            switch (compiler.currentType.kind) {\r\n                default:// any integer up to 32-bits incl. bool\r\n                    ret = module.createUnary(module_1.UnaryOp.PopcntI32, arg0);\r\n                    break;\r\n                case 9 /* USIZE */:\r\n                    if (compiler.currentType.isReference) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = module.createUnreachable();\r\n                        break;\r\n                    }\r\n                // fall-through\r\n                case 4 /* ISIZE */:\r\n                    ret = module.createUnary(compiler.options.isWasm64\r\n                        ? module_1.UnaryOp.PopcntI64\r\n                        : module_1.UnaryOp.PopcntI32, arg0);\r\n                    break;\r\n                case 3 /* I64 */:\r\n                case 8 /* U64 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.PopcntI64, arg0);\r\n                    break;\r\n                case 11 /* F32 */:\r\n                case 12 /* F64 */:\r\n                case 13 /* VOID */:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"rotl\":// rotl<T?>(value: T, shift: T) -> T\r\n            if (operands.length != 2) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"2\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.i32, 0 /* NONE */);\r\n            }\r\n            arg1 = compiler.compileExpression(operands[1], compiler.currentType);\r\n            switch (compiler.currentType.kind) {\r\n                case 0 /* I8 */:\r\n                case 1 /* I16 */:\r\n                case 5 /* U8 */:\r\n                case 6 /* U16 */:\r\n                case 10 /* BOOL */:\r\n                    ret = compiler_1.makeSmallIntegerWrap(module.createBinary(module_1.BinaryOp.RotlI32, arg0, arg1), compiler.currentType, module);\r\n                // fall-through\r\n                case 2 /* I32 */:\r\n                case 7 /* U32 */:\r\n                    ret = module.createBinary(module_1.BinaryOp.RotlI32, arg0, arg1);\r\n                    break;\r\n                case 9 /* USIZE */:\r\n                    if (compiler.currentType.isReference) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = module.createUnreachable();\r\n                        break;\r\n                    }\r\n                // fall-through\r\n                case 4 /* ISIZE */:\r\n                    ret = module.createBinary(compiler.options.isWasm64\r\n                        ? module_1.BinaryOp.RotlI64\r\n                        : module_1.BinaryOp.RotlI32, arg0, arg1);\r\n                    break;\r\n                case 3 /* I64 */:\r\n                case 8 /* U64 */:\r\n                    ret = module.createBinary(module_1.BinaryOp.RotlI64, arg0, arg1);\r\n                    break;\r\n                default:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"rotr\":// rotr<T?>(value: T, shift: T) -> T\r\n            if (operands.length != 2) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"2\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.i32, 0 /* NONE */);\r\n            }\r\n            arg1 = compiler.compileExpression(operands[1], compiler.currentType);\r\n            switch (compiler.currentType.kind) {\r\n                case 0 /* I8 */:\r\n                case 1 /* I16 */:\r\n                case 5 /* U8 */:\r\n                case 6 /* U16 */:\r\n                case 10 /* BOOL */:\r\n                    ret = compiler_1.makeSmallIntegerWrap(module.createBinary(module_1.BinaryOp.RotrI32, arg0, arg1), compiler.currentType, module);\r\n                    break;\r\n                case 2 /* I32 */:\r\n                case 7 /* U32 */:\r\n                    ret = module.createBinary(module_1.BinaryOp.RotrI32, arg0, arg1);\r\n                    break;\r\n                case 9 /* USIZE */:\r\n                    if (compiler.currentType.isReference) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = module.createUnreachable();\r\n                        break;\r\n                    }\r\n                // fall-through\r\n                case 4 /* ISIZE */:\r\n                    ret = module.createBinary(compiler.options.isWasm64\r\n                        ? module_1.BinaryOp.RotrI64\r\n                        : module_1.BinaryOp.RotrI32, arg0, arg1);\r\n                    break;\r\n                case 3 /* I64 */:\r\n                case 8 /* U64 */:\r\n                    ret = module.createBinary(module_1.BinaryOp.RotrI64, arg0, arg1);\r\n                    break;\r\n                default:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"abs\":// abs<T?>(value: T) -> T\r\n            if (operands.length != 1) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.f64, 0 /* NONE */);\r\n            }\r\n            switch (compiler.currentType.kind) {\r\n                case 0 /* I8 */:\r\n                case 1 /* I16 */:\r\n                // doesn't need sign-extension here because ifFalse below is either positive\r\n                // or MIN_VALUE (-MIN_VALUE == MIN_VALUE) if selected\r\n                case 2 /* I32 */:\r\n                    tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.i32);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createBinary(module_1.BinaryOp.SubI32, // ifFalse\r\n                    module.createI32(0), module.createGetLocal(tempLocal0.index, module_1.NativeType.I32)), module.createBinary(module_1.BinaryOp.GtI32, module.createGetLocal(tempLocal0.index, module_1.NativeType.I32), module.createI32(0)));\r\n                    break;\r\n                case 4 /* ISIZE */:\r\n                    tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(compiler.options.usizeType);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createBinary(compiler.options.isWasm64\r\n                        ? module_1.BinaryOp.SubI64\r\n                        : module_1.BinaryOp.SubI32, compiler.options.usizeType.toNativeZero(module), module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType)), module.createBinary(compiler.options.isWasm64\r\n                        ? module_1.BinaryOp.GtI64\r\n                        : module_1.BinaryOp.GtI32, module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType), compiler.options.usizeType.toNativeZero(module)));\r\n                    break;\r\n                case 3 /* I64 */:\r\n                    tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.i64);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createBinary(module_1.BinaryOp.SubI64, module.createI64(0, 0), module.createGetLocal(tempLocal0.index, module_1.NativeType.I64)), module.createBinary(module_1.BinaryOp.GtI64, module.createGetLocal(tempLocal0.index, module_1.NativeType.I64), module.createI64(0, 0)));\r\n                    break;\r\n                case 9 /* USIZE */:\r\n                    if (compiler.currentType.isReference) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = module.createUnreachable();\r\n                        break;\r\n                    }\r\n                // fall-through\r\n                case 5 /* U8 */:\r\n                case 6 /* U16 */:\r\n                case 7 /* U32 */:\r\n                case 8 /* U64 */:\r\n                case 10 /* BOOL */:\r\n                    ret = arg0;\r\n                    break;\r\n                case 11 /* F32 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.AbsF32, arg0);\r\n                    break;\r\n                case 12 /* F64 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.AbsF64, arg0);\r\n                    break;\r\n                case 13 /* VOID */:\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n                default:// void\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"max\":// max<T?>(left: T, right: T) -> T\r\n            if (operands.length != 2) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"2\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.f64, 0 /* NONE */);\r\n            }\r\n            arg1 = compiler.compileExpression(operands[1], compiler.currentType);\r\n            switch (compiler.currentType.kind) {\r\n                case 0 /* I8 */:\r\n                case 1 /* I16 */:\r\n                case 2 /* I32 */:\r\n                    tempLocal0 = compiler.currentFunction.getTempLocal(types_1.Type.i32);\r\n                    tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.i32);\r\n                    compiler.currentFunction.freeTempLocal(tempLocal0);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createTeeLocal(tempLocal1.index, arg1), module.createBinary(module_1.BinaryOp.GtI32, module.createGetLocal(tempLocal0.index, module_1.NativeType.I32), module.createGetLocal(tempLocal1.index, module_1.NativeType.I32)));\r\n                    break;\r\n                case 5 /* U8 */:\r\n                case 6 /* U16 */:\r\n                case 7 /* U32 */:\r\n                case 10 /* BOOL */:\r\n                    tempLocal0 = compiler.currentFunction.getTempLocal(types_1.Type.i32);\r\n                    tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.i32);\r\n                    compiler.currentFunction.freeTempLocal(tempLocal0);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createTeeLocal(tempLocal1.index, arg1), module.createBinary(module_1.BinaryOp.GtU32, module.createGetLocal(tempLocal0.index, module_1.NativeType.I32), module.createGetLocal(tempLocal1.index, module_1.NativeType.I32)));\r\n                    break;\r\n                case 3 /* I64 */:\r\n                    tempLocal0 = compiler.currentFunction.getTempLocal(types_1.Type.i64);\r\n                    tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.i64);\r\n                    compiler.currentFunction.freeTempLocal(tempLocal0);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createTeeLocal(tempLocal1.index, arg1), module.createBinary(module_1.BinaryOp.GtI64, module.createGetLocal(tempLocal0.index, module_1.NativeType.I64), module.createGetLocal(tempLocal1.index, module_1.NativeType.I64)));\r\n                    break;\r\n                case 8 /* U64 */:\r\n                    tempLocal0 = compiler.currentFunction.getTempLocal(types_1.Type.i64);\r\n                    tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.i64);\r\n                    compiler.currentFunction.freeTempLocal(tempLocal0);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createTeeLocal(tempLocal1.index, arg1), module.createBinary(module_1.BinaryOp.GtU64, module.createGetLocal(tempLocal0.index, module_1.NativeType.I64), module.createGetLocal(tempLocal1.index, module_1.NativeType.I64)));\r\n                    break;\r\n                case 4 /* ISIZE */:\r\n                    tempLocal0 = compiler.currentFunction.getTempLocal(compiler.options.usizeType);\r\n                    tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(compiler.options.usizeType);\r\n                    compiler.currentFunction.freeTempLocal(tempLocal0);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createTeeLocal(tempLocal1.index, arg1), module.createBinary(compiler.options.isWasm64\r\n                        ? module_1.BinaryOp.GtI64\r\n                        : module_1.BinaryOp.GtI32, module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType), module.createGetLocal(tempLocal1.index, compiler.options.nativeSizeType)));\r\n                    break;\r\n                case 9 /* USIZE */:\r\n                    if (compiler.currentType.isReference) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = module.createUnreachable();\r\n                        break;\r\n                    }\r\n                    tempLocal0 = compiler.currentFunction.getTempLocal(compiler.options.usizeType);\r\n                    tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(compiler.options.usizeType);\r\n                    compiler.currentFunction.freeTempLocal(tempLocal0);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createTeeLocal(tempLocal1.index, arg1), module.createBinary(compiler.options.isWasm64\r\n                        ? module_1.BinaryOp.GtU64\r\n                        : module_1.BinaryOp.GtU32, module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType), module.createGetLocal(tempLocal1.index, compiler.options.nativeSizeType)));\r\n                    break;\r\n                case 11 /* F32 */:\r\n                    ret = module.createBinary(module_1.BinaryOp.MaxF32, arg0, arg1);\r\n                    break;\r\n                case 12 /* F64 */:\r\n                    ret = module.createBinary(module_1.BinaryOp.MaxF64, arg0, arg1);\r\n                    break;\r\n                default:// void\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"min\":// min<T?>(left: T, right: T) -> T\r\n            if (operands.length != 2) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"2\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.f64, 0 /* NONE */);\r\n            }\r\n            arg1 = compiler.compileExpression(operands[1], compiler.currentType);\r\n            switch (compiler.currentType.kind) {\r\n                case 0 /* I8 */:\r\n                case 1 /* I16 */:\r\n                case 2 /* I32 */:\r\n                    tempLocal0 = compiler.currentFunction.getTempLocal(types_1.Type.i32);\r\n                    tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.i32);\r\n                    compiler.currentFunction.freeTempLocal(tempLocal0);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createTeeLocal(tempLocal1.index, arg1), module.createBinary(module_1.BinaryOp.LtI32, module.createGetLocal(tempLocal0.index, module_1.NativeType.I32), module.createGetLocal(tempLocal1.index, module_1.NativeType.I32)));\r\n                    break;\r\n                case 5 /* U8 */:\r\n                case 6 /* U16 */:\r\n                case 7 /* U32 */:\r\n                case 10 /* BOOL */:\r\n                    tempLocal0 = compiler.currentFunction.getTempLocal(types_1.Type.i32);\r\n                    tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.i32);\r\n                    compiler.currentFunction.freeTempLocal(tempLocal0);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createTeeLocal(tempLocal1.index, arg1), module.createBinary(module_1.BinaryOp.LtU32, module.createGetLocal(tempLocal0.index, module_1.NativeType.I32), module.createGetLocal(tempLocal1.index, module_1.NativeType.I32)));\r\n                    break;\r\n                case 3 /* I64 */:\r\n                    tempLocal0 = compiler.currentFunction.getTempLocal(types_1.Type.i64);\r\n                    tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.i64);\r\n                    compiler.currentFunction.freeTempLocal(tempLocal0);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createTeeLocal(tempLocal1.index, arg1), module.createBinary(module_1.BinaryOp.LtI64, module.createGetLocal(tempLocal0.index, module_1.NativeType.I64), module.createGetLocal(tempLocal1.index, module_1.NativeType.I64)));\r\n                    break;\r\n                case 8 /* U64 */:\r\n                    tempLocal0 = compiler.currentFunction.getTempLocal(types_1.Type.i64);\r\n                    tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.i64);\r\n                    compiler.currentFunction.freeTempLocal(tempLocal0);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createTeeLocal(tempLocal1.index, arg1), module.createBinary(module_1.BinaryOp.LtU64, module.createGetLocal(tempLocal0.index, module_1.NativeType.I64), module.createGetLocal(tempLocal1.index, module_1.NativeType.I64)));\r\n                    break;\r\n                case 4 /* ISIZE */:\r\n                    tempLocal0 = compiler.currentFunction.getTempLocal(compiler.options.usizeType);\r\n                    tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(compiler.options.usizeType);\r\n                    compiler.currentFunction.freeTempLocal(tempLocal0);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createTeeLocal(tempLocal1.index, arg1), module.createBinary(compiler.options.isWasm64\r\n                        ? module_1.BinaryOp.LtI64\r\n                        : module_1.BinaryOp.LtI32, module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType), module.createGetLocal(tempLocal1.index, compiler.options.nativeSizeType)));\r\n                    break;\r\n                case 9 /* USIZE */:\r\n                    if (compiler.currentType.isReference) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = module.createUnreachable();\r\n                        break;\r\n                    }\r\n                    tempLocal0 = compiler.currentFunction.getTempLocal(compiler.options.usizeType);\r\n                    tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(compiler.options.usizeType);\r\n                    compiler.currentFunction.freeTempLocal(tempLocal0);\r\n                    ret = module.createSelect(module.createTeeLocal(tempLocal0.index, arg0), module.createTeeLocal(tempLocal1.index, arg1), module.createBinary(compiler.options.isWasm64\r\n                        ? module_1.BinaryOp.LtU64\r\n                        : module_1.BinaryOp.LtU32, module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType), module.createGetLocal(tempLocal1.index, compiler.options.nativeSizeType)));\r\n                    break;\r\n                case 11 /* F32 */:\r\n                    ret = module.createBinary(module_1.BinaryOp.MinF32, arg0, arg1);\r\n                    break;\r\n                case 12 /* F64 */:\r\n                    ret = module.createBinary(module_1.BinaryOp.MinF64, arg0, arg1);\r\n                    break;\r\n                default:// void\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"ceil\":// ceil<T?>(value: T) -> T\r\n            if (operands.length != 1) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.f64, 0 /* NONE */);\r\n            }\r\n            switch (compiler.currentType.kind) {\r\n                case 9 /* USIZE */:\r\n                    if (compiler.currentType.isReference) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = module.createUnreachable();\r\n                        break;\r\n                    }\r\n                // fall-through\r\n                default:// any integer\r\n                    ret = arg0;\r\n                    break;\r\n                case 11 /* F32 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.CeilF32, arg0);\r\n                    break;\r\n                case 12 /* F64 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.CeilF64, arg0);\r\n                    break;\r\n                case 13 /* VOID */:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"floor\":// floor<T?>(value: T) -> T\r\n            if (operands.length != 1) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.f64, 0 /* NONE */);\r\n            }\r\n            switch (compiler.currentType.kind) {\r\n                case 9 /* USIZE */:\r\n                    if (compiler.currentType.isReference) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = module.createUnreachable();\r\n                        break;\r\n                    }\r\n                // fall-through\r\n                default:// any integer\r\n                    ret = arg0;\r\n                    break;\r\n                case 11 /* F32 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.FloorF32, arg0);\r\n                    break;\r\n                case 12 /* F64 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.FloorF64, arg0);\r\n                    break;\r\n                case 13 /* VOID */:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"copysign\":// copysign<T?>(left: T, right: T) -> T\r\n            if (operands.length != 2) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"2\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.f64, 0 /* NONE */);\r\n            }\r\n            arg1 = compiler.compileExpression(operands[1], compiler.currentType);\r\n            switch (compiler.currentType.kind) {\r\n                // TODO: does an integer version make sense?\r\n                case 11 /* F32 */:\r\n                    ret = module.createBinary(module_1.BinaryOp.CopysignF32, arg0, arg1);\r\n                    break;\r\n                case 12 /* F64 */:\r\n                    ret = module.createBinary(module_1.BinaryOp.CopysignF64, arg0, arg1);\r\n                    break;\r\n                default:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"nearest\":// nearest<T?>(value: T) -> T\r\n            if (operands.length != 1) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.f64, 0 /* NONE */);\r\n            }\r\n            switch (compiler.currentType.kind) {\r\n                case 9 /* USIZE */:\r\n                    if (compiler.currentType.isReference) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = module.createUnreachable();\r\n                        break;\r\n                    }\r\n                // fall-through\r\n                default:// any integer\r\n                    ret = arg0;\r\n                    break;\r\n                case 11 /* F32 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.NearestF32, arg0);\r\n                    break;\r\n                case 12 /* F64 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.NearestF64, arg0);\r\n                    break;\r\n                case 13 /* VOID */:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"reinterpret\":// reinterpret<T!>(value: *) -> T\r\n            if (operands.length != 1) {\r\n                if (!(typeArguments && typeArguments.length == 1)) {\r\n                    if (typeArguments && typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\");\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (!(typeArguments && typeArguments.length == 1)) {\r\n                if (typeArguments && typeArguments.length)\r\n                    compiler.currentType = typeArguments[0];\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\");\r\n                return module.createUnreachable();\r\n            }\r\n            switch (typeArguments[0].kind) {\r\n                case 2 /* I32 */:\r\n                case 7 /* U32 */:\r\n                    arg0 = compiler.compileExpression(operands[0], types_1.Type.f32);\r\n                    ret = module.createUnary(module_1.UnaryOp.ReinterpretF32, arg0);\r\n                    break;\r\n                case 3 /* I64 */:\r\n                case 8 /* U64 */:\r\n                    arg0 = compiler.compileExpression(operands[0], types_1.Type.f64);\r\n                    ret = module.createUnary(module_1.UnaryOp.ReinterpretF64, arg0);\r\n                    break;\r\n                case 9 /* USIZE */:\r\n                    if (typeArguments[0].isReference) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        compiler.currentType = typeArguments[0];\r\n                        return module.createUnreachable();\r\n                    }\r\n                // fall-through\r\n                case 4 /* ISIZE */:\r\n                    arg0 = compiler.compileExpression(operands[0], compiler.options.isWasm64\r\n                        ? types_1.Type.f64\r\n                        : types_1.Type.f32);\r\n                    ret = module.createUnary(compiler.options.isWasm64\r\n                        ? module_1.UnaryOp.ReinterpretF64\r\n                        : module_1.UnaryOp.ReinterpretF32, arg0);\r\n                    break;\r\n                case 11 /* F32 */:\r\n                    arg0 = compiler.compileExpression(operands[0], types_1.Type.u32);\r\n                    ret = module.createUnary(module_1.UnaryOp.ReinterpretI32, arg0);\r\n                    break;\r\n                case 12 /* F64 */:\r\n                    arg0 = compiler.compileExpression(operands[0], types_1.Type.u64);\r\n                    ret = module.createUnary(module_1.UnaryOp.ReinterpretI64, arg0);\r\n                    break;\r\n                default:// small integers and void\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            compiler.currentType = typeArguments[0];\r\n            return ret;\r\n        case \"sqrt\":// sqrt<T?>(value: T) -> T\r\n            if (operands.length != 1) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.f64, 0 /* NONE */);\r\n            }\r\n            switch (compiler.currentType.kind) {\r\n                // TODO: integer versions (that return f64 or convert)?\r\n                case 11 /* F32 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.SqrtF32, arg0);\r\n                    break;\r\n                case 12 /* F64 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.SqrtF64, arg0);\r\n                    break;\r\n                default:\r\n                    // case TypeKind.VOID:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"trunc\":// trunc<T?>(value: T) -> T\r\n            if (operands.length != 1) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments && typeArguments.length) {\r\n                compiler.currentType = typeArguments[0];\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.f64, 0 /* NONE */);\r\n            }\r\n            switch (compiler.currentType.kind) {\r\n                case 9 /* USIZE */:\r\n                    if (compiler.currentType.isReference) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = module.createUnreachable();\r\n                        break;\r\n                    }\r\n                // fall-through\r\n                default:// any integer\r\n                    ret = arg0;\r\n                    break;\r\n                // TODO: truncate to contextual type directly (if not void etc.)?\r\n                case 11 /* F32 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.TruncF32, arg0);\r\n                    break;\r\n                case 12 /* F64 */:\r\n                    ret = module.createUnary(module_1.UnaryOp.TruncF64, arg0);\r\n                    break;\r\n                case 13 /* VOID */:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        // memory access\r\n        case \"load\":// load<T!>(offset: usize, constantOffset?: usize) -> *\r\n            if (operands.length < 1 || operands.length > 2) {\r\n                if (!(typeArguments && typeArguments.length == 1)) {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\");\r\n                }\r\n                if (operands.length < 1) {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_at_least_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                }\r\n                else {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"2\", operands.length.toString(10));\r\n                }\r\n                return module.createUnreachable();\r\n            }\r\n            if (!(typeArguments && typeArguments.length == 1)) {\r\n                if (typeArguments && typeArguments.length)\r\n                    compiler.currentType = typeArguments[0];\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\");\r\n                return module.createUnreachable();\r\n            }\r\n            arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType);\r\n            offset = operands.length == 2 ? evaluateConstantOffset(compiler, operands[1]) : 0; // reports\r\n            if (offset < 0) {\r\n                return module.createUnreachable();\r\n            }\r\n            return module.createLoad(typeArguments[0].byteSize, typeArguments[0].is(1 /* SIGNED */ | 4 /* INTEGER */), arg0, typeArguments[0].is(4 /* INTEGER */) &&\r\n                contextualType.is(4 /* INTEGER */) &&\r\n                contextualType.size >= typeArguments[0].size\r\n                ? (compiler.currentType = contextualType).toNativeType()\r\n                : (compiler.currentType = typeArguments[0]).toNativeType(), offset);\r\n        case \"store\":// store<T!>(offset: usize, value: *, constantOffset?: usize) -> void\r\n            compiler.currentType = types_1.Type.void;\r\n            if (operands.length < 2 || operands.length > 3) {\r\n                if (!(typeArguments && typeArguments.length == 1)) {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\");\r\n                }\r\n                if (operands.length < 2) {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_at_least_0_arguments_but_got_1, reportNode.range, \"2\", operands.length.toString(10));\r\n                }\r\n                else {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"3\", operands.length.toString(10));\r\n                }\r\n                return module.createUnreachable();\r\n            }\r\n            if (!(typeArguments && typeArguments.length == 1)) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\");\r\n                return module.createUnreachable();\r\n            }\r\n            arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType);\r\n            arg1 = compiler.compileExpression(operands[1], typeArguments[0], typeArguments[0].is(4 /* INTEGER */)\r\n                ? 0 /* NONE */\r\n                : 1 /* IMPLICIT */);\r\n            if (compiler.currentType.is(4 /* INTEGER */) &&\r\n                typeArguments[0].is(4 /* INTEGER */) &&\r\n                typeArguments[0].size > compiler.currentType.size) {\r\n                arg1 = compiler.convertExpression(arg1, compiler.currentType, typeArguments[0], 1 /* IMPLICIT */, operands[1]);\r\n                type = typeArguments[0];\r\n            }\r\n            else {\r\n                type = compiler.currentType;\r\n            }\r\n            offset = operands.length == 3 ? evaluateConstantOffset(compiler, operands[2]) : 0; // reports\r\n            if (offset < 0) {\r\n                return module.createUnreachable();\r\n            }\r\n            compiler.currentType = types_1.Type.void;\r\n            return module.createStore(typeArguments[0].byteSize, arg0, arg1, type.toNativeType(), offset);\r\n        case \"sizeof\":// sizeof<T!>() -> usize\r\n            compiler.currentType = compiler.options.usizeType;\r\n            if (operands.length != 0) {\r\n                if (!(typeArguments && typeArguments.length == 1)) {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\");\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"0\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                ret = compiler.options.isWasm64\r\n                    ? module.createI64(typeArguments[0].byteSize, 0)\r\n                    : module.createI32(typeArguments[0].byteSize);\r\n            }\r\n            else {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", \"0\");\r\n                return module.createUnreachable();\r\n            }\r\n            return ret;\r\n        // control flow\r\n        case \"select\":// select<T?>(ifTrue: T, ifFalse: T, condition: bool) -> T\r\n            if (operands.length != 3) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"3\", operands.length.toString(10));\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length != 1) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0];\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.i32, 0 /* NONE */);\r\n            }\r\n            arg1 = compiler.compileExpression(operands[1], type = compiler.currentType);\r\n            arg2 = compiler.compileExpression(operands[2], types_1.Type.bool);\r\n            compiler.currentType = type;\r\n            switch (compiler.currentType.kind) {\r\n                default:// any value type\r\n                    ret = module.createSelect(arg0, arg1, arg2);\r\n                    break;\r\n                case 13 /* VOID */:\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                    ret = module.createUnreachable();\r\n                    break;\r\n            }\r\n            return ret;\r\n        case \"unreachable\":// unreachable() -> *\r\n            if (operands.length != 0) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"0\", operands.length.toString(10));\r\n            }\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            return module.createUnreachable();\r\n        // host operations\r\n        case \"current_memory\":// current_memory() -> i32\r\n            compiler.currentType = types_1.Type.i32;\r\n            if (operands.length != 0) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"0\", operands.length.toString(10));\r\n            }\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            return module.createHost(module_1.HostOp.CurrentMemory);\r\n        case \"grow_memory\":// grow_memory(pages: i32) -> i32\r\n            compiler.currentType = types_1.Type.i32;\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"0\", operands.length.toString(10));\r\n                arg0 = module.createUnreachable();\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.i32);\r\n            }\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            return module.createHost(module_1.HostOp.GrowMemory, null, [arg0]);\r\n        // see: https://github.com/WebAssembly/bulk-memory-operations\r\n        case \"move_memory\":// move_memory(dest: usize, src: usize: n: usize) -> void\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 3) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"3\", operands.length.toString(10));\r\n                compiler.currentType = types_1.Type.void;\r\n                return module.createUnreachable();\r\n            }\r\n            arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType);\r\n            arg1 = compiler.compileExpression(operands[1], compiler.options.usizeType);\r\n            arg2 = compiler.compileExpression(operands[2], compiler.options.usizeType);\r\n            compiler.currentType = types_1.Type.void;\r\n            throw new Error(\"not implemented\");\r\n        // return module.createHost(HostOp.MoveMemory, null, [ arg0, arg1, arg2 ]);\r\n        case \"set_memory\":// set_memory(dest: usize, value: u32, n: usize) -> void\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 3) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"3\", operands.length.toString(10));\r\n                compiler.currentType = types_1.Type.void;\r\n                return module.createUnreachable();\r\n            }\r\n            arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType);\r\n            arg1 = compiler.compileExpression(operands[1], types_1.Type.u32);\r\n            arg2 = compiler.compileExpression(operands[2], compiler.options.usizeType);\r\n            compiler.currentType = types_1.Type.void;\r\n            throw new Error(\"not implemented\");\r\n        // return module.createHost(HostOp.SetMemory, null, [ arg0, arg1, arg2 ]);\r\n        // other\r\n        case \"changetype\":// changetype<T!>(value: *) -> T\r\n            if (!(typeArguments && typeArguments.length == 1)) {\r\n                if (typeArguments && typeArguments.length)\r\n                    compiler.currentType = typeArguments[0];\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\");\r\n                return module.createUnreachable();\r\n            }\r\n            else if (typeArguments[0].kind != 9 /* USIZE */) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                compiler.currentType = typeArguments[0];\r\n                return module.createUnreachable();\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = typeArguments[0];\r\n                return module.createUnreachable();\r\n            }\r\n            arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType, 0 /* NONE */);\r\n            compiler.currentType = typeArguments[0];\r\n            if (compiler.currentType.kind != 9 /* USIZE */) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                return module.createUnreachable();\r\n            }\r\n            // if (reportNode.range.source.sourceKind != SourceKind.STDLIB)\r\n            //  compiler.warning(DiagnosticCode.Operation_is_unsafe, reportNode.range);\r\n            return arg0; // any usize to any usize\r\n        case \"assert\":// assert<T?>(isTrueish: T, message?: string) -> T with T != null\r\n            if (operands.length < 1 || operands.length > 2) {\r\n                if (typeArguments) {\r\n                    if (typeArguments.length)\r\n                        compiler.currentType = typeArguments[0].nonNullableType;\r\n                    if (typeArguments.length != 1) {\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    }\r\n                }\r\n                if (operands.length < 1) {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_at_least_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                }\r\n                else if (operands.length > 2) {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"2\", operands.length.toString(10));\r\n                }\r\n                return module.createUnreachable();\r\n            }\r\n            if (typeArguments) {\r\n                if (typeArguments.length)\r\n                    compiler.currentType = typeArguments[0].nonNullableType;\r\n                if (typeArguments.length != 1) {\r\n                    compiler.error(diagnostics_1.DiagnosticCode.Expected_0_type_arguments_but_got_1, reportNode.range, \"1\", typeArguments.length.toString(10));\r\n                    return module.createUnreachable();\r\n                }\r\n                arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n            }\r\n            else {\r\n                arg0 = compiler.compileExpression(operands[0], types_1.Type.i32, 0 /* NONE */);\r\n            }\r\n            type = compiler.currentType;\r\n            compiler.currentType = type.nonNullableType;\r\n            // just return ifTrueish if assertions are disabled, or simplify if dropped anyway\r\n            if (compiler.options.noAssert) {\r\n                if (contextualType == types_1.Type.void) {\r\n                    compiler.currentType = types_1.Type.void;\r\n                    return module.createNop();\r\n                }\r\n                return arg0;\r\n            }\r\n            var abort = compileAbort(compiler, operands.length == 2 ? operands[1] : null, reportNode);\r\n            compiler.currentType = type.nonNullableType;\r\n            if (contextualType == types_1.Type.void) {\r\n                switch (compiler.currentType.kind) {\r\n                    default:// any integer up to 32-bits incl. bool\r\n                        ret = module.createIf(module.createUnary(module_1.UnaryOp.EqzI32, arg0), abort);\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        ret = module.createIf(module.createUnary(module_1.UnaryOp.EqzI64, arg0), abort);\r\n                        break;\r\n                    case 4 /* ISIZE */:\r\n                    case 9 /* USIZE */:\r\n                        ret = module.createIf(module.createUnary(compiler.options.isWasm64\r\n                            ? module_1.UnaryOp.EqzI64\r\n                            : module_1.UnaryOp.EqzI32, arg0), abort);\r\n                        break;\r\n                    // TODO: also check for NaN in float assertions, as in `Boolean(NaN) -> false`?\r\n                    case 11 /* F32 */:\r\n                        ret = module.createIf(module.createBinary(module_1.BinaryOp.EqF32, arg0, module.createF32(0)), abort);\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        ret = module.createIf(module.createBinary(module_1.BinaryOp.EqF64, arg0, module.createF64(0)), abort);\r\n                        break;\r\n                    case 13 /* VOID */:\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = abort;\r\n                        break;\r\n                }\r\n                compiler.currentType = types_1.Type.void;\r\n            }\r\n            else {\r\n                switch (compiler.currentType.kind) {\r\n                    default:// any integer up to 32-bits incl. bool\r\n                        tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.i32);\r\n                        ret = module.createIf(module.createUnary(module_1.UnaryOp.EqzI32, module.createTeeLocal(tempLocal0.index, arg0)), abort, module.createGetLocal(tempLocal0.index, module_1.NativeType.I32));\r\n                        break;\r\n                    case 3 /* I64 */:\r\n                    case 8 /* U64 */:\r\n                        tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.i64);\r\n                        ret = module.createIf(module.createUnary(module_1.UnaryOp.EqzI64, module.createTeeLocal(tempLocal0.index, arg0)), abort, module.createGetLocal(tempLocal0.index, module_1.NativeType.I64));\r\n                        break;\r\n                    case 4 /* ISIZE */:\r\n                    case 9 /* USIZE */:\r\n                        tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(compiler.options.usizeType);\r\n                        ret = module.createIf(module.createUnary(compiler.options.isWasm64\r\n                            ? module_1.UnaryOp.EqzI64\r\n                            : module_1.UnaryOp.EqzI32, module.createTeeLocal(tempLocal0.index, arg0)), abort, module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType));\r\n                        break;\r\n                    case 11 /* F32 */:\r\n                        tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.f32);\r\n                        ret = module.createIf(module.createBinary(module_1.BinaryOp.EqF32, module.createTeeLocal(tempLocal0.index, arg0), module.createF32(0)), abort, module.createGetLocal(tempLocal0.index, module_1.NativeType.F32));\r\n                        break;\r\n                    case 12 /* F64 */:\r\n                        tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(types_1.Type.f64);\r\n                        ret = module.createIf(module.createBinary(module_1.BinaryOp.EqF64, module.createTeeLocal(tempLocal0.index, arg0), module.createF64(0)), abort, module.createGetLocal(tempLocal0.index, module_1.NativeType.F64));\r\n                        break;\r\n                    case 13 /* VOID */:\r\n                        compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n                        ret = abort;\r\n                        break;\r\n                }\r\n            }\r\n            return ret;\r\n        // conversions\r\n        case \"i8\":\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = types_1.Type.i8;\r\n                return module.createUnreachable();\r\n            }\r\n            return compiler.compileExpression(operands[0], types_1.Type.i8, 2 /* EXPLICIT */);\r\n        case \"i16\":\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = types_1.Type.i16;\r\n                return module.createUnreachable();\r\n            }\r\n            return compiler.compileExpression(operands[0], types_1.Type.i16, 2 /* EXPLICIT */);\r\n        case \"i32\":\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = types_1.Type.i32;\r\n                return module.createUnreachable();\r\n            }\r\n            return compiler.compileExpression(operands[0], types_1.Type.i32, 2 /* EXPLICIT */);\r\n        case \"i64\":\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = types_1.Type.i64;\r\n                return module.createUnreachable();\r\n            }\r\n            return compiler.compileExpression(operands[0], types_1.Type.i64, 2 /* EXPLICIT */);\r\n        case \"isize\":\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = compiler.options.isWasm64\r\n                    ? types_1.Type.isize64\r\n                    : types_1.Type.isize32;\r\n                return module.createUnreachable();\r\n            }\r\n            return compiler.compileExpression(operands[0], compiler.options.isWasm64\r\n                ? types_1.Type.isize64\r\n                : types_1.Type.isize32, 2 /* EXPLICIT */);\r\n        case \"u8\":\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = types_1.Type.u8;\r\n                return module.createUnreachable();\r\n            }\r\n            return compiler.compileExpression(operands[0], types_1.Type.u8, 2 /* EXPLICIT */);\r\n        case \"u16\":\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = types_1.Type.u16;\r\n                return module.createUnreachable();\r\n            }\r\n            return compiler.compileExpression(operands[0], types_1.Type.u16, 2 /* EXPLICIT */);\r\n        case \"u32\":\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = types_1.Type.u32;\r\n                return module.createUnreachable();\r\n            }\r\n            return compiler.compileExpression(operands[0], types_1.Type.u32, 2 /* EXPLICIT */);\r\n        case \"u64\":\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = types_1.Type.u64;\r\n                return module.createUnreachable();\r\n            }\r\n            return compiler.compileExpression(operands[0], types_1.Type.u64, 2 /* EXPLICIT */);\r\n        case \"usize\":\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = compiler.options.usizeType;\r\n                return module.createUnreachable();\r\n            }\r\n            return compiler.compileExpression(operands[0], compiler.options.usizeType, 2 /* EXPLICIT */);\r\n        case \"bool\":\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = types_1.Type.bool;\r\n                return module.createUnreachable();\r\n            }\r\n            return compiler.compileExpression(operands[0], types_1.Type.bool, 2 /* EXPLICIT */);\r\n        case \"f32\":\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = types_1.Type.f32;\r\n                return module.createUnreachable();\r\n            }\r\n            return compiler.compileExpression(operands[0], types_1.Type.f32, 2 /* EXPLICIT */);\r\n        case \"f64\":\r\n            if (typeArguments) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Type_0_is_not_generic, reportNode.range, prototype.internalName);\r\n            }\r\n            if (operands.length != 1) {\r\n                compiler.error(diagnostics_1.DiagnosticCode.Expected_0_arguments_but_got_1, reportNode.range, \"1\", operands.length.toString(10));\r\n                compiler.currentType = types_1.Type.f64;\r\n                return module.createUnreachable();\r\n            }\r\n            return compiler.compileExpression(operands[0], types_1.Type.f64, 2 /* EXPLICIT */);\r\n    }\r\n    compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, reportNode.range);\r\n    return module.createUnreachable();\r\n}\r\nexports.compileCall = compileCall;\r\nfunction evaluateConstantOffset(compiler, expression) {\r\n    var expr;\r\n    var value;\r\n    if (compiler.options.isWasm64) {\r\n        expr = compiler.precomputeExpression(expression, types_1.Type.usize64);\r\n        if (_BinaryenExpressionGetId(expr) != module_1.ExpressionId.Const ||\r\n            _BinaryenExpressionGetType(expr) != module_1.NativeType.I64 ||\r\n            _BinaryenConstGetValueI64High(expr) != 0 ||\r\n            (value = _BinaryenConstGetValueI64Low(expr)) < 0) {\r\n            compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n            value = -1;\r\n        }\r\n    }\r\n    else {\r\n        expr = compiler.precomputeExpression(expression, types_1.Type.usize32);\r\n        if (_BinaryenExpressionGetId(expr) != module_1.ExpressionId.Const ||\r\n            _BinaryenExpressionGetType(expr) != module_1.NativeType.I32 ||\r\n            (value = _BinaryenConstGetValueI32(expr)) < 0) {\r\n            compiler.error(diagnostics_1.DiagnosticCode.Operation_not_supported, expression.range);\r\n            value = -1;\r\n        }\r\n    }\r\n    return value;\r\n}\r\n/** Compiles a memory allocation for an instance of the specified class. */\r\nfunction compileAllocate(compiler, cls, reportNode) {\r\n    var program = cls.program;\r\n    var prototype = program.elements.get(compiler.options.allocateImpl);\r\n    if (prototype) {\r\n        if (prototype.kind == program_1.ElementKind.FUNCTION_PROTOTYPE) {\r\n            var instance = prototype.resolve(); // reports\r\n            if (instance) {\r\n                if (!instance.is(program_1.ElementFlags.GENERIC) &&\r\n                    instance.returnType == compiler.options.usizeType &&\r\n                    instance.parameters &&\r\n                    instance.parameters.length == 1 &&\r\n                    instance.parameters[0].type == compiler.options.usizeType) {\r\n                    if (compiler.compileFunction(instance)) {\r\n                        return compiler.makeCall(instance, [\r\n                            compiler.options.isWasm64\r\n                                ? compiler.module.createI64(cls.currentMemoryOffset)\r\n                                : compiler.module.createI32(cls.currentMemoryOffset)\r\n                        ]);\r\n                    }\r\n                }\r\n                else {\r\n                    program.error(diagnostics_1.DiagnosticCode.Implementation_0_must_match_the_signature_1, reportNode.range, compiler.options.allocateImpl, \"(size: usize): usize\");\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            program.error(diagnostics_1.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, reportNode.range, prototype.internalName);\r\n        }\r\n    }\r\n    else {\r\n        program.error(diagnostics_1.DiagnosticCode.Cannot_find_name_0, reportNode.range, compiler.options.allocateImpl);\r\n    }\r\n    return compiler.module.createUnreachable();\r\n}\r\nexports.compileAllocate = compileAllocate;\r\n/** Compiles an abort wired to the conditionally imported 'abort' function. */\r\nfunction compileAbort(compiler, message, reportNode) {\r\n    var module = compiler.module;\r\n    var abort = module.createUnreachable();\r\n    var abortPrototype = compiler.program.elements.get(\"abort\");\r\n    var stringType = compiler.program.types.get(\"string\");\r\n    if (abortPrototype &&\r\n        abortPrototype.kind == program_1.ElementKind.FUNCTION_PROTOTYPE &&\r\n        stringType) {\r\n        var abortInstance = abortPrototype.resolve(); // reports\r\n        if (abortInstance &&\r\n            compiler.compileFunction(abortInstance) // reports\r\n        ) {\r\n            assert(abortInstance.parameters && abortInstance.parameters.length == 4); // to be sure\r\n            abort = module.createBlock(null, [\r\n                compiler.makeCall(abortInstance, [\r\n                    message != null\r\n                        ? compiler.compileExpression(message, stringType)\r\n                        : compiler.options.usizeType.toNativeZero(module),\r\n                    compiler.compileStaticString(reportNode.range.source.normalizedPath),\r\n                    module.createI32(reportNode.range.line),\r\n                    module.createI32(reportNode.range.column)\r\n                ]),\r\n                abort\r\n            ]);\r\n        }\r\n    }\r\n    return abort;\r\n}\r\nexports.compileAbort = compileAbort;\r\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {const Long = global.Long || __webpack_require__(18);\r\n\r\nglobal.i64_new = function(lo, hi) {\r\n  return Long.fromBits(lo, hi);\r\n};\r\n\r\nglobal.i64_low = function(value) {\r\n  return value.low;\r\n};\r\n\r\nglobal.i64_high = function(value) {\r\n  return value.high;\r\n};\r\n\r\nglobal.i64_add = function(left, right) {\r\n  return left.add(right);\r\n};\r\n\r\nglobal.i64_sub = function(left, right) {\r\n  return left.sub(right);\r\n};\r\n\r\nglobal.i64_mul = function(left, right) {\r\n  return left.mul(right);\r\n};\r\n\r\nglobal.i64_div = function(left, right) {\r\n  return left.div(right);\r\n};\r\n\r\nglobal.i64_div_u = function(left, right) {\r\n  return left.toUnsigned().div(right.toUnsigned()).toSigned();\r\n};\r\n\r\nglobal.i64_rem = function(left, right) {\r\n  return left.mod(right);\r\n};\r\n\r\nglobal.i64_rem_u = function(left, right) {\r\n  return left.toUnsigned().mod(right.toUnsigned()).toSigned();\r\n};\r\n\r\nglobal.i64_and = function(left, right) {\r\n  return left.and(right);\r\n};\r\n\r\nglobal.i64_or = function(left, right) {\r\n  return left.or(right);\r\n};\r\n\r\nglobal.i64_xor = function(left, right) {\r\n  return left.xor(right);\r\n};\r\n\r\nglobal.i64_shl = function(left, right) {\r\n  return left.shl(right);\r\n};\r\n\r\nglobal.i64_shr = function(left, right) {\r\n  return left.shr(right);\r\n};\r\n\r\nglobal.i64_shr_u = function(left, right) {\r\n  return left.shru(right);\r\n};\r\n\r\nglobal.i64_not = function(value) {\r\n  return value.not();\r\n};\r\n\r\nglobal.i64_align = function(value, alignment) {\r\n  assert(alignment && (alignment & (alignment - 1)) == 0);\r\n  var mask = Long.fromInt(alignment - 1);\r\n  return value.add(mask).and(mask.not());\r\n};\r\n\r\nglobal.i64_is_i8 = function(value) {\r\n  return value.high === 0 && (value.low >= 0 && value.low <= i8.MAX_VALUE)\r\n      || value.high === -1 && (value.low >= i8.MIN_VALUE && value.low < 0);\r\n};\r\n\r\nglobal.i64_is_i16 = function(value) {\r\n  return value.high === 0 && (value.low >= 0 && value.low <= i16.MAX_VALUE)\r\n      || value.high === -1 && (value.low >= i16.MIN_VALUE && value.low < 0);\r\n};\r\n\r\nglobal.i64_is_i32 = function(value) {\r\n  return (value.high === 0 && value.low >= 0)\r\n      || (value.high === -1 && value.low < 0);\r\n};\r\n\r\nglobal.i64_is_u8 = function(value) {\r\n  return value.high === 0 && value.low >= 0 && value.low <= u8.MAX_VALUE;\r\n};\r\n\r\nglobal.i64_is_u16 = function(value) {\r\n  return value.high === 0 && value.low >= 0 && value.low <= u16.MAX_VALUE;\r\n};\r\n\r\nglobal.i64_is_u32 = function(value) {\r\n  return value.high === 0;\r\n};\r\n\r\nglobal.i64_is_bool = function(value) {\r\n  return value.high === 0 && (value.low === 0 || value.low === 1);\r\n};\r\n\r\nconst minSafeF32 = Long.fromNumber(f32.MIN_SAFE_INTEGER);\r\nconst maxSafeF32 = Long.fromNumber(f32.MAX_SAFE_INTEGER);\r\n\r\nglobal.i64_is_f32 = function(value) {\r\n  return value.gte(minSafeF32) && value.lte(maxSafeF32);\r\n};\r\n\r\nconst minSafeF64 = Long.fromNumber(f64.MIN_SAFE_INTEGER);\r\nconst maxSafeF64 = Long.fromNumber(f64.MAX_SAFE_INTEGER);\r\n\r\nglobal.i64_is_f64 = function(value) {\r\n  return value.gte(minSafeF64) && value.lte(maxSafeF64);\r\n};\r\n\r\nglobal.i64_to_f32 = function(value) {\r\n  return global.Math.fround(value.toNumber());\r\n};\r\n\r\nglobal.i64_to_f64 = function(value) {\r\n  return value.toNumber();\r\n};\r\n\r\nglobal.i64_to_string = function(value, unsigned) {\r\n  return (unsigned ? value.toUnsigned() : value).toString(10);\r\n};\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\nmodule.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n//////////////////////// Low-level C-Like Compiler API /////////////////////////\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar compiler_1 = __webpack_require__(4);\r\nvar decompiler_1 = __webpack_require__(20);\r\nvar diagnostics_1 = __webpack_require__(1);\r\nexports.formatDiagnostic = diagnostics_1.formatDiagnosticMessage;\r\nvar parser_1 = __webpack_require__(21);\r\n/** Parses a source file. If `parser` has been omitted a new one is created. */\r\nfunction parseFile(text, path, isEntry, parser) {\r\n    if (isEntry === void 0) { isEntry = false; }\r\n    if (parser === void 0) { parser = null; }\r\n    if (!parser) {\r\n        parser = new parser_1.Parser();\r\n        isEntry = true;\r\n    }\r\n    parser.parseFile(text, path, isEntry);\r\n    return parser;\r\n}\r\nexports.parseFile = parseFile;\r\n/** Obtains the next required file's path. Returns `null` once complete. */\r\nfunction nextFile(parser) {\r\n    return parser.nextFile();\r\n}\r\nexports.nextFile = nextFile;\r\n/** Obtains the next diagnostic message. Returns `null` once complete. */\r\nfunction nextDiagnostic(parser) {\r\n    var program = parser.program;\r\n    return program.diagnosticsOffset < program.diagnostics.length\r\n        ? program.diagnostics[program.diagnosticsOffset++]\r\n        : null;\r\n}\r\nexports.nextDiagnostic = nextDiagnostic;\r\n/** Tests whether a diagnostic is informatory. */\r\nfunction isInfo(message) {\r\n    return message.category == diagnostics_1.DiagnosticCategory.INFO;\r\n}\r\nexports.isInfo = isInfo;\r\n/** Tests whether a diagnostic is a warning. */\r\nfunction isWarning(message) {\r\n    return message.category == diagnostics_1.DiagnosticCategory.WARNING;\r\n}\r\nexports.isWarning = isWarning;\r\n/** Tests whether a diagnostic is an error. */\r\nfunction isError(message) {\r\n    return message.category == diagnostics_1.DiagnosticCategory.ERROR;\r\n}\r\nexports.isError = isError;\r\n/** Creates a new set of compiler options. */\r\nfunction createOptions() {\r\n    return new compiler_1.Options();\r\n}\r\nexports.createOptions = createOptions;\r\n/** Sets the `target` option. */\r\nfunction setTarget(options, target) {\r\n    options.target = target;\r\n}\r\nexports.setTarget = setTarget;\r\n/** Sets the `noTreeShaking` option. */\r\nfunction setNoTreeShaking(options, noTreeShaking) {\r\n    options.noTreeShaking = noTreeShaking;\r\n}\r\nexports.setNoTreeShaking = setNoTreeShaking;\r\n/** Sets the `noAssert` option. */\r\nfunction setNoAssert(options, noAssert) {\r\n    options.noAssert = noAssert;\r\n}\r\nexports.setNoAssert = setNoAssert;\r\n/** Sets the `noMemory` option. */\r\nfunction setNoMemory(options, noMemory) {\r\n    options.noMemory = noMemory;\r\n}\r\nexports.setNoMemory = setNoMemory;\r\n/** Sets the `importMemory` option. */\r\nfunction setImportMemory(options, importMemory) {\r\n    options.importMemory = importMemory;\r\n}\r\nexports.setImportMemory = setImportMemory;\r\n/** Sets the `sourceMap` option. */\r\nfunction setSourceMap(options, sourceMap) {\r\n    options.sourceMap = sourceMap;\r\n}\r\nexports.setSourceMap = setSourceMap;\r\n/** Sets the `memoryBase` option. */\r\nfunction setMemoryBase(options, memoryBase) {\r\n    options.memoryBase = memoryBase;\r\n}\r\nexports.setMemoryBase = setMemoryBase;\r\n/** Compiles the sources computed by the parser to a module. */\r\nfunction compile(parser, options) {\r\n    if (options === void 0) { options = null; }\r\n    var program = parser.finish();\r\n    var compiler = new compiler_1.Compiler(program, options);\r\n    return compiler.compile();\r\n}\r\nexports.compile = compile;\r\n/** Decompiles a module to its (low level) source. */\r\nfunction decompile(module) {\r\n    var decompiler = new decompiler_1.Decompiler();\r\n    decompiler.decompile(module);\r\n    return decompiler.finish();\r\n}\r\nexports.decompile = decompile;\r\n/** Prefix indicating a library file. */\r\nvar program_1 = __webpack_require__(2);\r\nexports.LIBRARY_PREFIX = program_1.LIBRARY_PREFIX;\r\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar module_1 = __webpack_require__(0);\r\n// TODO :-)\r\nvar Decompiler = /** @class */ (function () {\r\n    function Decompiler() {\r\n        this.text = [];\r\n        this.functionId = 0;\r\n    }\r\n    Decompiler.decompile = function (module) {\r\n        var decompiler = new Decompiler();\r\n        decompiler.decompile(module);\r\n        return decompiler.finish();\r\n    };\r\n    /** Decompiles a module to an AST that can then be serialized. */\r\n    Decompiler.prototype.decompile = function (module) {\r\n        throw new Error(\"not implemented\");\r\n    };\r\n    Decompiler.prototype.decompileFunction = function (func) {\r\n        var name = module_1.readString(_BinaryenFunctionGetName(func)) || \"$\" + this.functionId.toString(10);\r\n        var body = _BinaryenFunctionGetBody(func);\r\n        this.push(\"function \");\r\n        this.push(name);\r\n        this.push(\"(\");\r\n        for (var i = 0, k = _BinaryenFunctionGetNumParams(func); i < k; ++i) {\r\n            if (i > 0)\r\n                this.push(\", \");\r\n            this.push(\"$\");\r\n            this.push(i.toString(10));\r\n            this.push(\": \");\r\n            this.push(nativeTypeToType(_BinaryenFunctionGetParam(func, i)));\r\n        }\r\n        this.push(\"): \");\r\n        this.push(nativeTypeToType(_BinaryenFunctionGetResult(func)));\r\n        this.push(\" \");\r\n        if (_BinaryenExpressionGetId(body) != module_1.ExpressionId.Block) {\r\n            this.push(\"{\\n\");\r\n        }\r\n        this.decompileExpression(body);\r\n        if (_BinaryenExpressionGetId(body) != module_1.ExpressionId.Block) {\r\n            this.push(\"\\n}\\n\");\r\n        }\r\n        ++this.functionId;\r\n    };\r\n    Decompiler.prototype.decompileExpression = function (expr) {\r\n        var id = _BinaryenExpressionGetId(expr);\r\n        var type = _BinaryenExpressionGetType(expr);\r\n        var nested;\r\n        var string;\r\n        var i, k;\r\n        switch (id) {\r\n            case module_1.ExpressionId.Block:// TODO: magic\r\n                if ((string = module_1.readString(_BinaryenBlockGetName(expr))) != null) {\r\n                    this.push(string);\r\n                    this.push(\": \");\r\n                }\r\n                this.push(\"{\\n\");\r\n                k = _BinaryenBlockGetNumChildren(expr);\r\n                for (i = 0; i < k; ++i) {\r\n                    this.decompileExpression(_BinaryenBlockGetChild(expr, i));\r\n                }\r\n                this.push(\"}\\n\");\r\n                return;\r\n            case module_1.ExpressionId.If:\r\n                if (type == module_1.NativeType.None) {\r\n                    this.push(\"if (\");\r\n                    this.decompileExpression(_BinaryenIfGetCondition(expr));\r\n                    this.push(\") \");\r\n                    this.decompileExpression(_BinaryenIfGetIfTrue(expr));\r\n                    if (nested = _BinaryenIfGetIfFalse(expr)) {\r\n                        this.push(\" else \");\r\n                        this.decompileExpression(nested);\r\n                    }\r\n                }\r\n                else {\r\n                    this.decompileExpression(_BinaryenIfGetCondition(expr));\r\n                    this.push(\" ? \");\r\n                    this.decompileExpression(_BinaryenIfGetIfTrue(expr));\r\n                    this.push(\" : \");\r\n                    this.decompileExpression(_BinaryenIfGetIfFalse(expr));\r\n                }\r\n                return;\r\n            case module_1.ExpressionId.Loop:\r\n                if ((string = module_1.readString(_BinaryenLoopGetName(expr))) != null) {\r\n                    this.push(string);\r\n                    this.push(\": \");\r\n                }\r\n                this.push(\"do \");\r\n                this.decompileExpression(_BinaryenLoopGetBody(expr));\r\n                this.push(\"while (0);\\n\");\r\n            case module_1.ExpressionId.Break:\r\n                if (nested = _BinaryenBreakGetCondition(expr)) {\r\n                    this.push(\"if (\");\r\n                    this.decompileExpression(nested);\r\n                    this.push(\") \");\r\n                }\r\n                if ((string = module_1.readString(_BinaryenBreakGetName(expr))) != null) {\r\n                    this.push(\"break \");\r\n                    this.push(string);\r\n                    this.push(\";\\n\");\r\n                }\r\n                else {\r\n                    this.push(\"break;\\n\");\r\n                }\r\n                return;\r\n            case module_1.ExpressionId.Switch:\r\n            case module_1.ExpressionId.Call:\r\n            case module_1.ExpressionId.CallImport:\r\n            case module_1.ExpressionId.CallIndirect:\r\n            case module_1.ExpressionId.GetLocal:\r\n                this.push(\"$\");\r\n                this.push(_BinaryenGetLocalGetIndex(expr).toString(10));\r\n                return;\r\n            case module_1.ExpressionId.SetLocal:\r\n                this.push(\"$\");\r\n                this.push(_BinaryenSetLocalGetIndex(expr).toString(10));\r\n                this.push(\" = \");\r\n                this.decompileExpression(_BinaryenSetLocalGetValue(expr));\r\n                return;\r\n            case module_1.ExpressionId.GetGlobal:\r\n            case module_1.ExpressionId.SetGlobal:\r\n            case module_1.ExpressionId.Load:\r\n                this.push(\"load<\");\r\n                this.push(nativeTypeToType(type));\r\n                this.push(\">(\");\r\n                this.push(_BinaryenLoadGetOffset(expr).toString(10));\r\n                this.push(\" + \");\r\n                this.decompileExpression(_BinaryenLoadGetPtr(expr));\r\n                this.push(\")\");\r\n                return;\r\n            case module_1.ExpressionId.Store:\r\n                this.push(\"store<\");\r\n                this.push(nativeTypeToType(type));\r\n                this.push(\">(\");\r\n                this.push(_BinaryenStoreGetOffset(expr).toString(10));\r\n                this.push(\" + \");\r\n                this.decompileExpression(_BinaryenStoreGetPtr(expr));\r\n                this.push(\", \");\r\n                this.decompileExpression(_BinaryenStoreGetValue(expr));\r\n                this.push(\")\");\r\n                return;\r\n            case module_1.ExpressionId.Const:\r\n                switch (type) {\r\n                    case module_1.NativeType.I32:\r\n                        this.push(_BinaryenConstGetValueI32(expr).toString(10));\r\n                        return;\r\n                    case module_1.NativeType.I64:\r\n                        this.push(i64_to_string(i64_new(_BinaryenConstGetValueI64Low(expr), _BinaryenConstGetValueI64High(expr))));\r\n                        return;\r\n                    case module_1.NativeType.F32:\r\n                        this.push(_BinaryenConstGetValueF32(expr).toString(10));\r\n                        return;\r\n                    case module_1.NativeType.F64:\r\n                        this.push(_BinaryenConstGetValueF64(expr).toString(10));\r\n                        return;\r\n                }\r\n                break;\r\n            case module_1.ExpressionId.Unary:\r\n                switch (_BinaryenUnaryGetOp(expr)) {\r\n                    case module_1.UnaryOp.ClzI32:\r\n                        this.push(\"clz<i32>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.CtzI32:\r\n                        this.push(\"ctz<i32>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.PopcntI32:\r\n                        this.push(\"popcnt<i32>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.NegF32:\r\n                    case module_1.UnaryOp.NegF64:\r\n                        this.push(\"-\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.AbsF32:\r\n                        this.push(\"abs<f32>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.CeilF32:\r\n                        this.push(\"ceil<f32>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.FloorF32:\r\n                        this.push(\"floor<f32>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.TruncF32:\r\n                        this.push(\"trunc<f32>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.NearestF32:\r\n                        this.push(\"nearest<i32>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.SqrtF32:\r\n                        this.push(\"sqrt<f32>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.EqzI32:\r\n                    case module_1.UnaryOp.EqzI64:\r\n                        this.push(\"!\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.ClzI64:\r\n                        this.push(\"clz<i64>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.CtzI64:\r\n                        this.push(\"ctz<i64>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.PopcntI64:\r\n                        this.push(\"popcnt<i64>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.AbsF64:\r\n                        this.push(\"abs<f64>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.CeilF64:\r\n                        this.push(\"ceil<f64>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.FloorF64:\r\n                        this.push(\"floor<f64>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.TruncF64:\r\n                        this.push(\"trunc<f64>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.NearestF64:\r\n                        this.push(\"nearest<f64>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.SqrtF64:\r\n                        this.push(\"sqrt<f64>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.ExtendI32:\r\n                        this.push(\"<i64>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.ExtendU32:\r\n                        this.push(\"<i64><u64>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.WrapI64:\r\n                        this.push(\"<i32>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.TruncF32ToI32:\r\n                        this.push(\"<i32>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.TruncF32ToI64:\r\n                        this.push(\"<i64>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.TruncF32ToU32:\r\n                        this.push(\"<i32><u32>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.TruncF32ToU64:\r\n                        this.push(\"<i64><u64>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.TruncF64ToI32:\r\n                        this.push(\"<i32>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.TruncF64ToI64:\r\n                        this.push(\"<i64>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.TruncF64ToU32:\r\n                        this.push(\"<i32><u32>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.TruncF64ToU64:\r\n                        this.push(\"<i64><u64>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.ReinterpretF32:\r\n                        this.push(\"reinterpret<f32,i32>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.ReinterpretF64:\r\n                        this.push(\"reinterpret<f64,i64>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.ConvertI32ToF32:\r\n                        this.push(\"<f32>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.ConvertI32ToF64:\r\n                        this.push(\"<f64>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.ConvertU32ToF32:\r\n                        this.push(\"<f32><u32>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.ConvertU32ToF64:\r\n                        this.push(\"<f64><u32>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.ConvertI64ToF32:\r\n                        this.push(\"<f32>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.ConvertI64ToF64:\r\n                        this.push(\"<f64>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.ConvertU64ToF32:\r\n                        this.push(\"<f32><u64>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.ConvertU64ToF64:\r\n                        this.push(\"<f64><u64>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.PromoteF32:\r\n                        this.push(\"<f64>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.DemoteF64:\r\n                        this.push(\"<f32>\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        return;\r\n                    case module_1.UnaryOp.ReinterpretI32:\r\n                        this.push(\"reinterpret<i32,f32>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.UnaryOp.ReinterpretI64:\r\n                        this.push(\"reinterpret<i64,f64>(\");\r\n                        this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                }\r\n                break;\r\n            case module_1.ExpressionId.Binary:// TODO: precedence\r\n                switch (_BinaryenBinaryGetOp(expr)) {\r\n                    case module_1.BinaryOp.AddI32:\r\n                    case module_1.BinaryOp.AddI64:\r\n                    case module_1.BinaryOp.AddF32:\r\n                    case module_1.BinaryOp.AddF64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" + \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.SubI32:\r\n                    case module_1.BinaryOp.SubI64:\r\n                    case module_1.BinaryOp.SubF32:\r\n                    case module_1.BinaryOp.SubF64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" - \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.MulI32:\r\n                    case module_1.BinaryOp.MulI64:\r\n                    case module_1.BinaryOp.MulF32:\r\n                    case module_1.BinaryOp.MulF64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" * \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.DivI32:\r\n                    case module_1.BinaryOp.DivI64:\r\n                    case module_1.BinaryOp.DivF32:\r\n                    case module_1.BinaryOp.DivF64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" / \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.DivU32:\r\n                        this.push(\"<i32>(<u32>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" / <u32>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.BinaryOp.RemI32:\r\n                    case module_1.BinaryOp.RemI64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" % \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.RemU32:\r\n                        this.push(\"<i32>(<u32>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" / <u32>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.BinaryOp.AndI32:\r\n                    case module_1.BinaryOp.AndI64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" & \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.OrI32:\r\n                    case module_1.BinaryOp.OrI64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" | \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.XorI32:\r\n                    case module_1.BinaryOp.XorI64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" ^ \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.ShlI32:\r\n                    case module_1.BinaryOp.ShlI64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" << \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.ShrU32:\r\n                    case module_1.BinaryOp.ShrU64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" >>> \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.ShrI32:\r\n                    case module_1.BinaryOp.ShrI64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" >> \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.RotlI32:\r\n                        this.push(\"rotl<i32>(\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\", \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.BinaryOp.RotrI32:\r\n                        this.push(\"rotr<i32>(\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\", \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.BinaryOp.EqI32:\r\n                    case module_1.BinaryOp.EqI64:\r\n                    case module_1.BinaryOp.EqF32:\r\n                    case module_1.BinaryOp.EqF64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" == \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.NeI32:\r\n                    case module_1.BinaryOp.NeI64:\r\n                    case module_1.BinaryOp.NeF32:\r\n                    case module_1.BinaryOp.NeF64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" != \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.LtI32:\r\n                    case module_1.BinaryOp.LtI64:\r\n                    case module_1.BinaryOp.LtF32:\r\n                    case module_1.BinaryOp.LtF64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" < \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.LtU32:\r\n                        this.push(\"<u32>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" < <u32>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.LeI32:\r\n                    case module_1.BinaryOp.LeI64:\r\n                    case module_1.BinaryOp.LeF32:\r\n                    case module_1.BinaryOp.LeF64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" <= \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.LeU32:\r\n                        this.push(\"<u32>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" <= <u32>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.GtI32:\r\n                    case module_1.BinaryOp.GtI64:\r\n                    case module_1.BinaryOp.GtF32:\r\n                    case module_1.BinaryOp.GtF64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" > \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.GtU32:\r\n                        this.push(\"<u32>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" > <u32>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.GeI32:\r\n                    case module_1.BinaryOp.GeI64:\r\n                    case module_1.BinaryOp.GeF32:\r\n                    case module_1.BinaryOp.GeF64:\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" >= \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.GeU32:\r\n                        this.push(\"<u32>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" >= <u32>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.DivU64:\r\n                        this.push(\"<u64>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" / <u64>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.RemU64:\r\n                        this.push(\"<u64>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" % <u64>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.RotlI64:\r\n                        this.push(\"rotl<i64>(\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\", \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.BinaryOp.RotrI64:\r\n                        this.push(\"rotr<i64>(\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\", \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.BinaryOp.LtU64:\r\n                        this.push(\"<u64>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" < <u64>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.LeU64:\r\n                        this.push(\"<u64>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" <= <u64>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.GtU64:\r\n                        this.push(\"<u64>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" > <u64>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.GeU64:\r\n                        this.push(\"<u64>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\" >= <u64>\");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        return;\r\n                    case module_1.BinaryOp.CopysignF32:\r\n                        this.push(\"copysign<f32>(\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\", \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.BinaryOp.MinF32:\r\n                        this.push(\"min<f32>(\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\", \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.BinaryOp.MaxF32:\r\n                        this.push(\"max<f32>(\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\", \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.BinaryOp.CopysignF64:\r\n                        this.push(\"copysign<f64>(\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\", \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.BinaryOp.MinF64:\r\n                        this.push(\"min<f64>(\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\", \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                    case module_1.BinaryOp.MaxF64:\r\n                        this.push(\"max<f64>(\");\r\n                        this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n                        this.push(\", \");\r\n                        this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n                        this.push(\")\");\r\n                        return;\r\n                }\r\n                return;\r\n            case module_1.ExpressionId.Select:\r\n                this.push(\"select<\");\r\n                this.push(nativeTypeToType(type));\r\n                this.push(\">(\");\r\n                this.decompileExpression(_BinaryenSelectGetIfTrue(expr));\r\n                this.push(\", \");\r\n                this.decompileExpression(_BinaryenSelectGetIfFalse(expr));\r\n                this.push(\", \");\r\n                this.decompileExpression(_BinaryenSelectGetCondition(expr));\r\n                this.push(\")\");\r\n                return;\r\n            case module_1.ExpressionId.Drop:\r\n                this.decompileExpression(_BinaryenDropGetValue(expr));\r\n                this.push(\";\\n\");\r\n                return;\r\n            case module_1.ExpressionId.Return:\r\n                if (nested = _BinaryenReturnGetValue(expr)) {\r\n                    this.push(\"return \");\r\n                    this.decompileExpression(nested);\r\n                    this.push(\";\\n\");\r\n                }\r\n                else {\r\n                    this.push(\"return;\\n\");\r\n                }\r\n                return;\r\n            case module_1.ExpressionId.Host:\r\n                switch (_BinaryenHostGetOp(expr)) {\r\n                    case module_1.HostOp.CurrentMemory:\r\n                        this.push(\"current_memory()\");\r\n                        return;\r\n                    case module_1.HostOp.GrowMemory:\r\n                        this.push(\"grow_memory(\");\r\n                        this.decompileExpression(_BinaryenHostGetOperand(expr, 0));\r\n                        this.push(\")\");\r\n                        return;\r\n                }\r\n                break;\r\n            case module_1.ExpressionId.Nop:\r\n                this.push(\";\\n\");\r\n                return;\r\n            case module_1.ExpressionId.Unreachable:\r\n                this.push(\"unreachable()\");\r\n                return;\r\n            case module_1.ExpressionId.AtomicCmpxchg:\r\n            case module_1.ExpressionId.AtomicRMW:\r\n            case module_1.ExpressionId.AtomicWait:\r\n            case module_1.ExpressionId.AtomicWake:\r\n        }\r\n        throw new Error(\"not implemented\");\r\n    };\r\n    Decompiler.prototype.push = function (text) {\r\n        // mostly here so we can add debugging if necessary\r\n        this.text.push(text);\r\n    };\r\n    Decompiler.prototype.finish = function () {\r\n        var ret = this.text.join(\"\");\r\n        this.text = [];\r\n        return ret;\r\n    };\r\n    return Decompiler;\r\n}());\r\nexports.Decompiler = Decompiler;\r\nfunction nativeTypeToType(type) {\r\n    switch (type) {\r\n        case module_1.NativeType.None: return \"void\";\r\n        case module_1.NativeType.I32: return \"i32\";\r\n        case module_1.NativeType.I64: return \"i64\";\r\n        case module_1.NativeType.F32: return \"f32\";\r\n        case module_1.NativeType.F64: return \"f64\";\r\n        case module_1.NativeType.Unreachable: throw new Error(\"unreachable type\");\r\n        case module_1.NativeType.Auto: throw new Error(\"auto type\");\r\n        default: throw new Error(\"unexpected type\");\r\n    }\r\n}\r\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n/*\r\n\r\n This is a custom parser specifically written for the AssemblyScript subset. It accepts some of the\r\n most common TypeScript-only patterns that it knows an appropriate error message for but, though it\r\n uses TypeScript's codes for diagnostics, doesn't ultimately aim at full compatibility.\r\n\r\n*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar program_1 = __webpack_require__(2);\r\nvar tokenizer_1 = __webpack_require__(7);\r\nvar diagnostics_1 = __webpack_require__(1);\r\nvar path_1 = __webpack_require__(10);\r\nvar ast_1 = __webpack_require__(6);\r\n/** Parser interface. */\r\nvar Parser = /** @class */ (function (_super) {\r\n    __extends(Parser, _super);\r\n    /** Constructs a new parser. */\r\n    function Parser() {\r\n        var _this = _super.call(this) || this;\r\n        /** Log of source file names to be requested. */\r\n        _this.backlog = new Array();\r\n        /** Log of source file names already processed. */\r\n        _this.seenlog = new Set();\r\n        _this.program = new program_1.Program(_this.diagnostics);\r\n        return _this;\r\n    }\r\n    /** Parses a file and adds its definitions to the program. */\r\n    Parser.prototype.parseFile = function (text, path, isEntry) {\r\n        // check if already parsed\r\n        var normalizedPath = path_1.normalize(path);\r\n        for (var i = 0, k = this.program.sources.length; i < k; ++i) {\r\n            if (this.program.sources[i].normalizedPath == normalizedPath)\r\n                return;\r\n        }\r\n        this.seenlog.add(normalizedPath);\r\n        // create the source element\r\n        var source = new ast_1.Source(normalizedPath, text, isEntry\r\n            ? ast_1.SourceKind.ENTRY\r\n            : path.startsWith(program_1.LIBRARY_PREFIX) && path.indexOf(program_1.PATH_DELIMITER, program_1.LIBRARY_PREFIX.length) < 0\r\n                ? ast_1.SourceKind.LIBRARY\r\n                : ast_1.SourceKind.DEFAULT);\r\n        this.program.sources.push(source);\r\n        // tokenize and parse\r\n        var tn = new tokenizer_1.Tokenizer(source, this.program.diagnostics);\r\n        source.tokenizer = tn;\r\n        while (!tn.skip(tokenizer_1.Token.ENDOFFILE)) {\r\n            var statement = this.parseTopLevelStatement(tn);\r\n            if (statement) {\r\n                statement.parent = source;\r\n                source.statements.push(statement);\r\n            }\r\n        }\r\n        tn.finish();\r\n    };\r\n    /** Parses a top-level statement. */\r\n    Parser.prototype.parseTopLevelStatement = function (tn, isNamespaceMember) {\r\n        if (isNamespaceMember === void 0) { isNamespaceMember = false; }\r\n        // check decorators\r\n        var decorators = null;\r\n        while (tn.skip(tokenizer_1.Token.AT)) {\r\n            var decorator = this.parseDecorator(tn);\r\n            if (!decorator)\r\n                break;\r\n            if (!decorators)\r\n                decorators = [];\r\n            decorators.push(decorator);\r\n        }\r\n        // check modifiers\r\n        var modifiers = null;\r\n        if (tn.skip(tokenizer_1.Token.EXPORT)) {\r\n            modifiers = ast_1.addModifier(ast_1.Node.createModifier(ast_1.ModifierKind.EXPORT, tn.range()), modifiers);\r\n        }\r\n        if (tn.skip(tokenizer_1.Token.DECLARE)) {\r\n            modifiers = ast_1.addModifier(ast_1.Node.createModifier(ast_1.ModifierKind.DECLARE, tn.range()), modifiers);\r\n            tn.peek(true);\r\n            if (tn.nextTokenOnNewLine) {\r\n                this.error(diagnostics_1.DiagnosticCode.Line_break_not_permitted_here, tn.range(tn.pos)); // recoverable, compatibility\r\n            }\r\n        }\r\n        // remember where we took off\r\n        tn.mark();\r\n        // parse the statement\r\n        var statement = null;\r\n        var modifier;\r\n        // handle declarations\r\n        switch (tn.next()) {\r\n            case tokenizer_1.Token.CONST:\r\n                modifiers = ast_1.addModifier(ast_1.Node.createModifier(ast_1.ModifierKind.CONST, tn.range()), modifiers);\r\n                if (tn.skip(tokenizer_1.Token.ENUM)) {\r\n                    statement = this.parseEnum(tn, modifiers, decorators);\r\n                    break;\r\n                }\r\n                statement = this.parseVariable(tn, modifiers, decorators);\r\n                decorators = null;\r\n                break;\r\n            case tokenizer_1.Token.LET:\r\n                modifiers = ast_1.addModifier(ast_1.Node.createModifier(ast_1.ModifierKind.LET, tn.range()), modifiers);\r\n            // fall-through\r\n            case tokenizer_1.Token.VAR:\r\n                statement = this.parseVariable(tn, modifiers, decorators);\r\n                decorators = null;\r\n                break;\r\n            case tokenizer_1.Token.ENUM:\r\n                statement = this.parseEnum(tn, modifiers, decorators);\r\n                decorators = null;\r\n                break;\r\n            case tokenizer_1.Token.FUNCTION:\r\n                statement = this.parseFunction(tn, modifiers, decorators);\r\n                decorators = null;\r\n                break;\r\n            case tokenizer_1.Token.ABSTRACT:\r\n                if (!tn.skip(tokenizer_1.Token.CLASS)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), \"class\");\r\n                    break;\r\n                }\r\n                modifiers = ast_1.addModifier(ast_1.Node.createModifier(ast_1.ModifierKind.ABSTRACT, tn.range()), modifiers);\r\n            // fall through\r\n            case tokenizer_1.Token.CLASS:\r\n                statement = this.parseClass(tn, modifiers, decorators);\r\n                decorators = null;\r\n                break;\r\n            case tokenizer_1.Token.NAMESPACE:\r\n                statement = this.parseNamespace(tn, modifiers, decorators);\r\n                decorators = null;\r\n                break;\r\n            case tokenizer_1.Token.IMPORT:\r\n                if (modifier = ast_1.getModifier(ast_1.ModifierKind.EXPORT, modifiers)) {\r\n                    statement = this.parseExportImport(tn, modifier.range);\r\n                }\r\n                else {\r\n                    statement = this.parseImport(tn);\r\n                }\r\n                if (modifiers)\r\n                    ast_1.setReusableModifiers(modifiers);\r\n                break;\r\n            case tokenizer_1.Token.TYPE:\r\n                statement = this.parseTypeDeclaration(tn, modifiers, decorators);\r\n                decorators = null;\r\n                break;\r\n            default:\r\n                // handle plain exports\r\n                if (ast_1.hasModifier(ast_1.ModifierKind.EXPORT, modifiers)) {\r\n                    tn.reset();\r\n                    statement = this.parseExport(tn, modifiers); // TODO: why exactly does this have modifiers again? 'declare'?\r\n                    // handle non-declaration statements\r\n                }\r\n                else {\r\n                    if (modifiers) {\r\n                        if (modifier = ast_1.getModifier(ast_1.ModifierKind.DECLARE, modifiers)) {\r\n                            this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, modifier.range, \"declare\"); // recoverable\r\n                        }\r\n                        ast_1.setReusableModifiers(modifiers);\r\n                    }\r\n                    tn.reset();\r\n                    if (!isNamespaceMember) {\r\n                        statement = this.parseStatement(tn, true);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n        // check for decorators that weren't consumed\r\n        if (decorators) {\r\n            for (var i = 0, k = decorators.length; i < k; ++i) {\r\n                this.error(diagnostics_1.DiagnosticCode.Decorators_are_not_valid_here, decorators[i].range);\r\n            }\r\n        }\r\n        return statement;\r\n    };\r\n    /** Obtains the next file to parse. */\r\n    Parser.prototype.nextFile = function () {\r\n        return this.backlog.length ? this.backlog.shift() : null;\r\n    };\r\n    /** Finishes parsing and returns the program. */\r\n    Parser.prototype.finish = function () {\r\n        if (this.backlog.length)\r\n            throw new Error(\"backlog is not empty\");\r\n        this.backlog = [];\r\n        this.seenlog.clear();\r\n        return this.program;\r\n    };\r\n    /** Parses a type. */\r\n    Parser.prototype.parseType = function (tn, acceptParenthesized, suppressErrors) {\r\n        if (acceptParenthesized === void 0) { acceptParenthesized = true; }\r\n        if (suppressErrors === void 0) { suppressErrors = false; }\r\n        // NOTE: this parses our limited subset\r\n        var token = tn.next();\r\n        var startPos = tn.tokenPos;\r\n        // void\r\n        if (token == tokenizer_1.Token.VOID) {\r\n            return ast_1.Node.createType(ast_1.Node.createIdentifierExpression(\"void\", tn.range()), [], false, tn.range(startPos, tn.pos));\r\n        }\r\n        var type;\r\n        // ( ... )\r\n        if (acceptParenthesized && token == tokenizer_1.Token.OPENPAREN) {\r\n            var innerType = this.parseType(tn, false, suppressErrors);\r\n            if (!innerType)\r\n                return null;\r\n            if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {\r\n                if (!suppressErrors) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), \"}\");\r\n                }\r\n                return null;\r\n            }\r\n            type = innerType;\r\n            type.range.start = startPos;\r\n            type.range.end = tn.pos;\r\n            // this\r\n        }\r\n        else if (token == tokenizer_1.Token.THIS) {\r\n            type = ast_1.Node.createType(ast_1.Node.createThisExpression(tn.range()), [], false, tn.range(startPos, tn.pos));\r\n            // true\r\n        }\r\n        else if (token == tokenizer_1.Token.TRUE || token == tokenizer_1.Token.FALSE) {\r\n            type = ast_1.Node.createType(ast_1.Node.createIdentifierExpression(\"bool\", tn.range()), [], false, tn.range(startPos, tn.pos));\r\n            // string literal\r\n        }\r\n        else if (token == tokenizer_1.Token.STRINGLITERAL) {\r\n            tn.readString();\r\n            type = ast_1.Node.createType(ast_1.Node.createIdentifierExpression(\"string\", tn.range()), [], false, tn.range(startPos, tn.pos));\r\n            // Name\r\n        }\r\n        else if (token == tokenizer_1.Token.IDENTIFIER) {\r\n            var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n            var parameters = new Array();\r\n            var nullable = false;\r\n            // Name<T>\r\n            if (tn.skip(tokenizer_1.Token.LESSTHAN)) {\r\n                do {\r\n                    var parameter = this.parseType(tn, true, suppressErrors);\r\n                    if (!parameter)\r\n                        return null;\r\n                    parameters.push(parameter);\r\n                } while (tn.skip(tokenizer_1.Token.COMMA));\r\n                if (!tn.skip(tokenizer_1.Token.GREATERTHAN)) {\r\n                    if (!suppressErrors) {\r\n                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), \">\");\r\n                    }\r\n                    return null;\r\n                }\r\n            }\r\n            // ... | null\r\n            if (tn.skip(tokenizer_1.Token.BAR)) {\r\n                if (tn.skip(tokenizer_1.Token.NULL)) {\r\n                    nullable = true;\r\n                }\r\n                else {\r\n                    if (!suppressErrors) {\r\n                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), \"null\");\r\n                    }\r\n                    return null;\r\n                }\r\n            }\r\n            type = ast_1.Node.createType(identifier, parameters, nullable, tn.range(startPos, tn.pos));\r\n        }\r\n        else {\r\n            if (!suppressErrors) {\r\n                this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n            }\r\n            return null;\r\n        }\r\n        // ... [][]\r\n        while (tn.skip(tokenizer_1.Token.OPENBRACKET)) {\r\n            var bracketStart = tn.tokenPos;\r\n            if (!tn.skip(tokenizer_1.Token.CLOSEBRACKET)) {\r\n                if (!suppressErrors) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"]\");\r\n                }\r\n                return null;\r\n            }\r\n            var bracketRange = tn.range(bracketStart, tn.pos);\r\n            // ...[] | null\r\n            nullable = false;\r\n            if (tn.skip(tokenizer_1.Token.BAR)) {\r\n                if (tn.skip(tokenizer_1.Token.NULL)) {\r\n                    nullable = true;\r\n                }\r\n                else {\r\n                    if (!suppressErrors) {\r\n                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"null\");\r\n                    }\r\n                    return null;\r\n                }\r\n            }\r\n            type = ast_1.Node.createType(ast_1.Node.createIdentifierExpression(\"Array\", bracketRange), [type], nullable, tn.range(startPos, tn.pos));\r\n            if (nullable)\r\n                break;\r\n        }\r\n        return type;\r\n    };\r\n    // statements\r\n    Parser.prototype.parseDecorator = function (tn) {\r\n        // at '@': Identifier ('.' Identifier)* '(' Arguments\r\n        var startPos = tn.tokenPos;\r\n        if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n            var name = tn.readIdentifier();\r\n            var expression = ast_1.Node.createIdentifierExpression(name, tn.range(startPos, tn.pos));\r\n            while (tn.skip(tokenizer_1.Token.DOT)) {\r\n                if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n                    name = tn.readIdentifier();\r\n                    expression = ast_1.Node.createPropertyAccessExpression(expression, ast_1.Node.createIdentifierExpression(name, tn.range()), tn.range(startPos, tn.pos));\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n                    return null;\r\n                }\r\n            }\r\n            var args;\r\n            if (tn.skip(tokenizer_1.Token.OPENPAREN)) {\r\n                args = this.parseArguments(tn);\r\n                if (args) {\r\n                    return ast_1.Node.createDecorator(expression, args, tn.range(startPos, tn.pos));\r\n                }\r\n            }\r\n            else {\r\n                return ast_1.Node.createDecorator(expression, null, tn.range(startPos, tn.pos));\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseVariable = function (tn, modifiers, decorators) {\r\n        // at ('const' | 'let' | 'var'): VariableDeclaration (',' VariableDeclaration)* ';'?\r\n        var startPos = modifiers && modifiers.length ? modifiers[0].range.start : tn.tokenPos;\r\n        var members = new Array();\r\n        var isDeclare = ast_1.hasModifier(ast_1.ModifierKind.DECLARE, modifiers);\r\n        do {\r\n            var member = this.parseVariableDeclaration(tn, isDeclare, modifiers, decorators);\r\n            if (!member)\r\n                return null;\r\n            members.push(member);\r\n        } while (tn.skip(tokenizer_1.Token.COMMA));\r\n        var ret = ast_1.Node.createVariableStatement(members, modifiers, decorators, tn.range(startPos, tn.pos));\r\n        tn.skip(tokenizer_1.Token.SEMICOLON);\r\n        return ret;\r\n    };\r\n    Parser.prototype.parseVariableDeclaration = function (tn, isDeclare, parentModifiers, parentDecorators) {\r\n        // before: Identifier (':' Type)? ('=' Expression)?\r\n        if (isDeclare === void 0) { isDeclare = false; }\r\n        if (!tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n            return null;\r\n        }\r\n        var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        var type = null;\r\n        if (tn.skip(tokenizer_1.Token.COLON)) {\r\n            type = this.parseType(tn);\r\n        }\r\n        var initializer = null;\r\n        if (tn.skip(tokenizer_1.Token.EQUALS)) {\r\n            if (isDeclare) {\r\n                this.error(diagnostics_1.DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts, tn.range()); // recoverable\r\n            }\r\n            initializer = this.parseExpression(tn, 0 /* COMMA */ + 1);\r\n            if (!initializer)\r\n                return null;\r\n        }\r\n        else {\r\n            if (ast_1.hasModifier(ast_1.ModifierKind.CONST, parentModifiers)) {\r\n                if (!ast_1.hasModifier(ast_1.ModifierKind.DECLARE, parentModifiers)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._const_declarations_must_be_initialized, identifier.range);\r\n                }\r\n            }\r\n            else if (!type) {\r\n                this.error(diagnostics_1.DiagnosticCode.Type_expected, tn.range(tn.pos)); // recoverable\r\n            }\r\n        }\r\n        return ast_1.Node.createVariableDeclaration(identifier, type, initializer, parentModifiers, parentDecorators, tokenizer_1.Range.join(identifier.range, tn.range()));\r\n    };\r\n    Parser.prototype.parseEnum = function (tn, modifiers, decorators) {\r\n        // at 'enum': Identifier '{' (EnumValueDeclaration (',' EnumValueDeclaration )*)? '}' ';'?\r\n        var startPos = modifiers && modifiers.length ? modifiers[0].range.start : tn.tokenPos;\r\n        if (tn.next() != tokenizer_1.Token.IDENTIFIER) {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n            return null;\r\n        }\r\n        var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        if (tn.next() != tokenizer_1.Token.OPENBRACE) {\r\n            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"{\");\r\n            return null;\r\n        }\r\n        var members = new Array();\r\n        if (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {\r\n            do {\r\n                var member = this.parseEnumValue(tn);\r\n                if (!member)\r\n                    return null;\r\n                members.push(member);\r\n            } while (tn.skip(tokenizer_1.Token.COMMA));\r\n            if (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"}\");\r\n                return null;\r\n            }\r\n        }\r\n        var ret = ast_1.Node.createEnumDeclaration(identifier, members, modifiers, decorators, tn.range(startPos, tn.pos));\r\n        tn.skip(tokenizer_1.Token.SEMICOLON);\r\n        return ret;\r\n    };\r\n    Parser.prototype.parseEnumValue = function (tn) {\r\n        // before: Identifier ('=' Expression)?\r\n        if (!tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n            return null;\r\n        }\r\n        var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        var value = null;\r\n        if (tn.skip(tokenizer_1.Token.EQUALS)) {\r\n            value = this.parseExpression(tn, 0 /* COMMA */ + 1);\r\n            if (!value)\r\n                return null;\r\n        }\r\n        return ast_1.Node.createEnumValueDeclaration(identifier, value, tokenizer_1.Range.join(identifier.range, tn.range()));\r\n    };\r\n    Parser.prototype.parseReturn = function (tn) {\r\n        // at 'return': Expression | (';' | '}' | ...'\\n')\r\n        var expr = null;\r\n        if (tn.peek(true) != tokenizer_1.Token.SEMICOLON &&\r\n            tn.nextToken != tokenizer_1.Token.CLOSEBRACE &&\r\n            !tn.nextTokenOnNewLine) {\r\n            if (!(expr = this.parseExpression(tn)))\r\n                return null;\r\n        }\r\n        var ret = ast_1.Node.createReturnStatement(expr, tn.range());\r\n        tn.skip(tokenizer_1.Token.SEMICOLON);\r\n        return ret;\r\n    };\r\n    Parser.prototype.parseTypeParameters = function (tn) {\r\n        // at '<': TypeParameter (',' TypeParameter)* '>'\r\n        var typeParameters = new Array();\r\n        if (!tn.skip(tokenizer_1.Token.GREATERTHAN)) {\r\n            do {\r\n                var typeParameter = this.parseTypeParameter(tn);\r\n                if (!typeParameter)\r\n                    return null;\r\n                typeParameters.push(typeParameter);\r\n            } while (tn.skip(tokenizer_1.Token.COMMA));\r\n            if (!tn.skip(tokenizer_1.Token.GREATERTHAN)) {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \">\");\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode.Type_parameter_list_cannot_be_empty, tn.range()); // recoverable\r\n        }\r\n        return typeParameters;\r\n    };\r\n    Parser.prototype.parseTypeParameter = function (tn) {\r\n        // before: Identifier ('extends' Type)?\r\n        if (tn.next() == tokenizer_1.Token.IDENTIFIER) {\r\n            var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n            var extendsType = null;\r\n            if (tn.skip(tokenizer_1.Token.EXTENDS)) {\r\n                if (!(extendsType = this.parseType(tn)))\r\n                    return null;\r\n            }\r\n            return ast_1.Node.createTypeParameter(identifier, extendsType, tokenizer_1.Range.join(identifier.range, tn.range()));\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseParameters = function (tn) {\r\n        // at '(': (Parameter (',' Parameter)*)? ')'\r\n        var parameters = new Array();\r\n        var seenRest = null;\r\n        var seenOptional = false;\r\n        var reportedRest = false;\r\n        if (tn.peek() != tokenizer_1.Token.CLOSEPAREN) {\r\n            do {\r\n                var param = this.parseParameter(tn);\r\n                if (!param)\r\n                    return null;\r\n                if (seenRest && !reportedRest) {\r\n                    this.error(diagnostics_1.DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list, seenRest.name.range);\r\n                    reportedRest = true;\r\n                }\r\n                switch (param.parameterKind) {\r\n                    default:\r\n                        if (seenOptional) {\r\n                            this.error(diagnostics_1.DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter, param.name.range);\r\n                        }\r\n                        break;\r\n                    case ast_1.ParameterKind.OPTIONAL:\r\n                        seenOptional = true;\r\n                        break;\r\n                    case ast_1.ParameterKind.REST:\r\n                        seenRest = param;\r\n                        break;\r\n                }\r\n                parameters.push(param);\r\n            } while (tn.skip(tokenizer_1.Token.COMMA));\r\n        }\r\n        if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {\r\n            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \")\");\r\n            return null;\r\n        }\r\n        return parameters;\r\n    };\r\n    Parser.prototype.parseParameter = function (tn, suppressErrors) {\r\n        // before: '...'? Identifier '?'? (':' Type)? ('=' Expression)?\r\n        if (suppressErrors === void 0) { suppressErrors = false; }\r\n        var isRest = false;\r\n        var isOptional = false;\r\n        var startRange = null;\r\n        if (tn.skip(tokenizer_1.Token.DOT_DOT_DOT)) {\r\n            isRest = true;\r\n            startRange = tn.range();\r\n        }\r\n        if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n            if (!isRest)\r\n                startRange = tn.range();\r\n            var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n            var type = null;\r\n            if (isOptional = tn.skip(tokenizer_1.Token.QUESTION)) {\r\n                if (isRest) {\r\n                    this.error(diagnostics_1.DiagnosticCode.A_rest_parameter_cannot_be_optional, identifier.range);\r\n                }\r\n            }\r\n            if (tn.skip(tokenizer_1.Token.COLON)) {\r\n                type = this.parseType(tn);\r\n                if (!type)\r\n                    return null;\r\n            }\r\n            var initializer = null;\r\n            if (tn.skip(tokenizer_1.Token.EQUALS)) {\r\n                if (isRest) {\r\n                    this.error(diagnostics_1.DiagnosticCode.A_rest_parameter_cannot_have_an_initializer, identifier.range);\r\n                }\r\n                if (isOptional) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer, identifier.range);\r\n                }\r\n                else {\r\n                    isOptional = true;\r\n                }\r\n                initializer = this.parseExpression(tn, 0 /* COMMA */ + 1);\r\n                if (!initializer)\r\n                    return null;\r\n            }\r\n            return ast_1.Node.createParameter(identifier, type, initializer, isRest\r\n                ? ast_1.ParameterKind.REST\r\n                : isOptional\r\n                    ? ast_1.ParameterKind.OPTIONAL\r\n                    : ast_1.ParameterKind.DEFAULT, tokenizer_1.Range.join(startRange, tn.range()));\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseFunction = function (tn, modifiers, decorators) {\r\n        // at 'function':\r\n        //  Identifier\r\n        //  ('<' TypeParameters)?\r\n        //  '(' Parameters (':' Type)?\r\n        //  '{' Statement* '}'\r\n        //  ';'?\r\n        var startPos = modifiers && modifiers.length ? modifiers[0].range.start : tn.tokenPos;\r\n        if (!tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range(tn.pos));\r\n            return null;\r\n        }\r\n        var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        var typeParameters = null;\r\n        if (tn.skip(tokenizer_1.Token.LESSTHAN)) {\r\n            typeParameters = this.parseTypeParameters(tn);\r\n            if (!typeParameters)\r\n                return null;\r\n        }\r\n        if (!tn.skip(tokenizer_1.Token.OPENPAREN)) {\r\n            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), \"(\");\r\n            return null;\r\n        }\r\n        var parameters = this.parseParameters(tn);\r\n        if (!parameters)\r\n            return null;\r\n        var isSetter = ast_1.hasModifier(ast_1.ModifierKind.SET, modifiers);\r\n        if (isSetter) {\r\n            if (parameters.length != 1) {\r\n                this.error(diagnostics_1.DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter, identifier.range); // recoverable\r\n            }\r\n            if (parameters.length && parameters[0].initializer) {\r\n                this.error(diagnostics_1.DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer, identifier.range); // recoverable\r\n            }\r\n        }\r\n        var isGetter = ast_1.hasModifier(ast_1.ModifierKind.GET, modifiers);\r\n        if (isGetter && parameters.length) {\r\n            this.error(diagnostics_1.DiagnosticCode.A_get_accessor_cannot_have_parameters, identifier.range); // recoverable\r\n        }\r\n        var returnType = null;\r\n        if (tn.skip(tokenizer_1.Token.COLON)) {\r\n            returnType = this.parseType(tn, isSetter);\r\n            if (!returnType)\r\n                return null;\r\n        }\r\n        else if (!isSetter) {\r\n            this.error(diagnostics_1.DiagnosticCode.Type_expected, tn.range(tn.pos)); // recoverable\r\n        }\r\n        var isDeclare = ast_1.hasModifier(ast_1.ModifierKind.DECLARE, modifiers);\r\n        var body = null;\r\n        if (tn.skip(tokenizer_1.Token.OPENBRACE)) {\r\n            if (isDeclare) {\r\n                this.error(diagnostics_1.DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts, tn.range()); // recoverable\r\n            }\r\n            body = this.parseBlockStatement(tn, false);\r\n            if (!body)\r\n                return null;\r\n        }\r\n        else if (!isDeclare) {\r\n            this.error(diagnostics_1.DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration, tn.range(tn.pos));\r\n        }\r\n        var ret = ast_1.Node.createFunctionDeclaration(identifier, typeParameters, parameters, returnType, body, modifiers, decorators, tn.range(startPos, tn.pos));\r\n        tn.skip(tokenizer_1.Token.SEMICOLON);\r\n        return ret;\r\n    };\r\n    Parser.prototype.parseFunctionExpression = function (tn) {\r\n        var startPos = tn.tokenPos;\r\n        var identifier;\r\n        var isArrow = false;\r\n        // either at 'function':\r\n        //  Identifier?\r\n        //  '(' Parameters (':' Type)?\r\n        //  Statement\r\n        if (tn.token == tokenizer_1.Token.FUNCTION) {\r\n            isArrow = false;\r\n            if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n                identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n            }\r\n            else {\r\n                identifier = ast_1.Node.createIdentifierExpression(\"\", tn.range(tn.pos, tn.pos));\r\n            }\r\n            if (!tn.skip(tokenizer_1.Token.OPENPAREN)) {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), \"(\");\r\n                return null;\r\n            }\r\n            // or at '(' of arrow function:\r\n            //  Parameters (':' Type)?\r\n            //  Statement\r\n        }\r\n        else {\r\n            isArrow = true;\r\n            assert(tn.token == tokenizer_1.Token.OPENPAREN);\r\n            identifier = ast_1.Node.createIdentifierExpression(\"\", tn.range(tn.tokenPos, tn.tokenPos));\r\n        }\r\n        // TODO: type parameters? doesn't seem worth it.\r\n        var parameters = this.parseParameters(tn);\r\n        if (!parameters)\r\n            return null;\r\n        return this.parseFunctionExpressionCommon(tn, identifier, parameters, isArrow, startPos);\r\n    };\r\n    Parser.prototype.parseFunctionExpressionCommon = function (tn, identifier, parameters, isArrow, startPos) {\r\n        if (startPos === void 0) { startPos = -1; }\r\n        if (startPos < 0)\r\n            startPos = identifier.range.start;\r\n        var returnType = null;\r\n        if (tn.skip(tokenizer_1.Token.COLON)) {\r\n            returnType = this.parseType(tn);\r\n            if (!returnType)\r\n                return null;\r\n        }\r\n        if (isArrow) {\r\n            if (!tn.skip(tokenizer_1.Token.EQUALS_GREATERTHAN)) {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), \"=>\");\r\n                return null;\r\n            }\r\n        }\r\n        var body;\r\n        if (isArrow) {\r\n            body = this.parseStatement(tn, false);\r\n        }\r\n        else {\r\n            if (!tn.skip(tokenizer_1.Token.OPENBRACE)) {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(tn.pos), \"{\");\r\n                return null;\r\n            }\r\n            body = this.parseBlockStatement(tn, false);\r\n        }\r\n        if (!body)\r\n            return null;\r\n        var declaration = ast_1.Node.createFunctionDeclaration(identifier, null, parameters, returnType, body, null, null, tn.range(startPos, tn.pos));\r\n        return ast_1.Node.createFunctionExpression(declaration, isArrow);\r\n    };\r\n    Parser.prototype.parseClass = function (tn, modifiers, decorators) {\r\n        // at 'class':\r\n        //   Identifier\r\n        //   ('<' TypeParameters)?\r\n        //   ('extends' Type)?\r\n        //   ('implements' Type (',' Type)*)?\r\n        //   '{' ClassMember* '}'\r\n        var startPos = decorators && decorators.length\r\n            ? decorators[0].range.start\r\n            : modifiers && modifiers.length\r\n                ? modifiers[0].range.start\r\n                : tn.tokenPos;\r\n        if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n            var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n            var typeParameters;\r\n            if (tn.skip(tokenizer_1.Token.LESSTHAN)) {\r\n                typeParameters = this.parseTypeParameters(tn);\r\n                if (!typeParameters)\r\n                    return null;\r\n            }\r\n            else {\r\n                typeParameters = [];\r\n            }\r\n            var extendsType = null;\r\n            if (tn.skip(tokenizer_1.Token.EXTENDS)) {\r\n                extendsType = this.parseType(tn);\r\n                if (!extendsType)\r\n                    return null;\r\n            }\r\n            var implementsTypes = new Array();\r\n            if (tn.skip(tokenizer_1.Token.IMPLEMENTS)) {\r\n                do {\r\n                    var type = this.parseType(tn);\r\n                    if (!type)\r\n                        return null;\r\n                    implementsTypes.push(type);\r\n                } while (tn.skip(tokenizer_1.Token.COMMA));\r\n            }\r\n            if (tn.skip(tokenizer_1.Token.OPENBRACE)) {\r\n                var members = new Array();\r\n                if (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {\r\n                    var isDeclare = ast_1.hasModifier(ast_1.ModifierKind.DECLARE, modifiers);\r\n                    do {\r\n                        var member = this.parseClassMember(tn, isDeclare);\r\n                        if (!member)\r\n                            return null;\r\n                        members.push(member);\r\n                    } while (!tn.skip(tokenizer_1.Token.CLOSEBRACE));\r\n                }\r\n                return ast_1.Node.createClassDeclaration(identifier, typeParameters, extendsType, implementsTypes, members, modifiers, decorators, tn.range(startPos, tn.pos));\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"{\");\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseClassMember = function (tn, parentIsDeclare) {\r\n        // before:\r\n        //   ('public' | 'private' | 'protected')?\r\n        //   ('static' | 'abstract')?\r\n        //   ('get' | 'set')?\r\n        //   Identifier ...\r\n        var startPos = tn.pos;\r\n        var decorators = new Array();\r\n        while (tn.skip(tokenizer_1.Token.AT)) {\r\n            var decorator = this.parseDecorator(tn);\r\n            if (!decorator)\r\n                break;\r\n            decorators.push(decorator);\r\n        }\r\n        var modifiers = null;\r\n        if (tn.skip(tokenizer_1.Token.PUBLIC)) {\r\n            modifiers = ast_1.addModifier(ast_1.Node.createModifier(ast_1.ModifierKind.PUBLIC, tn.range()), modifiers);\r\n        }\r\n        else if (tn.skip(tokenizer_1.Token.PRIVATE)) {\r\n            modifiers = ast_1.addModifier(ast_1.Node.createModifier(ast_1.ModifierKind.PRIVATE, tn.range()), modifiers);\r\n        }\r\n        else if (tn.skip(tokenizer_1.Token.PROTECTED)) {\r\n            modifiers = ast_1.addModifier(ast_1.Node.createModifier(ast_1.ModifierKind.PROTECTED, tn.range()), modifiers);\r\n        }\r\n        if (tn.skip(tokenizer_1.Token.STATIC)) {\r\n            modifiers = ast_1.addModifier(ast_1.Node.createModifier(ast_1.ModifierKind.STATIC, tn.range()), modifiers);\r\n        }\r\n        else if (tn.skip(tokenizer_1.Token.ABSTRACT)) {\r\n            modifiers = ast_1.addModifier(ast_1.Node.createModifier(ast_1.ModifierKind.ABSTRACT, tn.range()), modifiers);\r\n        }\r\n        if (tn.skip(tokenizer_1.Token.READONLY)) {\r\n            modifiers = ast_1.addModifier(ast_1.Node.createModifier(ast_1.ModifierKind.READONLY, tn.range()), modifiers);\r\n        }\r\n        // check if accessor: ('get' | 'set') ^\\n Identifier\r\n        tn.mark();\r\n        var isGetter = false;\r\n        var isSetter = false;\r\n        if (isGetter = tn.skip(tokenizer_1.Token.GET)) {\r\n            if (tn.peek(true, true) == tokenizer_1.Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\r\n                modifiers = ast_1.addModifier(ast_1.Node.createModifier(ast_1.ModifierKind.GET, tn.range()), modifiers);\r\n            }\r\n            else {\r\n                tn.reset();\r\n                isGetter = false;\r\n            }\r\n        }\r\n        else if (isSetter = tn.skip(tokenizer_1.Token.SET)) {\r\n            if (tn.peek(true, true) == tokenizer_1.Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\r\n                modifiers = ast_1.addModifier(ast_1.Node.createModifier(ast_1.ModifierKind.SET, tn.range()), modifiers);\r\n            }\r\n            else {\r\n                tn.reset();\r\n                isSetter = false;\r\n            }\r\n        }\r\n        var isConstructor = tn.skip(tokenizer_1.Token.CONSTRUCTOR);\r\n        if (isConstructor || tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n            var identifier = isConstructor\r\n                ? ast_1.Node.createConstructorExpression(tn.range())\r\n                : ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n            var typeParameters = null;\r\n            if (tn.skip(tokenizer_1.Token.LESSTHAN)) {\r\n                if (isConstructor) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration, tn.range()); // recoverable\r\n                }\r\n                typeParameters = this.parseTypeParameters(tn);\r\n                if (!typeParameters)\r\n                    return null;\r\n            }\r\n            // method: '(' Parameters (':' Type)? '{' Statement* '}' ';'?\r\n            if (tn.skip(tokenizer_1.Token.OPENPAREN)) {\r\n                var parameters = this.parseParameters(tn);\r\n                if (!parameters)\r\n                    return null;\r\n                if (isGetter && parameters.length) {\r\n                    this.error(diagnostics_1.DiagnosticCode.A_get_accessor_cannot_have_parameters, identifier.range);\r\n                }\r\n                if (isSetter) {\r\n                    if (parameters.length != 1) {\r\n                        this.error(diagnostics_1.DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter, identifier.range);\r\n                    }\r\n                    if (parameters.length && parameters[0].initializer) {\r\n                        this.error(diagnostics_1.DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer, identifier.range);\r\n                    }\r\n                }\r\n                var returnType = null;\r\n                if (tn.skip(tokenizer_1.Token.COLON)) {\r\n                    if (identifier.kind == ast_1.NodeKind.CONSTRUCTOR) {\r\n                        this.error(diagnostics_1.DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration, tn.range());\r\n                    }\r\n                    else if (isSetter) {\r\n                        this.error(diagnostics_1.DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation, tn.range());\r\n                    }\r\n                    returnType = this.parseType(tn, identifier.kind == ast_1.NodeKind.CONSTRUCTOR || isSetter);\r\n                    if (!returnType)\r\n                        return null;\r\n                }\r\n                else if (!isSetter && identifier.kind != ast_1.NodeKind.CONSTRUCTOR) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Type_expected, tn.range()); // recoverable\r\n                }\r\n                var body = null;\r\n                if (tn.skip(tokenizer_1.Token.OPENBRACE)) {\r\n                    if (parentIsDeclare) {\r\n                        this.error(diagnostics_1.DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts, tn.range()); // recoverable\r\n                    }\r\n                    body = this.parseBlockStatement(tn, false);\r\n                    if (!body)\r\n                        return null;\r\n                }\r\n                else if (!parentIsDeclare) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration, tn.range()); // recoverable\r\n                }\r\n                var retMethod = ast_1.Node.createMethodDeclaration(identifier, typeParameters, parameters, returnType, body, modifiers, decorators, tn.range(startPos, tn.pos));\r\n                tn.skip(tokenizer_1.Token.SEMICOLON);\r\n                return retMethod;\r\n            }\r\n            else if (isConstructor) {\r\n                this.error(diagnostics_1.DiagnosticCode.Constructor_implementation_is_missing, identifier.range);\r\n            }\r\n            else if (isGetter || isSetter) {\r\n                this.error(diagnostics_1.DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration, identifier.range);\r\n                // field: (':' Type)? ('=' Expression)? ';'?\r\n            }\r\n            else {\r\n                var modifier;\r\n                if (modifier = ast_1.getModifier(ast_1.ModifierKind.ABSTRACT, modifiers)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, modifier.range, \"abstract\"); // recoverable\r\n                }\r\n                if (modifier = ast_1.getModifier(ast_1.ModifierKind.GET, modifiers)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, modifier.range, \"get\"); // recoverable\r\n                }\r\n                if (modifier = ast_1.getModifier(ast_1.ModifierKind.SET, modifiers)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_modifier_cannot_be_used_here, modifier.range, \"set\"); // recoverable\r\n                }\r\n                var type = null;\r\n                if (tn.skip(tokenizer_1.Token.COLON)) {\r\n                    type = this.parseType(tn);\r\n                    if (!type)\r\n                        return null;\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode.Type_expected, tn.range()); // recoverable\r\n                }\r\n                var initializer = null;\r\n                if (tn.skip(tokenizer_1.Token.EQUALS)) {\r\n                    initializer = this.parseExpression(tn);\r\n                    if (!initializer)\r\n                        return null;\r\n                }\r\n                var retField = ast_1.Node.createFieldDeclaration(identifier, type, initializer, modifiers, decorators, tn.range(startPos, tn.pos));\r\n                tn.skip(tokenizer_1.Token.SEMICOLON);\r\n                return retField;\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseNamespace = function (tn, modifiers, decorators) {\r\n        // at 'namespace': Identifier '{' (Variable | Function)* '}'\r\n        var startPos = modifiers && modifiers.length ? modifiers[0].range.start : tn.tokenPos;\r\n        if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n            var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n            if (tn.skip(tokenizer_1.Token.OPENBRACE)) {\r\n                var members = new Array();\r\n                while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {\r\n                    var member = this.parseTopLevelStatement(tn, true);\r\n                    if (!member)\r\n                        return null;\r\n                    members.push(member);\r\n                }\r\n                var ret = ast_1.Node.createNamespaceDeclaration(identifier, members, modifiers, decorators, tn.range(startPos, tn.pos));\r\n                tn.skip(tokenizer_1.Token.SEMICOLON);\r\n                return ret;\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"{\");\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseExport = function (tn, modifiers) {\r\n        // at 'export': '{' ExportMember (',' ExportMember)* }' ('from' StringLiteral)? ';'?\r\n        var startPos = modifiers && modifiers.length ? modifiers[0].range.start : tn.tokenPos;\r\n        if (tn.skip(tokenizer_1.Token.OPENBRACE)) {\r\n            var members = new Array();\r\n            if (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {\r\n                do {\r\n                    var member = this.parseExportMember(tn);\r\n                    if (!member)\r\n                        return null;\r\n                    members.push(member);\r\n                } while (tn.skip(tokenizer_1.Token.COMMA));\r\n                if (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"}\");\r\n                    return null;\r\n                }\r\n            }\r\n            var path = null;\r\n            if (tn.skip(tokenizer_1.Token.FROM)) {\r\n                if (tn.skip(tokenizer_1.Token.STRINGLITERAL)) {\r\n                    path = ast_1.Node.createStringLiteralExpression(tn.readString(), tn.range());\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode.String_literal_expected, tn.range());\r\n                    return null;\r\n                }\r\n            }\r\n            var ret = ast_1.Node.createExportStatement(members, path, modifiers, tn.range(startPos, tn.pos));\r\n            if (ret.normalizedPath && !this.seenlog.has(ret.normalizedPath)) {\r\n                this.backlog.push(ret.normalizedPath);\r\n                this.seenlog.add(ret.normalizedPath);\r\n            }\r\n            tn.skip(tokenizer_1.Token.SEMICOLON);\r\n            return ret;\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"{\");\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseExportMember = function (tn) {\r\n        // before: Identifier ('as' Identifier)?\r\n        if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n            var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n            var asIdentifier = null;\r\n            if (tn.skip(tokenizer_1.Token.AS)) {\r\n                if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n                    asIdentifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n                    return null;\r\n                }\r\n            }\r\n            return ast_1.Node.createExportMember(identifier, asIdentifier, asIdentifier\r\n                ? tokenizer_1.Range.join(identifier.range, asIdentifier.range)\r\n                : identifier.range);\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseImport = function (tn) {\r\n        // at 'import':\r\n        //  ('{' (ImportMember (',' ImportMember)* '}') | ('*' 'as' Identifier)?\r\n        //  'from' StringLiteral ';'?\r\n        var startPos = tn.tokenPos;\r\n        var members = null;\r\n        var namespaceName = null;\r\n        var skipFrom = false;\r\n        if (tn.skip(tokenizer_1.Token.OPENBRACE)) {\r\n            members = new Array();\r\n            if (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {\r\n                do {\r\n                    var member = this.parseImportDeclaration(tn);\r\n                    if (!member)\r\n                        return null;\r\n                    members.push(member);\r\n                } while (tn.skip(tokenizer_1.Token.COMMA));\r\n                if (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"}\");\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n        else if (tn.skip(tokenizer_1.Token.ASTERISK)) {\r\n            if (tn.skip(tokenizer_1.Token.AS)) {\r\n                if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n                    namespaceName = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n                    return null;\r\n                }\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"as\");\r\n                return null;\r\n            }\r\n        }\r\n        else {\r\n            skipFrom = true;\r\n        }\r\n        if (skipFrom || tn.skip(tokenizer_1.Token.FROM)) {\r\n            if (tn.skip(tokenizer_1.Token.STRINGLITERAL)) {\r\n                var path = ast_1.Node.createStringLiteralExpression(tn.readString(), tn.range());\r\n                var ret;\r\n                if (namespaceName) {\r\n                    assert(!members);\r\n                    ret = ast_1.Node.createImportStatementWithWildcard(namespaceName, path, tn.range(startPos, tn.pos));\r\n                }\r\n                else {\r\n                    ret = ast_1.Node.createImportStatement(members, path, tn.range(startPos, tn.pos));\r\n                }\r\n                if (!this.seenlog.has(ret.normalizedPath)) {\r\n                    this.backlog.push(ret.normalizedPath);\r\n                    this.seenlog.add(ret.normalizedPath);\r\n                }\r\n                tn.skip(tokenizer_1.Token.SEMICOLON);\r\n                return ret;\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode.String_literal_expected, tn.range());\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"from\");\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseImportDeclaration = function (tn) {\r\n        // before: Identifier ('as' Identifier)?\r\n        if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n            var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n            var asIdentifier = null;\r\n            if (tn.skip(tokenizer_1.Token.AS)) {\r\n                if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n                    asIdentifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n                    return null;\r\n                }\r\n            }\r\n            return ast_1.Node.createImportDeclaration(identifier, asIdentifier, asIdentifier\r\n                ? tokenizer_1.Range.join(identifier.range, asIdentifier.range)\r\n                : identifier.range);\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseExportImport = function (tn, startRange) {\r\n        // at 'export' 'import': Identifier ('=' Identifier)? ';'?\r\n        if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n            var asIdentifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n            if (tn.skip(tokenizer_1.Token.EQUALS)) {\r\n                if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n                    var identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n                    var ret = ast_1.Node.createExportImportStatement(identifier, asIdentifier, tokenizer_1.Range.join(startRange, tn.range()));\r\n                    tn.skip(tokenizer_1.Token.SEMICOLON);\r\n                    return ret;\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n                }\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"=\");\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseStatement = function (tn, topLevel) {\r\n        // at previous token\r\n        if (topLevel === void 0) { topLevel = false; }\r\n        tn.mark();\r\n        var token = tn.next();\r\n        switch (token) {\r\n            case tokenizer_1.Token.BREAK:\r\n                return this.parseBreak(tn);\r\n            case tokenizer_1.Token.CONST:\r\n                return this.parseVariable(tn, [\r\n                    ast_1.Node.createModifier(ast_1.ModifierKind.CONST, tn.range())\r\n                ], null);\r\n            case tokenizer_1.Token.CONTINUE:\r\n                return this.parseContinue(tn);\r\n            case tokenizer_1.Token.DO:\r\n                return this.parseDoStatement(tn);\r\n            case tokenizer_1.Token.FOR:\r\n                return this.parseForStatement(tn);\r\n            case tokenizer_1.Token.IF:\r\n                return this.parseIfStatement(tn);\r\n            case tokenizer_1.Token.LET:\r\n                return this.parseVariable(tn, [\r\n                    ast_1.Node.createModifier(ast_1.ModifierKind.LET, tn.range())\r\n                ], null);\r\n            case tokenizer_1.Token.VAR:\r\n                return this.parseVariable(tn, null, null);\r\n            case tokenizer_1.Token.OPENBRACE:\r\n                return this.parseBlockStatement(tn, topLevel);\r\n            case tokenizer_1.Token.RETURN:\r\n                if (topLevel) {\r\n                    this.error(diagnostics_1.DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body, tn.range()); // recoverable\r\n                }\r\n                return this.parseReturn(tn);\r\n            case tokenizer_1.Token.SEMICOLON:\r\n                return ast_1.Node.createEmptyStatement(tn.range(tn.tokenPos));\r\n            case tokenizer_1.Token.SWITCH:\r\n                return this.parseSwitchStatement(tn);\r\n            case tokenizer_1.Token.THROW:\r\n                return this.parseThrowStatement(tn);\r\n            case tokenizer_1.Token.TRY:\r\n                return this.parseTryStatement(tn);\r\n            case tokenizer_1.Token.TYPE:\r\n                return this.parseTypeDeclaration(tn, null);\r\n            case tokenizer_1.Token.WHILE:\r\n                return this.parseWhileStatement(tn);\r\n            default:\r\n                tn.reset();\r\n                return this.parseExpressionStatement(tn);\r\n        }\r\n    };\r\n    Parser.prototype.parseBlockStatement = function (tn, topLevel) {\r\n        // at '{': Statement* '}' ';'?\r\n        var startPos = tn.tokenPos;\r\n        var statements = new Array();\r\n        while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {\r\n            var statement = this.parseStatement(tn, topLevel);\r\n            if (!statement)\r\n                return null;\r\n            statements.push(statement);\r\n        }\r\n        var ret = ast_1.Node.createBlockStatement(statements, tn.range(startPos, tn.pos));\r\n        tn.skip(tokenizer_1.Token.SEMICOLON);\r\n        return ret;\r\n    };\r\n    Parser.prototype.parseBreak = function (tn) {\r\n        // at 'break': Identifier? ';'?\r\n        var identifier = null;\r\n        if (tn.peek(true) == tokenizer_1.Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\r\n            tn.next(true);\r\n            identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        }\r\n        var ret = ast_1.Node.createBreakStatement(identifier, tn.range());\r\n        tn.skip(tokenizer_1.Token.SEMICOLON);\r\n        return ret;\r\n    };\r\n    Parser.prototype.parseContinue = function (tn) {\r\n        // at 'continue': Identifier? ';'?\r\n        var identifier = null;\r\n        if (tn.peek(true) == tokenizer_1.Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\r\n            tn.next(true);\r\n            identifier = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        }\r\n        var ret = ast_1.Node.createContinueStatement(identifier, tn.range());\r\n        tn.skip(tokenizer_1.Token.SEMICOLON);\r\n        return ret;\r\n    };\r\n    Parser.prototype.parseDoStatement = function (tn) {\r\n        // at 'do': Statement 'while' '(' Expression ')' ';'?\r\n        var startPos = tn.tokenPos;\r\n        var statement = this.parseStatement(tn);\r\n        if (!statement)\r\n            return null;\r\n        if (tn.skip(tokenizer_1.Token.WHILE)) {\r\n            if (tn.skip(tokenizer_1.Token.OPENPAREN)) {\r\n                var condition = this.parseExpression(tn);\r\n                if (!condition)\r\n                    return null;\r\n                if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) {\r\n                    var ret = ast_1.Node.createDoStatement(statement, condition, tn.range(startPos, tn.pos));\r\n                    tn.skip(tokenizer_1.Token.SEMICOLON);\r\n                    return ret;\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \")\");\r\n                }\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"(\");\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"while\");\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseExpressionStatement = function (tn) {\r\n        // at previous token\r\n        var expr = this.parseExpression(tn);\r\n        if (!expr)\r\n            return null;\r\n        var ret = ast_1.Node.createExpressionStatement(expr);\r\n        tn.skip(tokenizer_1.Token.SEMICOLON);\r\n        return ret;\r\n    };\r\n    Parser.prototype.parseForStatement = function (tn) {\r\n        // at 'for': '(' Statement? Expression? ';' Expression? ')' Statement\r\n        var startPos = tn.tokenPos;\r\n        if (tn.skip(tokenizer_1.Token.OPENPAREN)) {\r\n            var initializer = null;\r\n            if (tn.skip(tokenizer_1.Token.LET) || tn.skip(tokenizer_1.Token.CONST) || tn.skip(tokenizer_1.Token.VAR)) {\r\n                initializer = this.parseVariable(tn, null, null);\r\n            }\r\n            else if (!tn.skip(tokenizer_1.Token.SEMICOLON)) {\r\n                initializer = this.parseExpressionStatement(tn);\r\n                if (!initializer)\r\n                    return null;\r\n            }\r\n            if (tn.token == tokenizer_1.Token.SEMICOLON) {\r\n                var condition = null;\r\n                if (!tn.skip(tokenizer_1.Token.SEMICOLON)) {\r\n                    condition = this.parseExpressionStatement(tn);\r\n                    if (!condition)\r\n                        return null;\r\n                }\r\n                if (tn.token == tokenizer_1.Token.SEMICOLON) {\r\n                    var incrementor = null;\r\n                    if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {\r\n                        incrementor = this.parseExpression(tn);\r\n                        if (!incrementor)\r\n                            return null;\r\n                        if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {\r\n                            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \")\");\r\n                            return null;\r\n                        }\r\n                    }\r\n                    var statement = this.parseStatement(tn);\r\n                    if (!statement)\r\n                        return null;\r\n                    return ast_1.Node.createForStatement(initializer, condition\r\n                        ? condition.expression\r\n                        : null, incrementor, statement, tn.range(startPos, tn.pos));\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \";\");\r\n                }\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \";\");\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"(\");\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseIfStatement = function (tn) {\r\n        // at 'if': '(' Expression ')' Statement ('else' Statement)?\r\n        var startPos = tn.tokenPos;\r\n        if (tn.skip(tokenizer_1.Token.OPENPAREN)) {\r\n            var condition = this.parseExpression(tn);\r\n            if (!condition)\r\n                return null;\r\n            if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) {\r\n                var statement = this.parseStatement(tn);\r\n                if (!statement)\r\n                    return null;\r\n                var elseStatement = null;\r\n                if (tn.skip(tokenizer_1.Token.ELSE)) {\r\n                    elseStatement = this.parseStatement(tn);\r\n                    if (!elseStatement)\r\n                        return null;\r\n                }\r\n                return ast_1.Node.createIfStatement(condition, statement, elseStatement, tn.range(startPos, tn.pos));\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \")\");\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"(\");\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseSwitchStatement = function (tn) {\r\n        // at 'switch': '(' Expression ')' '{' SwitchCase* '}' ';'?\r\n        var startPos = tn.tokenPos;\r\n        if (tn.skip(tokenizer_1.Token.OPENPAREN)) {\r\n            var condition = this.parseExpression(tn);\r\n            if (!condition)\r\n                return null;\r\n            if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) {\r\n                if (tn.skip(tokenizer_1.Token.OPENBRACE)) {\r\n                    var cases = new Array();\r\n                    while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {\r\n                        var case_ = this.parseSwitchCase(tn);\r\n                        if (!case_)\r\n                            return null;\r\n                        cases.push(case_);\r\n                    }\r\n                    var ret = ast_1.Node.createSwitchStatement(condition, cases, tn.range(startPos, tn.pos));\r\n                    tn.skip(tokenizer_1.Token.SEMICOLON);\r\n                    return ret;\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"{\");\r\n                }\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \")\");\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"(\");\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseSwitchCase = function (tn) {\r\n        var startPos = tn.tokenPos;\r\n        var statements, statement;\r\n        // 'case' Expression ':' Statement*\r\n        if (tn.skip(tokenizer_1.Token.CASE)) {\r\n            var label = this.parseExpression(tn);\r\n            if (!label)\r\n                return null;\r\n            if (tn.skip(tokenizer_1.Token.COLON)) {\r\n                statements = new Array();\r\n                while (tn.peek() != tokenizer_1.Token.CASE && tn.nextToken != tokenizer_1.Token.DEFAULT && tn.nextToken != tokenizer_1.Token.CLOSEBRACE) {\r\n                    statement = this.parseStatement(tn);\r\n                    if (!statement)\r\n                        return null;\r\n                    statements.push(statement);\r\n                }\r\n                return ast_1.Node.createSwitchCase(label, statements, tn.range(startPos, tn.pos));\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \":\");\r\n            }\r\n            // 'default' ':' Statement*\r\n        }\r\n        else if (tn.skip(tokenizer_1.Token.DEFAULT)) {\r\n            if (tn.skip(tokenizer_1.Token.COLON)) {\r\n                statements = new Array();\r\n                while (tn.peek() != tokenizer_1.Token.CASE && tn.nextToken != tokenizer_1.Token.DEFAULT && tn.nextToken != tokenizer_1.Token.CLOSEBRACE) {\r\n                    statement = this.parseStatement(tn);\r\n                    if (!statement)\r\n                        return null;\r\n                    statements.push(statement);\r\n                }\r\n                return ast_1.Node.createSwitchCase(null, statements, tn.range(startPos, tn.pos));\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \":\");\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode._case_or_default_expected, tn.range());\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseThrowStatement = function (tn) {\r\n        // at 'throw': Expression ';'?\r\n        var startPos = tn.tokenPos;\r\n        var expression = this.parseExpression(tn);\r\n        if (!expression)\r\n            return null;\r\n        var ret = ast_1.Node.createThrowStatement(expression, tn.range(startPos, tn.pos));\r\n        tn.skip(tokenizer_1.Token.SEMICOLON);\r\n        return ret;\r\n    };\r\n    Parser.prototype.parseTryStatement = function (tn) {\r\n        // at 'try':\r\n        //   '{' Statement* '}'\r\n        //   ('catch' '(' VariableMember ')' '{' Statement* '}')?\r\n        //   ('finally' '{' Statement* '}'? ';'?\r\n        var startPos = tn.tokenPos;\r\n        var stmt;\r\n        if (tn.skip(tokenizer_1.Token.OPENBRACE)) {\r\n            var statements = new Array();\r\n            while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {\r\n                stmt = this.parseStatement(tn);\r\n                if (!stmt)\r\n                    return null;\r\n                statements.push(stmt);\r\n            }\r\n            var catchVariable = null;\r\n            var catchStatements = null;\r\n            var finallyStatements = null;\r\n            if (tn.skip(tokenizer_1.Token.CATCH)) {\r\n                if (!tn.skip(tokenizer_1.Token.OPENPAREN)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"(\");\r\n                    return null;\r\n                }\r\n                if (!tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n                    this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n                    return null;\r\n                }\r\n                catchVariable = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n                if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \")\");\r\n                    return null;\r\n                }\r\n                if (!tn.skip(tokenizer_1.Token.OPENBRACE)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"{\");\r\n                    return null;\r\n                }\r\n                catchStatements = [];\r\n                while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {\r\n                    stmt = this.parseStatement(tn);\r\n                    if (!stmt)\r\n                        return null;\r\n                    catchStatements.push(stmt);\r\n                }\r\n            }\r\n            if (tn.skip(tokenizer_1.Token.FINALLY)) {\r\n                if (!tn.skip(tokenizer_1.Token.OPENBRACE)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"{\");\r\n                    return null;\r\n                }\r\n                finallyStatements = [];\r\n                while (!tn.skip(tokenizer_1.Token.CLOSEBRACE)) {\r\n                    stmt = this.parseStatement(tn);\r\n                    if (!stmt)\r\n                        return null;\r\n                    finallyStatements.push(stmt);\r\n                }\r\n            }\r\n            if (!(catchStatements || finallyStatements)) {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"catch\");\r\n                return null;\r\n            }\r\n            var ret = ast_1.Node.createTryStatement(statements, catchVariable, catchStatements, finallyStatements, tn.range(startPos, tn.pos));\r\n            tn.skip(tokenizer_1.Token.SEMICOLON);\r\n            return ret;\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"{\");\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseTypeDeclaration = function (tn, modifiers, decorators) {\r\n        // at 'type': Identifier '=' Type ';'?\r\n        if (modifiers === void 0) { modifiers = null; }\r\n        if (decorators === void 0) { decorators = null; }\r\n        var startPos = decorators && decorators.length ? decorators[0].range.start\r\n            : modifiers && modifiers.length ? modifiers[0].range.start\r\n                : tn.tokenPos;\r\n        if (tn.skip(tokenizer_1.Token.IDENTIFIER)) {\r\n            var name = ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n            if (tn.skip(tokenizer_1.Token.EQUALS)) {\r\n                var type = this.parseType(tn);\r\n                if (!type)\r\n                    return null;\r\n                var ret = ast_1.Node.createTypeDeclaration(name, type, modifiers, decorators, tn.range(startPos, tn.pos));\r\n                tn.skip(tokenizer_1.Token.SEMICOLON);\r\n                return ret;\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"=\");\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, tn.range());\r\n        }\r\n        return null;\r\n    };\r\n    Parser.prototype.parseWhileStatement = function (tn) {\r\n        // at 'while': '(' Expression ')' Statement ';'?\r\n        var startPos = tn.tokenPos;\r\n        if (tn.skip(tokenizer_1.Token.OPENPAREN)) {\r\n            var expression = this.parseExpression(tn);\r\n            if (!expression)\r\n                return null;\r\n            if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) {\r\n                var statement = this.parseStatement(tn);\r\n                if (!statement)\r\n                    return null;\r\n                var ret = ast_1.Node.createWhileStatement(expression, statement, tn.range(startPos, tn.pos));\r\n                tn.skip(tokenizer_1.Token.SEMICOLON);\r\n                return ret;\r\n            }\r\n            else {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \")\");\r\n            }\r\n        }\r\n        else {\r\n            this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"(\");\r\n        }\r\n        return null;\r\n    };\r\n    // expressions\r\n    // see: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing\r\n    Parser.prototype.parseExpressionStart = function (tn) {\r\n        var token = tn.next(true);\r\n        var startPos = tn.tokenPos;\r\n        var expr = null;\r\n        if (token == tokenizer_1.Token.NULL) {\r\n            return ast_1.Node.createNullExpression(tn.range());\r\n        }\r\n        if (token == tokenizer_1.Token.TRUE) {\r\n            return ast_1.Node.createTrueExpression(tn.range());\r\n        }\r\n        if (token == tokenizer_1.Token.FALSE) {\r\n            return ast_1.Node.createFalseExpression(tn.range());\r\n        }\r\n        var p = determinePrecedenceStart(token);\r\n        if (p != -1 /* INVALID */) {\r\n            var operand;\r\n            // TODO: SpreadExpression, YieldExpression (currently become unsupported UnaryPrefixExpressions)\r\n            // NewExpression\r\n            if (token == tokenizer_1.Token.NEW) {\r\n                operand = this.parseExpression(tn, 18 /* CALL */);\r\n                if (!operand)\r\n                    return null;\r\n                if (operand.kind == ast_1.NodeKind.CALL) {\r\n                    return ast_1.Node.createNewExpression(operand.expression, operand.typeArguments, operand.arguments, tn.range(startPos, tn.pos));\r\n                }\r\n                else {\r\n                    this.error(diagnostics_1.DiagnosticCode.Operation_not_supported, tn.range());\r\n                }\r\n                return null;\r\n            }\r\n            else {\r\n                operand = this.parseExpression(tn, p);\r\n                if (!operand)\r\n                    return null;\r\n            }\r\n            // UnaryPrefixExpression\r\n            if (token == tokenizer_1.Token.PLUS_PLUS || token == tokenizer_1.Token.MINUS_MINUS) {\r\n                if (operand.kind != ast_1.NodeKind.IDENTIFIER &&\r\n                    operand.kind != ast_1.NodeKind.ELEMENTACCESS &&\r\n                    operand.kind != ast_1.NodeKind.PROPERTYACCESS) {\r\n                    this.error(diagnostics_1.DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, operand.range);\r\n                }\r\n            }\r\n            return ast_1.Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\r\n        }\r\n        switch (token) {\r\n            // ParenthesizedExpression\r\n            // FunctionExpression\r\n            case tokenizer_1.Token.OPENPAREN:\r\n                // determine whether this is a function expression\r\n                if (tn.skip(tokenizer_1.Token.CLOSEPAREN)) {\r\n                    return this.parseFunctionExpressionCommon(tn, ast_1.Node.createIdentifierExpression(\"\", tn.range(startPos, startPos)), [], true);\r\n                }\r\n                tn.mark();\r\n                var again = true;\r\n                do {\r\n                    switch (tn.next(true)) {\r\n                        // function expression\r\n                        case tokenizer_1.Token.DOT_DOT_DOT:\r\n                            tn.reset();\r\n                            return this.parseFunctionExpression(tn);\r\n                        // can be both\r\n                        case tokenizer_1.Token.IDENTIFIER:\r\n                            tn.readIdentifier();\r\n                            switch (tn.next()) {\r\n                                // if we got here, check for arrow\r\n                                case tokenizer_1.Token.CLOSEPAREN:\r\n                                    if (!tn.skip(tokenizer_1.Token.EQUALS_GREATERTHAN)) {\r\n                                        again = false;\r\n                                        break;\r\n                                    }\r\n                                // fall-through\r\n                                // function expression\r\n                                case tokenizer_1.Token.QUESTION: // optional parameter\r\n                                case tokenizer_1.Token.COLON:// type annotation\r\n                                    tn.reset();\r\n                                    return this.parseFunctionExpression(tn);\r\n                                // can be both\r\n                                case tokenizer_1.Token.COMMA:\r\n                                    break; // continue\r\n                                // parenthesized expression\r\n                                // case Token.EQUALS:  // missing type annotation for simplicity\r\n                                default:\r\n                                    again = false;\r\n                                    break;\r\n                            }\r\n                            break;\r\n                        // parenthesized expression\r\n                        default:\r\n                            again = false;\r\n                            break;\r\n                    }\r\n                } while (again);\r\n                tn.reset();\r\n                // parse parenthesized\r\n                expr = this.parseExpression(tn);\r\n                if (!expr)\r\n                    return null;\r\n                if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \")\");\r\n                    return null;\r\n                }\r\n                return ast_1.Node.createParenthesizedExpression(expr, tn.range(startPos, tn.pos));\r\n            // ArrayLiteralExpression\r\n            case tokenizer_1.Token.OPENBRACKET:\r\n                var elementExpressions = new Array();\r\n                if (!tn.skip(tokenizer_1.Token.CLOSEBRACKET)) {\r\n                    do {\r\n                        if (tn.peek() == tokenizer_1.Token.COMMA) {\r\n                            expr = null; // omitted\r\n                        }\r\n                        else {\r\n                            expr = this.parseExpression(tn, 0 /* COMMA */ + 1);\r\n                            if (!expr)\r\n                                return null;\r\n                        }\r\n                        elementExpressions.push(expr);\r\n                        if (tn.peek() == tokenizer_1.Token.CLOSEBRACKET)\r\n                            break;\r\n                    } while (tn.skip(tokenizer_1.Token.COMMA));\r\n                    if (!tn.skip(tokenizer_1.Token.CLOSEBRACKET)) {\r\n                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"]\");\r\n                        return null;\r\n                    }\r\n                }\r\n                return ast_1.Node.createArrayLiteralExpression(elementExpressions, tn.range(startPos, tn.pos));\r\n            // AssertionExpression (unary prefix)\r\n            case tokenizer_1.Token.LESSTHAN:\r\n                var toType = this.parseType(tn);\r\n                if (!toType)\r\n                    return null;\r\n                if (!tn.skip(tokenizer_1.Token.GREATERTHAN)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \">\");\r\n                    return null;\r\n                }\r\n                expr = this.parseExpression(tn, 18 /* CALL */);\r\n                if (!expr)\r\n                    return null;\r\n                return ast_1.Node.createAssertionExpression(0 /* PREFIX */, expr, toType, tn.range(startPos, tn.pos));\r\n            case tokenizer_1.Token.IDENTIFIER:\r\n                return ast_1.Node.createIdentifierExpression(tn.readIdentifier(), tn.range(startPos, tn.pos));\r\n            case tokenizer_1.Token.THIS:\r\n                return ast_1.Node.createThisExpression(tn.range(startPos, tn.pos));\r\n            case tokenizer_1.Token.CONSTRUCTOR:\r\n                return ast_1.Node.createConstructorExpression(tn.range(startPos, tn.pos));\r\n            case tokenizer_1.Token.SUPER:\r\n                return ast_1.Node.createSuperExpression(tn.range(startPos, tn.pos));\r\n            case tokenizer_1.Token.STRINGLITERAL:\r\n                return ast_1.Node.createStringLiteralExpression(tn.readString(), tn.range(startPos, tn.pos));\r\n            case tokenizer_1.Token.INTEGERLITERAL:\r\n                return ast_1.Node.createIntegerLiteralExpression(tn.readInteger(), tn.range(startPos, tn.pos));\r\n            case tokenizer_1.Token.FLOATLITERAL:\r\n                return ast_1.Node.createFloatLiteralExpression(tn.readFloat(), tn.range(startPos, tn.pos));\r\n            // RegexpLiteralExpression\r\n            // note that this also continues on invalid ones so the surrounding AST remains intact\r\n            case tokenizer_1.Token.SLASH:\r\n                var regexpPattern = tn.readRegexpPattern(); // also reports\r\n                if (!tn.skip(tokenizer_1.Token.SLASH)) {\r\n                    this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"/\");\r\n                    return null;\r\n                }\r\n                return ast_1.Node.createRegexpLiteralExpression(regexpPattern, tn.readRegexpFlags(), // also reports\r\n                tn.range(startPos, tn.pos));\r\n            case tokenizer_1.Token.FUNCTION:\r\n                return this.parseFunctionExpression(tn);\r\n            default:\r\n                this.error(diagnostics_1.DiagnosticCode.Expression_expected, tn.range());\r\n                return null;\r\n        }\r\n    };\r\n    Parser.prototype.tryParseTypeArgumentsBeforeArguments = function (tn) {\r\n        // at '<': Type (',' Type)* '>' '('\r\n        tn.mark();\r\n        if (!tn.skip(tokenizer_1.Token.LESSTHAN))\r\n            return null;\r\n        var typeArguments = new Array();\r\n        do {\r\n            var type = this.parseType(tn, true, true);\r\n            if (!type) {\r\n                tn.reset();\r\n                return null;\r\n            }\r\n            typeArguments.push(type);\r\n        } while (tn.skip(tokenizer_1.Token.COMMA));\r\n        if (tn.skip(tokenizer_1.Token.GREATERTHAN) && tn.skip(tokenizer_1.Token.OPENPAREN)) {\r\n            return typeArguments;\r\n        }\r\n        tn.reset();\r\n        return null;\r\n    };\r\n    Parser.prototype.parseArguments = function (tn) {\r\n        // at '(': (Expression (',' Expression)*)? ')'\r\n        var args = new Array();\r\n        if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {\r\n            do {\r\n                var expr = this.parseExpression(tn, 0 /* COMMA */ + 1);\r\n                if (!expr)\r\n                    return null;\r\n                args.push(expr);\r\n            } while (tn.skip(tokenizer_1.Token.COMMA));\r\n            if (!tn.skip(tokenizer_1.Token.CLOSEPAREN)) {\r\n                this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \")\");\r\n                return null;\r\n            }\r\n        }\r\n        return args;\r\n    };\r\n    Parser.prototype.parseExpression = function (tn, precedence) {\r\n        if (precedence === void 0) { precedence = 0; }\r\n        var expr = this.parseExpressionStart(tn);\r\n        if (!expr)\r\n            return null;\r\n        var startPos = expr.range.start;\r\n        // CallExpression\r\n        var typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn); // skips '(' on success\r\n        // there might be better ways to distinguish a LESSTHAN from a CALL with type arguments\r\n        if (typeArguments || tn.skip(tokenizer_1.Token.OPENPAREN)) {\r\n            var args = this.parseArguments(tn);\r\n            if (!args)\r\n                return null;\r\n            expr = ast_1.Node.createCallExpression(expr, typeArguments, args, tn.range(startPos, tn.pos));\r\n        }\r\n        var token;\r\n        var next = null;\r\n        var nextPrecedence;\r\n        while ((nextPrecedence = determinePrecedence(token = tn.peek())) >= precedence) {\r\n            tn.next();\r\n            switch (token) {\r\n                // AssertionExpression\r\n                case tokenizer_1.Token.AS:\r\n                    var toType = this.parseType(tn);\r\n                    if (!toType)\r\n                        return null;\r\n                    expr = ast_1.Node.createAssertionExpression(1 /* AS */, expr, toType, tn.range(startPos, tn.pos));\r\n                    break;\r\n                // ElementAccessExpression\r\n                case tokenizer_1.Token.OPENBRACKET:\r\n                    next = this.parseExpression(tn);\r\n                    if (!next)\r\n                        return null;\r\n                    if (!tn.skip(tokenizer_1.Token.CLOSEBRACKET)) {\r\n                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \"]\");\r\n                        return null;\r\n                    }\r\n                    expr = ast_1.Node.createElementAccessExpression(expr, next, tn.range(startPos, tn.pos));\r\n                    break;\r\n                // UnaryPostfixExpression\r\n                case tokenizer_1.Token.PLUS_PLUS:\r\n                case tokenizer_1.Token.MINUS_MINUS:\r\n                    if (expr.kind != ast_1.NodeKind.IDENTIFIER &&\r\n                        expr.kind != ast_1.NodeKind.ELEMENTACCESS &&\r\n                        expr.kind != ast_1.NodeKind.PROPERTYACCESS) {\r\n                        this.error(diagnostics_1.DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access, expr.range);\r\n                    }\r\n                    expr = ast_1.Node.createUnaryPostfixExpression(token, expr, tn.range(startPos, tn.pos));\r\n                    break;\r\n                // TernaryExpression\r\n                case tokenizer_1.Token.QUESTION:\r\n                    var ifThen = this.parseExpression(tn);\r\n                    if (!ifThen)\r\n                        return null;\r\n                    if (!tn.skip(tokenizer_1.Token.COLON)) {\r\n                        this.error(diagnostics_1.DiagnosticCode._0_expected, tn.range(), \":\");\r\n                        return null;\r\n                    }\r\n                    var ifElse = this.parseExpression(tn);\r\n                    if (!ifElse)\r\n                        return null;\r\n                    expr = ast_1.Node.createTernaryExpression(expr, ifThen, ifElse, tn.range(startPos, tn.pos));\r\n                    break;\r\n                // CommaExpression\r\n                case tokenizer_1.Token.COMMA:\r\n                    var commaExprs = [expr];\r\n                    do {\r\n                        expr = this.parseExpression(tn, 0 /* COMMA */ + 1);\r\n                        if (!expr)\r\n                            return null;\r\n                        commaExprs.push(expr);\r\n                    } while (tn.skip(tokenizer_1.Token.COMMA));\r\n                    expr = ast_1.Node.createCommaExpression(commaExprs, tn.range(startPos, tn.pos));\r\n                    break;\r\n                default:\r\n                    next = this.parseExpression(tn, isRightAssociative(token)\r\n                        ? nextPrecedence\r\n                        : nextPrecedence + 1);\r\n                    if (!next)\r\n                        return null;\r\n                    // PropertyAccessExpression\r\n                    if (token == tokenizer_1.Token.DOT) {\r\n                        if (next.kind == ast_1.NodeKind.IDENTIFIER) {\r\n                            expr = ast_1.Node.createPropertyAccessExpression(expr, next, tn.range(startPos, tn.pos));\r\n                        }\r\n                        else if (next.kind == ast_1.NodeKind.CALL) {\r\n                            var propertyCall = next;\r\n                            if (propertyCall.expression.kind == ast_1.NodeKind.IDENTIFIER) {\r\n                                propertyCall.expression = ast_1.Node.createPropertyAccessExpression(expr, propertyCall.expression, tn.range(startPos, tn.pos));\r\n                            }\r\n                            else {\r\n                                this.error(diagnostics_1.DiagnosticCode.Identifier_expected, propertyCall.expression.range);\r\n                                return null;\r\n                            }\r\n                            expr = propertyCall;\r\n                        }\r\n                        else {\r\n                            this.error(diagnostics_1.DiagnosticCode.Identifier_expected, next.range);\r\n                            return null;\r\n                        }\r\n                        // BinaryExpression\r\n                    }\r\n                    else {\r\n                        expr = ast_1.Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        return expr;\r\n    };\r\n    return Parser;\r\n}(diagnostics_1.DiagnosticEmitter));\r\nexports.Parser = Parser;\r\n/** Operator precedence from least to largest. */\r\nvar Precedence;\r\n(function (Precedence) {\r\n    Precedence[Precedence[\"COMMA\"] = 0] = \"COMMA\";\r\n    Precedence[Precedence[\"SPREAD\"] = 1] = \"SPREAD\";\r\n    Precedence[Precedence[\"YIELD\"] = 2] = \"YIELD\";\r\n    Precedence[Precedence[\"ASSIGNMENT\"] = 3] = \"ASSIGNMENT\";\r\n    Precedence[Precedence[\"CONDITIONAL\"] = 4] = \"CONDITIONAL\";\r\n    Precedence[Precedence[\"LOGICAL_OR\"] = 5] = \"LOGICAL_OR\";\r\n    Precedence[Precedence[\"LOGICAL_AND\"] = 6] = \"LOGICAL_AND\";\r\n    Precedence[Precedence[\"BITWISE_OR\"] = 7] = \"BITWISE_OR\";\r\n    Precedence[Precedence[\"BITWISE_XOR\"] = 8] = \"BITWISE_XOR\";\r\n    Precedence[Precedence[\"BITWISE_AND\"] = 9] = \"BITWISE_AND\";\r\n    Precedence[Precedence[\"EQUALITY\"] = 10] = \"EQUALITY\";\r\n    Precedence[Precedence[\"RELATIONAL\"] = 11] = \"RELATIONAL\";\r\n    Precedence[Precedence[\"SHIFT\"] = 12] = \"SHIFT\";\r\n    Precedence[Precedence[\"ADDITIVE\"] = 13] = \"ADDITIVE\";\r\n    Precedence[Precedence[\"MULTIPLICATIVE\"] = 14] = \"MULTIPLICATIVE\";\r\n    Precedence[Precedence[\"EXPONENTIATED\"] = 15] = \"EXPONENTIATED\";\r\n    Precedence[Precedence[\"UNARY_PREFIX\"] = 16] = \"UNARY_PREFIX\";\r\n    Precedence[Precedence[\"UNARY_POSTFIX\"] = 17] = \"UNARY_POSTFIX\";\r\n    Precedence[Precedence[\"CALL\"] = 18] = \"CALL\";\r\n    Precedence[Precedence[\"MEMBERACCESS\"] = 19] = \"MEMBERACCESS\";\r\n    Precedence[Precedence[\"GROUPING\"] = 20] = \"GROUPING\";\r\n    Precedence[Precedence[\"INVALID\"] = -1] = \"INVALID\";\r\n})(Precedence = exports.Precedence || (exports.Precedence = {}));\r\n/** Determines the precedence of a starting token. */\r\nfunction determinePrecedenceStart(kind) {\r\n    switch (kind) {\r\n        case tokenizer_1.Token.DOT_DOT_DOT:\r\n            return 1 /* SPREAD */;\r\n        case tokenizer_1.Token.YIELD:\r\n            return 2 /* YIELD */;\r\n        case tokenizer_1.Token.EXCLAMATION:\r\n        case tokenizer_1.Token.TILDE:\r\n        case tokenizer_1.Token.PLUS:\r\n        case tokenizer_1.Token.MINUS:\r\n        case tokenizer_1.Token.PLUS_PLUS:\r\n        case tokenizer_1.Token.MINUS_MINUS:\r\n        case tokenizer_1.Token.TYPEOF:\r\n        case tokenizer_1.Token.VOID:\r\n        case tokenizer_1.Token.DELETE:\r\n            return 16 /* UNARY_PREFIX */;\r\n        case tokenizer_1.Token.NEW:\r\n            return 19 /* MEMBERACCESS */;\r\n        default:\r\n            return -1 /* INVALID */;\r\n    }\r\n}\r\n/** Determines the precende of a non-starting token. */\r\nfunction determinePrecedence(kind) {\r\n    switch (kind) {\r\n        case tokenizer_1.Token.COMMA:\r\n            return 0 /* COMMA */;\r\n        case tokenizer_1.Token.EQUALS:\r\n        case tokenizer_1.Token.PLUS_EQUALS:\r\n        case tokenizer_1.Token.MINUS_EQUALS:\r\n        case tokenizer_1.Token.ASTERISK_ASTERISK_EQUALS:\r\n        case tokenizer_1.Token.ASTERISK_EQUALS:\r\n        case tokenizer_1.Token.SLASH_EQUALS:\r\n        case tokenizer_1.Token.PERCENT_EQUALS:\r\n        case tokenizer_1.Token.LESSTHAN_LESSTHAN_EQUALS:\r\n        case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_EQUALS:\r\n        case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\r\n        case tokenizer_1.Token.AMPERSAND_EQUALS:\r\n        case tokenizer_1.Token.CARET_EQUALS:\r\n        case tokenizer_1.Token.BAR_EQUALS:\r\n            return 3 /* ASSIGNMENT */;\r\n        case tokenizer_1.Token.QUESTION:\r\n            return 4 /* CONDITIONAL */;\r\n        case tokenizer_1.Token.BAR_BAR:\r\n            return 5 /* LOGICAL_OR */;\r\n        case tokenizer_1.Token.AMPERSAND_AMPERSAND:\r\n            return 6 /* LOGICAL_AND */;\r\n        case tokenizer_1.Token.BAR:\r\n            return 7 /* BITWISE_OR */;\r\n        case tokenizer_1.Token.CARET:\r\n            return 8 /* BITWISE_XOR */;\r\n        case tokenizer_1.Token.AMPERSAND:\r\n            return 9 /* BITWISE_AND */;\r\n        case tokenizer_1.Token.EQUALS_EQUALS:\r\n        case tokenizer_1.Token.EXCLAMATION_EQUALS:\r\n        case tokenizer_1.Token.EQUALS_EQUALS_EQUALS:\r\n        case tokenizer_1.Token.EXCLAMATION_EQUALS_EQUALS:\r\n            return 10 /* EQUALITY */;\r\n        case tokenizer_1.Token.AS:\r\n        case tokenizer_1.Token.IN:\r\n        case tokenizer_1.Token.INSTANCEOF:\r\n        case tokenizer_1.Token.LESSTHAN:\r\n        case tokenizer_1.Token.GREATERTHAN:\r\n        case tokenizer_1.Token.LESSTHAN_EQUALS:\r\n        case tokenizer_1.Token.GREATERTHAN_EQUALS:\r\n            return 11 /* RELATIONAL */;\r\n        case tokenizer_1.Token.LESSTHAN_LESSTHAN:\r\n        case tokenizer_1.Token.GREATERTHAN_GREATERTHAN:\r\n        case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\r\n            return 12 /* SHIFT */;\r\n        case tokenizer_1.Token.PLUS:\r\n        case tokenizer_1.Token.MINUS:\r\n            return 13 /* ADDITIVE */;\r\n        case tokenizer_1.Token.ASTERISK:\r\n        case tokenizer_1.Token.SLASH:\r\n        case tokenizer_1.Token.PERCENT:\r\n            return 14 /* MULTIPLICATIVE */;\r\n        case tokenizer_1.Token.ASTERISK_ASTERISK:\r\n            return 15 /* EXPONENTIATED */;\r\n        case tokenizer_1.Token.PLUS_PLUS:\r\n        case tokenizer_1.Token.MINUS_MINUS:\r\n            return 17 /* UNARY_POSTFIX */;\r\n        case tokenizer_1.Token.DOT:\r\n        case tokenizer_1.Token.NEW:\r\n        case tokenizer_1.Token.OPENBRACKET:\r\n            return 19 /* MEMBERACCESS */;\r\n        default:\r\n            return -1 /* INVALID */;\r\n    }\r\n}\r\n/** Determines whether a non-starting token is right associative. */\r\nfunction isRightAssociative(kind) {\r\n    switch (kind) {\r\n        case tokenizer_1.Token.EQUALS:\r\n        case tokenizer_1.Token.PLUS_EQUALS:\r\n        case tokenizer_1.Token.MINUS_EQUALS:\r\n        case tokenizer_1.Token.ASTERISK_ASTERISK_EQUALS:\r\n        case tokenizer_1.Token.ASTERISK_EQUALS:\r\n        case tokenizer_1.Token.SLASH_EQUALS:\r\n        case tokenizer_1.Token.PERCENT_EQUALS:\r\n        case tokenizer_1.Token.LESSTHAN_LESSTHAN_EQUALS:\r\n        case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_EQUALS:\r\n        case tokenizer_1.Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\r\n        case tokenizer_1.Token.AMPERSAND_EQUALS:\r\n        case tokenizer_1.Token.CARET_EQUALS:\r\n        case tokenizer_1.Token.BAR_EQUALS:\r\n        case tokenizer_1.Token.QUESTION:\r\n        case tokenizer_1.Token.ASTERISK_ASTERISK:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// assemblyscript.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2814b8b5f549cb891410","import {\r\n  Target\r\n} from \"./compiler\";\r\n\r\nexport type ModuleRef = usize;\r\nexport type FunctionTypeRef = usize;\r\nexport type FunctionRef = usize;\r\nexport type ExpressionRef = usize;\r\nexport type GlobalRef = usize;\r\nexport type ImportRef = usize;\r\nexport type ExportRef = usize;\r\nexport type Index = u32;\r\n\r\nexport enum NativeType {\r\n  None = _BinaryenTypeNone(),\r\n  I32 = _BinaryenTypeInt32(),\r\n  I64 = _BinaryenTypeInt64(),\r\n  F32 = _BinaryenTypeFloat32(),\r\n  F64 =  _BinaryenTypeFloat64(),\r\n  Unreachable = _BinaryenTypeUnreachable(),\r\n  Auto = _BinaryenTypeAuto()\r\n}\r\n\r\nexport enum ExpressionId {\r\n  Invalid = _BinaryenInvalidId(),\r\n  Block = _BinaryenBlockId(),\r\n  If = _BinaryenIfId(),\r\n  Loop = _BinaryenLoopId(),\r\n  Break = _BinaryenBreakId(),\r\n  Switch = _BinaryenSwitchId(),\r\n  Call = _BinaryenCallId(),\r\n  CallImport = _BinaryenCallImportId(),\r\n  CallIndirect = _BinaryenCallIndirectId(),\r\n  GetLocal = _BinaryenGetLocalId(),\r\n  SetLocal = _BinaryenSetLocalId(),\r\n  GetGlobal = _BinaryenGetGlobalId(),\r\n  SetGlobal = _BinaryenSetGlobalId(),\r\n  Load = _BinaryenLoadId(),\r\n  Store = _BinaryenStoreId(),\r\n  Const = _BinaryenConstId(),\r\n  Unary = _BinaryenUnaryId(),\r\n  Binary = _BinaryenBinaryId(),\r\n  Select = _BinaryenSelectId(),\r\n  Drop = _BinaryenDropId(),\r\n  Return = _BinaryenReturnId(),\r\n  Host = _BinaryenHostId(),\r\n  Nop = _BinaryenNopId(),\r\n  Unreachable = _BinaryenUnreachableId(),\r\n  AtomicCmpxchg = _BinaryenAtomicCmpxchgId(),\r\n  AtomicRMW = _BinaryenAtomicRMWId(),\r\n  AtomicWait = _BinaryenAtomicWaitId(),\r\n  AtomicWake = _BinaryenAtomicWakeId()\r\n}\r\n\r\nexport enum UnaryOp {\r\n  ClzI32 = _BinaryenClzInt32(),\r\n  CtzI32 = _BinaryenCtzInt32(),\r\n  PopcntI32 = _BinaryenPopcntInt32(),\r\n  NegF32 = _BinaryenNegFloat32(),\r\n  AbsF32 = _BinaryenAbsFloat32(),\r\n  CeilF32 = _BinaryenCeilFloat32(),\r\n  FloorF32 = _BinaryenFloorFloat32(),\r\n  TruncF32 = _BinaryenTruncFloat32(),\r\n  NearestF32 = _BinaryenNearestFloat32(),\r\n  SqrtF32 = _BinaryenSqrtFloat32(),\r\n  EqzI32 = _BinaryenEqZInt32(),\r\n  ClzI64 = _BinaryenClzInt64(),\r\n  CtzI64 = _BinaryenCtzInt64(),\r\n  PopcntI64 = _BinaryenPopcntInt64(),\r\n  NegF64 = _BinaryenNegFloat64(),\r\n  AbsF64 = _BinaryenAbsFloat64(),\r\n  CeilF64 = _BinaryenCeilFloat64(),\r\n  FloorF64 = _BinaryenFloorFloat64(),\r\n  TruncF64 = _BinaryenTruncFloat64(),\r\n  NearestF64 = _BinaryenNearestFloat64(),\r\n  SqrtF64 = _BinaryenSqrtFloat64(),\r\n  EqzI64 = _BinaryenEqZInt64(),\r\n  ExtendI32 = _BinaryenExtendSInt32(),\r\n  ExtendU32 = _BinaryenExtendUInt32(),\r\n  WrapI64 = _BinaryenWrapInt64(),\r\n  TruncF32ToI32 = _BinaryenTruncSFloat32ToInt32(),\r\n  TruncF32ToI64 = _BinaryenTruncSFloat32ToInt64(),\r\n  TruncF32ToU32 = _BinaryenTruncUFloat32ToInt32(),\r\n  TruncF32ToU64 = _BinaryenTruncUFloat32ToInt64(),\r\n  TruncF64ToI32 = _BinaryenTruncSFloat64ToInt32(),\r\n  TruncF64ToI64 = _BinaryenTruncSFloat64ToInt64(),\r\n  TruncF64ToU32 = _BinaryenTruncUFloat64ToInt32(),\r\n  TruncF64ToU64 = _BinaryenTruncUFloat64ToInt64(),\r\n  ReinterpretF32 = _BinaryenReinterpretFloat32(),\r\n  ReinterpretF64 = _BinaryenReinterpretFloat64(),\r\n  ConvertI32ToF32 = _BinaryenConvertSInt32ToFloat32(),\r\n  ConvertI32ToF64 = _BinaryenConvertSInt32ToFloat64(),\r\n  ConvertU32ToF32 = _BinaryenConvertUInt32ToFloat32(),\r\n  ConvertU32ToF64 = _BinaryenConvertUInt32ToFloat64(),\r\n  ConvertI64ToF32 = _BinaryenConvertSInt64ToFloat32(),\r\n  ConvertI64ToF64 = _BinaryenConvertSInt64ToFloat64(),\r\n  ConvertU64ToF32 = _BinaryenConvertUInt64ToFloat32(),\r\n  ConvertU64ToF64 = _BinaryenConvertUInt64ToFloat64(),\r\n  PromoteF32 = _BinaryenPromoteFloat32(),\r\n  DemoteF64 = _BinaryenDemoteFloat64(),\r\n  ReinterpretI32 = _BinaryenReinterpretInt32(),\r\n  ReinterpretI64 = _BinaryenReinterpretInt64()\r\n\r\n  // see: https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md#new-sign-extending-operators\r\n  // ExtendI8ToI32 =_BinaryenExtendS8Int32()\r\n  // ExtendI16ToI32 = _BinaryenExtendS16Int32()\r\n  // ExtendI8ToI64 = _BinaryenExtendS8Int64() // operand is I64\r\n  // ExtendI16ToI64 = _BinaryenExtendS16Int64()\r\n  // ExtendI32ToI64 = _BinaryenExtendS32Int64()\r\n\r\n  // see: https://github.com/WebAssembly/nontrapping-float-to-int-conversions\r\n  // TruncF32ToI32Sat\r\n  // TruncF32ToU32Sat\r\n  // TruncF64ToI32Sat\r\n  // TruncF64ToU32Sat\r\n  // TruncF32ToI64Sat\r\n  // TruncF32ToU64Sat\r\n  // TruncF64ToI64Sat\r\n  // TruncF64ToU64Sat\r\n}\r\n\r\nexport enum BinaryOp {\r\n  AddI32 = _BinaryenAddInt32(),\r\n  SubI32 = _BinaryenSubInt32(),\r\n  MulI32 = _BinaryenMulInt32(),\r\n  DivI32 = _BinaryenDivSInt32(),\r\n  DivU32 = _BinaryenDivUInt32(),\r\n  RemI32 = _BinaryenRemSInt32(),\r\n  RemU32 = _BinaryenRemUInt32(),\r\n  AndI32 = _BinaryenAndInt32(),\r\n  OrI32 = _BinaryenOrInt32(),\r\n  XorI32 = _BinaryenXorInt32(),\r\n  ShlI32 = _BinaryenShlInt32(),\r\n  ShrU32 = _BinaryenShrUInt32(),\r\n  ShrI32 = _BinaryenShrSInt32(),\r\n  RotlI32 = _BinaryenRotLInt32(),\r\n  RotrI32 = _BinaryenRotRInt32(),\r\n  EqI32 = _BinaryenEqInt32(),\r\n  NeI32 = _BinaryenNeInt32(),\r\n  LtI32 = _BinaryenLtSInt32(),\r\n  LtU32 = _BinaryenLtUInt32(),\r\n  LeI32 = _BinaryenLeSInt32(),\r\n  LeU32 = _BinaryenLeUInt32(),\r\n  GtI32 = _BinaryenGtSInt32(),\r\n  GtU32 = _BinaryenGtUInt32(),\r\n  GeI32 = _BinaryenGeSInt32(),\r\n  GeU32 = _BinaryenGeUInt32(),\r\n  AddI64 = _BinaryenAddInt64(),\r\n  SubI64 = _BinaryenSubInt64(),\r\n  MulI64 = _BinaryenMulInt64(),\r\n  DivI64 = _BinaryenDivSInt64(),\r\n  DivU64 = _BinaryenDivUInt64(),\r\n  RemI64 = _BinaryenRemSInt64(),\r\n  RemU64 = _BinaryenRemUInt64(),\r\n  AndI64 = _BinaryenAndInt64(),\r\n  OrI64 = _BinaryenOrInt64(),\r\n  XorI64 = _BinaryenXorInt64(),\r\n  ShlI64 = _BinaryenShlInt64(),\r\n  ShrU64 = _BinaryenShrUInt64(),\r\n  ShrI64 = _BinaryenShrSInt64(),\r\n  RotlI64 = _BinaryenRotLInt64(),\r\n  RotrI64 = _BinaryenRotRInt64(),\r\n  EqI64 = _BinaryenEqInt64(),\r\n  NeI64 = _BinaryenNeInt64(),\r\n  LtI64 = _BinaryenLtSInt64(),\r\n  LtU64 = _BinaryenLtUInt64(),\r\n  LeI64 = _BinaryenLeSInt64(),\r\n  LeU64 = _BinaryenLeUInt64(),\r\n  GtI64 = _BinaryenGtSInt64(),\r\n  GtU64 = _BinaryenGtUInt64(),\r\n  GeI64 = _BinaryenGeSInt64(),\r\n  GeU64 = _BinaryenGeUInt64(),\r\n  AddF32 = _BinaryenAddFloat32(),\r\n  SubF32 = _BinaryenSubFloat32(),\r\n  MulF32 = _BinaryenMulFloat32(),\r\n  DivF32 = _BinaryenDivFloat32(),\r\n  CopysignF32 = _BinaryenCopySignFloat32(),\r\n  MinF32 = _BinaryenMinFloat32(),\r\n  MaxF32 = _BinaryenMaxFloat32(),\r\n  EqF32 = _BinaryenEqFloat32(),\r\n  NeF32 = _BinaryenNeFloat32(),\r\n  LtF32 = _BinaryenLtFloat32(),\r\n  LeF32 = _BinaryenLeFloat32(),\r\n  GtF32 = _BinaryenGtFloat32(),\r\n  GeF32 = _BinaryenGeFloat32(),\r\n  AddF64 = _BinaryenAddFloat64(),\r\n  SubF64 = _BinaryenSubFloat64(),\r\n  MulF64 = _BinaryenMulFloat64(),\r\n  DivF64 = _BinaryenDivFloat64(),\r\n  CopysignF64 = _BinaryenCopySignFloat64(),\r\n  MinF64 = _BinaryenMinFloat64(),\r\n  MaxF64 = _BinaryenMaxFloat64(),\r\n  EqF64 = _BinaryenEqFloat64(),\r\n  NeF64 = _BinaryenNeFloat64(),\r\n  LtF64 = _BinaryenLtFloat64(),\r\n  LeF64 = _BinaryenLeFloat64(),\r\n  GtF64 = _BinaryenGtFloat64(),\r\n  GeF64 = _BinaryenGeFloat64()\r\n}\r\n\r\nexport enum HostOp {\r\n  PageSize = _BinaryenPageSize(),\r\n  CurrentMemory = _BinaryenCurrentMemory(),\r\n  GrowMemory = _BinaryenGrowMemory(),\r\n  HasFeature = _BinaryenHasFeature(),\r\n\r\n  // see: https://github.com/WebAssembly/bulk-memory-operations\r\n  // MoveMemory\r\n  // SetMemory\r\n}\r\n\r\nexport enum AtomicRMWOp {\r\n  Add = _BinaryenAtomicRMWAdd(),\r\n  Sub = _BinaryenAtomicRMWSub(),\r\n  And = _BinaryenAtomicRMWAnd(),\r\n  Or = _BinaryenAtomicRMWOr(),\r\n  Xor = _BinaryenAtomicRMWXor(),\r\n  Xchg = _BinaryenAtomicRMWXchg()\r\n}\r\n\r\nexport class MemorySegment {\r\n\r\n  buffer: Uint8Array;\r\n  offset: I64;\r\n\r\n  static create(buffer: Uint8Array, offset: I64) {\r\n    var segment = new MemorySegment();\r\n    segment.buffer = buffer;\r\n    segment.offset = offset;\r\n    return segment;\r\n  }\r\n}\r\n\r\nexport class Module {\r\n\r\n  ref: ModuleRef;\r\n  out: usize;\r\n\r\n  static readonly MAX_MEMORY_WASM32: Index = 0xffff;\r\n  // TODO: static readonly MAX_MEMORY_WASM64\r\n\r\n  static create(): Module {\r\n    var module = new Module();\r\n    module.ref = _BinaryenModuleCreate();\r\n    module.out = allocate_memory(16);\r\n    return module;\r\n  }\r\n\r\n  static createFrom(buffer: Uint8Array): Module {\r\n    var cArr = allocU8Array(buffer);\r\n    try {\r\n      var module = new Module();\r\n      module.ref = _BinaryenModuleRead(cArr, buffer.length);\r\n      module.out = allocate_memory(3 * 8); // LLVM C-ABI, max used is 3 * usize\r\n       return module;\r\n    } finally {\r\n      free_memory(changetype<usize>(cArr));\r\n    }\r\n  }\r\n\r\n  private constructor() { }\r\n\r\n  // types\r\n\r\n  addFunctionType(\r\n    name: string,\r\n    result: NativeType,\r\n    paramTypes: NativeType[]\r\n  ): FunctionRef {\r\n    var cStr = allocString(name);\r\n    var cArr = allocI32Array(paramTypes);\r\n    try {\r\n      return _BinaryenAddFunctionType(this.ref, cStr, result, cArr, paramTypes.length);\r\n    } finally {\r\n      free_memory(cArr);\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  getFunctionTypeBySignature(\r\n    result: NativeType,\r\n    paramTypes: NativeType[]\r\n  ): FunctionTypeRef {\r\n    var cArr = allocI32Array(paramTypes);\r\n    try {\r\n      return _BinaryenGetFunctionTypeBySignature(this.ref, result, cArr, paramTypes.length);\r\n    } finally {\r\n      free_memory(cArr);\r\n    }\r\n  }\r\n\r\n  // constants\r\n\r\n  createI32(value: i32): ExpressionRef {\r\n    var out = this.out;\r\n    _BinaryenLiteralInt32(out, value);\r\n    return _BinaryenConst(this.ref, out);\r\n  }\r\n\r\n  createI64(valueLow: i32, valueHigh: i32 = 0): ExpressionRef {\r\n    var out = this.out;\r\n    _BinaryenLiteralInt64(out, valueLow, valueHigh);\r\n    return _BinaryenConst(this.ref, out);\r\n  }\r\n\r\n  createF32(value: f32): ExpressionRef {\r\n    var out = this.out;\r\n    _BinaryenLiteralFloat32(out, value);\r\n    return _BinaryenConst(this.ref, out);\r\n  }\r\n\r\n  createF64(value: f64): ExpressionRef {\r\n    var out = this.out;\r\n    _BinaryenLiteralFloat64(out, value);\r\n    return _BinaryenConst(this.ref, out);\r\n  }\r\n\r\n  // expressions\r\n\r\n  createUnary(\r\n    op: UnaryOp,\r\n    expr: ExpressionRef\r\n  ): ExpressionRef {\r\n    return _BinaryenUnary(this.ref, op, expr);\r\n  }\r\n\r\n  createBinary(\r\n    op: BinaryOp,\r\n    left: ExpressionRef,\r\n    right: ExpressionRef\r\n  ): ExpressionRef {\r\n    return _BinaryenBinary(this.ref, op, left, right);\r\n  }\r\n\r\n  createHost(\r\n    op: HostOp,\r\n    name: string | null = null,\r\n    operands: ExpressionRef[] | null = null\r\n  ): ExpressionRef {\r\n    var cStr = allocString(name);\r\n    var cArr = allocI32Array(operands);\r\n    try {\r\n      return _BinaryenHost(this.ref, op, cStr, cArr, operands ? (<ExpressionRef[]>operands).length : 0);\r\n    } finally {\r\n      free_memory(cArr);\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  createGetLocal(\r\n    index: i32,\r\n    type: NativeType\r\n  ): ExpressionRef {\r\n    return _BinaryenGetLocal(this.ref, index, type);\r\n  }\r\n\r\n  createTeeLocal(\r\n    index: i32,\r\n    value: ExpressionRef\r\n  ): ExpressionRef {\r\n    return _BinaryenTeeLocal(this.ref, index, value);\r\n  }\r\n\r\n  createGetGlobal(\r\n    name: string,\r\n    type: NativeType\r\n  ): ExpressionRef {\r\n    var cStr = allocString(name);\r\n    try {\r\n      return _BinaryenGetGlobal(this.ref, cStr, type);\r\n    } finally {\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  createLoad(\r\n    bytes: Index,\r\n    signed: bool,\r\n    ptr: ExpressionRef,\r\n    type: NativeType,\r\n    offset: Index = 0\r\n  ): ExpressionRef {\r\n    return _BinaryenLoad(this.ref, bytes, signed ? 1 : 0, offset, /* always aligned */ bytes, type, ptr);\r\n  }\r\n\r\n  createStore(\r\n    bytes: Index,\r\n    ptr: ExpressionRef,\r\n    value: ExpressionRef,\r\n    type: NativeType,\r\n    offset: Index = 0\r\n  ): ExpressionRef {\r\n    return _BinaryenStore(this.ref, bytes, offset, /* always aligned */ bytes, ptr, value, type);\r\n  }\r\n\r\n  createAtomicLoad(\r\n    bytes: Index,\r\n    ptr: ExpressionRef,\r\n    type: NativeType,\r\n    offset: Index = 0\r\n  ): ExpressionRef {\r\n    return _BinaryenAtomicLoad(this.ref, bytes, offset, type, ptr);\r\n  }\r\n\r\n  createAtomicStore(\r\n    bytes: Index,\r\n    ptr: ExpressionRef,\r\n    value: ExpressionRef,\r\n    type: NativeType,\r\n    offset: Index = 0\r\n  ): ExpressionRef {\r\n    return _BinaryenAtomicStore(this.ref, bytes, offset, ptr, value, type);\r\n  }\r\n\r\n  createAtomicRMW(\r\n    op: AtomicRMWOp,\r\n    bytes: Index,\r\n    offset: Index,\r\n    ptr: ExpressionRef,\r\n    value: ExpressionRef,\r\n    type: NativeType\r\n  ): ExpressionRef {\r\n    return _BinaryenAtomicRMW(this.ref, op, bytes, offset, ptr, value, type);\r\n  }\r\n\r\n  createAtomicCmpxchg(\r\n    bytes: Index,\r\n    offset: Index,\r\n    ptr: ExpressionRef,\r\n    expected: ExpressionRef,\r\n    replacement: ExpressionRef,\r\n    type: NativeType\r\n  ): ExpressionRef {\r\n    return _BinaryenAtomicCmpxchg(this.ref, bytes, offset, ptr, expected, replacement, type);\r\n  }\r\n\r\n  createAtomicWait(\r\n    ptr: ExpressionRef,\r\n    expected: ExpressionRef,\r\n    timeout: ExpressionRef,\r\n    expectedType: NativeType\r\n  ): ExpressionRef {\r\n    return _BinaryenAtomicWait(this.ref, ptr, expected, timeout, expectedType);\r\n  }\r\n\r\n  createAtomicWake(\r\n    ptr: ExpressionRef,\r\n    wakeCount: ExpressionRef\r\n  ): ExpressionRef {\r\n    return _BinaryenAtomicWake(this.ref, ptr, wakeCount);\r\n  }\r\n\r\n  // statements\r\n\r\n  createSetLocal(\r\n    index: Index,\r\n    value: ExpressionRef\r\n  ): ExpressionRef {\r\n    return _BinaryenSetLocal(this.ref, index, value);\r\n  }\r\n\r\n  createSetGlobal(\r\n    name: string,\r\n    value: ExpressionRef\r\n  ): ExpressionRef {\r\n    var cStr = allocString(name);\r\n    try {\r\n      return _BinaryenSetGlobal(this.ref, cStr, value);\r\n    } finally {\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  createBlock(\r\n    label: string | null,\r\n    children: ExpressionRef[],\r\n    type: NativeType = NativeType.None\r\n  ): ExpressionRef {\r\n    var cStr = allocString(label);\r\n    var cArr = allocI32Array(children);\r\n    try {\r\n      return _BinaryenBlock(this.ref, cStr, cArr, children.length, type);\r\n    } finally {\r\n      free_memory(cArr);\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  createBreak(\r\n    label: string | null,\r\n    condition: ExpressionRef = 0,\r\n    value: ExpressionRef = 0\r\n  ): ExpressionRef {\r\n    var cStr = allocString(label);\r\n    try {\r\n      return _BinaryenBreak(this.ref, cStr, condition, value);\r\n    } finally {\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  createDrop(\r\n    expression: ExpressionRef\r\n  ): ExpressionRef {\r\n    return _BinaryenDrop(this.ref, expression);\r\n  }\r\n\r\n  createLoop(\r\n    label: string | null,\r\n    body: ExpressionRef\r\n  ): ExpressionRef {\r\n    var cStr = allocString(label);\r\n    try {\r\n      return _BinaryenLoop(this.ref, cStr, body);\r\n    } finally {\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  createIf(\r\n    condition: ExpressionRef,\r\n    ifTrue: ExpressionRef,\r\n    ifFalse: ExpressionRef = 0\r\n  ): ExpressionRef {\r\n    return _BinaryenIf(this.ref, condition, ifTrue, ifFalse);\r\n  }\r\n\r\n  createNop(): ExpressionRef {\r\n    return _BinaryenNop(this.ref);\r\n  }\r\n\r\n  createReturn(\r\n    expression: ExpressionRef = 0\r\n  ): ExpressionRef {\r\n    return _BinaryenReturn(this.ref, expression);\r\n  }\r\n\r\n  createSelect(\r\n    ifTrue: ExpressionRef,\r\n    ifFalse: ExpressionRef,\r\n    condition: ExpressionRef\r\n  ): ExpressionRef {\r\n    return _BinaryenSelect(this.ref, condition, ifTrue, ifFalse);\r\n  }\r\n\r\n  createSwitch(\r\n    names: string[],\r\n    defaultName: string | null,\r\n    condition: ExpressionRef,\r\n    value: ExpressionRef = 0\r\n  ): ExpressionRef {\r\n    var strs = new Array<usize>(names.length);\r\n    for (var i = 0, k: i32 = names.length; i < k; ++i) {\r\n      strs[i] = allocString(names[i]);\r\n    }\r\n    var cArr = allocI32Array(strs);\r\n    var cStr = allocString(defaultName);\r\n    try {\r\n      return _BinaryenSwitch(this.ref, cArr, k, cStr, condition, value);\r\n    } finally {\r\n      free_memory(cStr);\r\n      free_memory(cArr);\r\n      for (i = k - 1; i >= 0; --i) free_memory(strs[i]);\r\n    }\r\n  }\r\n\r\n  createCall(\r\n    target: string,\r\n    operands: ExpressionRef[] | null,\r\n    returnType: NativeType\r\n  ): ExpressionRef {\r\n    var cStr = allocString(target);\r\n    var cArr = allocI32Array(operands);\r\n    try {\r\n      return _BinaryenCall(this.ref, cStr, cArr, operands && operands.length || 0, returnType);\r\n    } finally {\r\n      free_memory(cArr);\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  createCallImport(\r\n    target: string,\r\n    operands: ExpressionRef[] | null,\r\n    returnType: NativeType\r\n  ): ExpressionRef {\r\n    var cStr = allocString(target);\r\n    var cArr = allocI32Array(operands);\r\n    try {\r\n      return _BinaryenCallImport(this.ref, cStr, cArr, operands && operands.length || 0, returnType);\r\n    } finally {\r\n      free_memory(cArr);\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  createUnreachable(): ExpressionRef {\r\n    return _BinaryenUnreachable(this.ref);\r\n  }\r\n\r\n  // meta\r\n\r\n  addGlobal(\r\n    name: string,\r\n    type: NativeType,\r\n    mutable: bool,\r\n    initializer: ExpressionRef\r\n  ): GlobalRef {\r\n    var cStr = allocString(name);\r\n    try {\r\n      return _BinaryenAddGlobal(this.ref, cStr, type, mutable ? 1 : 0, initializer);\r\n    } finally {\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  addFunction(\r\n    name: string,\r\n    type: FunctionTypeRef,\r\n    varTypes: NativeType[],\r\n    body: ExpressionRef\r\n  ): FunctionRef {\r\n    var cStr = allocString(name);\r\n    var cArr = allocI32Array(varTypes);\r\n    try {\r\n      return _BinaryenAddFunction(this.ref, cStr, type, cArr, varTypes.length, body);\r\n    } finally {\r\n      free_memory(cArr);\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  removeFunction(name: string): void {\r\n    var cStr = allocString(name);\r\n    try {\r\n      _BinaryenRemoveFunction(this.ref, cStr);\r\n    } finally {\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  addFunctionExport(\r\n    internalName: string,\r\n    externalName: string\r\n  ): ExportRef {\r\n    var cStr1 = allocString(internalName);\r\n    var cStr2 = allocString(externalName);\r\n    try {\r\n      return _BinaryenAddFunctionExport(this.ref, cStr1, cStr2);\r\n    } finally {\r\n      free_memory(cStr2);\r\n      free_memory(cStr1);\r\n    }\r\n  }\r\n\r\n  addTableExport(\r\n    internalName: string,\r\n    externalName: string\r\n  ): ExportRef {\r\n    var cStr1 = allocString(internalName);\r\n    var cStr2 = allocString(externalName);\r\n    try {\r\n      return _BinaryenAddTableExport(this.ref, cStr1, cStr2);\r\n    } finally {\r\n      free_memory(cStr2);\r\n      free_memory(cStr1);\r\n    }\r\n  }\r\n\r\n  addMemoryExport(\r\n    internalName: string,\r\n    externalName: string\r\n  ): ExportRef {\r\n    var cStr1 = allocString(internalName);\r\n    var cStr2 = allocString(externalName);\r\n    try {\r\n      return _BinaryenAddMemoryExport(this.ref, cStr1, cStr2);\r\n    } finally {\r\n      free_memory(cStr2);\r\n      free_memory(cStr1);\r\n    }\r\n  }\r\n\r\n  addGlobalExport(\r\n    internalName: string,\r\n    externalName: string\r\n  ): ExportRef {\r\n    var cStr1 = allocString(internalName);\r\n    var cStr2 = allocString(externalName);\r\n    try {\r\n      return _BinaryenAddGlobalExport(this.ref, cStr1, cStr2);\r\n    } finally {\r\n      free_memory(cStr2);\r\n      free_memory(cStr1);\r\n    }\r\n  }\r\n\r\n  removeExport(externalName: string): void {\r\n    var cStr = allocString(externalName);\r\n    try {\r\n      _BinaryenRemoveExport(this.ref, cStr);\r\n    } finally {\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  addFunctionImport(\r\n    internalName: string,\r\n    externalModuleName: string,\r\n    externalBaseName: string,\r\n    functionType: FunctionTypeRef\r\n  ): ImportRef {\r\n    var cStr1 = allocString(internalName);\r\n    var cStr2 = allocString(externalModuleName);\r\n    var cStr3 = allocString(externalBaseName);\r\n    try {\r\n      return _BinaryenAddFunctionImport(this.ref, cStr1, cStr2, cStr3, functionType);\r\n    } finally {\r\n      free_memory(cStr3);\r\n      free_memory(cStr2);\r\n      free_memory(cStr1);\r\n    }\r\n  }\r\n\r\n  addTableImport(\r\n    internalName: string,\r\n    externalModuleName: string,\r\n    externalBaseName: string\r\n  ): ImportRef {\r\n    var cStr1 = allocString(internalName);\r\n    var cStr2 = allocString(externalModuleName);\r\n    var cStr3 = allocString(externalBaseName);\r\n    try {\r\n      return _BinaryenAddTableImport(this.ref, cStr1, cStr2, cStr3);\r\n    } finally {\r\n      free_memory(cStr3);\r\n      free_memory(cStr2);\r\n      free_memory(cStr1);\r\n    }\r\n  }\r\n\r\n  addMemoryImport(\r\n    internalName: string,\r\n    externalModuleName: string,\r\n    externalBaseName: string\r\n  ): ImportRef {\r\n    var cStr1 = allocString(internalName);\r\n    var cStr2 = allocString(externalModuleName);\r\n    var cStr3 = allocString(externalBaseName);\r\n    try {\r\n      return _BinaryenAddMemoryImport(this.ref, cStr1, cStr2, cStr3);\r\n    } finally {\r\n      free_memory(cStr3);\r\n      free_memory(cStr2);\r\n      free_memory(cStr1);\r\n    }\r\n  }\r\n\r\n  addGlobalImport(\r\n    internalName: string,\r\n    externalModuleName: string,\r\n    externalBaseName: string,\r\n    globalType: NativeType\r\n  ): ImportRef {\r\n    var cStr1 = allocString(internalName);\r\n    var cStr2 = allocString(externalModuleName);\r\n    var cStr3 = allocString(externalBaseName);\r\n    try {\r\n      return _BinaryenAddGlobalImport(this.ref, cStr1, cStr2, cStr3, globalType);\r\n    } finally {\r\n      free_memory(cStr3);\r\n      free_memory(cStr2);\r\n      free_memory(cStr1);\r\n    }\r\n  }\r\n\r\n  removeImport(internalName: string): void {\r\n    var cStr = allocString(internalName);\r\n    try {\r\n      _BinaryenRemoveImport(this.ref, cStr);\r\n    } finally {\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  setMemory(\r\n    initial: Index,\r\n    maximum: Index,\r\n    segments: MemorySegment[],\r\n    target: Target,\r\n    exportName: string | null = null\r\n  ): void {\r\n    var cStr = allocString(exportName);\r\n    var k = segments.length;\r\n    var segs = new Array<usize>(k);\r\n    var offs = new Array<ExpressionRef>(k);\r\n    var sizs = new Array<Index>(k);\r\n    for (var i = 0; i < k; ++i) {\r\n      var buffer = segments[i].buffer;\r\n      var offset = segments[i].offset;\r\n      segs[i] = allocU8Array(buffer);\r\n      offs[i] = target == Target.WASM64\r\n        ? this.createI64(i64_low(offset), i64_high(offset))\r\n        : this.createI32(i64_low(offset));\r\n      sizs[i] = buffer.length;\r\n    }\r\n    var cArr1 = allocI32Array(segs);\r\n    var cArr2 = allocI32Array(offs);\r\n    var cArr3 = allocI32Array(sizs);\r\n    try {\r\n      _BinaryenSetMemory(this.ref, initial, maximum, cStr, cArr1, cArr2, cArr3, k);\r\n    } finally {\r\n      free_memory(cArr3);\r\n      free_memory(cArr2);\r\n      free_memory(cArr1);\r\n      for (i = k - 1; i >= 0; --i) free_memory(segs[i]);\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  setFunctionTable(funcs: FunctionRef[]): void {\r\n    var cArr = allocI32Array(funcs);\r\n    try {\r\n      _BinaryenSetFunctionTable(this.ref, cArr, funcs.length);\r\n    } finally {\r\n      free_memory(cArr);\r\n    }\r\n  }\r\n\r\n  setStart(func: FunctionRef): void {\r\n    _BinaryenSetStart(this.ref, func);\r\n  }\r\n\r\n  setOptimizeLevel(level: i32 = 2): void {\r\n    _BinaryenSetOptimizeLevel(level);\r\n  }\r\n\r\n  setShrinkLevel(level: i32 = 1): void {\r\n    _BinaryenSetShrinkLevel(level);\r\n  }\r\n\r\n  setDebugInfo(on: bool = false): void {\r\n    _BinaryenSetDebugInfo(on);\r\n  }\r\n\r\n  optimize(func: FunctionRef = 0): void {\r\n    if (func) {\r\n      _BinaryenFunctionOptimize(func, this.ref);\r\n    } else {\r\n      _BinaryenModuleOptimize(this.ref);\r\n    }\r\n  }\r\n\r\n  runPasses(passes: string[], func: FunctionRef = 0): void {\r\n    var k = passes.length;\r\n    var names = new Array<usize>(k);\r\n    for (var i = 0; i < k; ++i) {\r\n      names[i] = allocString(passes[i]);\r\n    }\r\n    var cArr = allocI32Array(names);\r\n    try {\r\n      if (func) {\r\n        _BinaryenFunctionRunPasses(func, this.ref, cArr, k);\r\n      } else {\r\n        _BinaryenModuleRunPasses(this.ref, cArr, k);\r\n      }\r\n    } finally {\r\n      free_memory(cArr);\r\n      for (; i >= 0; --i) free_memory(names[i]);\r\n    }\r\n  }\r\n\r\n  validate(): bool {\r\n    return _BinaryenModuleValidate(this.ref) == 1;\r\n  }\r\n\r\n  interpret(): void {\r\n    _BinaryenModuleInterpret(this.ref);\r\n  }\r\n\r\n  toBinary(sourceMapUrl: string | null): Binary {\r\n    var out = this.out;\r\n    var cStr = allocString(sourceMapUrl);\r\n    var binaryPtr: usize = 0;\r\n    var sourceMapPtr: usize = 0;\r\n    try {\r\n      _BinaryenModuleAllocateAndWrite(out, this.ref, cStr);\r\n      binaryPtr    = readInt(out);\r\n      var binaryBytes  = readInt(out + 4);\r\n      sourceMapPtr = readInt(out + 4 * 2);\r\n      var ret = new Binary();\r\n      ret.output = readBuffer(binaryPtr, binaryBytes);\r\n      ret.sourceMap = readString(sourceMapPtr);\r\n      return ret;\r\n    } finally {\r\n      if (cStr) free_memory(cStr);\r\n      if (binaryPtr) free_memory(binaryPtr);\r\n      if (sourceMapPtr) free_memory(sourceMapPtr);\r\n    }\r\n  }\r\n\r\n  toText(): string {\r\n    throw new Error(\"not implemented\"); // JS glue overrides this\r\n  }\r\n\r\n  toAsmjs(): string {\r\n    throw new Error(\"not implemented\"); // JS glue overrides this\r\n  }\r\n\r\n  dispose(): void {\r\n    if (!this.ref) return; // sic\r\n    _BinaryenModuleDispose(this.ref);\r\n    free_memory(this.out);\r\n  }\r\n\r\n  createRelooper(): Relooper {\r\n    return Relooper.create(this);\r\n  }\r\n\r\n  cloneExpression(expr: ExpressionRef,\r\n    noSideEffects: bool = false,\r\n    maxDepth: i32 = i32.MAX_VALUE\r\n  ): ExpressionRef { // currently supports side effect free expressions only\r\n    if (maxDepth < 0) return 0;\r\n    maxDepth -= 1;\r\n\r\n    var nested1: ExpressionRef,\r\n        nested2: ExpressionRef;\r\n\r\n    switch (_BinaryenExpressionGetId(expr)) {\r\n\r\n      case ExpressionId.Const:\r\n        switch (_BinaryenExpressionGetType(expr)) {\r\n          case NativeType.I32:\r\n            return this.createI32(_BinaryenConstGetValueI32(expr));\r\n          case NativeType.I64:\r\n            return this.createI64(\r\n              _BinaryenConstGetValueI64Low(expr),\r\n              _BinaryenConstGetValueI64High(expr)\r\n            );\r\n          case NativeType.F32:\r\n            return this.createF32(_BinaryenConstGetValueF32(expr));\r\n          case NativeType.F64:\r\n            return this.createF64(_BinaryenConstGetValueF64(expr));\r\n          default:\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n\r\n      case ExpressionId.GetLocal:\r\n        return _BinaryenGetLocal(this.ref,\r\n          _BinaryenGetLocalGetIndex(expr),\r\n          _BinaryenExpressionGetType(expr)\r\n        );\r\n\r\n      case ExpressionId.GetGlobal:\r\n        var globalName = _BinaryenGetGlobalGetName(expr);\r\n        if (!globalName) break;\r\n        return _BinaryenGetGlobal(this.ref, globalName, _BinaryenExpressionGetType(expr));\r\n\r\n      case ExpressionId.Load:\r\n        if (!(nested1 = this.cloneExpression(_BinaryenLoadGetPtr(expr), noSideEffects, maxDepth))) {\r\n          break;\r\n        }\r\n        return _BinaryenLoadIsAtomic(expr)\r\n          ? _BinaryenAtomicLoad(this.ref,\r\n              _BinaryenLoadGetBytes(expr),\r\n              _BinaryenLoadGetOffset(expr),\r\n              _BinaryenExpressionGetType(expr),\r\n              nested1\r\n            )\r\n          : _BinaryenLoad(this.ref,\r\n              _BinaryenLoadGetBytes(expr),\r\n              _BinaryenLoadIsSigned(expr) ? 1 : 0,\r\n              _BinaryenLoadGetOffset(expr),\r\n               _BinaryenLoadGetAlign(expr),\r\n               _BinaryenExpressionGetType(expr),\r\n               nested1\r\n            );\r\n\r\n      case ExpressionId.Unary:\r\n        if (!(nested1 = this.cloneExpression(_BinaryenUnaryGetValue(expr), noSideEffects, maxDepth))) {\r\n          break;\r\n        }\r\n        return _BinaryenUnary(this.ref, _BinaryenUnaryGetOp(expr), nested1);\r\n\r\n      case ExpressionId.Binary:\r\n        if (!(nested1 = this.cloneExpression(_BinaryenBinaryGetLeft(expr), noSideEffects, maxDepth))) {\r\n          break;\r\n        }\r\n        if (!(nested2 = this.cloneExpression(_BinaryenBinaryGetRight(expr), noSideEffects, maxDepth))) {\r\n          break;\r\n        }\r\n        return _BinaryenBinary(this.ref, _BinaryenBinaryGetOp(expr), nested1, nested2);\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  // source map generation\r\n\r\n  addDebugInfoFile(name: string): Index {\r\n    var cStr = allocString(name);\r\n    try {\r\n      return _BinaryenModuleAddDebugInfoFileName(this.ref, cStr);\r\n    } finally {\r\n      free_memory(cStr);\r\n    }\r\n  }\r\n\r\n  getDebugInfoFile(index: Index): string | null {\r\n    return readString(_BinaryenModuleGetDebugInfoFileName(this.ref, index));\r\n  }\r\n\r\n  setDebugLocation(\r\n    func: FunctionRef,\r\n    expr: ExpressionRef,\r\n    fileIndex: Index,\r\n    lineNumber: Index,\r\n    columnNumber: Index\r\n  ): void {\r\n    _BinaryenFunctionSetDebugLocation(func, expr, fileIndex, lineNumber, columnNumber);\r\n  }\r\n}\r\n\r\nexport class Relooper {\r\n\r\n  module: Module;\r\n  ref: RelooperRef;\r\n\r\n  static create(module: Module): Relooper {\r\n    var relooper = new Relooper();\r\n    relooper.module = module;\r\n    relooper.ref = _RelooperCreate();\r\n      return relooper;\r\n  }\r\n\r\n  static createStub(module: Module): Relooper {\r\n    var relooper = new Relooper();\r\n    relooper.module = module;\r\n    relooper.ref = 0;\r\n    return relooper;\r\n  }\r\n\r\n  private constructor() {}\r\n\r\n  addBlock(code: ExpressionRef): RelooperBlockRef {\r\n    return _RelooperAddBlock(this.ref, code);\r\n  }\r\n\r\n  addBranch(from: RelooperBlockRef, to: RelooperBlockRef, condition: ExpressionRef = 0, code: ExpressionRef = 0): void {\r\n    _RelooperAddBranch(from, to, condition, code);\r\n  }\r\n\r\n  addBlockWithSwitch(code: ExpressionRef, condition: ExpressionRef): RelooperBlockRef {\r\n    return _RelooperAddBlockWithSwitch(this.ref, code, condition);\r\n  }\r\n\r\n  addBranchForSwitch(from: RelooperBlockRef, to: RelooperBlockRef, indexes: i32[], code: ExpressionRef = 0): void {\r\n    var cArr = allocI32Array(indexes);\r\n    try {\r\n      _RelooperAddBranchForSwitch(from, to, cArr, indexes.length, code);\r\n    } finally {\r\n      free_memory(cArr);\r\n    }\r\n  }\r\n\r\n  renderAndDispose(entry: RelooperBlockRef, labelHelper: Index): ExpressionRef {\r\n    return _RelooperRenderAndDispose(this.ref, entry, labelHelper, this.module.ref);\r\n  }\r\n}\r\n\r\n// helpers\r\n// can't do stack allocation here: STACKTOP is a global in WASM but a hidden variable in asm.js\r\n\r\nfunction allocU8Array(u8s: Uint8Array | null): usize {\r\n  if (!u8s) return 0;\r\n  var ptr = allocate_memory(u8s.length);\r\n  var idx = ptr;\r\n  for (var i = 0, k = u8s.length; i < k; ++i) {\r\n    store<u8>(idx++, u8s[i]);\r\n  }\r\n  return ptr;\r\n}\r\n\r\nfunction allocI32Array(i32s: i32[] | null): usize {\r\n  if (!i32s) return 0;\r\n  var ptr = allocate_memory(i32s.length << 2);\r\n  var idx = ptr;\r\n  for (var i = 0, k = i32s.length; i < k; ++i) {\r\n    var val = i32s[i];\r\n    // store<i32>(idx, val) is not portable\r\n    store<u8>(idx    , ( val         & 0xff) as u8);\r\n    store<u8>(idx + 1, ((val >>   8) & 0xff) as u8);\r\n    store<u8>(idx + 2, ((val >>  16) & 0xff) as u8);\r\n    store<u8>(idx + 3, ( val >>> 24        ) as u8);\r\n    idx += 4;\r\n  }\r\n  return ptr;\r\n}\r\n\r\nfunction stringLengthUTF8(str: string): usize {\r\n  var len = 0;\r\n  for (var i = 0, k = str.length; i < k; ++i) {\r\n    var u = str.charCodeAt(i);\r\n    if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {\r\n      u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\r\n    }\r\n    if (u <= 0x7F) {\r\n      ++len;\r\n    } else if (u <= 0x7FF) {\r\n      len += 2;\r\n    } else if (u <= 0xFFFF) {\r\n      len += 3;\r\n    } else if (u <= 0x1FFFFF) {\r\n      len += 4;\r\n    } else if (u <= 0x3FFFFFF) {\r\n      len += 5;\r\n    } else {\r\n      len += 6;\r\n    }\r\n  }\r\n  return len;\r\n}\r\n\r\nfunction allocString(str: string | null): usize {\r\n  if (str == null) return 0;\r\n  var ptr = allocate_memory(stringLengthUTF8(str) + 1);\r\n  var idx = ptr;\r\n  for (var i = 0, k = str.length; i < k; ++i) {\r\n    var u = str.charCodeAt(i);\r\n    if (u >= 0xD800 && u <= 0xDFFF && i + 1 < k) {\r\n      u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);\r\n    }\r\n    if (u <= 0x7F) {\r\n      store<u8>(idx++, u as u8);\r\n    } else if (u <= 0x7FF) {\r\n      store<u8>(idx++, (0xC0 |  (u >>> 6)       ) as u8);\r\n      store<u8>(idx++, (0x80 | ( u         & 63)) as u8);\r\n    } else if (u <= 0xFFFF) {\r\n      store<u8>(idx++, (0xE0 |  (u >>> 12)      ) as u8);\r\n      store<u8>(idx++, (0x80 | ((u >>>  6) & 63)) as u8);\r\n      store<u8>(idx++, (0x80 | ( u         & 63)) as u8);\r\n    } else if (u <= 0x1FFFFF) {\r\n      store<u8>(idx++, (0xF0 |  (u >>> 18)      ) as u8);\r\n      store<u8>(idx++, (0x80 | ((u >>> 12) & 63)) as u8);\r\n      store<u8>(idx++, (0x80 | ((u >>>  6) & 63)) as u8);\r\n      store<u8>(idx++, (0x80 | ( u         & 63)) as u8);\r\n    } else if (u <= 0x3FFFFFF) {\r\n      store<u8>(idx++, (0xF8 |  (u >>> 24)      ) as u8);\r\n      store<u8>(idx++, (0x80 | ((u >>> 18) & 63)) as u8);\r\n      store<u8>(idx++, (0x80 | ((u >>> 12) & 63)) as u8);\r\n      store<u8>(idx++, (0x80 | ((u >>>  6) & 63)) as u8);\r\n      store<u8>(idx++, (0x80 | ( u         & 63)) as u8);\r\n    } else {\r\n      store<u8>(idx++, (0xFC |  (u >>> 30)      ) as u8);\r\n      store<u8>(idx++, (0x80 | ((u >>> 24) & 63)) as u8);\r\n      store<u8>(idx++, (0x80 | ((u >>> 18) & 63)) as u8);\r\n      store<u8>(idx++, (0x80 | ((u >>> 12) & 63)) as u8);\r\n      store<u8>(idx++, (0x80 | ((u >>>  6) & 63)) as u8);\r\n      store<u8>(idx++, (0x80 | ( u         & 63)) as u8);\r\n    }\r\n  }\r\n  store<u8>(idx, 0);\r\n  return ptr;\r\n}\r\n\r\nexport function readInt(ptr: usize): i32 {\r\n  return (\r\n     load<u8>(ptr    )        |\r\n    (load<u8>(ptr + 1) <<  8) |\r\n    (load<u8>(ptr + 2) << 16) |\r\n    (load<u8>(ptr + 3) << 24)\r\n  );\r\n}\r\n\r\nexport function readBuffer(ptr: usize, length: usize): Uint8Array {\r\n  var ret = new Uint8Array(length);\r\n  for (var i: usize = 0; i < length; ++i) {\r\n    ret[i] = load<u8>(ptr + i);\r\n  }\r\n  return ret;\r\n}\r\n\r\nexport function readString(ptr: usize): string | null {\r\n  if (!ptr) return null;\r\n  var arr = new Array<i32>();\r\n  // the following is based on Emscripten's UTF8ArrayToString\r\n  var cp: u32;\r\n  var u1: u32, u2: u32, u3: u32, u4: u32, u5: u32;\r\n  while (cp = load<u8>(ptr++)) {\r\n    if (!(cp & 0x80)) {\r\n      arr.push(cp);\r\n      continue;\r\n    }\r\n    u1 = load<u8>(ptr++) & 63;\r\n    if ((cp & 0xE0) == 0xC0) {\r\n      arr.push(((cp & 31) << 6) | u1);\r\n      continue;\r\n    }\r\n    u2 = load<u8>(ptr++) & 63;\r\n    if ((cp & 0xF0) == 0xE0) {\r\n      cp = ((cp & 15) << 12) | (u1 << 6) | u2;\r\n    } else {\r\n      u3 = load<u8>(ptr++) & 63;\r\n      if ((cp & 0xF8) == 0xF0) {\r\n        cp = ((cp & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;\r\n      } else {\r\n        u4 = load<u8>(ptr++) & 63;\r\n        if ((cp & 0xFC) == 0xF8) {\r\n          cp = ((cp & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;\r\n        } else {\r\n          u5 = load<u8>(ptr++) & 63;\r\n          cp = ((cp & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;\r\n        }\r\n      }\r\n    }\r\n    // if (cp < 0x10000) {\r\n    //   arr.push(cp);\r\n    // } else {\r\n    //   var ch = cp - 0x10000;\r\n    //   arr.push(0xD800 | (ch >> 10));\r\n    //   arr.push(0xDC00 | (ch & 0x3FF));\r\n    // }\r\n  }\r\n  // return String.fromCharCodes(arr);\r\n  return String.fromCodePoints(arr);\r\n}\r\n\r\n/** Result structure of {@link Module#toBinary}. */\r\nclass Binary {\r\n  /** WebAssembly binary. */\r\n  output: Uint8Array;\r\n  /** Source map, if generated. */\r\n  sourceMap: string | null;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/module.ts","import {\r\n  Range\r\n} from \"./ast\";\r\n\r\nimport {\r\n  DiagnosticCode,\r\n  diagnosticCodeToString\r\n} from \"./diagnosticMessages.generated\";\r\n\r\nimport {\r\n  isLineBreak\r\n} from \"./util/charcode\";\r\n\r\nexport {\r\n  DiagnosticCode,\r\n  diagnosticCodeToString\r\n} from \"./diagnosticMessages.generated\";\r\n\r\nexport enum DiagnosticCategory {\r\n  INFO,\r\n  WARNING,\r\n  ERROR\r\n}\r\n\r\nexport function diagnosticCategoryToString(category: DiagnosticCategory): string {\r\n  switch (category) {\r\n    case DiagnosticCategory.INFO: return \"INFO\";\r\n    case DiagnosticCategory.WARNING: return \"WARNING\";\r\n    case DiagnosticCategory.ERROR: return \"ERROR\";\r\n    default: return \"\";\r\n  }\r\n}\r\n\r\nconst colorBlue: string = \"\\u001b[93m\";\r\nconst colorYellow: string = \"\\u001b[93m\";\r\nconst colorRed: string = \"\\u001b[91m\";\r\nconst colorReset: string = \"\\u001b[0m\";\r\n\r\nexport function diagnosticCategoryToColor(category: DiagnosticCategory): string {\r\n  switch (category) {\r\n    case DiagnosticCategory.INFO: return colorBlue;\r\n    case DiagnosticCategory.WARNING: return colorYellow;\r\n    case DiagnosticCategory.ERROR: return colorRed;\r\n    default: return \"\";\r\n  }\r\n}\r\n\r\nexport class DiagnosticMessage {\r\n\r\n  code: i32;\r\n  category: DiagnosticCategory;\r\n  message: string;\r\n  range: Range | null = null;\r\n\r\n  constructor(code: i32, category: DiagnosticCategory, message: string) {\r\n    this.code = code;\r\n    this.category = category;\r\n    this.message = message;\r\n  }\r\n\r\n  static create(\r\n    code: DiagnosticCode,\r\n    category: DiagnosticCategory,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): DiagnosticMessage {\r\n    var message = diagnosticCodeToString(code);\r\n    if (arg0 != null) message = message.replace(\"{0}\", arg0);\r\n    if (arg1 != null) message = message.replace(\"{1}\", arg1);\r\n    if (arg2 != null) message = message.replace(\"{2}\", arg2);\r\n    return new DiagnosticMessage(code, category, message);\r\n  }\r\n\r\n  static createInfo(\r\n    code: DiagnosticCode,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null\r\n  ): DiagnosticMessage {\r\n    return DiagnosticMessage.create(code, DiagnosticCategory.INFO, arg0, arg1);\r\n  }\r\n\r\n  static createWarning(\r\n    code: DiagnosticCode,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null\r\n  ): DiagnosticMessage {\r\n    return DiagnosticMessage.create(code, DiagnosticCategory.WARNING, arg0, arg1);\r\n  }\r\n\r\n  static createError(\r\n    code: DiagnosticCode,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null\r\n  ): DiagnosticMessage {\r\n    return DiagnosticMessage.create(code, DiagnosticCategory.ERROR, arg0, arg1);\r\n  }\r\n\r\n  withRange(range: Range): this {\r\n    this.range = range;\r\n    return this;\r\n  }\r\n\r\n  toString(): string {\r\n    if (this.range) {\r\n      return (\r\n        diagnosticCategoryToString(this.category) +\r\n        \" \" +\r\n        this.code.toString(10) +\r\n        \": \\\"\" +\r\n        this.message +\r\n        \"\\\" in \" +\r\n        this.range.source.normalizedPath +\r\n        \" @ \" +\r\n        this.range.start.toString(10) +\r\n        \",\" +\r\n        this.range.end.toString(10)\r\n      );\r\n    }\r\n    return (\r\n      diagnosticCategoryToString(this.category) +\r\n      \" \" +\r\n      this.code.toString(10) +\r\n      \": \" +\r\n      this.message\r\n    );\r\n  }\r\n}\r\n\r\nexport function formatDiagnosticMessage(\r\n  message: DiagnosticMessage,\r\n  useColors: bool = false,\r\n  showContext: bool = false\r\n): string {\r\n  // format context first (uses same string builder)\r\n  var context = \"\";\r\n  if (message.range && showContext) {\r\n    context = formatDiagnosticContext(message.range, useColors);\r\n  }\r\n\r\n  // general information\r\n  var sb: string[] = [];\r\n  if (useColors) sb.push(diagnosticCategoryToColor(message.category));\r\n  sb.push(diagnosticCategoryToString(message.category));\r\n  if (useColors) sb.push(colorReset);\r\n  sb.push(message.code < 1000 ? \" AS\" : \" TS\");\r\n  sb.push(message.code.toString(10));\r\n  sb.push(\": \");\r\n  sb.push(message.message);\r\n\r\n  // range information if available\r\n  if (message.range) {\r\n    var range = message.range;\r\n    if (showContext) {\r\n      sb.push(\"\\n\");\r\n      sb.push(context);\r\n    }\r\n    sb.push(\"\\n\");\r\n    sb.push(\" in \");\r\n    sb.push(range.source.normalizedPath);\r\n    sb.push(\"(\");\r\n    sb.push(range.line.toString(10));\r\n    sb.push(\",\");\r\n    sb.push(range.column.toString(10));\r\n    sb.push(\")\");\r\n  }\r\n  return sb.join(\"\");\r\n}\r\n\r\nexport function formatDiagnosticContext(range: Range, useColors: bool = false): string {\r\n  var text = range.source.text;\r\n  var len = text.length;\r\n  var start = range.start;\r\n  var end = range.end;\r\n  while (start > 0 && !isLineBreak(text.charCodeAt(start - 1))) {\r\n    start--;\r\n  }\r\n  while (end < len && !isLineBreak(text.charCodeAt(end))) {\r\n    end++;\r\n  }\r\n  var sb: string[] = [\r\n    \"\\n \",\r\n    text.substring(start, end),\r\n    \"\\n \"\r\n  ];\r\n  while (start < range.start) {\r\n    sb.push(\" \");\r\n    start++;\r\n  }\r\n  if (useColors) sb.push(colorRed);\r\n  if (range.start == range.end) {\r\n    sb.push(\"^\");\r\n  } else {\r\n    while (start++ < range.end) {\r\n      sb.push(\"~\");\r\n    }\r\n  }\r\n  if (useColors) sb.push(colorReset);\r\n  return sb.join(\"\");\r\n}\r\n\r\nexport abstract class DiagnosticEmitter {\r\n\r\n  diagnostics: DiagnosticMessage[];\r\n  // silentDiagnostics: bool = false;\r\n\r\n  constructor(diagnostics: DiagnosticMessage[] | null = null) {\r\n    this.diagnostics = diagnostics ? <DiagnosticMessage[]>diagnostics : new Array();\r\n  }\r\n\r\n  emitDiagnostic(\r\n    code: DiagnosticCode,\r\n    category: DiagnosticCategory,\r\n    range: Range,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ) {\r\n    var message = DiagnosticMessage.create(code, category, arg0, arg1, arg2).withRange(range);\r\n    this.diagnostics.push(message);\r\n    // console.log(formatDiagnosticMessage(message, true, true) + \"\\n\"); // temporary\r\n    // console.log(<string>new Error(\"stack\").stack);\r\n  }\r\n\r\n  error(\r\n    code: DiagnosticCode,\r\n    range: Range,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): void {\r\n    this.emitDiagnostic(code, DiagnosticCategory.ERROR, range, arg0, arg1, arg2);\r\n  }\r\n\r\n  info(\r\n    code: DiagnosticCode,\r\n    range: Range,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): void {\r\n    this.emitDiagnostic(code, DiagnosticCategory.INFO, range, arg0, arg1, arg2);\r\n  }\r\n\r\n  warning(\r\n    code: DiagnosticCode,\r\n    range: Range,\r\n    arg0: string | null = null,\r\n    arg1: string | null = null,\r\n    arg2: string | null = null\r\n  ): void {\r\n    this.emitDiagnostic(code, DiagnosticCategory.WARNING, range, arg0, arg1, arg2);\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/diagnostics.ts","import {\r\n  Options\r\n} from \"./compiler\";\r\n\r\nimport {\r\n  DiagnosticCode,\r\n  DiagnosticMessage,\r\n  DiagnosticEmitter\r\n} from \"./diagnostics\";\r\n\r\nimport {\r\n  Type,\r\n  typesToString\r\n} from \"./types\";\r\n\r\nimport {\r\n  ModifierKind,\r\n  Node,\r\n  NodeKind,\r\n  Source,\r\n  Range,\r\n  TypeNode,\r\n  TypeParameter,\r\n  Decorator,\r\n  DecoratorKind,\r\n\r\n  Expression,\r\n  AssertionExpression,\r\n  ElementAccessExpression,\r\n  IdentifierExpression,\r\n  LiteralExpression,\r\n  LiteralKind,\r\n  ParenthesizedExpression,\r\n  PropertyAccessExpression,\r\n  StringLiteralExpression,\r\n  CallExpression,\r\n\r\n  ClassDeclaration,\r\n  DeclarationStatement,\r\n  EnumDeclaration,\r\n  EnumValueDeclaration,\r\n  ExportMember,\r\n  ExportStatement,\r\n  FieldDeclaration,\r\n  FunctionDeclaration,\r\n  ImportDeclaration,\r\n  ImportStatement,\r\n  InterfaceDeclaration,\r\n  MethodDeclaration,\r\n  NamespaceDeclaration,\r\n  TypeDeclaration,\r\n  VariableLikeDeclarationStatement,\r\n  VariableStatement,\r\n\r\n  hasDecorator,\r\n  hasModifier\r\n} from \"./ast\";\r\n\r\nimport {\r\n  Module,\r\n  NativeType,\r\n  FunctionRef,\r\n} from \"./module\";\r\n\r\n/** Path delimiter inserted between file system levels. */\r\nexport const PATH_DELIMITER = \"/\";\r\n/** Substitution used to indicate the parent directory. */\r\nexport const PARENT_SUBST = \"..\";\r\n/** Function name prefix used for getters. */\r\nexport const GETTER_PREFIX = \"get:\";\r\n/** Function name prefix used for setters. */\r\nexport const SETTER_PREFIX = \"set:\";\r\n/** Delimiter used between class names and instance members. */\r\nexport const INSTANCE_DELIMITER = \"#\";\r\n/** Delimiter used between class and namespace names and static members. */\r\nexport const STATIC_DELIMITER = \".\";\r\n/** Substitution used to indicate a library directory. */\r\nexport const LIBRARY_SUBST = \"(lib)\";\r\n/** Library directory prefix. */\r\nexport const LIBRARY_PREFIX = LIBRARY_SUBST + PATH_DELIMITER;\r\n\r\nclass QueuedExport {\r\n  isReExport: bool;\r\n  referencedName: string;\r\n  member: ExportMember;\r\n}\r\n\r\nclass QueuedImport {\r\n  internalName: string;\r\n  referencedName: string;\r\n  referencedNameAlt: string;\r\n  declaration: ImportDeclaration;\r\n}\r\n\r\nconst noTypesYet = new Map<string,Type>();\r\n\r\n/** Represents an AssemblyScript program. */\r\nexport class Program extends DiagnosticEmitter {\r\n\r\n  /** Array of source files. */\r\n  sources: Source[];\r\n  /** Diagnostic offset used where repeatedly obtaining the next diagnostic. */\r\n  diagnosticsOffset: i32 = 0;\r\n  /** Compiler options. */\r\n  options: Options;\r\n  /** Elements by internal name. */\r\n  elements: Map<string,Element> = new Map();\r\n  /** Types by internal name. */\r\n  types: Map<string,Type> = noTypesYet;\r\n  /** Declared type aliases. */\r\n  typeAliases: Map<string,TypeNode> = new Map();\r\n  /** Exports of individual files by exported name. Not global exports. */\r\n  exports: Map<string,Element> = new Map();\r\n\r\n  /** Constructs a new program, optionally inheriting parser diagnostics. */\r\n  constructor(diagnostics: DiagnosticMessage[] | null = null) {\r\n    super(diagnostics);\r\n    this.sources = [];\r\n  }\r\n\r\n  /** Initializes the program and its elements prior to compilation. */\r\n  initialize(options: Options): void {\r\n    this.options = options;\r\n\r\n    this.types = new Map([\r\n      [\"i8\", Type.i8],\r\n      [\"i16\", Type.i16],\r\n      [\"i32\", Type.i32],\r\n      [\"i64\", Type.i64],\r\n      [\"isize\", options.isizeType],\r\n      [\"u8\", Type.u8],\r\n      [\"u16\", Type.u16],\r\n      [\"u32\", Type.u32],\r\n      [\"u64\", Type.u64],\r\n      [\"usize\", options.usizeType],\r\n      [\"bool\", Type.bool],\r\n      [\"f32\", Type.f32],\r\n      [\"f64\", Type.f64],\r\n      [\"void\", Type.void],\r\n      [\"number\", Type.f64],\r\n      [\"boolean\", Type.bool]\r\n    ]);\r\n\r\n    var queuedExports = new Map<string,QueuedExport>();\r\n    var queuedImports = new Array<QueuedImport>();\r\n    var queuedDerivedClasses = new Array<ClassPrototype>();\r\n\r\n    // build initial lookup maps of internal names to declarations\r\n    for (var i = 0, k = this.sources.length; i < k; ++i) {\r\n      var source = this.sources[i];\r\n      var statements = source.statements;\r\n      for (var j = 0, l = statements.length; j < l; ++j) {\r\n        var statement = statements[j];\r\n        switch (statement.kind) {\r\n\r\n          case NodeKind.CLASSDECLARATION:\r\n            this.initializeClass(\r\n              <ClassDeclaration>statement,\r\n              queuedDerivedClasses\r\n            );\r\n            break;\r\n\r\n          case NodeKind.ENUMDECLARATION:\r\n            this.initializeEnum(<EnumDeclaration>statement);\r\n            break;\r\n\r\n          case NodeKind.EXPORT:\r\n            this.initializeExports(\r\n              <ExportStatement>statement,\r\n              queuedExports\r\n            );\r\n            break;\r\n\r\n          case NodeKind.FUNCTIONDECLARATION:\r\n            this.initializeFunction(<FunctionDeclaration>statement);\r\n            break;\r\n\r\n          case NodeKind.IMPORT:\r\n            this.initializeImports(\r\n              <ImportStatement>statement,\r\n              queuedExports,\r\n              queuedImports\r\n            );\r\n            break;\r\n\r\n          case NodeKind.INTERFACEDECLARATION:\r\n            this.initializeInterface(<InterfaceDeclaration>statement);\r\n            break;\r\n\r\n          case NodeKind.NAMESPACEDECLARATION:\r\n            this.initializeNamespace(\r\n              <NamespaceDeclaration>statement,\r\n              queuedDerivedClasses\r\n            );\r\n            break;\r\n\r\n          case NodeKind.TYPEDECLARATION:\r\n            this.initializeTypeAlias(<TypeDeclaration>statement);\r\n            break;\r\n\r\n          case NodeKind.VARIABLE:\r\n            this.initializeVariables(<VariableStatement>statement);\r\n            break;\r\n        }\r\n      }\r\n    }\r\n\r\n    var element: Element | null;\r\n\r\n    // queued imports should be resolvable now through traversing exports and\r\n    // queued exports\r\n    for (i = 0; i < queuedImports.length;) {\r\n      var queuedImport = queuedImports[i];\r\n      element = this.tryResolveImport(\r\n        queuedImport.referencedName,\r\n        queuedExports\r\n      );\r\n      if (element) {\r\n        this.elements.set(queuedImport.internalName, element);\r\n        queuedImports.splice(i, 1);\r\n      } else {\r\n        element = this.tryResolveImport(\r\n          queuedImport.referencedNameAlt,\r\n          queuedExports\r\n        );\r\n        if (element) {\r\n          this.elements.set(queuedImport.internalName, element);\r\n          queuedImports.splice(i, 1);\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Module_0_has_no_exported_member_1,\r\n            queuedImport.declaration.range,\r\n            (<ImportStatement>queuedImport.declaration.parent).path.value,\r\n            queuedImport.declaration.externalName.text\r\n          );\r\n          ++i;\r\n        }\r\n      }\r\n    }\r\n\r\n    // queued exports should be resolvable now that imports are finalized\r\n    for (var [exportName, queuedExport] of queuedExports) {\r\n      var currentExport: QueuedExport | null = queuedExport; // nullable below\r\n      do {\r\n        if (currentExport.isReExport) {\r\n          if (element = this.exports.get(currentExport.referencedName)) {\r\n            this.setExportAndCheckLibrary(\r\n              exportName,\r\n              element,\r\n              currentExport.member.externalName\r\n            );\r\n            break;\r\n          }\r\n          currentExport = queuedExports.get(currentExport.referencedName);\r\n          if (!currentExport) {\r\n            this.error(\r\n              DiagnosticCode.Module_0_has_no_exported_member_1,\r\n              queuedExport.member.externalName.range,\r\n              (<StringLiteralExpression>(\r\n                <ExportStatement>queuedExport.member.parent\r\n              ).path).value,\r\n              queuedExport.member.externalName.text\r\n            );\r\n          }\r\n        } else {\r\n          if (\r\n            // normal export\r\n            (element = this.elements.get(currentExport.referencedName)) ||\r\n            // library re-export\r\n            (element = this.elements.get(currentExport.member.name.text))\r\n          ) {\r\n            this.setExportAndCheckLibrary(\r\n              exportName,\r\n              element,\r\n              currentExport.member.externalName\r\n            );\r\n          } else {\r\n            this.error(\r\n              DiagnosticCode.Cannot_find_name_0,\r\n              queuedExport.member.range, queuedExport.member.name.text\r\n            );\r\n          }\r\n          break;\r\n        }\r\n      } while (currentExport);\r\n    }\r\n\r\n    // resolve base prototypes of derived classes\r\n    for (i = 0, k = queuedDerivedClasses.length; i < k; ++i) {\r\n      var derivedDeclaration = queuedDerivedClasses[i].declaration;\r\n      var derivedType = assert(derivedDeclaration.extendsType);\r\n      var resolved = this.resolveIdentifier(derivedType.name, null);\r\n      if (resolved) {\r\n        if (resolved.element.kind != ElementKind.CLASS_PROTOTYPE) {\r\n          this.error(\r\n            DiagnosticCode.A_class_may_only_extend_another_class,\r\n            derivedType.range\r\n          );\r\n          continue;\r\n        }\r\n        queuedDerivedClasses[i].basePrototype = (\r\n          <ClassPrototype>resolved.element\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Tries to resolve an import by traversing exports and queued exports. */\r\n  private tryResolveImport(\r\n    referencedName: string,\r\n    queuedExports: Map<string,QueuedExport>\r\n  ): Element | null {\r\n    var element: Element | null;\r\n    do {\r\n      if (element = this.exports.get(referencedName)) {\r\n        return element;\r\n      }\r\n      var queuedExport = queuedExports.get(referencedName);\r\n      if (!queuedExport) return null;\r\n      if (queuedExport.isReExport) {\r\n        referencedName = queuedExport.referencedName;\r\n        continue;\r\n      }\r\n      return this.elements.get(queuedExport.referencedName);\r\n    } while (true);\r\n  }\r\n\r\n  private checkInternalDecorators(\r\n    element: Element,\r\n    declaration: DeclarationStatement\r\n  ): void {\r\n    var isBuiltin: bool = hasDecorator(\"builtin\", declaration.decorators);\r\n    if (isBuiltin) {\r\n      element.set(ElementFlags.BUILTIN);\r\n    }\r\n    if (\r\n      hasDecorator(\"global\", declaration.decorators) ||\r\n      (\r\n        declaration.range.source.isLibrary &&\r\n        element.is(ElementFlags.EXPORTED) &&\r\n        (\r\n          assert(declaration.parent).kind == NodeKind.SOURCE ||\r\n          (\r\n            <Node>declaration.parent).kind == NodeKind.VARIABLE &&\r\n            assert((<Node>declaration.parent).parent).kind == NodeKind.SOURCE\r\n          )\r\n        )\r\n    ) {\r\n      element.set(ElementFlags.GLOBAL);\r\n      if (this.elements.has(declaration.name.text)) {\r\n        this.error(\r\n          DiagnosticCode.Duplicate_identifier_0,\r\n          declaration.name.range, element.internalName\r\n        );\r\n      } else {\r\n        this.elements.set(declaration.name.text, element);\r\n        this.exports.set(declaration.name.text, element);\r\n        if (isBuiltin) {\r\n          element.internalName = declaration.name.text;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private initializeClass(\r\n    declaration: ClassDeclaration,\r\n    queuedDerivedClasses: ClassPrototype[],\r\n    namespace: Element | null = null\r\n  ): void {\r\n    var internalName = declaration.fileLevelInternalName;\r\n    if (this.elements.has(internalName)) {\r\n      this.error(\r\n        DiagnosticCode.Duplicate_identifier_0,\r\n        declaration.name.range, internalName\r\n      );\r\n      return;\r\n    }\r\n    var prototype = new ClassPrototype(\r\n      this,\r\n      declaration.name.text,\r\n      internalName,\r\n      declaration\r\n    );\r\n    prototype.namespace = namespace;\r\n    this.elements.set(internalName, prototype);\r\n\r\n    this.checkInternalDecorators(prototype, declaration);\r\n\r\n    if (hasDecorator(\"unmanaged\", declaration.decorators)) {\r\n      prototype.isUnmanaged = true;\r\n      if (declaration.implementsTypes && declaration.implementsTypes.length) {\r\n        this.error(\r\n          DiagnosticCode.Structs_cannot_implement_interfaces,\r\n          Range.join(\r\n            declaration.name.range,\r\n            declaration.implementsTypes[declaration.implementsTypes.length - 1]\r\n              .range\r\n          )\r\n        );\r\n      }\r\n    } else if (declaration.implementsTypes.length) {\r\n      throw new Error(\"not implemented\");\r\n    }\r\n\r\n    // remember classes that extend another one\r\n    if (declaration.extendsType) {\r\n      queuedDerivedClasses.push(prototype);\r\n    }\r\n\r\n    // add as namespace member if applicable\r\n    if (namespace) {\r\n      if (namespace.members) {\r\n        if (namespace.members.has(declaration.name.text)) {\r\n          this.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range, internalName\r\n          );\r\n          return;\r\n        }\r\n      } else {\r\n        namespace.members = new Map();\r\n      }\r\n      namespace.members.set(declaration.name.text, prototype);\r\n\r\n    // otherwise add to file-level exports if exported\r\n    } else if (prototype.is(ElementFlags.EXPORTED)) {\r\n      if (this.exports.has(internalName)) {\r\n        this.error(\r\n          DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\r\n          declaration.name.range, internalName\r\n        );\r\n        return;\r\n      }\r\n      this.exports.set(internalName, prototype);\r\n    }\r\n\r\n    // initialize members\r\n    var memberDeclarations = declaration.members;\r\n    for (var i = 0, k = memberDeclarations.length; i < k; ++i) {\r\n      var memberDeclaration = memberDeclarations[i];\r\n      switch (memberDeclaration.kind) {\r\n\r\n        case NodeKind.FIELDDECLARATION:\r\n          this.initializeField(<FieldDeclaration>memberDeclaration, prototype);\r\n          break;\r\n\r\n        case NodeKind.METHODDECLARATION:\r\n          var isGetter = hasModifier(\r\n            ModifierKind.GET,\r\n            memberDeclaration.modifiers\r\n          );\r\n          if (\r\n            isGetter ||\r\n            hasModifier(ModifierKind.SET, memberDeclaration.modifiers)\r\n          ) {\r\n            this.initializeAccessor(\r\n              <MethodDeclaration>memberDeclaration,\r\n              prototype,\r\n              isGetter\r\n            );\r\n          } else {\r\n            this.initializeMethod(\r\n              <MethodDeclaration>memberDeclaration,\r\n              prototype\r\n            );\r\n          }\r\n          break;\r\n\r\n        default:\r\n          throw new Error(\"class member expected\");\r\n      }\r\n    }\r\n\r\n    // check and possibly register string type\r\n    if (\r\n      prototype.is(ElementFlags.GLOBAL) &&\r\n      declaration.name.text == \"String\"\r\n    ) {\r\n      if (!this.types.has(\"string\")) {\r\n        var instance = prototype.resolve(null);\r\n        if (instance) {\r\n          this.types.set(\"string\", instance.type);\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.Duplicate_identifier_0,\r\n          declaration.name.range, declaration.programLevelInternalName\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  private initializeField(\r\n    declaration: FieldDeclaration,\r\n    classPrototype: ClassPrototype\r\n  ): void {\r\n    var name = declaration.name.text;\r\n    var internalName = declaration.fileLevelInternalName;\r\n\r\n    // static fields become global variables\r\n    if (hasModifier(ModifierKind.STATIC, declaration.modifiers)) {\r\n      if (this.elements.has(internalName)) {\r\n        this.error(\r\n          DiagnosticCode.Duplicate_identifier_0,\r\n          declaration.name.range, internalName\r\n        );\r\n        return;\r\n      }\r\n      if (classPrototype.members) {\r\n        if (classPrototype.members.has(name)) {\r\n          this.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range, internalName\r\n          );\r\n          return;\r\n        }\r\n      } else {\r\n        classPrototype.members = new Map();\r\n      }\r\n      var staticField = new Global(\r\n        this, name, internalName, declaration, Type.void\r\n      );\r\n      classPrototype.members.set(name, staticField);\r\n      this.elements.set(internalName, staticField);\r\n\r\n    // instance fields are remembered until resolved\r\n    } else {\r\n      if (classPrototype.instanceMembers) {\r\n        if (classPrototype.instanceMembers.has(name)) {\r\n          this.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range, internalName\r\n          );\r\n          return;\r\n        }\r\n      } else {\r\n        classPrototype.instanceMembers = new Map();\r\n      }\r\n      var instanceField = new FieldPrototype(\r\n        classPrototype,\r\n        name, internalName,\r\n        declaration\r\n      );\r\n      classPrototype.instanceMembers.set(name, instanceField);\r\n    }\r\n  }\r\n\r\n  private initializeMethod(\r\n    declaration: MethodDeclaration,\r\n    classPrototype: ClassPrototype\r\n  ): void {\r\n    var name = declaration.name.text;\r\n    var internalName = declaration.fileLevelInternalName;\r\n    var prototype: FunctionPrototype | null = null;\r\n\r\n    // static methods become global functions\r\n    if (hasModifier(ModifierKind.STATIC, declaration.modifiers)) {\r\n      assert(declaration.name.kind != NodeKind.CONSTRUCTOR);\r\n\r\n      if (this.elements.has(internalName)) {\r\n        this.error(\r\n          DiagnosticCode.Duplicate_identifier_0, declaration.name.range,\r\n          internalName\r\n        );\r\n        return;\r\n      }\r\n      if (classPrototype.members) {\r\n        if (classPrototype.members.has(name)) {\r\n          this.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range, internalName\r\n          );\r\n          return;\r\n        }\r\n      } else {\r\n        classPrototype.members = new Map();\r\n      }\r\n      prototype = new FunctionPrototype(\r\n        this,\r\n        name, internalName,\r\n        declaration,\r\n        null\r\n      );\r\n      classPrototype.members.set(name, prototype);\r\n      this.elements.set(internalName, prototype);\r\n\r\n    // instance methods are remembered until resolved\r\n    } else {\r\n      if (classPrototype.instanceMembers) {\r\n        if (classPrototype.instanceMembers.has(name)) {\r\n          this.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range, internalName\r\n          );\r\n          return;\r\n        }\r\n      } else {\r\n        classPrototype.instanceMembers = new Map();\r\n      }\r\n      prototype = new FunctionPrototype(\r\n        this,\r\n        name, internalName,\r\n        declaration,\r\n        classPrototype\r\n      );\r\n      // if (classPrototype.isUnmanaged && instancePrototype.isAbstract) {\r\n      //   this.error( Unmanaged classes cannot declare abstract methods. );\r\n      // }\r\n      if (declaration.name.kind == NodeKind.CONSTRUCTOR) {\r\n        if (classPrototype.constructorPrototype) {\r\n          this.error(\r\n            DiagnosticCode.Multiple_constructor_implementations_are_not_allowed,\r\n            declaration.name.range\r\n          );\r\n        } else {\r\n          prototype.set(ElementFlags.CONSTRUCTOR);\r\n          classPrototype.constructorPrototype = prototype;\r\n        }\r\n      } else {\r\n        classPrototype.instanceMembers.set(name, prototype);\r\n      }\r\n    }\r\n\r\n    this.checkOperators(declaration.decorators, prototype, classPrototype);\r\n  }\r\n\r\n  private checkOperators(\r\n    decorators: Decorator[] | null,\r\n    prototype: FunctionPrototype,\r\n    classPrototype: ClassPrototype\r\n  ) {\r\n    // handle operator annotations. operators are either instance methods taking\r\n    // a second argument of the instance's type or static methods taking two\r\n    // arguments of the instance's type. return values vary depending on the\r\n    // operation.\r\n    if (decorators) {\r\n      for (var i = 0, k = decorators.length; i < k; ++i) {\r\n        var decorator = decorators[i];\r\n        if (decorator.decoratorKind == DecoratorKind.OPERATOR) {\r\n          if (!prototype) {\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              decorator.range\r\n            );\r\n            continue;\r\n          }\r\n          var numArgs = decorator.arguments && decorator.arguments.length || 0;\r\n          if (numArgs == 1) {\r\n            var firstArg = (<Expression[]>decorator.arguments)[0];\r\n            if (\r\n              firstArg.kind == NodeKind.LITERAL &&\r\n              (<LiteralExpression>firstArg).literalKind == LiteralKind.STRING\r\n            ) {\r\n              switch ((<StringLiteralExpression>firstArg).value) {\r\n\r\n                case \"[]\":\r\n                  classPrototype.fnIndexedGet = prototype.simpleName;\r\n                  break;\r\n\r\n                case \"[]=\":\r\n                  classPrototype.fnIndexedSet = prototype.simpleName;\r\n                  break;\r\n\r\n                case \"+\":\r\n                  classPrototype.fnConcat = prototype.simpleName;\r\n                  break;\r\n\r\n                case \"==\":\r\n                  classPrototype.fnEquals = prototype.simpleName;\r\n                  break;\r\n\r\n                default:\r\n                  this.error(\r\n                    DiagnosticCode.Operation_not_supported,\r\n                    firstArg.range\r\n                  );\r\n              }\r\n            } else {\r\n              this.error(\r\n                DiagnosticCode.String_literal_expected,\r\n                firstArg.range\r\n              );\r\n            }\r\n          } else {\r\n            this.error(\r\n              DiagnosticCode.Expected_0_arguments_but_got_1,\r\n              decorator.range, \"1\", numArgs.toString(0)\r\n            );\r\n          }\r\n        } else if (decorator.decoratorKind != DecoratorKind.CUSTOM) {\r\n          // methods support built-in @operator only\r\n          this.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            decorator.range\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private initializeAccessor(\r\n    declaration: MethodDeclaration,\r\n    classPrototype: ClassPrototype,\r\n    isGetter: bool\r\n  ): void {\r\n    var propertyName = declaration.name.text;\r\n    var internalPropertyName = declaration.fileLevelInternalName;\r\n\r\n    var propertyElement = this.elements.get(internalPropertyName);\r\n    if (propertyElement) {\r\n      if (\r\n        propertyElement.kind != ElementKind.PROPERTY ||\r\n        (isGetter\r\n          ? (<Property>propertyElement).getterPrototype\r\n          : (<Property>propertyElement).setterPrototype\r\n        )\r\n      ) {\r\n        this.error(\r\n          DiagnosticCode.Duplicate_identifier_0,\r\n          declaration.name.range, internalPropertyName\r\n        );\r\n        return;\r\n      }\r\n    } else {\r\n      propertyElement = new Property(\r\n        this,\r\n        propertyName, internalPropertyName,\r\n        classPrototype\r\n      );\r\n    }\r\n\r\n    var name = (isGetter ? GETTER_PREFIX : SETTER_PREFIX) + propertyName;\r\n\r\n    // static accessors become global functions\r\n    if (hasModifier(ModifierKind.STATIC, declaration.modifiers)) {\r\n      var staticName = classPrototype.internalName + STATIC_DELIMITER + name;\r\n      if (this.elements.has(staticName)) {\r\n        this.error(\r\n          DiagnosticCode.Duplicate_identifier_0,\r\n          declaration.name.range, staticName\r\n        );\r\n        return;\r\n      }\r\n      var staticPrototype = new FunctionPrototype(\r\n        this,\r\n        name, staticName,\r\n        declaration,\r\n        null\r\n      );\r\n      if (isGetter) {\r\n        (<Property>propertyElement).getterPrototype = staticPrototype;\r\n      } else {\r\n        (<Property>propertyElement).setterPrototype = staticPrototype;\r\n      }\r\n      if (!classPrototype.members) {\r\n        classPrototype.members = new Map();\r\n      }\r\n      classPrototype.members.set(propertyName, propertyElement); // check above\r\n      this.elements.set(internalPropertyName, propertyElement);\r\n\r\n    // instance accessors are remembered until resolved\r\n    } else {\r\n      var instanceName = classPrototype.internalName + INSTANCE_DELIMITER + name;\r\n      if (classPrototype.instanceMembers) {\r\n        if (classPrototype.instanceMembers.has(name)) {\r\n          this.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range, internalPropertyName\r\n          );\r\n          return;\r\n        }\r\n      } else {\r\n        classPrototype.instanceMembers = new Map();\r\n      }\r\n      var instancePrototype = new FunctionPrototype(\r\n        this,\r\n        name, instanceName,\r\n        declaration,\r\n        classPrototype\r\n      );\r\n      if (isGetter) {\r\n        (<Property>propertyElement).getterPrototype = instancePrototype;\r\n      } else {\r\n        (<Property>propertyElement).setterPrototype = instancePrototype;\r\n      }\r\n      classPrototype.instanceMembers.set(name, propertyElement);\r\n      this.elements.set(internalPropertyName, propertyElement);\r\n    }\r\n  }\r\n\r\n  private initializeEnum(\r\n    declaration: EnumDeclaration,\r\n    namespace: Element | null = null\r\n  ): void {\r\n    var internalName = declaration.fileLevelInternalName;\r\n    if (this.elements.has(internalName)) {\r\n      this.error(\r\n        DiagnosticCode.Duplicate_identifier_0,\r\n        declaration.name.range, internalName\r\n      );\r\n      return;\r\n    }\r\n    var enm = new Enum(this, declaration.name.text, internalName, declaration);\r\n    enm.namespace = namespace;\r\n    this.elements.set(internalName, enm);\r\n\r\n    this.checkInternalDecorators(enm, declaration);\r\n\r\n    if (namespace) {\r\n      if (namespace.members) {\r\n        if (namespace.members.has(declaration.name.text)) {\r\n          this.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range, internalName\r\n          );\r\n          return;\r\n        }\r\n      } else {\r\n        namespace.members = new Map();\r\n      }\r\n      namespace.members.set(declaration.name.text, enm);\r\n    } else if (enm.is(ElementFlags.EXPORTED)) {\r\n      if (this.exports.has(internalName)) {\r\n        this.error(\r\n          DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\r\n          declaration.name.range, internalName\r\n        );\r\n        return;\r\n      }\r\n      this.exports.set(internalName, enm);\r\n    }\r\n\r\n    var values = declaration.values;\r\n    for (var i = 0, k = values.length; i < k; ++i) {\r\n      this.initializeEnumValue(values[i], enm);\r\n    }\r\n  }\r\n\r\n  private initializeEnumValue(\r\n    declaration: EnumValueDeclaration,\r\n    enm: Enum\r\n  ): void {\r\n    var name = declaration.name.text;\r\n    var internalName = declaration.fileLevelInternalName;\r\n    if (enm.members) {\r\n      if (enm.members.has(name)) {\r\n        this.error(\r\n          DiagnosticCode.Duplicate_identifier_0,\r\n          declaration.name.range, internalName\r\n        );\r\n        return;\r\n      }\r\n    } else {\r\n      enm.members = new Map();\r\n    }\r\n    var value = new EnumValue(enm, this, name, internalName, declaration);\r\n    enm.members.set(name, value);\r\n  }\r\n\r\n  private initializeExports(\r\n    statement: ExportStatement,\r\n    queuedExports: Map<string,QueuedExport>\r\n  ): void {\r\n    var members = statement.members;\r\n    for (var i = 0, k = members.length; i < k; ++i) {\r\n      this.initializeExport(members[i], statement.internalPath, queuedExports);\r\n    }\r\n  }\r\n\r\n  private setExportAndCheckLibrary(\r\n    name: string,\r\n    element: Element,\r\n    identifier: IdentifierExpression\r\n  ): void {\r\n    this.exports.set(name, element);\r\n    if (identifier.range.source.isLibrary) { // add global alias\r\n      if (this.elements.has(identifier.text)) {\r\n        this.error(\r\n          DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\r\n          identifier.range, identifier.text\r\n        );\r\n      } else {\r\n        element.internalName = identifier.text;\r\n        this.elements.set(identifier.text, element);\r\n      }\r\n    }\r\n  }\r\n\r\n  private initializeExport(\r\n    member: ExportMember,\r\n    internalPath: string | null,\r\n    queuedExports: Map<string,QueuedExport>\r\n  ): void {\r\n    var externalName = member.range.source.internalPath + PATH_DELIMITER + member.externalName.text;\r\n    if (this.exports.has(externalName)) {\r\n      this.error(\r\n        DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\r\n        member.externalName.range, externalName\r\n      );\r\n      return;\r\n    }\r\n    var referencedName: string;\r\n    var referencedElement: Element | null;\r\n    var queuedExport: QueuedExport | null;\r\n\r\n    // export local element\r\n    if (internalPath == null) {\r\n      referencedName = member.range.source.internalPath + PATH_DELIMITER + member.name.text;\r\n\r\n      // resolve right away if the element exists\r\n      if (referencedElement = this.elements.get(referencedName)) {\r\n        this.setExportAndCheckLibrary(\r\n          externalName,\r\n          referencedElement,\r\n          member.externalName\r\n        );\r\n        return;\r\n      }\r\n\r\n      // otherwise queue it\r\n      if (queuedExports.has(externalName)) {\r\n        this.error(\r\n          DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\r\n          member.externalName.range, externalName\r\n        );\r\n        return;\r\n      }\r\n      queuedExport = new QueuedExport();\r\n      queuedExport.isReExport = false;\r\n      queuedExport.referencedName = referencedName; // -> internal name\r\n      queuedExport.member = member;\r\n      queuedExports.set(externalName, queuedExport);\r\n\r\n    // export external element\r\n    } else {\r\n      referencedName = internalPath + PATH_DELIMITER + member.name.text;\r\n\r\n      // resolve right away if the export exists\r\n      referencedElement = this.elements.get(referencedName);\r\n      if (referencedElement) {\r\n        this.setExportAndCheckLibrary(\r\n          externalName,\r\n          referencedElement,\r\n          member.externalName\r\n        );\r\n        return;\r\n      }\r\n\r\n      // walk already known queued exports\r\n      var seen = new Set<QueuedExport>();\r\n      while (queuedExport = queuedExports.get(referencedName)) {\r\n        if (queuedExport.isReExport) {\r\n          referencedElement = this.exports.get(queuedExport.referencedName);\r\n          if (referencedElement) {\r\n            this.setExportAndCheckLibrary(\r\n              externalName,\r\n              referencedElement,\r\n              member.externalName\r\n            );\r\n            return;\r\n          }\r\n          referencedName = queuedExport.referencedName;\r\n          if (seen.has(queuedExport)) break;\r\n          seen.add(queuedExport);\r\n        } else {\r\n          referencedElement = this.elements.get(queuedExport.referencedName);\r\n          if (referencedElement) {\r\n            this.setExportAndCheckLibrary(\r\n              externalName,\r\n              referencedElement,\r\n              member.externalName\r\n            );\r\n            return;\r\n          }\r\n          break;\r\n        }\r\n      }\r\n\r\n      // otherwise queue it\r\n      if (queuedExports.has(externalName)) {\r\n        this.error(\r\n          DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\r\n          member.externalName.range, externalName\r\n        );\r\n        return;\r\n      }\r\n      queuedExport = new QueuedExport();\r\n      queuedExport.isReExport = true;\r\n      queuedExport.referencedName = referencedName; // -> export name\r\n      queuedExport.member = member;\r\n      queuedExports.set(externalName, queuedExport);\r\n    }\r\n  }\r\n\r\n  private initializeFunction(\r\n    declaration: FunctionDeclaration,\r\n    namespace: Element | null = null\r\n  ): void {\r\n    var internalName = declaration.fileLevelInternalName;\r\n    if (this.elements.has(internalName)) {\r\n      this.error(\r\n        DiagnosticCode.Duplicate_identifier_0,\r\n        declaration.name.range, internalName\r\n      );\r\n      return;\r\n    }\r\n    var prototype = new FunctionPrototype(\r\n      this,\r\n      declaration.name.text, internalName,\r\n      declaration,\r\n      null\r\n    );\r\n    prototype.namespace = namespace;\r\n    this.elements.set(internalName, prototype);\r\n\r\n    this.checkInternalDecorators(prototype, declaration);\r\n\r\n    if (namespace) {\r\n      if (namespace.members) {\r\n        if (namespace.members.has(declaration.name.text)) {\r\n          this.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range, internalName\r\n          );\r\n          return;\r\n        }\r\n      } else {\r\n        namespace.members = new Map();\r\n      }\r\n      namespace.members.set(declaration.name.text, prototype);\r\n    } else if (prototype.is(ElementFlags.EXPORTED)) {\r\n      if (this.exports.has(internalName)) {\r\n        this.error(\r\n          DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\r\n          declaration.name.range, internalName\r\n        );\r\n        return;\r\n      }\r\n      this.exports.set(internalName, prototype);\r\n    }\r\n  }\r\n\r\n  private initializeImports(\r\n    statement: ImportStatement,\r\n    queuedExports: Map<string,QueuedExport>,\r\n    queuedImports: QueuedImport[]\r\n  ): void {\r\n    var declarations = statement.declarations;\r\n    if (declarations) {\r\n      for (var i = 0, k = declarations.length; i < k; ++i) {\r\n        this.initializeImport(\r\n          declarations[i],\r\n          statement.internalPath,\r\n          queuedExports, queuedImports\r\n        );\r\n      }\r\n    } else if (statement.namespaceName) {\r\n      var internalName = (\r\n        statement.range.source.internalPath +\r\n        PATH_DELIMITER +\r\n        statement.namespaceName.text\r\n      );\r\n      if (this.elements.has(internalName)) {\r\n        this.error(\r\n          DiagnosticCode.Duplicate_identifier_0,\r\n          statement.namespaceName.range,\r\n          internalName\r\n        );\r\n        return;\r\n      }\r\n      this.error( // TODO\r\n        DiagnosticCode.Operation_not_supported,\r\n        statement.range\r\n      );\r\n    }\r\n  }\r\n\r\n  private initializeImport(\r\n    declaration: ImportDeclaration,\r\n    internalPath: string,\r\n    queuedExports: Map<string,QueuedExport>,\r\n    queuedImports: QueuedImport[]\r\n  ): void {\r\n    var internalName = declaration.fileLevelInternalName;\r\n    if (this.elements.has(internalName)) {\r\n      this.error(\r\n        DiagnosticCode.Duplicate_identifier_0,\r\n        declaration.name.range, internalName\r\n      );\r\n      return;\r\n    }\r\n\r\n    var referencedName = internalPath + PATH_DELIMITER + declaration.externalName.text;\r\n\r\n    // resolve right away if the exact export exists\r\n    var element: Element | null;\r\n    if (element = this.exports.get(referencedName)) {\r\n      this.elements.set(internalName, element);\r\n      return;\r\n    }\r\n\r\n    // otherwise queue it\r\n    var indexPart = PATH_DELIMITER + \"index\";\r\n    var queuedImport = new QueuedImport();\r\n    queuedImport.internalName = internalName;\r\n    if (internalPath.endsWith(indexPart)) {\r\n      queuedImport.referencedName = referencedName; // try exact first\r\n      queuedImport.referencedNameAlt = (\r\n        internalPath.substring(0, internalPath.length - indexPart.length + 1) +\r\n        declaration.externalName.text\r\n      );\r\n    } else {\r\n      queuedImport.referencedName = referencedName; // try exact first\r\n      queuedImport.referencedNameAlt = (\r\n        internalPath +\r\n        indexPart +\r\n        PATH_DELIMITER +\r\n        declaration.externalName.text\r\n      );\r\n    }\r\n    queuedImport.declaration = declaration;\r\n    queuedImports.push(queuedImport);\r\n  }\r\n\r\n  private initializeInterface(declaration: InterfaceDeclaration, namespace: Element | null = null): void {\r\n    var internalName = declaration.fileLevelInternalName;\r\n    if (this.elements.has(internalName)) {\r\n      this.error(\r\n        DiagnosticCode.Duplicate_identifier_0,\r\n        declaration.name.range, internalName\r\n      );\r\n      return;\r\n    }\r\n    var prototype = new InterfacePrototype(this, declaration.name.text, internalName, declaration);\r\n    prototype.namespace = namespace;\r\n    this.elements.set(internalName, prototype);\r\n\r\n    this.checkInternalDecorators(prototype, declaration);\r\n\r\n    if (namespace) {\r\n      if (namespace.members) {\r\n        if (namespace.members.has(prototype.internalName)) {\r\n          this.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range, internalName\r\n          );\r\n          return;\r\n        }\r\n      } else {\r\n        namespace.members = new Map();\r\n      }\r\n      namespace.members.set(prototype.internalName, prototype);\r\n    } else if (prototype.is(ElementFlags.EXPORTED)) {\r\n      if (this.exports.has(internalName)) {\r\n        this.error(\r\n          DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\r\n          declaration.name.range, internalName\r\n        );\r\n        return;\r\n      }\r\n      this.exports.set(internalName, prototype);\r\n    }\r\n\r\n    var memberDeclarations = declaration.members;\r\n    for (var i = 0, k = memberDeclarations.length; i < k; ++i) {\r\n      var memberDeclaration = memberDeclarations[i];\r\n      switch (memberDeclaration.kind) {\r\n\r\n        case NodeKind.FIELDDECLARATION:\r\n          this.initializeField(<FieldDeclaration>memberDeclaration, prototype);\r\n          break;\r\n\r\n        case NodeKind.METHODDECLARATION:\r\n          var isGetter = hasModifier(ModifierKind.GET, memberDeclaration.modifiers);\r\n          if (isGetter || hasModifier(ModifierKind.SET, memberDeclaration.modifiers)) {\r\n            this.initializeAccessor(<MethodDeclaration>memberDeclaration, prototype, isGetter);\r\n          } else {\r\n            this.initializeMethod(<MethodDeclaration>memberDeclaration, prototype);\r\n          }\r\n          break;\r\n\r\n        default:\r\n          throw new Error(\"interface member expected\");\r\n      }\r\n    }\r\n  }\r\n\r\n  private initializeNamespace(\r\n    declaration: NamespaceDeclaration,\r\n    queuedExtendingClasses: ClassPrototype[],\r\n    parentNamespace: Element | null = null\r\n  ): void {\r\n    var internalName = declaration.fileLevelInternalName;\r\n\r\n    var namespace = this.elements.get(internalName);\r\n    if (!namespace) {\r\n      namespace = new Namespace(this, declaration.name.text, internalName, declaration);\r\n      namespace.namespace = parentNamespace;\r\n      this.elements.set(internalName, namespace);\r\n      this.checkInternalDecorators(namespace, declaration);\r\n    }\r\n\r\n    if (parentNamespace) {\r\n      if (parentNamespace.members) {\r\n        if (parentNamespace.members.has(declaration.name.text)) {\r\n          this.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range, internalName\r\n          );\r\n          return;\r\n        }\r\n      } else {\r\n        parentNamespace.members = new Map();\r\n      }\r\n      parentNamespace.members.set(declaration.name.text, namespace);\r\n    } else if (namespace.is(ElementFlags.EXPORTED)) {\r\n      if (this.exports.has(internalName)) {\r\n        this.error(\r\n          DiagnosticCode.Export_declaration_conflicts_with_exported_declaration_of_0,\r\n          declaration.name.range, internalName\r\n        );\r\n        return;\r\n      }\r\n      this.exports.set(internalName, namespace);\r\n    }\r\n\r\n    var members = declaration.members;\r\n    for (var i = 0, k = members.length; i < k; ++i) {\r\n      switch (members[i].kind) {\r\n\r\n        case NodeKind.CLASSDECLARATION:\r\n          this.initializeClass(<ClassDeclaration>members[i], queuedExtendingClasses, namespace);\r\n          break;\r\n\r\n        case NodeKind.ENUMDECLARATION:\r\n          this.initializeEnum(<EnumDeclaration>members[i], namespace);\r\n          break;\r\n\r\n        case NodeKind.FUNCTIONDECLARATION:\r\n          this.initializeFunction(<FunctionDeclaration>members[i], namespace);\r\n          break;\r\n\r\n        case NodeKind.INTERFACEDECLARATION:\r\n          this.initializeInterface(<InterfaceDeclaration>members[i], namespace);\r\n          break;\r\n\r\n        case NodeKind.NAMESPACEDECLARATION:\r\n          this.initializeNamespace(<NamespaceDeclaration>members[i], queuedExtendingClasses, namespace);\r\n          break;\r\n\r\n        case NodeKind.TYPEDECLARATION:\r\n          // this.initializeTypeAlias(<TypeDeclaration>members[i], namespace);\r\n          // TODO: what about namespaced types?\r\n          this.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            members[i].range\r\n          );\r\n          break;\r\n\r\n        case NodeKind.VARIABLE:\r\n          this.initializeVariables(<VariableStatement>members[i], namespace);\r\n          break;\r\n\r\n        default:\r\n          throw new Error(\"namespace member expected\");\r\n      }\r\n    }\r\n  }\r\n\r\n  private initializeTypeAlias(declaration: TypeDeclaration, namespace: Element | null = null): void {\r\n    // type aliases are program globals\r\n    // TODO: what about namespaced types?\r\n    var name = declaration.name.text;\r\n    if (this.types.has(name) || this.typeAliases.has(name)) {\r\n      this.error(\r\n        DiagnosticCode.Duplicate_identifier_0,\r\n        declaration.name.range, name\r\n      );\r\n      return;\r\n    }\r\n    this.typeAliases.set(name, declaration.alias);\r\n  }\r\n\r\n  private initializeVariables(statement: VariableStatement, namespace: Element | null = null): void {\r\n    var declarations = statement.declarations;\r\n    for (var i = 0, k = declarations.length; i < k; ++i) {\r\n      var declaration = declarations[i];\r\n      var internalName = declaration.fileLevelInternalName;\r\n      if (this.elements.has(internalName)) {\r\n        this.error(\r\n          DiagnosticCode.Duplicate_identifier_0,\r\n          declaration.name.range, internalName\r\n        );\r\n        continue;\r\n      }\r\n\r\n      var global = new Global(\r\n        this,\r\n        declaration.name.text,\r\n        internalName,\r\n        declaration,\r\n        Type.void // resolved later on\r\n      );\r\n      global.namespace = namespace;\r\n      this.elements.set(internalName, global);\r\n\r\n      this.checkInternalDecorators(global, declaration);\r\n\r\n      if (namespace) {\r\n        if (namespace.members) {\r\n          if (namespace.members.has(declaration.name.text)) {\r\n            this.error(\r\n              DiagnosticCode.Duplicate_identifier_0,\r\n              declaration.name.range, internalName\r\n            );\r\n            continue;\r\n          }\r\n        } else {\r\n          namespace.members = new Map();\r\n        }\r\n        namespace.members.set(declaration.name.text, global);\r\n      } else if (global.is(ElementFlags.EXPORTED)) {\r\n        if (this.exports.has(internalName)) {\r\n          this.error(\r\n            DiagnosticCode.Duplicate_identifier_0,\r\n            declaration.name.range, internalName\r\n          );\r\n        } else {\r\n          this.exports.set(internalName, global);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Resolves a {@link TypeNode} to a concrete {@link Type}. */\r\n  resolveType(\r\n    node: TypeNode,\r\n    contextualTypeArguments: Map<string,Type> | null = null,\r\n    reportNotFound: bool = true\r\n  ): Type | null {\r\n    var globalName = node.name.text;\r\n    var localName = node.range.source.internalPath + PATH_DELIMITER + node.name.text;\r\n\r\n    var element: Element | null;\r\n\r\n    // check file-global / program-global element\r\n    if ((element = this.elements.get(localName)) || (element = this.elements.get(globalName))) {\r\n      switch (element.kind) {\r\n        case ElementKind.CLASS_PROTOTYPE:\r\n          var instance = (<ClassPrototype>element).resolveInclTypeArguments(\r\n            node.typeArguments,\r\n            contextualTypeArguments,\r\n            null\r\n          ); // reports\r\n          return instance ? instance.type : null;\r\n      }\r\n    }\r\n\r\n    // resolve parameters\r\n    var k = node.typeArguments.length;\r\n    var paramTypes = new Array<Type>(k);\r\n    for (var i = 0; i < k; ++i) {\r\n      var paramType = this.resolveType( // reports\r\n        node.typeArguments[i],\r\n        contextualTypeArguments,\r\n        reportNotFound\r\n      );\r\n      if (!paramType) return null;\r\n      paramTypes[i] = paramType;\r\n    }\r\n\r\n    if (k) { // can't be a placeholder if it has parameters\r\n      var instanceKey = typesToString(paramTypes);\r\n      if (instanceKey.length) {\r\n        localName += \"<\" + instanceKey + \">\";\r\n        globalName += \"<\" + instanceKey + \">\";\r\n      }\r\n    } else if (contextualTypeArguments) {\r\n      var placeholderType = contextualTypeArguments.get(globalName);\r\n      if (placeholderType) return placeholderType;\r\n    }\r\n\r\n    var type: Type | null;\r\n\r\n    // check file-global / program-global type\r\n    if ((type = this.types.get(localName)) || (type = this.types.get(globalName))) {\r\n      return type;\r\n    }\r\n\r\n    // check type alias\r\n    var alias = this.typeAliases.get(globalName);\r\n    if (alias && (type = this.resolveType(alias, null, reportNotFound))) {\r\n      return type;\r\n    }\r\n\r\n    if (reportNotFound) {\r\n      this.error(\r\n        DiagnosticCode.Cannot_find_name_0,\r\n        node.name.range, globalName\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /** Resolves an array of type parameters to concrete types. */\r\n  resolveTypeArguments(\r\n    typeParameters: TypeParameter[],\r\n    typeArgumentNodes: TypeNode[] | null,\r\n    contextualTypeArguments: Map<string,Type> | null = null,\r\n    alternativeReportNode: Node | null = null\r\n  ): Type[] | null {\r\n    var parameterCount = typeParameters.length;\r\n    var argumentCount = typeArgumentNodes ? typeArgumentNodes.length : 0;\r\n    if (parameterCount != argumentCount) {\r\n      if (argumentCount) {\r\n        this.error(\r\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n          Range.join(\r\n            (<TypeNode[]>typeArgumentNodes)[0].range,\r\n            (<TypeNode[]>typeArgumentNodes)[argumentCount - 1].range\r\n          ),\r\n          parameterCount.toString(10), argumentCount.toString(10)\r\n        );\r\n      } else if (alternativeReportNode) {\r\n        this.error(\r\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n          alternativeReportNode.range.atEnd, parameterCount.toString(10), \"0\"\r\n        );\r\n      }\r\n      return null;\r\n    }\r\n    var typeArguments = new Array<Type>(parameterCount);\r\n    for (var i = 0; i < parameterCount; ++i) {\r\n      var type = this.resolveType( // reports\r\n        (<TypeNode[]>typeArgumentNodes)[i],\r\n        contextualTypeArguments,\r\n        true\r\n      );\r\n      if (!type) return null;\r\n      // TODO: check extendsType\r\n      typeArguments[i] = type;\r\n    }\r\n    return typeArguments;\r\n  }\r\n\r\n  /** Resolves an identifier to the element it refers to. */\r\n  resolveIdentifier(\r\n    identifier: IdentifierExpression,\r\n    contextualFunction: Function | null,\r\n    contextualEnum: Enum | null = null\r\n  ): ResolvedElement | null {\r\n    var name = identifier.text;\r\n\r\n    var element: Element | null;\r\n    var namespace: Element | null;\r\n\r\n    // check siblings\r\n    if (contextualEnum) {\r\n\r\n      if (\r\n        contextualEnum.members &&\r\n        (element = contextualEnum.members.get(name)) &&\r\n        element.kind == ElementKind.ENUMVALUE\r\n      ) {\r\n        if (!resolvedElement) resolvedElement = new ResolvedElement();\r\n        return resolvedElement.set(element);\r\n      }\r\n\r\n    } else if (contextualFunction) {\r\n\r\n      // check locals\r\n      if (element = contextualFunction.flow.getScopedLocal(name)) {\r\n        if (!resolvedElement) resolvedElement = new ResolvedElement();\r\n        return resolvedElement.set(element);\r\n      }\r\n\r\n      // search contextual parent namespaces if applicable\r\n      if (namespace = contextualFunction.prototype.namespace) {\r\n        do {\r\n          if (element = this.elements.get(namespace.internalName + STATIC_DELIMITER + name)) {\r\n            if (!resolvedElement) resolvedElement = new ResolvedElement();\r\n            return resolvedElement.set(element);\r\n          }\r\n        } while (namespace = namespace.namespace);\r\n      }\r\n    }\r\n\r\n    // search current file\r\n    if (element = this.elements.get(identifier.range.source.internalPath + PATH_DELIMITER + name)) {\r\n      if (!resolvedElement) resolvedElement = new ResolvedElement();\r\n      return resolvedElement.set(element);\r\n    }\r\n\r\n    // search global scope\r\n    if (element = this.elements.get(name)) {\r\n      if (!resolvedElement) resolvedElement = new ResolvedElement();\r\n      return resolvedElement.set(element);\r\n    }\r\n\r\n    this.error(\r\n      DiagnosticCode.Cannot_find_name_0,\r\n      identifier.range, name\r\n    );\r\n    return null;\r\n  }\r\n\r\n  /** Resolves a property access to the element it refers to. */\r\n  resolvePropertyAccess(\r\n    propertyAccess: PropertyAccessExpression,\r\n    contextualFunction: Function\r\n  ): ResolvedElement | null {\r\n    // start by resolving the lhs target (expression before the last dot)\r\n    var targetExpression = propertyAccess.expression;\r\n    resolvedElement = this.resolveExpression(targetExpression, contextualFunction); // reports\r\n    if (!resolvedElement) return null;\r\n    var target = resolvedElement.element;\r\n\r\n    // at this point we know exactly what the target is, so look up the element within\r\n    var propertyName = propertyAccess.property.text;\r\n    var targetType: Type;\r\n    var member: Element | null;\r\n\r\n    // Resolve variable-likes to their class type first\r\n    switch (target.kind) {\r\n\r\n      case ElementKind.GLOBAL:\r\n      case ElementKind.LOCAL:\r\n      case ElementKind.FIELD:\r\n        if (!(targetType = (<VariableLikeElement>target).type).classType) {\r\n          this.error(\r\n            DiagnosticCode.Property_0_does_not_exist_on_type_1,\r\n            propertyAccess.property.range, propertyName, targetType.toString()\r\n          );\r\n          return null;\r\n        }\r\n        target = <Class>targetType.classType;\r\n        break;\r\n\r\n      case ElementKind.PROPERTY:\r\n        var getter = assert((<Property>target).getterPrototype).resolve(); // reports\r\n        if (!getter) return null;\r\n        if (!(targetType = getter.returnType).classType) {\r\n          this.error(\r\n            DiagnosticCode.Property_0_does_not_exist_on_type_1,\r\n            propertyAccess.property.range, propertyName, targetType.toString()\r\n          );\r\n          return null;\r\n        }\r\n        target = <Class>targetType.classType;\r\n        break;\r\n    }\r\n\r\n    // Look up the member within\r\n    switch (target.kind) {\r\n\r\n      case ElementKind.CLASS_PROTOTYPE:\r\n      case ElementKind.CLASS:\r\n        do {\r\n          if (target.members && (member = target.members.get(propertyName))) {\r\n            return resolvedElement.set(member).withTarget(target, targetExpression);\r\n          }\r\n          // check inherited static members on the base prototype while target is a class prototype\r\n          if (target.kind == ElementKind.CLASS_PROTOTYPE) {\r\n            if ((<ClassPrototype>target).basePrototype) {\r\n              target = <ClassPrototype>(<ClassPrototype>target).basePrototype;\r\n            } else {\r\n              break;\r\n            }\r\n          // or inherited instance members on the cbase class while target is a class instance\r\n          } else if (target.kind == ElementKind.CLASS) {\r\n            if ((<Class>target).base) {\r\n              target = <Class>(<Class>target).base;\r\n            } else {\r\n              break;\r\n            }\r\n          } else {\r\n            break;\r\n          }\r\n        } while (true);\r\n        break;\r\n\r\n      default: // enums or other namespace-like elements\r\n        if (target.members && (member = target.members.get(propertyName))) {\r\n          return resolvedElement.set(member).withTarget(target, targetExpression);\r\n        }\r\n        break;\r\n    }\r\n    this.error(\r\n      DiagnosticCode.Property_0_does_not_exist_on_type_1,\r\n      propertyAccess.property.range, propertyName, target.internalName\r\n    );\r\n    return null;\r\n  }\r\n\r\n  resolveElementAccess(elementAccess: ElementAccessExpression, contextualFunction: Function): ResolvedElement | null {\r\n    // start by resolving the lhs target (expression before the last dot)\r\n    var targetExpression = elementAccess.expression;\r\n    resolvedElement = this.resolveExpression(targetExpression, contextualFunction);\r\n    if (!resolvedElement) return null;\r\n    var target = resolvedElement.element;\r\n    switch (target.kind) {\r\n\r\n      case ElementKind.GLOBAL:\r\n      case ElementKind.LOCAL:\r\n      case ElementKind.FIELD:\r\n        var type = (<VariableLikeElement>target).type;\r\n        if (type.classType) {\r\n          var indexedGetName = (target = type.classType).prototype.fnIndexedGet;\r\n          var indexedGet: Element | null;\r\n          if (\r\n            indexedGetName != null &&\r\n            target.members &&\r\n            (indexedGet = target.members.get(indexedGetName)) &&\r\n            indexedGet.kind == ElementKind.FUNCTION_PROTOTYPE\r\n          ) {\r\n            return resolvedElement.set(indexedGet).withTarget(type.classType, targetExpression);\r\n          }\r\n        }\r\n        break;\r\n    }\r\n    this.error(\r\n      DiagnosticCode.Index_signature_is_missing_in_type_0,\r\n      targetExpression.range, target.internalName\r\n    );\r\n    return null;\r\n  }\r\n\r\n  resolveExpression(expression: Expression, contextualFunction: Function): ResolvedElement | null {\r\n    var classType: Class | null;\r\n\r\n    while (expression.kind == NodeKind.PARENTHESIZED) {\r\n      expression = (<ParenthesizedExpression>expression).expression;\r\n    }\r\n\r\n    switch (expression.kind) {\r\n\r\n      case NodeKind.ASSERTION:\r\n        var type = this.resolveType((<AssertionExpression>expression).toType); // reports\r\n        if (type && (classType = type.classType)) {\r\n          if (!resolvedElement) resolvedElement = new ResolvedElement();\r\n          return resolvedElement.set(classType);\r\n        }\r\n        return null;\r\n\r\n      case NodeKind.BINARY:\r\n        // TODO: string concatenation, mostly\r\n        throw new Error(\"not implemented\");\r\n\r\n      case NodeKind.THIS: // -> Class\r\n        if (classType = contextualFunction.instanceMethodOf) {\r\n          if (!resolvedElement) resolvedElement = new ResolvedElement();\r\n          return resolvedElement.set(classType);\r\n        }\r\n        this.error(\r\n          DiagnosticCode._this_cannot_be_referenced_in_current_location,\r\n          expression.range\r\n        );\r\n        return null;\r\n\r\n      case NodeKind.SUPER: // -> Class\r\n        if ((classType = contextualFunction.instanceMethodOf) && (classType = classType.base)) {\r\n          if (!resolvedElement) resolvedElement = new ResolvedElement();\r\n          return resolvedElement.set(classType);\r\n        }\r\n        this.error(\r\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\r\n          expression.range\r\n        );\r\n        return null;\r\n\r\n      case NodeKind.IDENTIFIER:\r\n        return this.resolveIdentifier(<IdentifierExpression>expression, contextualFunction);\r\n\r\n      case NodeKind.PROPERTYACCESS:\r\n        return this.resolvePropertyAccess(<PropertyAccessExpression>expression, contextualFunction);\r\n\r\n      case NodeKind.ELEMENTACCESS:\r\n        return this.resolveElementAccess(<ElementAccessExpression>expression, contextualFunction);\r\n\r\n      case NodeKind.CALL:\r\n        var resolved = this.resolveExpression((<CallExpression>expression).expression, contextualFunction);\r\n        if (resolved) {\r\n          var element = resolved.element;\r\n          if (element && element.kind == ElementKind.FUNCTION_PROTOTYPE) {\r\n            var instance = (<FunctionPrototype>element).resolveInclTypeArguments(\r\n              (<CallExpression>expression).typeArguments,\r\n              null,\r\n              expression\r\n            );\r\n            if (instance && instance.returnType.classType) {\r\n              if (!resolvedElement) resolvedElement = new ResolvedElement();\r\n              return resolvedElement.set(instance.returnType.classType);\r\n            }\r\n          }\r\n        }\r\n        break;\r\n    }\r\n    this.error(\r\n      DiagnosticCode.Operation_not_supported,\r\n      expression.range\r\n    );\r\n    return null;\r\n  }\r\n}\r\n\r\n/** Common result structure returned when calling any of the resolve functions on a {@link Program}. */\r\nexport class ResolvedElement {\r\n\r\n  /** The target element, if a property or element access */\r\n  target: Element | null;\r\n  /** The target element's expression, if a property or element access. */\r\n  targetExpression: Expression | null;\r\n  /** The element being accessed. */\r\n  element: Element;\r\n\r\n  /** Clears the target and sets the resolved element. */\r\n  set(element: Element): this {\r\n    this.target = null;\r\n    this.targetExpression = null;\r\n    this.element = element;\r\n    return this;\r\n  }\r\n\r\n  /** Sets the resolved target in addition to the previously set element. */\r\n  withTarget(target: Element, targetExpression: Expression): this {\r\n    this.target = target;\r\n    this.targetExpression = targetExpression;\r\n    return this;\r\n  }\r\n}\r\n\r\n// Cached result structure instance\r\nvar resolvedElement: ResolvedElement | null;\r\n\r\n/** Indicates the specific kind of an {@link Element}. */\r\nexport enum ElementKind {\r\n  /** A {@link Global}. */\r\n  GLOBAL,\r\n  /** A {@link Local}. */\r\n  LOCAL,\r\n  /** An {@link Enum}. */\r\n  ENUM,\r\n  /** An {@link EnumValue}. */\r\n  ENUMVALUE,\r\n  /** A {@link FunctionPrototype}. */\r\n  FUNCTION_PROTOTYPE,\r\n  /** A {@link Function}. */\r\n  FUNCTION,\r\n  /** A {@link ClassPrototype}. */\r\n  CLASS_PROTOTYPE,\r\n  /** A {@link Class}. */\r\n  CLASS,\r\n  /** An {@link InterfacePrototype}. */\r\n  INTERFACE_PROTOTYPE,\r\n  /** An {@link Interface}. */\r\n  INTERFACE,\r\n  /** A {@link FieldPrototype}. */\r\n  FIELD_PROTOTYPE,\r\n  /** A {@link Field}. */\r\n  FIELD,\r\n  /** A {@link Property}. */\r\n  PROPERTY,\r\n  /** A {@link Namespace}. */\r\n  NAMESPACE\r\n}\r\n\r\n/** Indicates traits of an {@link Element}. */\r\nexport enum ElementFlags {\r\n  /** No flags set. */\r\n  NONE = 0,\r\n  /** Is compiled. */\r\n  COMPILED = 1 << 0,\r\n  /** Is an import. */\r\n  IMPORTED = 1 << 1,\r\n  /** Is an export. */\r\n  EXPORTED = 1 << 2,\r\n  /** Is built-in. */\r\n  BUILTIN = 1 << 3,\r\n  /** Is declared. */\r\n  DECLARED = 1 << 4,\r\n  /** Is generic. */\r\n  GENERIC = 1 << 5,\r\n  /** Is constant. */\r\n  CONSTANT = 1 << 6,\r\n  /** Has a constant value and is therefore inlined. */\r\n  INLINED = 1 << 7,\r\n  /** Is instance member. */\r\n  INSTANCE = 1 << 8,\r\n  /** Is getter. */\r\n  GETTER = 1 << 9,\r\n  /** Is setter. */\r\n  SETTER = 1 << 10,\r\n  /** Is global. */\r\n  GLOBAL = 1 << 11,\r\n  /** Is read-only. */\r\n  READONLY = 1 << 12,\r\n  /** Is a public member. */\r\n  PUBLIC = 1 << 13,\r\n  /** Is a protected member. */\r\n  PROTECTED = 1 << 14,\r\n  /** Is a private member. */\r\n  PRIVATE = 1 << 15,\r\n  /** Is an abstract member. */\r\n  ABSTRACT = 1 << 16,\r\n  /** Is a constructor. */\r\n  CONSTRUCTOR = 1 << 17,\r\n  /** Is an unmanaged class with limited capabilites. */\r\n  UNMANAGED = 1 << 18,\r\n  /** Is scoped. */\r\n  SCOPED = 1 << 19,\r\n  /** Is the start function. */\r\n  START = 1 << 20\r\n}\r\n\r\n/** Base class of all program elements. */\r\nexport abstract class Element {\r\n\r\n  /** Specific element kind. */\r\n  kind: ElementKind;\r\n  /** Containing {@link Program}. */\r\n  program: Program;\r\n  /** Simple name. */\r\n  simpleName: string;\r\n  /** Internal name referring to this element. */\r\n  internalName: string;\r\n  /** Element flags. */\r\n  flags: ElementFlags = ElementFlags.NONE;\r\n  /** Namespaced member elements. */\r\n  members: Map<string,Element> | null = null;\r\n  /** Parent namespace, if applicable. */\r\n  namespace: Element | null = null;\r\n\r\n  /** Constructs a new element, linking it to its containing {@link Program}. */\r\n  protected constructor(program: Program, simpleName: string, internalName: string) {\r\n    this.program = program;\r\n    this.simpleName = simpleName;\r\n    this.internalName = internalName;\r\n  }\r\n\r\n  /** Tests if this element has a specific flag or flags. */\r\n  is(flag: ElementFlags): bool { return (this.flags & flag) == flag; }\r\n\r\n  /** Sets a specific flag or flags. */\r\n  set(flag: ElementFlags): void { this.flags |= flag; }\r\n}\r\n\r\n/** A namespace. */\r\nexport class Namespace extends Element {\r\n\r\n  // All elements have namespace semantics. This is an explicitly declared one.\r\n  kind = ElementKind.NAMESPACE;\r\n\r\n  /** Declaration reference. */\r\n  declaration: NamespaceDeclaration; // more specific\r\n\r\n  /** Constructs a new namespace. */\r\n  constructor(\r\n    program: Program,\r\n    simpleName: string,\r\n    internalName: string,\r\n    declaration: NamespaceDeclaration\r\n  ) {\r\n    super(program, simpleName, internalName);\r\n    this.declaration = declaration;\r\n    if (this.declaration.modifiers) {\r\n      for (var i = 0, k = this.declaration.modifiers.length; i < k; ++i) {\r\n        switch (this.declaration.modifiers[i].modifierKind) {\r\n          case ModifierKind.IMPORT: this.set(ElementFlags.IMPORTED); break;\r\n          case ModifierKind.EXPORT: this.set(ElementFlags.EXPORTED); break;\r\n          case ModifierKind.DECLARE: this.set(ElementFlags.DECLARED); break;\r\n          default: throw new Error(\"unexpected modifier\");\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/** An enum. */\r\nexport class Enum extends Element {\r\n\r\n  kind = ElementKind.ENUM;\r\n\r\n  /** Declaration reference. */\r\n  declaration: EnumDeclaration;\r\n\r\n  /** Constructs a new enum. */\r\n  constructor(\r\n    program: Program,\r\n    simpleName: string,\r\n    internalName: string,\r\n    declaration: EnumDeclaration\r\n  ) {\r\n    super(program, simpleName, internalName);\r\n    this.declaration = declaration;\r\n    if (this.declaration.modifiers) {\r\n      for (var i = 0, k = this.declaration.modifiers.length; i < k; ++i) {\r\n        switch (this.declaration.modifiers[i].modifierKind) {\r\n          case ModifierKind.EXPORT: this.set(ElementFlags.EXPORTED); break;\r\n          case ModifierKind.IMPORT: this.set(ElementFlags.IMPORTED); break;\r\n          case ModifierKind.DECLARE: this.set(ElementFlags.DECLARED); break;\r\n          case ModifierKind.CONST: this.set(ElementFlags.CONSTANT); break;\r\n          default: throw new Error(\"unexpected modifier\");\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/** An enum value. */\r\nexport class EnumValue extends Element {\r\n\r\n  kind = ElementKind.ENUMVALUE;\r\n\r\n  /** Declaration reference. */\r\n  declaration: EnumValueDeclaration;\r\n  /** Parent enum. */\r\n  enum: Enum;\r\n  /** Constant value, if applicable. */\r\n  constantValue: i32 = 0;\r\n\r\n  constructor(\r\n    enm: Enum,\r\n    program: Program,\r\n    simpleName: string,\r\n    internalName: string,\r\n    declaration: EnumValueDeclaration\r\n  ) {\r\n    super(program, simpleName, internalName);\r\n    this.enum = enm;\r\n    this.declaration = declaration;\r\n  }\r\n}\r\n\r\nexport const enum ConstantValueKind {\r\n  NONE,\r\n  INTEGER,\r\n  FLOAT\r\n}\r\n\r\nexport class VariableLikeElement extends Element {\r\n\r\n  // kind varies\r\n\r\n  /** Declaration reference. */\r\n  declaration: VariableLikeDeclarationStatement;\r\n  /** Variable type. Is {@link Type.void} for type-inferred {@link Global}s before compilation. */\r\n  type: Type;\r\n  /** Constant value kind. */\r\n  constantValueKind: ConstantValueKind = ConstantValueKind.NONE;\r\n  /** Constant integer value, if applicable. */\r\n  constantIntegerValue: I64;\r\n  /** Constant float value, if applicable. */\r\n  constantFloatValue: f64;\r\n\r\n  withConstantIntegerValue(lo: i32, hi: i32): this {\r\n    this.constantValueKind = ConstantValueKind.INTEGER;\r\n    this.constantIntegerValue = i64_new(lo, hi);\r\n    this.set(ElementFlags.CONSTANT | ElementFlags.INLINED);\r\n    return this;\r\n  }\r\n\r\n  withConstantFloatValue(value: f64): this {\r\n    this.constantValueKind = ConstantValueKind.FLOAT;\r\n    this.constantFloatValue = value;\r\n    this.set(ElementFlags.CONSTANT | ElementFlags.INLINED);\r\n    return this;\r\n  }\r\n}\r\n\r\n/** A global variable. */\r\nexport class Global extends VariableLikeElement {\r\n\r\n  kind = ElementKind.GLOBAL;\r\n\r\n  constructor(\r\n    program: Program,\r\n    simpleName: string,\r\n    internalName: string,\r\n    declaration: VariableLikeDeclarationStatement,\r\n    type: Type\r\n  ) {\r\n    super(program, simpleName, internalName);\r\n    this.declaration = declaration;\r\n    if (this.declaration.modifiers) {\r\n      for (var i = 0, k = this.declaration.modifiers.length; i < k; ++i) {\r\n        switch (this.declaration.modifiers[i].modifierKind) {\r\n\r\n          case ModifierKind.IMPORT:\r\n            this.set(ElementFlags.IMPORTED);\r\n            break;\r\n\r\n          case ModifierKind.EXPORT:\r\n            this.set(ElementFlags.EXPORTED);\r\n            break;\r\n\r\n          case ModifierKind.CONST:\r\n            this.set(ElementFlags.CONSTANT);\r\n            break;\r\n\r\n          case ModifierKind.LET:\r\n            this.set(ElementFlags.SCOPED);\r\n            break;\r\n\r\n          case ModifierKind.DECLARE:\r\n            this.set(ElementFlags.DECLARED);\r\n            break;\r\n\r\n          case ModifierKind.READONLY:\r\n            this.set(this.declaration.initializer\r\n              ? ElementFlags.CONSTANT | ElementFlags.READONLY\r\n              : ElementFlags.READONLY\r\n            );\r\n            break;\r\n\r\n          case ModifierKind.PUBLIC:\r\n          case ModifierKind.PRIVATE:\r\n          case ModifierKind.PROTECTED:\r\n          case ModifierKind.STATIC:\r\n            break; // static fields become globals\r\n\r\n          default:\r\n            throw new Error(\"unexpected modifier\");\r\n        }\r\n      }\r\n    }\r\n    this.type = type; // resolved later if `void`\r\n  }\r\n}\r\n\r\n/** A function parameter. */\r\nexport class Parameter {\r\n\r\n  // not an Element on its own\r\n\r\n  /** Parameter name. */\r\n  name: string;\r\n  /** Parameter type. */\r\n  type: Type;\r\n  /** Parameter initializer. */\r\n  initializer: Expression | null;\r\n\r\n  /** Constructs a new function parameter. */\r\n  constructor(name: string, type: Type, initializer: Expression | null = null) {\r\n    this.name = name;\r\n    this.type = type;\r\n    this.initializer = initializer;\r\n  }\r\n}\r\n\r\n/** A function local. */\r\nexport class Local extends VariableLikeElement {\r\n\r\n  kind = ElementKind.LOCAL;\r\n\r\n  /** Local index. */\r\n  index: i32;\r\n\r\n  constructor(program: Program, simpleName: string, index: i32, type: Type) {\r\n    super(program, simpleName, simpleName);\r\n    this.index = index;\r\n    this.type = type;\r\n  }\r\n}\r\n\r\n/** A yet unresolved function prototype. */\r\nexport class FunctionPrototype extends Element {\r\n\r\n  kind = ElementKind.FUNCTION_PROTOTYPE;\r\n\r\n  /** Declaration reference. */\r\n  declaration: FunctionDeclaration;\r\n  /** If an instance method, the class prototype reference. */\r\n  classPrototype: ClassPrototype | null;\r\n  /** Resolved instances. */\r\n  instances: Map<string,Function> = new Map();\r\n  /** Class type arguments, if a partially resolved method of a generic class. */\r\n  classTypeArguments: Type[] | null = null;\r\n\r\n  /** Constructs a new function prototype. */\r\n  constructor(\r\n    program: Program,\r\n    simpleName: string,\r\n    internalName: string,\r\n    declaration: FunctionDeclaration,\r\n    classPrototype: ClassPrototype | null = null\r\n  ) {\r\n    super(program, simpleName, internalName);\r\n    this.declaration = declaration;\r\n    if (this.declaration.modifiers) {\r\n      for (var i = 0, k = this.declaration.modifiers.length; i < k; ++i) {\r\n        switch (this.declaration.modifiers[i].modifierKind) {\r\n\r\n          case ModifierKind.IMPORT:\r\n            this.set(ElementFlags.IMPORTED);\r\n            break;\r\n\r\n          case ModifierKind.EXPORT:\r\n            this.set(ElementFlags.EXPORTED);\r\n            break;\r\n\r\n          case ModifierKind.DECLARE:\r\n            this.set(ElementFlags.DECLARED);\r\n            break;\r\n\r\n          case ModifierKind.GET:\r\n            this.set(ElementFlags.GETTER);\r\n            break;\r\n\r\n          case ModifierKind.SET:\r\n            this.set(ElementFlags.SETTER);\r\n            break;\r\n\r\n          case ModifierKind.STATIC:\r\n          case ModifierKind.ABSTRACT:\r\n          case ModifierKind.PRIVATE:\r\n          case ModifierKind.PROTECTED:\r\n          case ModifierKind.PUBLIC:\r\n            break; // already handled\r\n\r\n          default:\r\n            throw new Error(\"unexpected modifier\");\r\n        }\r\n      }\r\n    }\r\n    if (this.declaration.isGeneric) {\r\n      this.set(ElementFlags.GENERIC);\r\n    }\r\n    if (this.classPrototype = classPrototype) {\r\n      this.set(ElementFlags.INSTANCE);\r\n    }\r\n  }\r\n\r\n  resolve(\r\n    functionTypeArguments: Type[] | null = null,\r\n    contextualTypeArguments: Map<string,Type> | null = null\r\n  ): Function | null {\r\n    var instanceKey = functionTypeArguments ? typesToString(functionTypeArguments) : \"\";\r\n    var instance = this.instances.get(instanceKey);\r\n    if (instance) return instance;\r\n\r\n    var declaration = this.declaration;\r\n\r\n    // inherit contextual type arguments\r\n    var inheritedTypeArguments = contextualTypeArguments;\r\n    contextualTypeArguments = new Map();\r\n    if (inheritedTypeArguments) {\r\n      for (var [inheritedName, inheritedType] of inheritedTypeArguments) {\r\n        contextualTypeArguments.set(inheritedName, inheritedType);\r\n      }\r\n    }\r\n\r\n    var i: i32, k: i32;\r\n\r\n    // inherit class type arguments if a partially resolved instance method (classTypeArguments is set)\r\n    if (this.classTypeArguments) {\r\n      if (!this.classPrototype) {\r\n        throw new Error(\"partially resolved instance method must reference its class prototype\");\r\n      }\r\n      var classDeclaration = (<ClassPrototype>this.classPrototype).declaration;\r\n      var classTypeParameters = classDeclaration.typeParameters;\r\n      if ((k = this.classTypeArguments.length) != classTypeParameters.length) {\r\n        throw new Error(\"type argument count mismatch\");\r\n      }\r\n      for (i = 0; i < k; ++i) {\r\n        contextualTypeArguments.set(classTypeParameters[i].name.text, this.classTypeArguments[i]);\r\n      }\r\n    }\r\n\r\n    // override call specific contextual type arguments\r\n    var functionTypeParameters = declaration.typeParameters;\r\n    if (functionTypeArguments && (k = functionTypeArguments.length)) {\r\n      if (!functionTypeParameters || k != functionTypeParameters.length) {\r\n        throw new Error(\"type argument count mismatch\");\r\n      }\r\n      for (i = 0; i < k; ++i) {\r\n        contextualTypeArguments.set(functionTypeParameters[i].name.text, functionTypeArguments[i]);\r\n      }\r\n    }\r\n\r\n    // resolve parameters\r\n    // TODO: 'this' type\r\n    k = declaration.parameters.length;\r\n    var parameters = new Array<Parameter>(k);\r\n    var parameterTypes = new Array<Type>(k);\r\n    var typeNode: TypeNode | null;\r\n    for (i = 0; i < k; ++i) {\r\n      var parameterDeclaration = declaration.parameters[i];\r\n      typeNode = assert(parameterDeclaration.type);\r\n      var parameterType = this.program.resolveType(typeNode, contextualTypeArguments, true); // reports\r\n      if (parameterType) {\r\n        parameters[i] = new Parameter(parameterDeclaration.name.text, parameterType, parameterDeclaration.initializer);\r\n        parameterTypes[i] = parameterType;\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    var internalName = this.internalName;\r\n    if (instanceKey.length) {\r\n      internalName += \"<\" + instanceKey + \">\";\r\n    }\r\n    var classInstance: Class | null = null;\r\n    if (this.classPrototype) {\r\n      classInstance = this.classPrototype.resolve(this.classTypeArguments, contextualTypeArguments); // reports\r\n      if (!classInstance) return null;\r\n    }\r\n\r\n    // resolve return type\r\n    // TODO: 'this' type\r\n    var returnType: Type;\r\n    if (this.is(ElementFlags.SETTER) || this.is(ElementFlags.CONSTRUCTOR)) {\r\n      returnType = Type.void; // not annotated\r\n    } else {\r\n      typeNode = assert(declaration.returnType);\r\n      var type = this.program.resolveType(<TypeNode>typeNode, contextualTypeArguments, true); // reports\r\n      if (type) {\r\n        returnType = type;\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    instance = new Function(this, internalName, functionTypeArguments, parameters, returnType, classInstance);\r\n    instance.contextualTypeArguments = contextualTypeArguments;\r\n    this.instances.set(instanceKey, instance);\r\n    return instance;\r\n  }\r\n\r\n  resolveInclTypeArguments(\r\n    typeArgumentNodes: TypeNode[] | null,\r\n    contextualTypeArguments: Map<string,Type> | null,\r\n    reportNode: Node\r\n  ): Function | null {\r\n    var resolvedTypeArguments: Type[] | null = null;\r\n    if (this.is(ElementFlags.GENERIC)) {\r\n      assert(typeArgumentNodes != null && typeArgumentNodes.length != 0);\r\n      resolvedTypeArguments = this.program.resolveTypeArguments(\r\n        assert(this.declaration.typeParameters),\r\n        typeArgumentNodes,\r\n        contextualTypeArguments,\r\n        reportNode\r\n      );\r\n      if (!resolvedTypeArguments) return null;\r\n    }\r\n    return this.resolve(resolvedTypeArguments, contextualTypeArguments);\r\n  }\r\n\r\n  resolvePartial(classTypeArguments: Type[] | null): FunctionPrototype | null {\r\n    if (!this.classPrototype) {\r\n      throw new Error(\"partially resolved instance method must reference its class prototype\");\r\n    }\r\n    if (classTypeArguments && classTypeArguments.length) {\r\n      var partialPrototype = new FunctionPrototype(\r\n        this.program,\r\n        this.simpleName,\r\n        this.internalName,\r\n        this.declaration,\r\n        this.classPrototype\r\n      );\r\n      partialPrototype.flags = this.flags;\r\n      partialPrototype.classTypeArguments = classTypeArguments;\r\n      return partialPrototype;\r\n    }\r\n    return this; // no need to clone\r\n  }\r\n\r\n  toString(): string { return this.simpleName; }\r\n}\r\n\r\n/** A resolved function. */\r\nexport class Function extends Element {\r\n\r\n  kind = ElementKind.FUNCTION;\r\n\r\n  /** Prototype reference. */\r\n  prototype: FunctionPrototype;\r\n  /** Concrete type arguments. */\r\n  typeArguments: Type[] | null;\r\n  /** Concrete function parameters. Excluding `this` if an instance method. */\r\n  parameters: Parameter[] | null;\r\n  /** Concrete return type. */\r\n  returnType: Type;\r\n  /** If an instance method, the concrete class it is a member of. */\r\n  instanceMethodOf: Class | null;\r\n  /** Map of locals by name. */\r\n  locals: Map<string,Local> = new Map();\r\n  /** List of additional non-parameter locals. */\r\n  additionalLocals: Type[] = [];\r\n  /** Current break context label. */\r\n  breakContext: string | null = null;\r\n  /** Contextual type arguments. */\r\n  contextualTypeArguments: Map<string,Type> | null;\r\n  /** Current control flow. */\r\n  flow: Flow;\r\n  /** Remembered debug locations. */\r\n  debugLocations: Range[] | null = null;\r\n  /** Function reference, if compiled. */\r\n  ref: FunctionRef = 0;\r\n  /** Function table index, if any. */\r\n  functionTableIndex: i32 = -1;\r\n\r\n  private nextBreakId: i32 = 0;\r\n  private breakStack: i32[] | null = null;\r\n\r\n  /** Constructs a new concrete function. */\r\n  constructor(\r\n    prototype: FunctionPrototype,\r\n    internalName: string,\r\n    typeArguments: Type[] | null,\r\n    parameters: Parameter[] | null,\r\n    returnType: Type,\r\n    instanceMethodOf: Class | null = null\r\n  ) {\r\n    super(prototype.program, prototype.simpleName, internalName);\r\n    this.prototype = prototype;\r\n    this.typeArguments = typeArguments;\r\n    this.parameters = parameters || [];\r\n    this.returnType = returnType;\r\n    this.instanceMethodOf = instanceMethodOf;\r\n    this.flags = prototype.flags;\r\n    if (!(prototype.is(ElementFlags.BUILTIN) || prototype.is(ElementFlags.DECLARED))) {\r\n      var localIndex = 0;\r\n      if (instanceMethodOf) {\r\n        assert(this.is(ElementFlags.INSTANCE)); // internal error\r\n        this.locals.set(\"this\", new Local(prototype.program, \"this\", localIndex++, instanceMethodOf.type));\r\n        if (instanceMethodOf.contextualTypeArguments) {\r\n          if (!this.contextualTypeArguments) {\r\n            this.contextualTypeArguments = new Map();\r\n          }\r\n          for (var [inheritedName, inheritedType] of instanceMethodOf.contextualTypeArguments) {\r\n            this.contextualTypeArguments.set(inheritedName, inheritedType);\r\n          }\r\n        }\r\n      } else {\r\n        assert(!this.is(ElementFlags.INSTANCE)); // internal error\r\n      }\r\n      for (var i = 0, k = this.parameters.length; i < k; ++i) {\r\n        var parameter = this.parameters[i];\r\n        var parameterName = assert(parameter.name, \"parameter must be named\"); // not a builtin or declared\r\n        this.locals.set(\r\n          parameterName,\r\n          new Local(\r\n            prototype.program,\r\n            parameterName,\r\n            localIndex++,\r\n            parameter.type\r\n          )\r\n        );\r\n      }\r\n    }\r\n    this.flow = Flow.create(this);\r\n  }\r\n\r\n  /** Adds a local of the specified type, with an optional name. */\r\n  addLocal(type: Type, name: string | null = null): Local {\r\n    // if it has a name, check previously as this method will throw otherwise\r\n    var localIndex = (this.parameters ? this.parameters.length : 0) + this.additionalLocals.length;\r\n    if (this.is(ElementFlags.INSTANCE)) localIndex++; // plus 'this'\r\n    var local = new Local(\r\n      this.prototype.program,\r\n      name\r\n        ? name\r\n        : \"var$\" + localIndex.toString(10),\r\n      localIndex,\r\n      type\r\n    );\r\n    if (name) {\r\n      if (this.locals.has(name)) throw new Error(\"duplicate local name\");\r\n      this.locals.set(name, local);\r\n    }\r\n    this.additionalLocals.push(type);\r\n    return local;\r\n  }\r\n\r\n  private tempI32s: Local[] | null = null;\r\n  private tempI64s: Local[] | null = null;\r\n  private tempF32s: Local[] | null = null;\r\n  private tempF64s: Local[] | null = null;\r\n\r\n  /** Gets a free temporary local of the specified type. */\r\n  getTempLocal(type: Type): Local {\r\n    var temps: Local[] | null;\r\n    switch (type.toNativeType()) {\r\n      case NativeType.I32: temps = this.tempI32s; break;\r\n      case NativeType.I64: temps = this.tempI64s; break;\r\n      case NativeType.F32: temps = this.tempF32s; break;\r\n      case NativeType.F64: temps = this.tempF64s; break;\r\n      default: throw new Error(\"concrete type expected\");\r\n    }\r\n    if (temps && temps.length) {\r\n      var ret = temps.pop();\r\n      ret.type = type;\r\n      return ret;\r\n    }\r\n    return this.addLocal(type);\r\n  }\r\n\r\n  /** Frees the temporary local for reuse. */\r\n  freeTempLocal(local: Local): void {\r\n    var temps: Local[];\r\n    assert(local.type != null); // internal error\r\n    switch ((<Type>local.type).toNativeType()) {\r\n      case NativeType.I32: temps = this.tempI32s || (this.tempI32s = []); break;\r\n      case NativeType.I64: temps = this.tempI64s || (this.tempI64s = []); break;\r\n      case NativeType.F32: temps = this.tempF32s || (this.tempF32s = []); break;\r\n      case NativeType.F64: temps = this.tempF64s || (this.tempF64s = []); break;\r\n      default: throw new Error(\"concrete type expected\");\r\n    }\r\n    temps.push(local);\r\n  }\r\n\r\n  /** Gets and immediately frees a temporary local of the specified type. */\r\n  getAndFreeTempLocal(type: Type): Local {\r\n    var temps: Local[];\r\n    switch (type.toNativeType()) {\r\n      case NativeType.I32: temps = this.tempI32s || (this.tempI32s = []); break;\r\n      case NativeType.I64: temps = this.tempI64s || (this.tempI64s = []); break;\r\n      case NativeType.F32: temps = this.tempF32s || (this.tempF32s = []); break;\r\n      case NativeType.F64: temps = this.tempF64s || (this.tempF64s = []); break;\r\n      default: throw new Error(\"concrete type expected\");\r\n    }\r\n    if (temps.length > 0) {\r\n      return temps[temps.length - 1];\r\n    }\r\n    var local: Local = this.addLocal(type);\r\n    temps.push(local);\r\n    return local;\r\n  }\r\n\r\n  /** Enters a(nother) break context. */\r\n  enterBreakContext(): string {\r\n    var id = this.nextBreakId++;\r\n    if (!this.breakStack) {\r\n      this.breakStack = [ id ];\r\n    } else {\r\n      this.breakStack.push(id);\r\n    }\r\n    return this.breakContext = id.toString(10);\r\n  }\r\n\r\n  /** Leaves the current break context. */\r\n  leaveBreakContext(): void {\r\n    assert(this.breakStack != null);\r\n    var length = (<i32[]>this.breakStack).length;\r\n    assert(length > 0);\r\n    (<i32[]>this.breakStack).pop();\r\n    if (length > 1) {\r\n      this.breakContext = (<i32[]>this.breakStack)[length - 2].toString(10);\r\n    } else {\r\n      this.breakContext = null;\r\n      this.breakStack = null;\r\n    }\r\n  }\r\n\r\n  /** Finalizes the function once compiled, releasing no longer needed resources. */\r\n  finalize(module: Module, ref: FunctionRef): void {\r\n    this.ref = ref;\r\n    assert(!this.breakStack || !this.breakStack.length); // internal error\r\n    this.breakStack = null;\r\n    this.breakContext = null;\r\n    this.tempI32s = this.tempI64s = this.tempF32s = this.tempF64s = null;\r\n    if (this.program.options.sourceMap) {\r\n      var debugLocations = this.debugLocations;\r\n      if (debugLocations) {\r\n        for (var i = 0, k = debugLocations.length; i < k; ++i) {\r\n          var debugLocation = debugLocations[i];\r\n          module.setDebugLocation(\r\n            ref,\r\n            debugLocation.debugInfoRef,\r\n            debugLocation.source.debugInfoIndex,\r\n            debugLocation.line,\r\n            debugLocation.column\r\n          );\r\n        }\r\n      }\r\n    }\r\n    this.debugLocations = null;\r\n  }\r\n\r\n  /** Tests if a value of this function type is assignable to a target of the specified function type. */\r\n  isAssignableTo(target: Function): bool {\r\n    return this == target; // TODO\r\n  }\r\n\r\n  /** Returns the TypeScript representation of this function. */\r\n  toString(): string { return this.prototype.simpleName; }\r\n\r\n  /** Returns the function type TypeScript representation of this function.*/\r\n  toTypeString(): string { throw new Error(\"not implemented\"); }\r\n}\r\n\r\n/** A yet unresolved instance field prototype. */\r\nexport class FieldPrototype extends Element {\r\n\r\n  kind = ElementKind.FIELD_PROTOTYPE;\r\n\r\n  /** Declaration reference. */\r\n  declaration: FieldDeclaration;\r\n  /** Parent class prototype. */\r\n  classPrototype: ClassPrototype;\r\n\r\n  /** Constructs a new field prototype. */\r\n  constructor(\r\n    classPrototype: ClassPrototype,\r\n    simpleName: string,\r\n    internalName: string,\r\n    declaration: FieldDeclaration\r\n  ) {\r\n    super(classPrototype.program, simpleName, internalName);\r\n    this.classPrototype = classPrototype;\r\n    this.declaration = declaration;\r\n    if (this.declaration.modifiers) {\r\n      for (var i = 0, k = this.declaration.modifiers.length; i < k; ++i) {\r\n        switch (this.declaration.modifiers[i].modifierKind) {\r\n\r\n          case ModifierKind.EXPORT:\r\n            this.set(ElementFlags.EXPORTED);\r\n            break;\r\n\r\n          case ModifierKind.READONLY:\r\n            this.set(ElementFlags.READONLY);\r\n            break;\r\n\r\n          case ModifierKind.PRIVATE:\r\n          case ModifierKind.PROTECTED:\r\n          case ModifierKind.PUBLIC:\r\n          case ModifierKind.STATIC:\r\n            break; // already handled\r\n\r\n          default:\r\n            throw new Error(\"unexpected modifier\");\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Whether the field is read-only or not. */\r\n  get isReadonly(): bool {\r\n    return (this.flags & ElementFlags.READONLY) != 0;\r\n  }\r\n  set isReadonly(is: bool) {\r\n    if (is) {\r\n      this.flags |= ElementFlags.READONLY;\r\n    } else {\r\n      this.flags &= ~ElementFlags.READONLY;\r\n    }\r\n  }\r\n}\r\n\r\n/** A resolved instance field. */\r\nexport class Field extends VariableLikeElement {\r\n\r\n  kind = ElementKind.FIELD;\r\n\r\n  /** Field prototype reference. */\r\n  prototype: FieldPrototype;\r\n  /** Field memory offset, if an instance field. */\r\n  memoryOffset: i32 = -1;\r\n\r\n  /** Constructs a new field. */\r\n  constructor(prototype: FieldPrototype, internalName: string, type: Type) {\r\n    super(prototype.program, prototype.simpleName, internalName);\r\n    this.prototype = prototype;\r\n    this.flags = prototype.flags;\r\n    this.type = type;\r\n  }\r\n}\r\n\r\n/** A property comprised of a getter and a setter function. */\r\nexport class Property extends Element {\r\n\r\n  kind = ElementKind.PROPERTY;\r\n\r\n  /** Parent class prototype. */\r\n  parent: ClassPrototype;\r\n  /** Getter prototype. */\r\n  getterPrototype: FunctionPrototype | null = null;\r\n  /** Setter prototype. */\r\n  setterPrototype: FunctionPrototype | null = null;\r\n\r\n  /** Constructs a new property prototype. */\r\n  constructor(\r\n    program: Program,\r\n    simpleName: string,\r\n    internalName: string,\r\n    parent: ClassPrototype\r\n  ) {\r\n    super(program, simpleName, internalName);\r\n    this.parent = parent;\r\n  }\r\n}\r\n\r\n/** A yet unresolved class prototype. */\r\nexport class ClassPrototype extends Element {\r\n\r\n  kind = ElementKind.CLASS_PROTOTYPE;\r\n\r\n  /** Declaration reference. */\r\n  declaration: ClassDeclaration;\r\n  /** Resolved instances. */\r\n  instances: Map<string,Class> = new Map();\r\n  /** Instance member prototypes. */\r\n  instanceMembers: Map<string,Element> | null = null;\r\n  /** Base class prototype, if applicable. */\r\n  basePrototype: ClassPrototype | null = null; // set in Program#initialize\r\n  /** Constructor prototype. */\r\n  constructorPrototype: FunctionPrototype | null = null;\r\n\r\n  /** Overloaded indexed get method, if any. */\r\n  fnIndexedGet: string | null = null;\r\n  /** Overloaded indexed set method, if any. */\r\n  fnIndexedSet: string | null = null;\r\n  /** Overloaded concatenation method, if any. */\r\n  fnConcat: string | null = null;\r\n  /** Overloaded equality comparison method, if any. */\r\n  fnEquals: string | null = null;\r\n\r\n  constructor(\r\n    program: Program,\r\n    simpleName: string,\r\n    internalName: string,\r\n    declaration: ClassDeclaration\r\n  ) {\r\n    super(program, simpleName, internalName);\r\n    this.declaration = declaration;\r\n    if (this.declaration.modifiers) {\r\n      for (var i = 0, k = this.declaration.modifiers.length; i < k; ++i) {\r\n        switch (this.declaration.modifiers[i].modifierKind) {\r\n          case ModifierKind.IMPORT: this.set(ElementFlags.IMPORTED); break;\r\n          case ModifierKind.EXPORT: this.set(ElementFlags.EXPORTED); break;\r\n          case ModifierKind.DECLARE: this.set(ElementFlags.DECLARED); break;\r\n          default: throw new Error(\"unexpected modifier\");\r\n        }\r\n      }\r\n    }\r\n    if (this.declaration.typeParameters.length) {\r\n      this.set(ElementFlags.GENERIC);\r\n    }\r\n  }\r\n\r\n  /** Whether an unamanaged class or not. */\r\n  get isUnmanaged(): bool {\r\n    return (this.flags & ElementFlags.UNMANAGED) != 0;\r\n  }\r\n  set isUnmanaged(is: bool) {\r\n    if (is) {\r\n      this.flags |= ElementFlags.UNMANAGED;\r\n    } else {\r\n      this.flags &= ~ElementFlags.UNMANAGED;\r\n    }\r\n  }\r\n\r\n  resolve(typeArguments: Type[] | null, contextualTypeArguments: Map<string,Type> | null = null): Class | null {\r\n    var instanceKey = typeArguments ? typesToString(typeArguments) : \"\";\r\n    var instance = this.instances.get(instanceKey);\r\n    if (instance) return instance;\r\n\r\n    // inherit contextual type arguments\r\n    var inheritedTypeArguments = contextualTypeArguments;\r\n    contextualTypeArguments = new Map();\r\n    if (inheritedTypeArguments) {\r\n      for (var [inheritedName, inheritedType] of inheritedTypeArguments) {\r\n        contextualTypeArguments.set(inheritedName, inheritedType);\r\n      }\r\n    }\r\n\r\n    var declaration = this.declaration;\r\n    var baseClass: Class | null = null;\r\n    if (declaration.extendsType) {\r\n      var baseClassType = this.program.resolveType(declaration.extendsType, null); // reports\r\n      if (!baseClassType) return null;\r\n      if (!(baseClass = baseClassType.classType)) {\r\n        this.program.error(\r\n          DiagnosticCode.A_class_may_only_extend_another_class,\r\n          declaration.extendsType.range\r\n        );\r\n        return null;\r\n      }\r\n      if (baseClass.prototype.isUnmanaged != this.isUnmanaged) {\r\n        this.program.error(\r\n          DiagnosticCode.Structs_cannot_extend_classes_and_vice_versa,\r\n          Range.join(declaration.name.range, declaration.extendsType.range)\r\n        );\r\n        return null;\r\n      }\r\n    }\r\n\r\n    // override call specific contextual type arguments if provided\r\n    var i: i32, k: i32;\r\n    if (typeArguments) {\r\n      if ((k = typeArguments.length) != declaration.typeParameters.length) {\r\n        throw new Error(\"type argument count mismatch\");\r\n      }\r\n      for (i = 0; i < k; ++i) {\r\n        contextualTypeArguments.set(declaration.typeParameters[i].name.text, typeArguments[i]);\r\n      }\r\n    } else if (declaration.typeParameters.length) {\r\n      throw new Error(\"type argument count mismatch\");\r\n    }\r\n\r\n    var internalName = this.internalName;\r\n    if (instanceKey.length) {\r\n      internalName += \"<\" + instanceKey + \">\";\r\n    }\r\n    instance = new Class(this, internalName, typeArguments, baseClass);\r\n    instance.contextualTypeArguments = contextualTypeArguments;\r\n    this.instances.set(instanceKey, instance);\r\n\r\n    var memoryOffset: u32 = 0;\r\n    if (baseClass) {\r\n      memoryOffset = baseClass.currentMemoryOffset;\r\n      if (baseClass.members) {\r\n        if (!instance.members) instance.members = new Map();\r\n        for (var inheritedMember of baseClass.members.values()) {\r\n          instance.members.set(inheritedMember.simpleName, inheritedMember);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.constructorPrototype) {\r\n      var partialConstructor = this.constructorPrototype.resolvePartial(typeArguments); // reports\r\n      if (partialConstructor) {\r\n        instance.constructorInstance = partialConstructor.resolve(); // reports\r\n      }\r\n      // TODO: ^ doesn't know the return type, hence returns null\r\n    }\r\n\r\n    if (this.instanceMembers) {\r\n      for (var member of this.instanceMembers.values()) {\r\n        switch (member.kind) {\r\n\r\n          case ElementKind.FIELD_PROTOTYPE: // fields are layed out in advance\r\n            if (!instance.members) instance.members = new Map();\r\n            var fieldDeclaration = (<FieldPrototype>member).declaration;\r\n            if (!fieldDeclaration.type) {\r\n              throw new Error(\"type expected\"); // TODO: check if parent class defines a type\r\n            }\r\n            var fieldType = this.program.resolveType( // reports\r\n              fieldDeclaration.type,\r\n              instance.contextualTypeArguments\r\n            );\r\n            if (fieldType) {\r\n              var fieldInstance = new Field(<FieldPrototype>member, (<FieldPrototype>member).internalName, fieldType);\r\n              switch (fieldType.byteSize) { // align\r\n                case 1: break;\r\n                case 2: if (memoryOffset & 1) ++memoryOffset; break;\r\n                case 4: if (memoryOffset & 3) memoryOffset = (memoryOffset | 3) + 1; break;\r\n                case 8: if (memoryOffset & 7) memoryOffset = (memoryOffset | 7) + 1; break;\r\n                default: assert(false);\r\n              }\r\n              fieldInstance.memoryOffset = memoryOffset;\r\n              memoryOffset += fieldType.byteSize;\r\n              instance.members.set(member.simpleName, fieldInstance);\r\n            }\r\n            break;\r\n\r\n          case ElementKind.FUNCTION_PROTOTYPE: // instance methods remain partially resolved prototypes until compiled\r\n            if (!instance.members) instance.members = new Map();\r\n            var methodPrototype = (<FunctionPrototype>member).resolvePartial(typeArguments); // reports\r\n            if (methodPrototype) {\r\n              instance.members.set(member.simpleName, methodPrototype);\r\n            }\r\n            break;\r\n\r\n          case ElementKind.PROPERTY: // instance properties are cloned with partially resolved getters and setters\r\n            if (!instance.members) instance.members = new Map();\r\n            assert((<Property>member).getterPrototype);\r\n            var instanceProperty = new Property(this.program, member.simpleName, member.internalName, this);\r\n            instanceProperty.getterPrototype = (\r\n              (<FunctionPrototype>(<Property>member).getterPrototype).resolvePartial(\r\n                typeArguments\r\n              )\r\n            );\r\n            if ((<Property>member).setterPrototype) {\r\n              instanceProperty.setterPrototype = (\r\n                (<FunctionPrototype>(<Property>member).setterPrototype).resolvePartial(\r\n                  typeArguments\r\n                )\r\n              );\r\n            }\r\n            instance.members.set(member.simpleName, instanceProperty);\r\n            break;\r\n\r\n          default:\r\n            throw new Error(\"instance member expected\");\r\n        }\r\n      }\r\n    }\r\n    instance.currentMemoryOffset = memoryOffset; // sizeof<this>() is its byte size in memory\r\n    return instance;\r\n  }\r\n\r\n  resolveInclTypeArguments(\r\n    typeArgumentNodes: TypeNode[] | null,\r\n    contextualTypeArguments: Map<string,Type> | null,\r\n    alternativeReportNode: Node | null\r\n  ): Class | null {\r\n    var resolvedTypeArguments: Type[] | null = null;\r\n    if (this.is(ElementFlags.GENERIC)) {\r\n      assert(typeArgumentNodes != null && typeArgumentNodes.length != 0);\r\n      resolvedTypeArguments = this.program.resolveTypeArguments(\r\n        this.declaration.typeParameters,\r\n        typeArgumentNodes,\r\n        contextualTypeArguments,\r\n        alternativeReportNode\r\n      );\r\n      if (!resolvedTypeArguments) return null;\r\n    } else {\r\n      assert(typeArgumentNodes == null || !typeArgumentNodes.length);\r\n    }\r\n    return this.resolve(resolvedTypeArguments, contextualTypeArguments);\r\n  }\r\n\r\n  toString(): string {\r\n    return this.simpleName;\r\n  }\r\n}\r\n\r\n/** A resolved class. */\r\nexport class Class extends Element {\r\n\r\n  kind = ElementKind.CLASS;\r\n\r\n  /** Prototype reference. */\r\n  prototype: ClassPrototype;\r\n  /** Resolved type arguments. */\r\n  typeArguments: Type[] | null;\r\n  /** Resolved class type. */\r\n  type: Type;\r\n  /** Base class, if applicable. */\r\n  base: Class | null;\r\n  /** Contextual type arguments for fields and methods. */\r\n  contextualTypeArguments: Map<string,Type> | null = null;\r\n  /** Current member memory offset. */\r\n  currentMemoryOffset: u32 = 0;\r\n  /** Constructor instance. */\r\n  constructorInstance: Function | null = null;\r\n\r\n  /** Constructs a new class. */\r\n  constructor(\r\n    prototype: ClassPrototype,\r\n    internalName: string,\r\n    typeArguments: Type[] | null = null,\r\n    base: Class | null = null\r\n  ) {\r\n    super(prototype.program, prototype.simpleName, internalName);\r\n    this.prototype = prototype;\r\n    this.flags = prototype.flags;\r\n    this.typeArguments = typeArguments;\r\n    this.type = prototype.program.options.usizeType.asClass(this);\r\n    this.base = base;\r\n\r\n    // inherit static members and contextual type arguments from base class\r\n    if (base) {\r\n      if (base.contextualTypeArguments) {\r\n        if (!this.contextualTypeArguments) this.contextualTypeArguments = new Map();\r\n        for (var [baseName, baseType] of base.contextualTypeArguments) {\r\n          this.contextualTypeArguments.set(baseName, baseType);\r\n        }\r\n      }\r\n    }\r\n\r\n    // apply instance-specific contextual type arguments\r\n    var declaration = this.prototype.declaration;\r\n    var i: i32, k: i32;\r\n    if (declaration) { // irrelevant for built-ins\r\n      var typeParameters = declaration.typeParameters;\r\n      if (typeArguments) {\r\n        if ((k = typeArguments.length) != typeParameters.length) {\r\n          throw new Error(\"type argument count mismatch\");\r\n        }\r\n        if (k) {\r\n          if (!this.contextualTypeArguments) this.contextualTypeArguments = new Map();\r\n          for (i = 0; i < k; ++i) {\r\n            this.contextualTypeArguments.set(typeParameters[i].name.text, typeArguments[i]);\r\n          }\r\n        }\r\n      } else if (typeParameters.length) {\r\n        throw new Error(\"type argument count mismatch\");\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Tests if a value of this class type is assignable to a target of the specified class type. */\r\n  isAssignableTo(target: Class): bool {\r\n    var current: Class | null = this;\r\n    do {\r\n      if (current == target) {\r\n        return true;\r\n      }\r\n    } while (current = current.base);\r\n    return false;\r\n  }\r\n\r\n  toString(): string {\r\n    return this.prototype.simpleName;\r\n  }\r\n}\r\n\r\n/** A yet unresolved interface. */\r\nexport class InterfacePrototype extends ClassPrototype {\r\n\r\n  kind = ElementKind.INTERFACE_PROTOTYPE;\r\n\r\n  /** Declaration reference. */\r\n  declaration: InterfaceDeclaration; // more specific\r\n\r\n  /** Constructs a new interface prototype. */\r\n  constructor(\r\n    program: Program,\r\n    simpleName: string,\r\n    internalName: string,\r\n    declaration: InterfaceDeclaration\r\n  ) {\r\n    super(program, simpleName, internalName, declaration);\r\n  }\r\n}\r\n\r\n/** A resolved interface. */\r\nexport class Interface extends Class {\r\n\r\n  kind = ElementKind.INTERFACE;\r\n\r\n  /** Prototype reference. */\r\n  prototype: InterfacePrototype; // more specific\r\n  /** Base interface, if applcable. */\r\n  base: Interface | null; // more specific\r\n\r\n  /** Constructs a new interface. */\r\n  constructor(\r\n    prototype: InterfacePrototype,\r\n    internalName: string,\r\n    typeArguments: Type[] = [],\r\n    base: Interface | null = null\r\n  ) {\r\n    super(prototype, internalName, typeArguments, base);\r\n  }\r\n}\r\n\r\n/** Control flow flags indicating specific conditions. */\r\nexport const enum FlowFlags {\r\n  /** No specific conditions. */\r\n  NONE = 0,\r\n  /** This branch always returns. */\r\n  RETURNS = 1 << 0,\r\n  /** This branch possibly throws. */\r\n  POSSIBLY_THROWS = 1 << 1,\r\n  /** This branch possible breaks. */\r\n  POSSIBLY_BREAKS = 1 << 2,\r\n  /** This branch possible continues. */\r\n  POSSIBLY_CONTINUES = 1 << 3\r\n}\r\n\r\n/** A control flow evaluator. */\r\nexport class Flow {\r\n\r\n  /** Parent flow. */\r\n  parent: Flow | null;\r\n  /** Flow flags indicating specific conditions. */\r\n  flags: FlowFlags;\r\n  /** Function this flow belongs to. */\r\n  currentFunction: Function;\r\n  /** The label we break to when encountering a continue statement. */\r\n  continueLabel: string | null;\r\n  /** The label we break to when encountering a break statement. */\r\n  breakLabel: string | null;\r\n  /** Scoped local variables. */\r\n  scopedLocals: Map<string,Local> | null = null;\r\n\r\n  /** Creates the parent flow of the specified function. */\r\n  static create(currentFunction: Function): Flow {\r\n    var parentFlow = new Flow();\r\n    parentFlow.parent = null;\r\n    parentFlow.flags = FlowFlags.NONE;\r\n    parentFlow.currentFunction = currentFunction;\r\n    parentFlow.continueLabel = null;\r\n    parentFlow.breakLabel = null;\r\n    return parentFlow;\r\n  }\r\n\r\n  private constructor() { }\r\n\r\n  /** Tests if this flow has the specified flag or flags. */\r\n  is(flag: FlowFlags): bool { return (this.flags & flag) == flag; }\r\n\r\n  /** Sets the specified flag or flags. */\r\n  set(flag: FlowFlags): void { this.flags |= flag; }\r\n\r\n  /** Enters a new branch or scope and returns the new flow. */\r\n  enterBranchOrScope(): Flow {\r\n    var branchFlow = new Flow();\r\n    branchFlow.parent = this;\r\n    branchFlow.flags = this.flags;\r\n    branchFlow.currentFunction = this.currentFunction;\r\n    branchFlow.continueLabel = this.continueLabel;\r\n    branchFlow.breakLabel = this.breakLabel;\r\n    return branchFlow;\r\n  }\r\n\r\n  /** Leaves the current branch or scope and returns the parent flow. */\r\n  leaveBranchOrScope(): Flow {\r\n    var parent = assert(this.parent);\r\n\r\n    // Free block-scoped locals\r\n    if (this.scopedLocals) {\r\n      for (var scopedLocal of this.scopedLocals.values()) {\r\n        this.currentFunction.freeTempLocal(scopedLocal);\r\n      }\r\n      this.scopedLocals = null;\r\n    }\r\n\r\n    // Propagate flags to parent\r\n    if (this.is(FlowFlags.POSSIBLY_THROWS)) {\r\n      parent.set(FlowFlags.POSSIBLY_THROWS);\r\n    }\r\n    if (this.is(FlowFlags.POSSIBLY_BREAKS) && parent.breakLabel == this.breakLabel) {\r\n      parent.set(FlowFlags.POSSIBLY_BREAKS);\r\n    }\r\n    if (this.is(FlowFlags.POSSIBLY_CONTINUES) && parent.continueLabel == this.continueLabel) {\r\n      parent.set(FlowFlags.POSSIBLY_CONTINUES);\r\n    }\r\n\r\n    return parent;\r\n  }\r\n\r\n  /** Adds a new scoped local of the specified name. */\r\n  addScopedLocal(name: string, type: Type, reportNode: Node): void {\r\n    var scopedLocal = this.currentFunction.getTempLocal(type);\r\n    if (!this.scopedLocals) this.scopedLocals = new Map();\r\n    else if (this.scopedLocals.has(name)) {\r\n      this.currentFunction.program.error(\r\n        DiagnosticCode.Duplicate_identifier_0,\r\n        reportNode.range\r\n      );\r\n      return;\r\n    }\r\n    this.scopedLocals.set(name, scopedLocal);\r\n  }\r\n\r\n  /** Gets the local of the specified name in the current scope. */\r\n  getScopedLocal(name: string): Local | null {\r\n    var local: Local | null;\r\n    var current: Flow | null = this;\r\n    do {\r\n      if (current.scopedLocals && (local = current.scopedLocals.get(name))) {\r\n        return local;\r\n      }\r\n    } while (current = current.parent);\r\n    return this.currentFunction.locals.get(name);\r\n  }\r\n\r\n  /** Finalizes this flow. Must be the topmost parent flow of the function. */\r\n  finalize(): bool {\r\n    assert(this.parent == null, \"must be the topmost parent flow\");\r\n    this.continueLabel = null;\r\n    this.breakLabel = null;\r\n    return this.is(FlowFlags.RETURNS);\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/program.ts","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 3\n// module chunks = 0","import {\r\n  compileCall as compileBuiltinCall,\r\n  compileGetConstant as compileBuiltinGetConstant,\r\n  compileAllocate as compileBuiltinAllocate\r\n} from \"./builtins\";\r\n\r\nimport {\r\n  DiagnosticCode,\r\n  DiagnosticEmitter\r\n} from \"./diagnostics\";\r\n\r\nimport {\r\n  Module,\r\n  MemorySegment,\r\n  ExpressionRef,\r\n  UnaryOp,\r\n  BinaryOp,\r\n  NativeType,\r\n  FunctionRef,\r\n  ExpressionId\r\n} from \"./module\";\r\n\r\nimport {\r\n  Program,\r\n  ClassPrototype,\r\n  Class,\r\n  Element,\r\n  ElementKind,\r\n  Enum,\r\n  Field,\r\n  FunctionPrototype,\r\n  Function,\r\n  Global,\r\n  Local,\r\n  Namespace,\r\n  EnumValue,\r\n  Property,\r\n  VariableLikeElement,\r\n  FlowFlags,\r\n  ElementFlags,\r\n  ConstantValueKind,\r\n  Parameter,\r\n\r\n  PATH_DELIMITER,\r\n  LIBRARY_PREFIX\r\n} from \"./program\";\r\n\r\nimport {\r\n  Token\r\n} from \"./tokenizer\";\r\n\r\nimport {\r\n  Node,\r\n  NodeKind,\r\n  TypeNode,\r\n  Source,\r\n  Range,\r\n\r\n  Statement,\r\n  BlockStatement,\r\n  BreakStatement,\r\n  ClassDeclaration,\r\n  ContinueStatement,\r\n  DoStatement,\r\n  EmptyStatement,\r\n  EnumDeclaration,\r\n  ExportStatement,\r\n  ExpressionStatement,\r\n  FunctionDeclaration,\r\n  ForStatement,\r\n  IfStatement,\r\n  ImportStatement,\r\n  InterfaceDeclaration,\r\n  ModifierKind,\r\n  NamespaceDeclaration,\r\n  ReturnStatement,\r\n  SwitchStatement,\r\n  ThrowStatement,\r\n  TryStatement,\r\n  VariableDeclaration,\r\n  VariableStatement,\r\n  WhileStatement,\r\n\r\n  Expression,\r\n  AssertionExpression,\r\n  BinaryExpression,\r\n  CallExpression,\r\n  CommaExpression,\r\n  ElementAccessExpression,\r\n  FloatLiteralExpression,\r\n  FunctionExpression,\r\n  IdentifierExpression,\r\n  IntegerLiteralExpression,\r\n  LiteralExpression,\r\n  LiteralKind,\r\n  NewExpression,\r\n  ParenthesizedExpression,\r\n  PropertyAccessExpression,\r\n  TernaryExpression,\r\n  ArrayLiteralExpression,\r\n  StringLiteralExpression,\r\n  UnaryPostfixExpression,\r\n  UnaryPrefixExpression,\r\n\r\n  hasModifier\r\n} from \"./ast\";\r\n\r\nimport {\r\n  Type,\r\n  TypeKind,\r\n  TypeFlags,\r\n\r\n  typesToNativeTypes\r\n} from \"./types\";\r\n\r\n/** Compilation target. */\r\nexport enum Target {\r\n  /** WebAssembly with 32-bit pointers. */\r\n  WASM32,\r\n  /** WebAssembly with 64-bit pointers. Experimental and not supported by any runtime yet. */\r\n  WASM64\r\n}\r\n\r\n/** Compiler options. */\r\nexport class Options {\r\n\r\n  /** WebAssembly target. Defaults to {@link Target.WASM32}. */\r\n  target: Target = Target.WASM32;\r\n  /** If true, compiles everything instead of just reachable code. */\r\n  noTreeShaking: bool = false;\r\n  /** If true, replaces assertions with nops. */\r\n  noAssert: bool = false;\r\n  /** If true, does not set up a memory. */\r\n  noMemory: bool = false;\r\n  /** If true, imports the memory provided by the embedder. */\r\n  importMemory: bool = false;\r\n  /** Static memory start offset. */\r\n  memoryBase: u32 = 0;\r\n  /** Memory allocation implementation to use. */\r\n  allocateImpl: string = \"allocate_memory\";\r\n  /** Memory freeing implementation to use. */\r\n  freeImpl: string = \"free_memory\";\r\n  /** If true, generates information necessary for source maps. */\r\n  sourceMap: bool = false;\r\n\r\n  /** Tests if the target is WASM64 or, otherwise, WASM32. */\r\n  get isWasm64(): bool {\r\n    return this.target == Target.WASM64;\r\n  }\r\n\r\n  /** Gets the unsigned size type matching the target. */\r\n  get usizeType(): Type {\r\n    return this.target == Target.WASM64 ? Type.usize64 : Type.usize32;\r\n  }\r\n\r\n  /** Gets the signed size type matching the target. */\r\n  get isizeType(): Type {\r\n    return this.target == Target.WASM64 ? Type.isize64 : Type.isize32;\r\n  }\r\n\r\n  /** Gets the native size type matching the target. */\r\n  get nativeSizeType(): NativeType {\r\n    return this.target == Target.WASM64 ? NativeType.I64 : NativeType.I32;\r\n  }\r\n}\r\n\r\n/** Indicates the desired kind of a conversion. */\r\nexport const enum ConversionKind {\r\n  /** No conversion. */\r\n  NONE,\r\n  /** Implicit conversion. */\r\n  IMPLICIT,\r\n  /** Explicit conversion. */\r\n  EXPLICIT\r\n}\r\n\r\n/** Compiler interface. */\r\nexport class Compiler extends DiagnosticEmitter {\r\n\r\n  /** Program reference. */\r\n  program: Program;\r\n  /** Provided options. */\r\n  options: Options;\r\n  /** Module instance being compiled. */\r\n  module: Module;\r\n\r\n  /** Start function being compiled. */\r\n  startFunction: Function;\r\n  /** Start function statements. */\r\n  startFunctionBody: ExpressionRef[] = new Array();\r\n\r\n  /** Current function in compilation. */\r\n  currentFunction: Function;\r\n  /** Current enum in compilation. */\r\n  currentEnum: Enum | null = null;\r\n  /** Current type in compilation. */\r\n  currentType: Type = Type.void;\r\n\r\n  /** Counting memory offset. */\r\n  memoryOffset: I64;\r\n  /** Memory segments being compiled. */\r\n  memorySegments: MemorySegment[] = new Array();\r\n  /** Map of already compiled static string segments. */\r\n  stringSegments: Map<string,MemorySegment> = new Map();\r\n\r\n  /** Function table being compiled. */\r\n  functionTable: Function[] = new Array();\r\n\r\n  /** Already processed file names. */\r\n  files: Set<string> = new Set();\r\n\r\n  /** Compiles a {@link Program} to a {@link Module} using the specified options. */\r\n  static compile(program: Program, options: Options | null = null): Module {\r\n    return new Compiler(program, options).compile();\r\n  }\r\n\r\n  /** Constructs a new compiler for a {@link Program} using the specified options. */\r\n  constructor(program: Program, options: Options | null = null) {\r\n    super(program.diagnostics);\r\n    this.program = program;\r\n    this.options = options ? options : new Options();\r\n    this.memoryOffset = i64_new(\r\n      max(this.options.memoryBase, this.options.usizeType.byteSize) // leave space for `null`\r\n    );\r\n    this.module = Module.create();\r\n  }\r\n\r\n  /** Performs compilation of the underlying {@link Program} to a {@link Module}. */\r\n  compile(): Module {\r\n\r\n    // initialize lookup maps, built-ins, imports, exports, etc.\r\n    this.program.initialize(this.options);\r\n\r\n    // set up the start function wrapping top-level statements, of all files.\r\n    var startFunctionPrototype = assert(this.program.elements.get(\"start\"));\r\n    assert(startFunctionPrototype.kind == ElementKind.FUNCTION_PROTOTYPE);\r\n    var startFunctionInstance = new Function(\r\n      <FunctionPrototype>startFunctionPrototype,\r\n      startFunctionPrototype.internalName,\r\n      null, // not generic\r\n      null, // no parameters\r\n      Type.void\r\n    );\r\n    startFunctionInstance.set(ElementFlags.START);\r\n    this.currentFunction = this.startFunction = startFunctionInstance;\r\n\r\n    var sources = this.program.sources;\r\n\r\n    // compile entry file(s) while traversing to reachable elements\r\n    for (var i = 0, k = sources.length; i < k; ++i) {\r\n      if (sources[i].isEntry) {\r\n        this.compileSource(sources[i]);\r\n      }\r\n    }\r\n\r\n    // compile the start function if not empty\r\n    if (this.startFunctionBody.length) {\r\n      var typeRef = this.module.getFunctionTypeBySignature(NativeType.None, []);\r\n      if (!typeRef) typeRef = this.module.addFunctionType(\"v\", NativeType.None, []);\r\n      var ref: FunctionRef;\r\n      this.module.setStart(\r\n        ref = this.module.addFunction(\r\n          this.startFunction.prototype.internalName,\r\n          typeRef,\r\n          typesToNativeTypes(this.startFunction.additionalLocals),\r\n          this.module.createBlock(null, this.startFunctionBody)\r\n        )\r\n      );\r\n      this.startFunction.finalize(this.module, ref);\r\n    }\r\n\r\n    // set up static memory segments and the heap base pointer\r\n    if (!this.options.noMemory) {\r\n      var memoryOffset = this.memoryOffset;\r\n      memoryOffset = i64_align(memoryOffset, this.options.usizeType.byteSize);\r\n      this.memoryOffset = memoryOffset;\r\n      if (this.options.isWasm64) {\r\n        this.module.addGlobal(\r\n          \"HEAP_BASE\",\r\n          NativeType.I64,\r\n          false,\r\n          this.module.createI64(i64_low(memoryOffset), i64_high(memoryOffset))\r\n        );\r\n      } else {\r\n        this.module.addGlobal(\r\n          \"HEAP_BASE\",\r\n          NativeType.I32,\r\n          false,\r\n          this.module.createI32(i64_low(memoryOffset))\r\n        );\r\n      }\r\n\r\n      // determine initial page size\r\n      var pages = i64_shr_u(i64_align(memoryOffset, 0x10000), i64_new(16, 0));\r\n      this.module.setMemory(\r\n        i64_low(pages),\r\n        Module.MAX_MEMORY_WASM32 /* TODO: not WASM64 compatible yet */,\r\n        this.memorySegments,\r\n        this.options.target,\r\n        \"memory\"\r\n      );\r\n    }\r\n\r\n    // import memory if requested\r\n    if (this.options.importMemory) {\r\n      this.module.addMemoryImport(\"memory\", \"env\", \"memory\");\r\n    }\r\n\r\n    // set up function table\r\n    if (k = this.functionTable.length) {\r\n      var entries = new Array<FunctionRef>(k);\r\n      for (i = 0; i < k; ++i) {\r\n        entries[i] = this.functionTable[i].ref;\r\n      }\r\n      this.module.setFunctionTable(entries);\r\n    }\r\n\r\n    return this.module;\r\n  }\r\n\r\n  // sources\r\n\r\n  compileSourceByPath(normalizedPathWithoutExtension: string, reportNode: Node): void {\r\n    var sources = this.program.sources;\r\n\r\n    var source: Source;\r\n    var expected = normalizedPathWithoutExtension + \".ts\";\r\n    for (var i = 0, k = sources.length; i < k; ++i) {\r\n      source = sources[i];\r\n      if (source.normalizedPath == expected) {\r\n        this.compileSource(source);\r\n        return;\r\n      }\r\n    }\r\n\r\n    expected = normalizedPathWithoutExtension + \"/index.ts\";\r\n    for (i = 0, k = sources.length; i < k; ++i) {\r\n      source = sources[i];\r\n      if (source.normalizedPath == expected) {\r\n        this.compileSource(source);\r\n        return;\r\n      }\r\n    }\r\n\r\n    expected = LIBRARY_PREFIX + normalizedPathWithoutExtension + \".ts\";\r\n    for (i = 0, k = sources.length; i < k; ++i) {\r\n      source = sources[i];\r\n      if (source.normalizedPath == expected) {\r\n        this.compileSource(source);\r\n        return;\r\n      }\r\n    }\r\n\r\n    this.error(\r\n      DiagnosticCode.File_0_not_found,\r\n      reportNode.range, normalizedPathWithoutExtension\r\n    );\r\n  }\r\n\r\n  compileSource(source: Source): void {\r\n    var files = this.files;\r\n    if (files.has(source.normalizedPath)) return;\r\n    files.add(source.normalizedPath);\r\n\r\n    var noTreeShaking = this.options.noTreeShaking;\r\n    var isEntry = source.isEntry;\r\n    var startFunctionBody = this.startFunctionBody;\r\n    var statements = source.statements;\r\n    for (var i = 0, k = statements.length; i < k; ++i) {\r\n      var statement = statements[i];\r\n      switch (statement.kind) {\r\n\r\n        case NodeKind.CLASSDECLARATION:\r\n          if (\r\n            (\r\n              noTreeShaking ||\r\n              (isEntry && hasModifier(ModifierKind.EXPORT, (<ClassDeclaration>statement).modifiers))\r\n            ) &&\r\n            !(<ClassDeclaration>statement).typeParameters.length\r\n          ) {\r\n            this.compileClassDeclaration(<ClassDeclaration>statement, []);\r\n          }\r\n          break;\r\n\r\n        case NodeKind.ENUMDECLARATION:\r\n          if (\r\n            noTreeShaking ||\r\n            (isEntry && hasModifier(ModifierKind.EXPORT, (<EnumDeclaration>statement).modifiers))\r\n          ) {\r\n            this.compileEnumDeclaration(<EnumDeclaration>statement);\r\n          }\r\n          break;\r\n\r\n        case NodeKind.FUNCTIONDECLARATION:\r\n          if (\r\n            (\r\n              noTreeShaking ||\r\n              (isEntry && hasModifier(ModifierKind.EXPORT, (<FunctionDeclaration>statement).modifiers))\r\n            ) &&\r\n            !(<FunctionDeclaration>statement).isGeneric\r\n          ) {\r\n            this.compileFunctionDeclaration(<FunctionDeclaration>statement, []);\r\n          }\r\n          break;\r\n\r\n        case NodeKind.IMPORT:\r\n          this.compileSourceByPath(\r\n            (<ImportStatement>statement).normalizedPath,\r\n            (<ImportStatement>statement).path\r\n          );\r\n          break;\r\n\r\n        case NodeKind.NAMESPACEDECLARATION:\r\n          if (\r\n            noTreeShaking ||\r\n            (isEntry && hasModifier(ModifierKind.EXPORT, (<NamespaceDeclaration>statement).modifiers))\r\n          ) {\r\n            this.compileNamespaceDeclaration(<NamespaceDeclaration>statement);\r\n          }\r\n          break;\r\n\r\n        case NodeKind.VARIABLE: // global, always compiled as initializers might have side effects\r\n          var variableInit = this.compileVariableStatement(<VariableStatement>statement);\r\n          if (variableInit) startFunctionBody.push(variableInit);\r\n          break;\r\n\r\n        case NodeKind.EXPORT:\r\n          if ((<ExportStatement>statement).normalizedPath != null) {\r\n            this.compileSourceByPath(\r\n              <string>(<ExportStatement>statement).normalizedPath,\r\n              <StringLiteralExpression>(<ExportStatement>statement).path\r\n            );\r\n          }\r\n          if (noTreeShaking || isEntry) {\r\n            this.compileExportStatement(<ExportStatement>statement);\r\n          }\r\n          break;\r\n\r\n        // otherwise a top-level statement that is part of the start function's body\r\n        default:\r\n          var previousFunction = this.currentFunction;\r\n          this.currentFunction = this.startFunction;\r\n          var expr = this.compileStatement(statement);\r\n          this.startFunctionBody.push(expr);\r\n          this.currentFunction = previousFunction;\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // globals\r\n\r\n  compileGlobalDeclaration(declaration: VariableDeclaration): Global | null {\r\n    var element = this.program.elements.get(declaration.fileLevelInternalName);\r\n    if (!element || element.kind != ElementKind.GLOBAL) {\r\n      throw new Error(\"global expected\");\r\n    }\r\n    if (!this.compileGlobal(<Global>element)) { // reports\r\n      return null;\r\n    }\r\n    return <Global>element;\r\n  }\r\n\r\n  compileGlobal(global: Global): bool {\r\n    if (global.is(ElementFlags.COMPILED) || global.is(ElementFlags.BUILTIN)) {\r\n      return true;\r\n    }\r\n\r\n    var declaration = global.declaration;\r\n    var initExpr: ExpressionRef = 0;\r\n    if (global.type == Type.void) { // infer type\r\n      if (declaration.type) {\r\n        var resolvedType = this.program.resolveType(declaration.type); // reports\r\n        if (!resolvedType) return false;\r\n        if (resolvedType == Type.void) {\r\n          this.error(\r\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n            declaration.type.range, \"*\", resolvedType.toString()\r\n          );\r\n          return false;\r\n        }\r\n        global.type = resolvedType;\r\n      } else if (declaration.initializer) { // infer type using void/NONE for literal inference\r\n        initExpr = this.compileExpression( // reports\r\n          declaration.initializer,\r\n          Type.void,\r\n          ConversionKind.NONE\r\n        );\r\n        if (this.currentType == Type.void) {\r\n          this.error(\r\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n            declaration.initializer.range, this.currentType.toString(), \"<auto>\"\r\n          );\r\n          return false;\r\n        }\r\n        global.type = this.currentType;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.Type_expected,\r\n          declaration.name.range.atEnd\r\n        );\r\n        return false;\r\n      }\r\n    }\r\n\r\n    var nativeType = global.type.toNativeType();\r\n\r\n    if (global.is(ElementFlags.DECLARED)) {\r\n      if (global.is(ElementFlags.CONSTANT)) {\r\n        this.module.addGlobalImport(\r\n          global.internalName,\r\n          global.namespace\r\n            ? global.namespace.simpleName\r\n            : \"env\",\r\n          global.simpleName,\r\n          nativeType\r\n        );\r\n        global.set(ElementFlags.COMPILED);\r\n        return true;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.Operation_not_supported,\r\n          declaration.range\r\n        );\r\n      }\r\n      return false;\r\n    }\r\n\r\n    var initializeInStart = false;\r\n\r\n    if (global.is(ElementFlags.INLINED)) {\r\n      initExpr = this.compileInlineConstant(global, global.type);\r\n    } else {\r\n      if (declaration.initializer) {\r\n        if (!initExpr) {\r\n          initExpr = this.compileExpression(declaration.initializer, global.type);\r\n        }\r\n        if (_BinaryenExpressionGetId(initExpr) != ExpressionId.Const) {\r\n          if (global.is(ElementFlags.CONSTANT)) {\r\n            initExpr = this.precomputeExpressionRef(initExpr);\r\n            if (_BinaryenExpressionGetId(initExpr) != ExpressionId.Const) {\r\n              this.warning(\r\n                DiagnosticCode.Compiling_constant_with_non_constant_initializer_as_mutable,\r\n                declaration.range\r\n              );\r\n              initializeInStart = true;\r\n            }\r\n          } else {\r\n            initializeInStart = true;\r\n          }\r\n        }\r\n      } else {\r\n        initExpr = global.type.toNativeZero(this.module);\r\n      }\r\n    }\r\n\r\n    var internalName = global.internalName;\r\n    if (initializeInStart) {\r\n      this.module.addGlobal(internalName, nativeType, true, global.type.toNativeZero(this.module));\r\n      var setExpr = this.module.createSetGlobal(internalName, initExpr);\r\n      this.startFunctionBody.push(setExpr);\r\n    } else {\r\n      if (global.is(ElementFlags.CONSTANT)) {\r\n        var exprType = _BinaryenExpressionGetType(initExpr);\r\n        switch (exprType) {\r\n\r\n          case NativeType.I32:\r\n            global.constantValueKind = ConstantValueKind.INTEGER;\r\n            global.constantIntegerValue = i64_new(_BinaryenConstGetValueI32(initExpr), 0);\r\n            break;\r\n\r\n          case NativeType.I64:\r\n            global.constantValueKind = ConstantValueKind.INTEGER;\r\n            global.constantIntegerValue = i64_new(\r\n              _BinaryenConstGetValueI64Low(initExpr),\r\n              _BinaryenConstGetValueI64High(initExpr)\r\n            );\r\n            break;\r\n\r\n          case NativeType.F32:\r\n            global.constantValueKind = ConstantValueKind.FLOAT;\r\n            global.constantFloatValue = _BinaryenConstGetValueF32(initExpr);\r\n            break;\r\n\r\n          case NativeType.F64:\r\n            global.constantValueKind = ConstantValueKind.FLOAT;\r\n            global.constantFloatValue = _BinaryenConstGetValueF64(initExpr);\r\n            break;\r\n\r\n          default:\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        global.set(ElementFlags.INLINED);\r\n        if (declaration.isTopLevel) { // might be re-exported\r\n          this.module.addGlobal(internalName, nativeType, !global.is(ElementFlags.CONSTANT), initExpr);\r\n        }\r\n        if (declaration.range.source.isEntry && declaration.isTopLevelExport) {\r\n          this.module.addGlobalExport(global.internalName, declaration.programLevelInternalName);\r\n        }\r\n      } else {\r\n        this.module.addGlobal(internalName, nativeType, !global.is(ElementFlags.CONSTANT), initExpr);\r\n      }\r\n    }\r\n    global.set(ElementFlags.COMPILED);\r\n    return true;\r\n  }\r\n\r\n  // enums\r\n\r\n  compileEnumDeclaration(declaration: EnumDeclaration): Enum | null {\r\n    var element = this.program.elements.get(declaration.fileLevelInternalName);\r\n    if (!element || element.kind != ElementKind.ENUM) throw new Error(\"enum expected\");\r\n    return this.compileEnum(<Enum>element) ? <Enum>element : null;\r\n  }\r\n\r\n  compileEnum(element: Enum): bool {\r\n    if (element.is(ElementFlags.COMPILED)) return true;\r\n\r\n    // members might reference each other, triggering another compile\r\n    element.set(ElementFlags.COMPILED);\r\n\r\n    this.currentEnum = element;\r\n    var previousValue: EnumValue | null = null;\r\n    if (element.members) {\r\n      for (var member of element.members.values()) {\r\n        if (member.kind != ElementKind.ENUMVALUE) continue; // happens if an enum is also a namespace\r\n        var initInStart = false;\r\n        var val = <EnumValue>member;\r\n        var valueDeclaration = val.declaration;\r\n        val.set(ElementFlags.COMPILED);\r\n        if (val.is(ElementFlags.INLINED)) {\r\n          if (element.declaration.isTopLevelExport) {\r\n            this.module.addGlobal(\r\n              val.internalName,\r\n              NativeType.I32,\r\n              false, // constant\r\n              this.module.createI32(val.constantValue)\r\n            );\r\n          }\r\n        } else {\r\n          var initExpr: ExpressionRef;\r\n          if (valueDeclaration.value) {\r\n            initExpr = this.compileExpression(<Expression>valueDeclaration.value, Type.i32);\r\n            if (_BinaryenExpressionGetId(initExpr) != ExpressionId.Const) {\r\n              initExpr = this.precomputeExpressionRef(initExpr);\r\n              if (_BinaryenExpressionGetId(initExpr) != ExpressionId.Const) {\r\n                if (element.is(ElementFlags.CONSTANT)) {\r\n                  this.warning(\r\n                    DiagnosticCode.Compiling_constant_with_non_constant_initializer_as_mutable,\r\n                    valueDeclaration.range\r\n                  );\r\n                }\r\n                initInStart = true;\r\n              }\r\n            }\r\n          } else if (previousValue == null) {\r\n            initExpr = this.module.createI32(0);\r\n          } else if (previousValue.is(ElementFlags.INLINED)) {\r\n            initExpr = this.module.createI32(previousValue.constantValue + 1);\r\n          } else {\r\n            // in TypeScript this errors with TS1061, but actually we can do:\r\n            initExpr = this.module.createBinary(BinaryOp.AddI32,\r\n              this.module.createGetGlobal(previousValue.internalName, NativeType.I32),\r\n              this.module.createI32(1)\r\n            );\r\n            if (element.is(ElementFlags.CONSTANT)) {\r\n              this.warning(\r\n                DiagnosticCode.Compiling_constant_with_non_constant_initializer_as_mutable,\r\n                valueDeclaration.range\r\n              );\r\n            }\r\n            initInStart = true;\r\n          }\r\n          if (initInStart) {\r\n            this.module.addGlobal(\r\n              val.internalName,\r\n              NativeType.I32,\r\n              true, // mutable\r\n              this.module.createI32(0)\r\n            );\r\n            var setExpr = this.module.createSetGlobal(val.internalName, initExpr);\r\n            this.startFunctionBody.push(setExpr);\r\n          } else {\r\n            this.module.addGlobal(val.internalName, NativeType.I32, false, initExpr);\r\n            if (_BinaryenExpressionGetType(initExpr) == NativeType.I32) {\r\n              val.constantValue = _BinaryenConstGetValueI32(initExpr);\r\n              val.set(ElementFlags.INLINED);\r\n            } else {\r\n              throw new Error(\"i32 expected\");\r\n            }\r\n          }\r\n        }\r\n        previousValue = <EnumValue>val;\r\n\r\n        // export values if the enum is exported\r\n        if (element.declaration.range.source.isEntry && element.declaration.isTopLevelExport) {\r\n          if (member.is(ElementFlags.INLINED)) {\r\n            this.module.addGlobalExport(member.internalName, member.internalName);\r\n          } else if (valueDeclaration) {\r\n            this.warning(\r\n              DiagnosticCode.Cannot_export_a_mutable_global,\r\n              valueDeclaration.range\r\n            );\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this.currentEnum = null;\r\n    return true;\r\n  }\r\n\r\n  // functions\r\n\r\n  compileFunctionDeclaration(\r\n    declaration: FunctionDeclaration,\r\n    typeArguments: TypeNode[],\r\n    contextualTypeArguments: Map<string,Type> | null = null\r\n  ): Function | null {\r\n    var element = this.program.elements.get(declaration.fileLevelInternalName);\r\n    if (!element || element.kind != ElementKind.FUNCTION_PROTOTYPE) {\r\n      throw new Error(\"function expected\");\r\n    }\r\n    return this.compileFunctionUsingTypeArguments( // reports\r\n      <FunctionPrototype>element,\r\n      typeArguments,\r\n      contextualTypeArguments,\r\n      (<FunctionPrototype>element).declaration.name\r\n    );\r\n  }\r\n\r\n  compileFunctionUsingTypeArguments(\r\n    prototype: FunctionPrototype,\r\n    typeArguments: TypeNode[],\r\n    contextualTypeArguments: Map<string,Type> | null,\r\n    reportNode: Node\r\n  ): Function | null {\r\n    var instance = prototype.resolveInclTypeArguments( // reports\r\n      typeArguments,\r\n      contextualTypeArguments,\r\n      reportNode\r\n    );\r\n    if (!instance) return null;\r\n    return this.compileFunction(instance) ? instance : null;\r\n  }\r\n\r\n  compileFunction(instance: Function): bool {\r\n    if (instance.is(ElementFlags.COMPILED)) return true;\r\n\r\n    assert(!instance.is(ElementFlags.BUILTIN) || instance.simpleName == \"abort\");\r\n\r\n    var declaration = instance.prototype.declaration;\r\n    if (instance.is(ElementFlags.DECLARED)) {\r\n      if (declaration.body) {\r\n        this.error(\r\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\r\n          declaration.name.range\r\n        );\r\n        return false;\r\n      }\r\n    } else if (!declaration.body) {\r\n      this.error(\r\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\r\n        declaration.name.range\r\n      );\r\n      return false;\r\n    }\r\n\r\n    // might trigger compilation of other functions referring to this one\r\n    instance.set(ElementFlags.COMPILED);\r\n\r\n    // compile statements\r\n    var stmt: ExpressionRef = 0;\r\n    if (!instance.is(ElementFlags.DECLARED)) {\r\n      var previousFunction = this.currentFunction;\r\n      this.currentFunction = instance;\r\n      var body = assert(declaration.body, \"implementation expected\");\r\n      stmt = this.compileStatement(body);\r\n      // make sure the top-level branch or all child branches return\r\n      var allBranchesReturn = this.currentFunction.flow.finalize();\r\n      if (instance.returnType != Type.void && !allBranchesReturn) {\r\n        this.error(\r\n          DiagnosticCode.A_function_whose_declared_type_is_not_void_must_return_a_value,\r\n          assert(declaration.returnType, \"return type expected\").range\r\n        );\r\n      }\r\n      this.currentFunction = previousFunction;\r\n    }\r\n\r\n    // create the function type\r\n    var numParameters = instance.parameters ? instance.parameters.length : 0;\r\n    var numParametersInclThis = instance.instanceMethodOf ? numParameters + 1 : numParameters;\r\n    var paramIndex = 0;\r\n\r\n    var nativeResultType = instance.returnType.toNativeType();\r\n    var nativeParamTypes = new Array<NativeType>(numParametersInclThis);\r\n    var signatureNameParts = new Array<string>(numParametersInclThis + 1);\r\n\r\n    if (instance.instanceMethodOf) {\r\n      nativeParamTypes[paramIndex] = this.options.isWasm64 ? NativeType.I64 : NativeType.I32;\r\n      signatureNameParts[paramIndex++] = instance.instanceMethodOf.type.toSignatureString();\r\n    }\r\n    if (instance.parameters) {\r\n      for (var i = 0; i < numParameters; ++i) {\r\n        nativeParamTypes[paramIndex] = instance.parameters[i].type.toNativeType();\r\n        signatureNameParts[paramIndex++] = instance.parameters[i].type.toSignatureString();\r\n      }\r\n    }\r\n    signatureNameParts[paramIndex] = instance.returnType.toSignatureString();\r\n    var typeRef = this.module.getFunctionTypeBySignature(nativeResultType, nativeParamTypes);\r\n    if (!typeRef) {\r\n      typeRef = this.module.addFunctionType(\r\n        signatureNameParts.join(\"\"),\r\n        nativeResultType,\r\n        nativeParamTypes\r\n      );\r\n    }\r\n\r\n    // create the function\r\n    var ref: FunctionRef;\r\n    if (instance.is(ElementFlags.DECLARED)) {\r\n      ref = this.module.addFunctionImport(\r\n        instance.internalName,\r\n        instance.prototype.namespace\r\n          ? instance.prototype.namespace.simpleName\r\n          : \"env\",\r\n        instance.simpleName,\r\n        typeRef\r\n      );\r\n    } else {\r\n      ref = this.module.addFunction(\r\n        instance.internalName,\r\n        typeRef,\r\n        typesToNativeTypes(instance.additionalLocals),\r\n        assert(stmt)\r\n      );\r\n    }\r\n\r\n    // check module export\r\n    if (declaration.range.source.isEntry && declaration.isTopLevelExport) {\r\n      this.module.addFunctionExport(instance.internalName, declaration.name.text);\r\n    }\r\n\r\n    instance.finalize(this.module, ref);\r\n    return true;\r\n  }\r\n\r\n  // namespaces\r\n\r\n  compileNamespaceDeclaration(declaration: NamespaceDeclaration): void {\r\n    var members = declaration.members;\r\n    var noTreeShaking = this.options.noTreeShaking;\r\n    for (var i = 0, k = members.length; i < k; ++i) {\r\n      var member = members[i];\r\n      switch (member.kind) {\r\n\r\n        case NodeKind.CLASSDECLARATION:\r\n          if (\r\n            (\r\n              noTreeShaking ||\r\n              hasModifier(ModifierKind.EXPORT, (<ClassDeclaration>member).modifiers)\r\n            ) && !(<ClassDeclaration>member).typeParameters.length\r\n          ) {\r\n            this.compileClassDeclaration(<ClassDeclaration>member, []);\r\n          }\r\n          break;\r\n\r\n        case NodeKind.INTERFACEDECLARATION:\r\n          if (\r\n            (\r\n              noTreeShaking ||\r\n              hasModifier(ModifierKind.EXPORT, (<InterfaceDeclaration>member).modifiers)\r\n            ) && !(<InterfaceDeclaration>member).typeParameters.length\r\n          ) {\r\n            this.compileInterfaceDeclaration(<InterfaceDeclaration>member, []);\r\n          }\r\n          break;\r\n\r\n        case NodeKind.ENUMDECLARATION:\r\n          if (\r\n            noTreeShaking ||\r\n            hasModifier(ModifierKind.EXPORT, (<EnumDeclaration>member).modifiers)\r\n          ) {\r\n            this.compileEnumDeclaration(<EnumDeclaration>member);\r\n          }\r\n          break;\r\n\r\n        case NodeKind.FUNCTIONDECLARATION:\r\n          if (\r\n            (\r\n              noTreeShaking ||\r\n              hasModifier(ModifierKind.EXPORT, (<FunctionDeclaration>member).modifiers)\r\n            ) &&\r\n            !(<FunctionDeclaration>member).isGeneric\r\n          ) {\r\n            this.compileFunctionDeclaration(<FunctionDeclaration>member, []);\r\n          }\r\n          break;\r\n\r\n        case NodeKind.NAMESPACEDECLARATION:\r\n          if (\r\n            noTreeShaking ||\r\n            hasModifier(ModifierKind.EXPORT, (<NamespaceDeclaration>member).modifiers)\r\n          ) {\r\n            this.compileNamespaceDeclaration(<NamespaceDeclaration>member);\r\n          }\r\n          break;\r\n\r\n        case NodeKind.VARIABLE:\r\n          if (\r\n            noTreeShaking ||\r\n            hasModifier(ModifierKind.EXPORT, (<VariableStatement>member).modifiers)\r\n          ) {\r\n            var variableInit = this.compileVariableStatement(<VariableStatement>member, true);\r\n            if (variableInit) this.startFunctionBody.push(variableInit);\r\n          }\r\n          break;\r\n\r\n        default:\r\n          throw new Error(\"namespace member expected\");\r\n      }\r\n    }\r\n  }\r\n\r\n  compileNamespace(ns: Namespace): void {\r\n    if (!ns.members) return;\r\n\r\n    var noTreeShaking = this.options.noTreeShaking;\r\n    for (var element of ns.members.values()) {\r\n      switch (element.kind) {\r\n\r\n        case ElementKind.CLASS_PROTOTYPE:\r\n          if (\r\n            (\r\n              noTreeShaking ||\r\n              (<ClassPrototype>element).is(ElementFlags.EXPORTED)\r\n            ) && !(<ClassPrototype>element).is(ElementFlags.GENERIC)\r\n          ) {\r\n            this.compileClassUsingTypeArguments(<ClassPrototype>element, []);\r\n          }\r\n          break;\r\n\r\n        case ElementKind.ENUM:\r\n          this.compileEnum(<Enum>element);\r\n          break;\r\n\r\n        case ElementKind.FUNCTION_PROTOTYPE:\r\n          if (\r\n            (\r\n              noTreeShaking || (<FunctionPrototype>element).is(ElementFlags.EXPORTED)\r\n            ) && !(<FunctionPrototype>element).is(ElementFlags.GENERIC)\r\n          ) {\r\n            this.compileFunctionUsingTypeArguments(\r\n              <FunctionPrototype>element,\r\n              [],\r\n              null,\r\n              (<FunctionPrototype>element).declaration.name\r\n            );\r\n          }\r\n          break;\r\n\r\n        case ElementKind.GLOBAL:\r\n          this.compileGlobal(<Global>element);\r\n          break;\r\n\r\n        case ElementKind.NAMESPACE:\r\n          this.compileNamespace(<Namespace>element);\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // exports\r\n\r\n  compileExportStatement(statement: ExportStatement): void {\r\n    var members = statement.members;\r\n    for (var i = 0, k = members.length; i < k; ++i) {\r\n      var member = members[i];\r\n      var internalExportName = (\r\n        statement.range.source.internalPath +\r\n        PATH_DELIMITER +\r\n        member.externalName.text\r\n      );\r\n      var element = this.program.exports.get(internalExportName);\r\n      if (!element) continue; // reported in Program#initialize\r\n\r\n      switch (element.kind) {\r\n\r\n        case ElementKind.CLASS_PROTOTYPE:\r\n          if (!(<ClassPrototype>element).is(ElementFlags.GENERIC)) {\r\n            this.compileClassUsingTypeArguments(<ClassPrototype>element, []);\r\n          }\r\n          break;\r\n\r\n        case ElementKind.ENUM:\r\n          this.compileEnum(<Enum>element);\r\n          break;\r\n\r\n        case ElementKind.FUNCTION_PROTOTYPE:\r\n          if (\r\n            !(<FunctionPrototype>element).is(ElementFlags.GENERIC) &&\r\n            statement.range.source.isEntry\r\n          ) {\r\n            var functionInstance = this.compileFunctionUsingTypeArguments(\r\n              <FunctionPrototype>element,\r\n              [],\r\n              null,\r\n              (<FunctionPrototype>element).declaration.name\r\n            );\r\n            if (functionInstance) {\r\n              var functionDeclaration = functionInstance.prototype.declaration;\r\n              if (functionDeclaration && functionDeclaration.needsExplicitExport(member)) {\r\n                this.module.addFunctionExport(functionInstance.internalName, member.externalName.text);\r\n              }\r\n            }\r\n          }\r\n          break;\r\n\r\n        case ElementKind.GLOBAL:\r\n          if (this.compileGlobal(<Global>element) && statement.range.source.isEntry) {\r\n            var globalDeclaration = (<Global>element).declaration;\r\n            if (globalDeclaration && globalDeclaration.needsExplicitExport(member)) {\r\n              if ((<Global>element).is(ElementFlags.INLINED)) {\r\n                this.module.addGlobalExport(element.internalName, member.externalName.text);\r\n              } else {\r\n                this.warning(\r\n                  DiagnosticCode.Cannot_export_a_mutable_global,\r\n                  member.range\r\n                );\r\n              }\r\n            }\r\n          }\r\n          break;\r\n\r\n        case ElementKind.NAMESPACE:\r\n          this.compileNamespace(<Namespace>element);\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // classes\r\n\r\n  compileClassDeclaration(\r\n    declaration: ClassDeclaration,\r\n    typeArguments: TypeNode[],\r\n    contextualTypeArguments: Map<string,Type> | null = null,\r\n    alternativeReportNode: Node | null = null\r\n  ): void {\r\n    var element = this.program.elements.get(declaration.fileLevelInternalName);\r\n    if (!element || element.kind != ElementKind.CLASS_PROTOTYPE) {\r\n      throw new Error(\"class expected\");\r\n    }\r\n    this.compileClassUsingTypeArguments(\r\n      <ClassPrototype>element,\r\n      typeArguments,\r\n      contextualTypeArguments,\r\n      alternativeReportNode\r\n    );\r\n  }\r\n\r\n  compileClassUsingTypeArguments(\r\n    prototype: ClassPrototype,\r\n    typeArguments: TypeNode[],\r\n    contextualTypeArguments: Map<string,Type> | null = null,\r\n    alternativeReportNode: Node | null = null\r\n  ): void {\r\n    var instance = prototype.resolveInclTypeArguments( // reports\r\n      typeArguments,\r\n      contextualTypeArguments,\r\n      alternativeReportNode\r\n    );\r\n    if (!instance) return;\r\n    this.compileClass(instance);\r\n  }\r\n\r\n  compileClass(instance: Class): bool {\r\n    if (instance.is(ElementFlags.COMPILED)) return true;\r\n    instance.set(ElementFlags.COMPILED);\r\n    return true;\r\n  }\r\n\r\n  compileInterfaceDeclaration(\r\n    declaration: InterfaceDeclaration,\r\n    typeArguments: TypeNode[],\r\n    contextualTypeArguments: Map<string,Type> | null = null,\r\n    alternativeReportNode: Node | null = null\r\n  ): void {\r\n    throw new Error(\"not implemented\");\r\n  }\r\n\r\n  // memory\r\n\r\n  /** Adds a static memory segment with the specified data. */\r\n  addMemorySegment(buffer: Uint8Array, alignment: i32 = 8): MemorySegment {\r\n    var memoryOffset = i64_align(this.memoryOffset, alignment);\r\n    var segment = MemorySegment.create(buffer, memoryOffset);\r\n    this.memorySegments.push(segment);\r\n    this.memoryOffset = i64_add(memoryOffset, i64_new(buffer.length, 0));\r\n    return segment;\r\n  }\r\n\r\n  // function table\r\n\r\n  /** Adds a function table entry and returns the assigned index. */\r\n  addFunctionTableEntry(func: Function): i32 {\r\n    assert(func.is(ElementFlags.COMPILED));\r\n    if (func.functionTableIndex >= 0) {\r\n      return func.functionTableIndex;\r\n    }\r\n    var index = this.functionTable.length;\r\n    this.functionTable.push(func);\r\n    func.functionTableIndex = index;\r\n    return index;\r\n  }\r\n\r\n  // statements\r\n\r\n  compileStatement(statement: Statement): ExpressionRef {\r\n    var expr: ExpressionRef;\r\n    switch (statement.kind) {\r\n\r\n      case NodeKind.BLOCK:\r\n        expr = this.compileBlockStatement(<BlockStatement>statement);\r\n        break;\r\n\r\n      case NodeKind.BREAK:\r\n        expr = this.compileBreakStatement(<BreakStatement>statement);\r\n        break;\r\n\r\n      case NodeKind.CONTINUE:\r\n        expr = this.compileContinueStatement(<ContinueStatement>statement);\r\n        break;\r\n\r\n      case NodeKind.DO:\r\n        expr = this.compileDoStatement(<DoStatement>statement);\r\n        break;\r\n\r\n      case NodeKind.EMPTY:\r\n        expr = this.compileEmptyStatement(<EmptyStatement>statement);\r\n        break;\r\n\r\n      case NodeKind.EXPRESSION:\r\n        expr = this.compileExpressionStatement(<ExpressionStatement>statement);\r\n        break;\r\n\r\n      case NodeKind.FOR:\r\n        expr = this.compileForStatement(<ForStatement>statement);\r\n        break;\r\n\r\n      case NodeKind.IF:\r\n        expr = this.compileIfStatement(<IfStatement>statement);\r\n        break;\r\n\r\n      case NodeKind.RETURN:\r\n        expr = this.compileReturnStatement(<ReturnStatement>statement);\r\n        break;\r\n\r\n      case NodeKind.SWITCH:\r\n        expr = this.compileSwitchStatement(<SwitchStatement>statement);\r\n        break;\r\n\r\n      case NodeKind.THROW:\r\n        expr = this.compileThrowStatement(<ThrowStatement>statement);\r\n        break;\r\n\r\n      case NodeKind.TRY:\r\n        expr = this.compileTryStatement(<TryStatement>statement);\r\n        break;\r\n\r\n      case NodeKind.VARIABLE:\r\n        var variableInit = this.compileVariableStatement(<VariableStatement>statement);\r\n        expr = variableInit ? variableInit : this.module.createNop();\r\n        break;\r\n\r\n      case NodeKind.WHILE:\r\n        expr = this.compileWhileStatement(<WhileStatement>statement);\r\n        break;\r\n\r\n      case NodeKind.TYPEDECLARATION:\r\n        if (this.currentFunction == this.startFunction) {\r\n          return this.module.createNop();\r\n        }\r\n        // fall-through: must be top-level; function bodies are not guaranteed to be evaluated\r\n\r\n      default:\r\n        throw new Error(\"statement expected\");\r\n    }\r\n\r\n    this.addDebugLocation(expr, statement.range);\r\n    return expr;\r\n  }\r\n\r\n  compileStatements(statements: Statement[]): ExpressionRef[] {\r\n    var k = statements.length;\r\n    var stmts = new Array<ExpressionRef>(k);\r\n    for (var i = 0; i < k; ++i) {\r\n      stmts[i] = this.compileStatement(statements[i]);\r\n    }\r\n    return stmts; // array of 0-es in noEmit-mode\r\n  }\r\n\r\n  compileBlockStatement(statement: BlockStatement): ExpressionRef {\r\n    var statements = statement.statements;\r\n\r\n    // NOTE that we could optimize this to a NOP if empty or unwrap a single\r\n    // statement, but that's not what the source told us to do and left to the\r\n    // optimizer.\r\n\r\n    // Not actually a branch, but can contain its own scoped variables.\r\n    this.currentFunction.flow = this.currentFunction.flow.enterBranchOrScope();\r\n\r\n    var stmt = this.module.createBlock(null, this.compileStatements(statements), NativeType.None);\r\n    var stmtReturns = this.currentFunction.flow.is(FlowFlags.RETURNS);\r\n\r\n    // Switch back to the parent flow\r\n    this.currentFunction.flow = this.currentFunction.flow.leaveBranchOrScope();\r\n    if (stmtReturns) {\r\n      this.currentFunction.flow.set(FlowFlags.RETURNS);\r\n    }\r\n    return stmt;\r\n  }\r\n\r\n  compileBreakStatement(statement: BreakStatement): ExpressionRef {\r\n    if (statement.label) {\r\n      this.error(\r\n        DiagnosticCode.Operation_not_supported,\r\n        statement.label.range\r\n      );\r\n      return this.module.createUnreachable();\r\n    }\r\n    var breakLabel = this.currentFunction.flow.breakLabel;\r\n    if (breakLabel == null) {\r\n      this.error(\r\n        DiagnosticCode.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement,\r\n        statement.range\r\n      );\r\n      return this.module.createUnreachable();\r\n    }\r\n    this.currentFunction.flow.set(FlowFlags.POSSIBLY_BREAKS);\r\n    return this.module.createBreak(breakLabel);\r\n  }\r\n\r\n  compileContinueStatement(statement: ContinueStatement): ExpressionRef {\r\n    if (statement.label) {\r\n      this.error(\r\n        DiagnosticCode.Operation_not_supported,\r\n        statement.label.range\r\n      );\r\n      return this.module.createUnreachable();\r\n    }\r\n    // Check if 'continue' is allowed here\r\n    var continueLabel = this.currentFunction.flow.continueLabel;\r\n    if (continueLabel == null) {\r\n      this.error(\r\n        DiagnosticCode.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement,\r\n        statement.range\r\n      );\r\n      return this.module.createUnreachable();\r\n    }\r\n    this.currentFunction.flow.set(FlowFlags.POSSIBLY_CONTINUES);\r\n    return this.module.createBreak(continueLabel);\r\n  }\r\n\r\n  compileDoStatement(statement: DoStatement): ExpressionRef {\r\n\r\n    // A do statement does not initiate a new branch because it is executed at\r\n    // least once, but has its own break and continue labels.\r\n    var label = this.currentFunction.enterBreakContext();\r\n    var previousBreakLabel = this.currentFunction.flow.breakLabel;\r\n    var previousContinueLabel = this.currentFunction.flow.continueLabel;\r\n    var breakLabel = this.currentFunction.flow.breakLabel = \"break|\" + label;\r\n    var continueLabel = this.currentFunction.flow.continueLabel = \"continue|\" + label;\r\n\r\n    var body = this.compileStatement(statement.statement);\r\n\r\n    // Reset to the previous break and continue labels, if any.\r\n    this.currentFunction.flow.breakLabel = previousBreakLabel;\r\n    this.currentFunction.flow.continueLabel = previousContinueLabel;\r\n\r\n    var condition = makeIsTrueish(\r\n      this.compileExpression(statement.condition, Type.i32, ConversionKind.NONE),\r\n      this.currentType,\r\n      this.module\r\n    );\r\n\r\n    this.currentFunction.leaveBreakContext();\r\n\r\n    return this.module.createBlock(breakLabel, [\r\n      this.module.createLoop(continueLabel,\r\n        this.module.createBlock(null, [\r\n          body,\r\n          this.module.createBreak(continueLabel, condition)\r\n        ], NativeType.None))\r\n    ], NativeType.None);\r\n  }\r\n\r\n  compileEmptyStatement(statement: EmptyStatement): ExpressionRef {\r\n    return this.module.createNop();\r\n  }\r\n\r\n  compileExpressionStatement(statement: ExpressionStatement): ExpressionRef {\r\n    var expr = this.compileExpression(statement.expression, Type.void, ConversionKind.NONE);\r\n    if (this.currentType != Type.void) {\r\n      expr = this.module.createDrop(expr);\r\n      this.currentType = Type.void;\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  compileForStatement(statement: ForStatement): ExpressionRef {\r\n\r\n    // A for statement initiates a new branch with its own scoped variables\r\n    // possibly declared in its initializer, and break context.\r\n    var context = this.currentFunction.enterBreakContext();\r\n    this.currentFunction.flow = this.currentFunction.flow.enterBranchOrScope();\r\n    var breakLabel = this.currentFunction.flow.breakLabel = \"break|\" + context;\r\n    var continueLabel = this.currentFunction.flow.continueLabel = \"continue|\" + context;\r\n\r\n    // Compile in correct order\r\n    var initializer = statement.initializer\r\n      ? this.compileStatement(<Statement>statement.initializer)\r\n      : this.module.createNop();\r\n    var condition = statement.condition\r\n      ? this.compileExpression(<Expression>statement.condition, Type.i32)\r\n      : this.module.createI32(1);\r\n    var incrementor = statement.incrementor\r\n      ? this.compileExpression(<Expression>statement.incrementor, Type.void)\r\n      : this.module.createNop();\r\n    var body = this.compileStatement(statement.statement);\r\n    var alwaysReturns = !statement.condition && this.currentFunction.flow.is(FlowFlags.RETURNS);\r\n    // TODO: check other always-true conditions as well, not just omitted\r\n\r\n    // Switch back to the parent flow\r\n    this.currentFunction.flow = this.currentFunction.flow.leaveBranchOrScope();\r\n    this.currentFunction.leaveBreakContext();\r\n\r\n    var expr = this.module.createBlock(breakLabel, [\r\n      initializer,\r\n      this.module.createLoop(continueLabel, this.module.createBlock(null, [\r\n        this.module.createIf(condition, this.module.createBlock(null, [\r\n          body,\r\n          incrementor,\r\n          this.module.createBreak(continueLabel)\r\n        ], NativeType.None))\r\n      ], NativeType.None))\r\n    ], NativeType.None);\r\n\r\n    // If the loop is guaranteed to run and return, propagate that and append a hint\r\n    if (alwaysReturns) {\r\n      this.currentFunction.flow.set(FlowFlags.RETURNS);\r\n      expr = this.module.createBlock(null, [\r\n        expr,\r\n        this.module.createUnreachable()\r\n      ]);\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  compileIfStatement(statement: IfStatement): ExpressionRef {\r\n\r\n    // The condition doesn't initiate a branch yet\r\n    var condition = makeIsTrueish(\r\n      this.compileExpression(statement.condition, Type.i32, ConversionKind.NONE),\r\n      this.currentType,\r\n      this.module\r\n    );\r\n\r\n    // Each arm initiates a branch\r\n    this.currentFunction.flow = this.currentFunction.flow.enterBranchOrScope();\r\n    var ifTrue = this.compileStatement(statement.ifTrue);\r\n    var ifTrueReturns = this.currentFunction.flow.is(FlowFlags.RETURNS);\r\n    this.currentFunction.flow = this.currentFunction.flow.leaveBranchOrScope();\r\n\r\n    var ifFalse: ExpressionRef = 0;\r\n    var ifFalseReturns = false;\r\n    if (statement.ifFalse) {\r\n      this.currentFunction.flow = this.currentFunction.flow.enterBranchOrScope();\r\n      ifFalse = this.compileStatement(statement.ifFalse);\r\n      ifFalseReturns = this.currentFunction.flow.is(FlowFlags.RETURNS);\r\n      this.currentFunction.flow = this.currentFunction.flow.leaveBranchOrScope();\r\n    }\r\n    if (ifTrueReturns && ifFalseReturns) { // not necessary to append a hint\r\n      this.currentFunction.flow.set(FlowFlags.RETURNS);\r\n    }\r\n    return this.module.createIf(condition, ifTrue, ifFalse);\r\n  }\r\n\r\n  compileReturnStatement(statement: ReturnStatement): ExpressionRef {\r\n    var expression: ExpressionRef = 0;\r\n    if (statement.value) {\r\n      expression = this.compileExpression(<Expression>statement.value, this.currentFunction.returnType);\r\n    }\r\n\r\n    // Remember that this flow returns\r\n    this.currentFunction.flow.set(FlowFlags.RETURNS);\r\n\r\n    return this.module.createReturn(expression);\r\n  }\r\n\r\n  compileSwitchStatement(statement: SwitchStatement): ExpressionRef {\r\n\r\n    // Everything within a switch uses the same break context\r\n    var context = this.currentFunction.enterBreakContext();\r\n\r\n    // introduce a local for evaluating the condition (exactly once)\r\n    var tempLocal = this.currentFunction.getTempLocal(Type.u32);\r\n    var k = statement.cases.length;\r\n\r\n    // Prepend initializer to inner block. Does not initiate a new branch, yet.\r\n    var breaks = new Array<ExpressionRef>(1 + k);\r\n    breaks[0] = this.module.createSetLocal( // initializer\r\n      tempLocal.index,\r\n      this.compileExpression(statement.condition, Type.u32)\r\n    );\r\n\r\n    // make one br_if per (possibly dynamic) labeled case (binaryen optimizes to br_table where possible)\r\n    var breakIndex = 1;\r\n    var defaultIndex = -1;\r\n    for (var i = 0; i < k; ++i) {\r\n      var case_ = statement.cases[i];\r\n      if (case_.label) {\r\n        breaks[breakIndex++] = this.module.createBreak(\"case\" + i.toString(10) + \"|\" + context,\r\n          this.module.createBinary(BinaryOp.EqI32,\r\n            this.module.createGetLocal(tempLocal.index, NativeType.I32),\r\n            this.compileExpression(case_.label, Type.i32)\r\n          )\r\n        );\r\n      } else {\r\n        defaultIndex = i;\r\n      }\r\n    }\r\n\r\n    this.currentFunction.freeTempLocal(tempLocal);\r\n\r\n    // otherwise br to default respectively out of the switch if there is no default case\r\n    breaks[breakIndex] = this.module.createBreak((defaultIndex >= 0\r\n        ? \"case\" + defaultIndex.toString(10)\r\n        : \"break\"\r\n      ) + \"|\" + context);\r\n\r\n    // nest blocks in order\r\n    var currentBlock = this.module.createBlock(\"case0|\" + context, breaks, NativeType.None);\r\n    var alwaysReturns = true;\r\n    for (i = 0; i < k; ++i) {\r\n      case_ = statement.cases[i];\r\n      var l = case_.statements.length;\r\n      var body = new Array<ExpressionRef>(1 + l);\r\n      body[0] = currentBlock;\r\n\r\n      // Each switch case initiates a new branch\r\n      this.currentFunction.flow = this.currentFunction.flow.enterBranchOrScope();\r\n      var breakLabel = this.currentFunction.flow.breakLabel = \"break|\" + context;\r\n\r\n      var fallsThrough = i != k - 1;\r\n      var nextLabel = !fallsThrough ? breakLabel : \"case\" + (i + 1).toString(10) + \"|\" + context;\r\n      for (var j = 0; j < l; ++j) {\r\n        body[j + 1] = this.compileStatement(case_.statements[j]);\r\n      }\r\n      if (!(fallsThrough || this.currentFunction.flow.is(FlowFlags.RETURNS))) {\r\n        alwaysReturns = false; // ignore fall-throughs\r\n      }\r\n\r\n      // Switch back to the parent flow\r\n      this.currentFunction.flow = this.currentFunction.flow.leaveBranchOrScope();\r\n\r\n      currentBlock = this.module.createBlock(nextLabel, body, NativeType.None);\r\n    }\r\n    this.currentFunction.leaveBreakContext();\r\n\r\n    // If the switch has a default and always returns, propagate that\r\n    if (defaultIndex >= 0 && alwaysReturns) {\r\n      this.currentFunction.flow.set(FlowFlags.RETURNS);\r\n      // Binaryen understands that so we don't need a hint\r\n    }\r\n    return currentBlock;\r\n  }\r\n\r\n  compileThrowStatement(statement: ThrowStatement): ExpressionRef {\r\n\r\n    // Remember that this branch possibly throws\r\n    this.currentFunction.flow.set(FlowFlags.POSSIBLY_THROWS);\r\n\r\n    // FIXME: without try-catch it is safe to assume RETURNS as well for now\r\n    this.currentFunction.flow.set(FlowFlags.RETURNS);\r\n\r\n    // TODO: requires exception-handling spec.\r\n    return this.module.createUnreachable();\r\n  }\r\n\r\n  compileTryStatement(statement: TryStatement): ExpressionRef {\r\n    throw new Error(\"not implemented\");\r\n    // can't yet support something like: try { return ... } finally { ... }\r\n    // worthwhile to investigate lowering returns to block results (here)?\r\n  }\r\n\r\n  /**\r\n   * Compiles a variable statement. Returns `0` if an initializer is not\r\n   * necessary.\r\n   */\r\n  compileVariableStatement(statement: VariableStatement, isKnownGlobal: bool = false): ExpressionRef {\r\n    var declarations = statement.declarations;\r\n\r\n    // top-level variables and constants become globals\r\n    if (isKnownGlobal || (\r\n      this.currentFunction == this.startFunction &&\r\n      statement.parent && statement.parent.kind == NodeKind.SOURCE\r\n    )) {\r\n      // NOTE that the above condition also covers top-level variables declared with 'let', even\r\n      // though such variables could also become start function locals if, and only if, not used\r\n      // within any function declared in the same source, which is unknown at this point. the only\r\n      // efficient way to deal with this would be to keep track of all occasions it is used and\r\n      // replace these instructions afterwards, dynamically. (TOOD: what about a Binaryen pass?)\r\n      for (var i = 0, k = declarations.length; i < k; ++i) {\r\n        this.compileGlobalDeclaration(declarations[i]);\r\n      }\r\n      return 0;\r\n    }\r\n\r\n    // other variables become locals\r\n    var initializers = new Array<ExpressionRef>();\r\n    for (i = 0, k = declarations.length; i < k; ++i) {\r\n      var declaration = declarations[i];\r\n      var name = declaration.name.text;\r\n      var type: Type | null = null;\r\n      var init: ExpressionRef = 0;\r\n      if (declaration.type) {\r\n        type = this.program.resolveType( // reports\r\n          declaration.type,\r\n          this.currentFunction.contextualTypeArguments\r\n        );\r\n        if (!type) continue;\r\n        if (declaration.initializer) {\r\n          init = this.compileExpression(declaration.initializer, type); // reports\r\n        }\r\n      } else if (declaration.initializer) { // infer type using void/NONE for proper literal inference\r\n        init = this.compileExpression( // reports\r\n          declaration.initializer,\r\n          Type.void,\r\n          ConversionKind.NONE\r\n        );\r\n        if (this.currentType == Type.void) {\r\n          this.error(\r\n            DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n            declaration.range, this.currentType.toString(), \"<auto>\"\r\n          );\r\n          continue;\r\n        }\r\n        type = this.currentType;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.Type_expected,\r\n          declaration.name.range.atEnd\r\n        );\r\n        continue;\r\n      }\r\n      if (hasModifier(ModifierKind.CONST, declaration.modifiers)) {\r\n        if (init) {\r\n          init = this.precomputeExpressionRef(init);\r\n          if (_BinaryenExpressionGetId(init) == ExpressionId.Const) {\r\n            var local = new Local(this.program, name, -1, type);\r\n            switch (_BinaryenExpressionGetType(init)) {\r\n              case NativeType.I32:\r\n                local = local.withConstantIntegerValue(_BinaryenConstGetValueI32(init), 0);\r\n                break;\r\n              case NativeType.I64:\r\n                local = local.withConstantIntegerValue(\r\n                  _BinaryenConstGetValueI64Low(init),\r\n                  _BinaryenConstGetValueI64High(init)\r\n                );\r\n                break;\r\n              case NativeType.F32:\r\n                local = local.withConstantFloatValue(<f64>_BinaryenConstGetValueF32(init));\r\n                break;\r\n              case NativeType.F64:\r\n                local = local.withConstantFloatValue(_BinaryenConstGetValueF64(init));\r\n                break;\r\n              default:\r\n                throw new Error(\"concrete type expected\");\r\n            }\r\n            // Create a virtual local that doesn't actually exist in WebAssembly\r\n            var scopedLocals = this.currentFunction.flow.scopedLocals;\r\n            if (!scopedLocals) scopedLocals = this.currentFunction.flow.scopedLocals = new Map();\r\n            else if (scopedLocals.has(name)) {\r\n              this.error(\r\n                DiagnosticCode.Duplicate_identifier_0,\r\n                declaration.name.range, name\r\n              );\r\n              return 0;\r\n            }\r\n            scopedLocals.set(name, local);\r\n            return 0;\r\n          } else {\r\n            this.warning(\r\n              DiagnosticCode.Compiling_constant_with_non_constant_initializer_as_mutable,\r\n              declaration.range\r\n            );\r\n          }\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._const_declarations_must_be_initialized,\r\n            declaration.range\r\n          );\r\n        }\r\n      }\r\n      if (hasModifier(ModifierKind.LET, declaration.modifiers)) { // here: not top-level\r\n        this.currentFunction.flow.addScopedLocal(name, type, declaration.name); // reports\r\n      } else {\r\n        this.currentFunction.addLocal(type, name); // reports\r\n      }\r\n      if (init) {\r\n        initializers.push(this.compileAssignmentWithValue(declaration.name, init));\r\n      }\r\n    }\r\n    return initializers.length   // we can unwrap these here because the\r\n      ? initializers.length == 1 // source didn't tell us exactly what to do\r\n        ? initializers[0]\r\n        : this.module.createBlock(null, initializers, NativeType.None)\r\n      : 0;\r\n  }\r\n\r\n  compileWhileStatement(statement: WhileStatement): ExpressionRef {\r\n\r\n    // The condition does not yet initialize a branch\r\n    var condition = makeIsTrueish(\r\n      this.compileExpression(statement.condition, Type.i32, ConversionKind.NONE),\r\n      this.currentType,\r\n      this.module\r\n    );\r\n\r\n    // Statements initiate a new branch with its own break context\r\n    var label = this.currentFunction.enterBreakContext();\r\n    this.currentFunction.flow = this.currentFunction.flow.enterBranchOrScope();\r\n    var breakLabel = this.currentFunction.flow.breakLabel = \"break|\" + label;\r\n    var continueLabel = this.currentFunction.flow.continueLabel = \"continue|\" + label;\r\n\r\n    var body = this.compileStatement(statement.statement);\r\n    var alwaysReturns = false && this.currentFunction.flow.is(FlowFlags.RETURNS);\r\n    // TODO: evaluate possible always-true conditions\r\n\r\n    // Switch back to the parent flow\r\n    this.currentFunction.flow = this.currentFunction.flow.leaveBranchOrScope();\r\n    this.currentFunction.leaveBreakContext();\r\n\r\n    var expr = this.module.createBlock(breakLabel, [\r\n      this.module.createLoop(continueLabel,\r\n        this.module.createIf(condition, this.module.createBlock(null, [\r\n          body,\r\n          this.module.createBreak(continueLabel)\r\n        ], NativeType.None))\r\n      )\r\n    ], NativeType.None);\r\n\r\n    // If the loop is guaranteed to run and return, propagate that and append a hint\r\n    if (alwaysReturns) {\r\n      expr = this.module.createBlock(null, [\r\n        expr,\r\n        this.module.createUnreachable()\r\n      ]);\r\n    }\r\n    return expr;\r\n  }\r\n\r\n  // expressions\r\n\r\n  /** Compiles an inlined constant value of a variable-like element. */\r\n  compileInlineConstant(element: VariableLikeElement, contextualType: Type): ExpressionRef {\r\n    assert(element.is(ElementFlags.INLINED));\r\n\r\n    switch (\r\n      element.type.is(TypeFlags.INTEGER) &&\r\n      contextualType.is(TypeFlags.INTEGER) &&\r\n      element.type.size < contextualType.size\r\n        ? (this.currentType = contextualType).kind // essentially precomputes a (sign-)extension\r\n        : (this.currentType = element.type).kind\r\n    ) {\r\n\r\n      case TypeKind.I8:\r\n      case TypeKind.I16:\r\n        var shift = element.type.computeSmallIntegerShift(Type.i32);\r\n        return this.module.createI32(\r\n          element.constantValueKind == ConstantValueKind.INTEGER\r\n            ? i64_low(element.constantIntegerValue) << shift >> shift\r\n            : 0\r\n        );\r\n\r\n      case TypeKind.U8:\r\n      case TypeKind.U16:\r\n      case TypeKind.BOOL:\r\n        var mask = element.type.computeSmallIntegerMask(Type.i32);\r\n        return this.module.createI32(\r\n          element.constantValueKind == ConstantValueKind.INTEGER\r\n            ? i64_low(element.constantIntegerValue) & mask\r\n            : 0\r\n        );\r\n\r\n      case TypeKind.I32:\r\n      case TypeKind.U32:\r\n        return this.module.createI32(\r\n          element.constantValueKind == ConstantValueKind.INTEGER\r\n            ? i64_low(element.constantIntegerValue)\r\n            : 0\r\n        );\r\n\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE:\r\n        if (!element.program.options.isWasm64) {\r\n          return this.module.createI32(\r\n            element.constantValueKind == ConstantValueKind.INTEGER\r\n              ? i64_low(element.constantIntegerValue)\r\n              : 0\r\n          );\r\n        }\r\n        // fall-through\r\n\r\n      case TypeKind.I64:\r\n      case TypeKind.U64:\r\n        return element.constantValueKind == ConstantValueKind.INTEGER\r\n          ? this.module.createI64(\r\n              i64_low(element.constantIntegerValue),\r\n              i64_high(element.constantIntegerValue)\r\n            )\r\n          : this.module.createI64(0);\r\n\r\n      case TypeKind.F32:\r\n        return this.module.createF32((<VariableLikeElement>element).constantFloatValue);\r\n\r\n      case TypeKind.F64:\r\n        return this.module.createF64((<VariableLikeElement>element).constantFloatValue);\r\n\r\n      default:\r\n        throw new Error(\"concrete type expected\");\r\n    }\r\n  }\r\n\r\n  compileExpression(\r\n    expression: Expression,\r\n    contextualType: Type,\r\n    conversionKind: ConversionKind = ConversionKind.IMPLICIT,\r\n    wrapSmallIntegers: bool = true\r\n  ): ExpressionRef {\r\n    this.currentType = contextualType;\r\n\r\n    var expr: ExpressionRef;\r\n    switch (expression.kind) {\r\n\r\n      case NodeKind.ASSERTION:\r\n        expr = this.compileAssertionExpression(<AssertionExpression>expression, contextualType);\r\n        break;\r\n\r\n      case NodeKind.BINARY:\r\n        expr = this.compileBinaryExpression(<BinaryExpression>expression, contextualType, wrapSmallIntegers);\r\n        break;\r\n\r\n      case NodeKind.CALL:\r\n        expr = this.compileCallExpression(<CallExpression>expression, contextualType);\r\n        break;\r\n\r\n      case NodeKind.COMMA:\r\n        expr = this.compileCommaExpression(<CommaExpression>expression, contextualType);\r\n        break;\r\n\r\n      case NodeKind.ELEMENTACCESS:\r\n        expr = this.compileElementAccessExpression(<ElementAccessExpression>expression, contextualType);\r\n        break;\r\n\r\n      case NodeKind.FUNCTION:\r\n      case NodeKind.FUNCTIONARROW:\r\n        expr = this.compileFunctionExpression(<FunctionExpression>expression, contextualType);\r\n        break;\r\n\r\n      case NodeKind.IDENTIFIER:\r\n      case NodeKind.FALSE:\r\n      case NodeKind.NULL:\r\n      case NodeKind.THIS:\r\n      case NodeKind.TRUE:\r\n        expr = this.compileIdentifierExpression(<IdentifierExpression>expression, contextualType);\r\n        break;\r\n\r\n      case NodeKind.LITERAL:\r\n        expr = this.compileLiteralExpression(<LiteralExpression>expression, contextualType);\r\n        break;\r\n\r\n      case NodeKind.NEW:\r\n        expr = this.compileNewExpression(<NewExpression>expression, contextualType);\r\n        break;\r\n\r\n      case NodeKind.PARENTHESIZED:\r\n        expr = this.compileParenthesizedExpression(<ParenthesizedExpression>expression, contextualType);\r\n        break;\r\n\r\n      case NodeKind.PROPERTYACCESS:\r\n        expr = this.compilePropertyAccessExpression(<PropertyAccessExpression>expression, contextualType);\r\n        break;\r\n\r\n      case NodeKind.TERNARY:\r\n        expr = this.compileTernaryExpression(<TernaryExpression>expression, contextualType);\r\n        break;\r\n\r\n      case NodeKind.UNARYPOSTFIX:\r\n        expr = this.compileUnaryPostfixExpression(<UnaryPostfixExpression>expression, contextualType);\r\n        break;\r\n\r\n      case NodeKind.UNARYPREFIX:\r\n        expr = this.compileUnaryPrefixExpression(<UnaryPrefixExpression>expression, contextualType, wrapSmallIntegers);\r\n        break;\r\n\r\n      default:\r\n        throw new Error(\"expression expected\");\r\n    }\r\n\r\n    if (conversionKind != ConversionKind.NONE && this.currentType != contextualType) {\r\n      expr = this.convertExpression(expr, this.currentType, contextualType, conversionKind, expression);\r\n      this.currentType = contextualType;\r\n    }\r\n\r\n    this.addDebugLocation(expr, expression.range);\r\n    return expr;\r\n  }\r\n\r\n  precomputeExpression(\r\n    expression: Expression,\r\n    contextualType: Type,\r\n    conversionKind: ConversionKind = ConversionKind.IMPLICIT\r\n  ): ExpressionRef {\r\n    return this.precomputeExpressionRef(this.compileExpression(expression, contextualType, conversionKind));\r\n  }\r\n\r\n  precomputeExpressionRef(expr: ExpressionRef): ExpressionRef {\r\n    var nativeType = this.currentType.toNativeType();\r\n    var typeRef = this.module.getFunctionTypeBySignature(nativeType, []);\r\n    var typeRefAdded = false;\r\n    if (!typeRef) {\r\n      typeRef = this.module.addFunctionType(this.currentType.toSignatureString(), nativeType, []);\r\n      typeRefAdded = true;\r\n    }\r\n    var funcRef = this.module.addFunction(\"__precompute\", typeRef, [], expr);\r\n    this.module.runPasses([ \"precompute\" ], funcRef);\r\n    var ret = _BinaryenFunctionGetBody(funcRef);\r\n    this.module.removeFunction(\"__precompute\");\r\n    if (typeRefAdded) {\r\n      // TODO: also remove the function type somehow if no longer used or make the C-API accept\r\n      // a `null` typeRef, using an implicit type.\r\n    }\r\n    return ret;\r\n  }\r\n\r\n  convertExpression(\r\n    expr: ExpressionRef,\r\n    fromType: Type,\r\n    toType: Type,\r\n    conversionKind: ConversionKind,\r\n    reportNode: Node\r\n  ): ExpressionRef {\r\n    if (conversionKind == ConversionKind.NONE) {\r\n      assert(false, \"concrete type expected\");\r\n      return expr;\r\n    }\r\n\r\n    // void to any\r\n    if (fromType.kind == TypeKind.VOID) {\r\n      this.error(\r\n        DiagnosticCode.Type_0_is_not_assignable_to_type_1,\r\n        reportNode.range, fromType.toString(), toType.toString()\r\n      );\r\n      return this.module.createUnreachable();\r\n    }\r\n\r\n    // any to void\r\n    if (toType.kind == TypeKind.VOID) {\r\n      return this.module.createDrop(expr);\r\n    }\r\n\r\n    if (conversionKind == ConversionKind.IMPLICIT && !fromType.isAssignableTo(toType)) {\r\n      this.error(\r\n        DiagnosticCode.Conversion_from_type_0_to_1_requires_an_explicit_cast,\r\n        reportNode.range, fromType.toString(), toType.toString()\r\n      );\r\n    }\r\n\r\n    var mod = this.module;\r\n    var losesInformation = false;\r\n\r\n    if (fromType.is(TypeFlags.FLOAT)) {\r\n\r\n      // float to float\r\n      if (toType.is(TypeFlags.FLOAT)) {\r\n        if (fromType.kind == TypeKind.F32) {\r\n\r\n          // f32 to f64\r\n          if (toType.kind == TypeKind.F64) {\r\n            expr = mod.createUnary(UnaryOp.PromoteF32, expr);\r\n          }\r\n\r\n          // otherwise f32 to f32\r\n\r\n        // f64 to f32\r\n        } else if (toType.kind == TypeKind.F32) {\r\n          losesInformation = true;\r\n          expr = mod.createUnary(UnaryOp.DemoteF64, expr);\r\n        }\r\n\r\n        // otherwise f64 to f64\r\n\r\n      // float to int\r\n      } else if (toType.is(TypeFlags.INTEGER)) {\r\n        losesInformation = true;\r\n\r\n        // f32 to int\r\n        if (fromType.kind == TypeKind.F32) {\r\n          if (toType.is(TypeFlags.SIGNED)) {\r\n            if (toType.is(TypeFlags.LONG)) {\r\n              expr = mod.createUnary(UnaryOp.TruncF32ToI64, expr);\r\n            } else {\r\n              expr = mod.createUnary(UnaryOp.TruncF32ToI32, expr);\r\n              if (toType.is(TypeFlags.SMALL)) {\r\n                expr = makeSmallIntegerWrap(expr, toType, this.module);\r\n              }\r\n            }\r\n          } else {\r\n            if (toType.is(TypeFlags.LONG)) {\r\n              expr = mod.createUnary(UnaryOp.TruncF32ToU64, expr);\r\n            } else {\r\n              expr = mod.createUnary(UnaryOp.TruncF32ToU32, expr);\r\n              if (toType.is(TypeFlags.SMALL)) {\r\n                expr = makeSmallIntegerWrap(expr, toType, this.module);\r\n              }\r\n            }\r\n          }\r\n\r\n        // f64 to int\r\n        } else {\r\n          if (toType.is(TypeFlags.SIGNED)) {\r\n            if (toType.is(TypeFlags.LONG)) {\r\n              expr = mod.createUnary(UnaryOp.TruncF64ToI64, expr);\r\n            } else {\r\n              expr = mod.createUnary(UnaryOp.TruncF64ToI32, expr);\r\n              if (toType.is(TypeFlags.SMALL)) {\r\n                expr = makeSmallIntegerWrap(expr, toType, this.module);\r\n              }\r\n            }\r\n          } else {\r\n            if (toType.is(TypeFlags.LONG)) {\r\n              expr = mod.createUnary(UnaryOp.TruncF64ToU64, expr);\r\n            } else {\r\n              expr = mod.createUnary(UnaryOp.TruncF64ToU32, expr);\r\n              if (toType.is(TypeFlags.SMALL)) {\r\n                expr = makeSmallIntegerWrap(expr, toType, this.module);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n      // float to void\r\n      } else {\r\n        assert(toType.flags == TypeFlags.NONE, \"void type expected\");\r\n        expr = this.module.createDrop(expr);\r\n      }\r\n\r\n    // int to float\r\n    } else if (fromType.is(TypeFlags.INTEGER) && toType.is(TypeFlags.FLOAT)) {\r\n\r\n      // int to f32\r\n      if (toType.kind == TypeKind.F32) {\r\n        if (fromType.is(TypeFlags.LONG)) {\r\n          losesInformation = true;\r\n          expr = mod.createUnary(\r\n            fromType.is(TypeFlags.SIGNED)\r\n              ? UnaryOp.ConvertI64ToF32\r\n              : UnaryOp.ConvertU64ToF32,\r\n            expr\r\n          );\r\n        } else {\r\n          losesInformation = !fromType.is(TypeFlags.SMALL);\r\n          expr = mod.createUnary(\r\n            fromType.is(TypeFlags.SIGNED)\r\n              ? UnaryOp.ConvertI32ToF32\r\n              : UnaryOp.ConvertU32ToF32,\r\n            expr\r\n          );\r\n        }\r\n\r\n      // int to f64\r\n      } else {\r\n        if (fromType.is(TypeFlags.LONG)) {\r\n          losesInformation = true;\r\n          expr = mod.createUnary(\r\n            fromType.is(TypeFlags.SIGNED)\r\n              ? UnaryOp.ConvertI64ToF64\r\n              : UnaryOp.ConvertU64ToF64,\r\n            expr\r\n          );\r\n        } else {\r\n          expr = mod.createUnary(\r\n            fromType.is(TypeFlags.SIGNED)\r\n              ? UnaryOp.ConvertI32ToF64\r\n              : UnaryOp.ConvertU32ToF64,\r\n            expr\r\n          );\r\n        }\r\n      }\r\n\r\n    // int to int\r\n    } else {\r\n      if (fromType.is(TypeFlags.LONG)) {\r\n\r\n        // i64 to i32\r\n        if (!toType.is(TypeFlags.LONG)) {\r\n          losesInformation = true;\r\n          expr = mod.createUnary(UnaryOp.WrapI64, expr); // discards upper bits\r\n          if (toType.is(TypeFlags.SMALL)) {\r\n            expr = makeSmallIntegerWrap(expr, toType, this.module);\r\n          }\r\n        }\r\n\r\n      // i32 to i64\r\n      } else if (toType.is(TypeFlags.LONG)) {\r\n        expr = mod.createUnary(toType.is(TypeFlags.SIGNED) ? UnaryOp.ExtendI32 : UnaryOp.ExtendU32, expr);\r\n\r\n      // i32 or smaller to even smaller or same size int with change of sign\r\n      } else if (\r\n        toType.is(TypeFlags.SMALL) &&\r\n        (\r\n          fromType.size > toType.size ||\r\n          (\r\n            fromType.size == toType.size &&\r\n            fromType.is(TypeFlags.SIGNED) != toType.is(TypeFlags.SIGNED)\r\n          )\r\n        )\r\n      ) {\r\n        losesInformation = true;\r\n        expr = makeSmallIntegerWrap(expr, toType, this.module);\r\n      }\r\n\r\n      // otherwise (smaller) i32/u32 to (same size) i32/u32\r\n    }\r\n\r\n    return expr;\r\n  }\r\n\r\n  /** Computes the common compatible type of two types. Returns `null` if incompatible. */\r\n  computeCommonType(leftType: Type, rightType: Type): Type | null {\r\n    if (leftType.isAssignableTo(rightType)) {\r\n      return rightType;\r\n    } else if (rightType.isAssignableTo(leftType)) {\r\n      return leftType;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  compileAssertionExpression(expression: AssertionExpression, contextualType: Type): ExpressionRef {\r\n    var toType = this.program.resolveType( // reports\r\n      expression.toType,\r\n      this.currentFunction.contextualTypeArguments\r\n    );\r\n    if (!toType) return this.module.createUnreachable();\r\n    return this.compileExpression(expression.expression, toType, ConversionKind.EXPLICIT);\r\n  }\r\n\r\n  compileBinaryExpression(\r\n    expression: BinaryExpression,\r\n    contextualType: Type,\r\n    wrapSmallIntegers: bool = true\r\n  ): ExpressionRef {\r\n    var left: ExpressionRef;\r\n    var right: ExpressionRef;\r\n\r\n    // TODO: Currently, the common type of any binary expression is the first operand's type. This\r\n    // differs from C and other languages where comparing an int to a long, in this order, upcasts\r\n    // left to a long before comparison, instead of failing when trying to downcast right to an int.\r\n    // NOTE that if we change the current behaviour, some examples, tests and wiki pages will have\r\n    // to be updated, while compound binary operations must retain the previous behavior.\r\n\r\n    // var left = this.compileExpression(\r\n    //   expression.left,\r\n    //   contextualType == Type.void\r\n    //     ? Type.i32\r\n    //     : contextualType,\r\n    //   ConversionKind.NONE\r\n    // );\r\n    // var leftType = this.currentType;\r\n    // var right = this.compileExpression(\r\n    //   expression.right,\r\n    //   leftType,\r\n    //   ConversionKind.NONE\r\n    // );\r\n    // var rightType = this.currentType;\r\n    // var commonType = this.computeCommonType(leftType, rightType);\r\n    // if (!commonType) {\r\n    //   this.error(\r\n    //     DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2,\r\n    //     expression.range,\r\n    //     Token.operatorToString(expression.operator), leftType.toString(), rightType.toString()\r\n    //   );\r\n    //   this.currentType = contextualType;\r\n    //   return this.module.createUnreachable();\r\n    // }\r\n\r\n    var condition: ExpressionRef;\r\n    var expr: ExpressionRef;\r\n\r\n    var compound = false;\r\n    var possiblyOverflows = false;\r\n    var tempLocal: Local | null = null;\r\n\r\n    switch (expression.operator) {\r\n\r\n      case Token.LESSTHAN:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE\r\n        );\r\n        right = this.compileExpression(expression.right, this.currentType);\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.I32:\r\n            expr = this.module.createBinary(BinaryOp.LtI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n            expr = this.module.createBinary(BinaryOp.LtI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.LtI64\r\n                : BinaryOp.LtI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.U32:\r\n          case TypeKind.BOOL:\r\n            expr = this.module.createBinary(BinaryOp.LtU32, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.LtU64\r\n                : BinaryOp.LtU32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.LtU64, left, right);\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            expr = this.module.createBinary(BinaryOp.LtF32, left, right);\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            expr = this.module.createBinary(BinaryOp.LtF64, left, right);\r\n            break;\r\n\r\n          default:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        this.currentType = Type.bool;\r\n        break;\r\n\r\n      case Token.GREATERTHAN:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE\r\n        );\r\n        right = this.compileExpression(expression.right, this.currentType);\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.I32:\r\n            expr = this.module.createBinary(BinaryOp.GtI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.GtI64\r\n                : BinaryOp.GtI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n            expr = this.module.createBinary(BinaryOp.GtI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.U32:\r\n          case TypeKind.BOOL:\r\n            expr = this.module.createBinary(BinaryOp.GtU32, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.GtU64\r\n                : BinaryOp.GtU32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.GtU64, left, right);\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            expr = this.module.createBinary(BinaryOp.GtF32, left, right);\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            expr = this.module.createBinary(BinaryOp.GtF64, left, right);\r\n            break;\r\n\r\n          default:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        this.currentType = Type.bool;\r\n        break;\r\n\r\n      case Token.LESSTHAN_EQUALS:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE\r\n        );\r\n        right = this.compileExpression(expression.right, this.currentType);\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.I32:\r\n            expr = this.module.createBinary(BinaryOp.LeI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.LeI64\r\n                : BinaryOp.LeI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n            expr = this.module.createBinary(BinaryOp.LeI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.U32:\r\n          case TypeKind.BOOL:\r\n            expr = this.module.createBinary(BinaryOp.LeU32, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.LeU64\r\n                : BinaryOp.LeU32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.LeU64, left, right);\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            expr = this.module.createBinary(BinaryOp.LeF32, left, right);\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            expr = this.module.createBinary(BinaryOp.LeF64, left, right);\r\n            break;\r\n\r\n          default:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        this.currentType = Type.bool;\r\n        break;\r\n\r\n      case Token.GREATERTHAN_EQUALS:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE\r\n        );\r\n        right = this.compileExpression(expression.right, this.currentType);\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.I32:\r\n            expr = this.module.createBinary(BinaryOp.GeI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.GeI64\r\n                : BinaryOp.GeI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n            expr = this.module.createBinary(BinaryOp.GeI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.U32:\r\n          case TypeKind.BOOL:\r\n            expr = this.module.createBinary(BinaryOp.GeU32, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.GeU64\r\n                : BinaryOp.GeU32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.GeU64, left, right);\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            expr = this.module.createBinary(BinaryOp.GeF32, left, right);\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            expr = this.module.createBinary(BinaryOp.GeF64, left, right);\r\n            break;\r\n\r\n          default:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        this.currentType = Type.bool;\r\n        break;\r\n\r\n      case Token.EQUALS_EQUALS_EQUALS:\r\n        // TODO?\r\n      case Token.EQUALS_EQUALS:\r\n\r\n        // NOTE that this favors correctness, in terms of emitting a binary expression, over\r\n        // checking for a possible use of unary EQZ. while the most classic of all optimizations,\r\n        // that's not what the source told us to do. for reference, `!left` emits unary EQZ.\r\n\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE\r\n        );\r\n        right = this.compileExpression(expression.right, this.currentType);\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.I32:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.U32:\r\n          case TypeKind.BOOL:\r\n            expr = this.module.createBinary(BinaryOp.EqI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.EqI64\r\n                : BinaryOp.EqI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.EqI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            expr = this.module.createBinary(BinaryOp.EqF32, left, right);\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            expr = this.module.createBinary(BinaryOp.EqF64, left, right);\r\n            break;\r\n\r\n          default:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        this.currentType = Type.bool;\r\n        break;\r\n\r\n      case Token.EXCLAMATION_EQUALS_EQUALS:\r\n        // TODO?\r\n      case Token.EXCLAMATION_EQUALS:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE\r\n        );\r\n        right = this.compileExpression(expression.right, this.currentType);\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.I32:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.U32:\r\n          case TypeKind.BOOL:\r\n            expr = this.module.createBinary(BinaryOp.NeI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.NeI64\r\n                : BinaryOp.NeI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.NeI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            expr = this.module.createBinary(BinaryOp.NeF32, left, right);\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            expr = this.module.createBinary(BinaryOp.NeF64, left, right);\r\n            break;\r\n\r\n          default:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        this.currentType = Type.bool;\r\n        break;\r\n\r\n      case Token.EQUALS:\r\n        return this.compileAssignment(expression.left, expression.right, contextualType);\r\n\r\n      case Token.PLUS_EQUALS:\r\n        compound = true;\r\n      case Token.PLUS:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE,\r\n          false // retains low bits of small integers\r\n        );\r\n        right = this.compileExpression(\r\n          expression.right,\r\n          this.currentType,\r\n          ConversionKind.IMPLICIT,\r\n          false // ^\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            possiblyOverflows = true;\r\n          case TypeKind.I32:\r\n          case TypeKind.U32:\r\n            expr = this.module.createBinary(BinaryOp.AddI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.AddI64\r\n                : BinaryOp.AddI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.AddI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            expr = this.module.createBinary(BinaryOp.AddF32, left, right);\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            expr = this.module.createBinary(BinaryOp.AddF64, left, right);\r\n            break;\r\n\r\n          default:\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        break;\r\n\r\n      case Token.MINUS_EQUALS:\r\n        compound = true;\r\n      case Token.MINUS:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE,\r\n          false // retains low bits of small integers\r\n        );\r\n        right = this.compileExpression(\r\n          expression.right,\r\n          this.currentType,\r\n          ConversionKind.IMPLICIT,\r\n          false // ^\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            possiblyOverflows = true;\r\n          case TypeKind.I32:\r\n          case TypeKind.U32:\r\n            expr = this.module.createBinary(BinaryOp.SubI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.SubI64\r\n                : BinaryOp.SubI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.SubI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            expr = this.module.createBinary(BinaryOp.SubF32, left, right);\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            expr = this.module.createBinary(BinaryOp.SubF64, left, right);\r\n            break;\r\n\r\n          default:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        break;\r\n\r\n      case Token.ASTERISK_EQUALS:\r\n        compound = true;\r\n      case Token.ASTERISK:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE,\r\n          false // retains low bits of small integers\r\n        );\r\n        right = this.compileExpression(\r\n          expression.right,\r\n          this.currentType,\r\n          ConversionKind.IMPLICIT,\r\n          false // ^\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            possiblyOverflows = true;\r\n            // fall-through\r\n          case TypeKind.I32:\r\n          case TypeKind.U32:\r\n            expr = this.module.createBinary(BinaryOp.MulI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.MulI64\r\n                : BinaryOp.MulI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.MulI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            expr = this.module.createBinary(BinaryOp.MulF32, left, right);\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            expr = this.module.createBinary(BinaryOp.MulF64, left, right);\r\n            break;\r\n\r\n          default:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        break;\r\n\r\n      case Token.SLASH_EQUALS:\r\n        compound = true;\r\n      case Token.SLASH:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE,\r\n          true // TODO: when can division remain unwrapped? does it overflow?\r\n        );\r\n        right = this.compileExpression(\r\n          expression.right,\r\n          this.currentType,\r\n          ConversionKind.IMPLICIT,\r\n          true // ^\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n            possiblyOverflows = true;\r\n          case TypeKind.I32:\r\n            expr = this.module.createBinary(BinaryOp.DivI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.DivI64\r\n                : BinaryOp.DivI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n            expr = this.module.createBinary(BinaryOp.DivI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            possiblyOverflows = true;\r\n          case TypeKind.U32:\r\n            expr = this.module.createBinary(BinaryOp.DivU32, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.DivU64\r\n                : BinaryOp.DivU32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.DivU64, left, right);\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            expr = this.module.createBinary(BinaryOp.DivF32, left, right);\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            expr = this.module.createBinary(BinaryOp.DivF64, left, right);\r\n            break;\r\n\r\n          default:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        break;\r\n\r\n      case Token.PERCENT_EQUALS:\r\n        compound = true;\r\n      case Token.PERCENT:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE,\r\n          true // TODO: when can remainder remain unwrapped? may it overflow?\r\n        );\r\n        right = this.compileExpression(\r\n          expression.right,\r\n          this.currentType,\r\n          ConversionKind.IMPLICIT,\r\n          true // ^\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.I32:\r\n            expr = this.module.createBinary(BinaryOp.RemI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.RemI64\r\n                : BinaryOp.RemI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n            expr = this.module.createBinary(BinaryOp.RemI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.U32:\r\n          case TypeKind.BOOL:\r\n            expr = this.module.createBinary(BinaryOp.RemU32, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.RemU64\r\n                : BinaryOp.RemU32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.RemU64, left, right);\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n          case TypeKind.F64:\r\n            // TODO: internal fmod, possibly simply imported from JS\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            expr = this.module.createUnreachable();\r\n            break;\r\n\r\n          default:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        break;\r\n\r\n      case Token.LESSTHAN_LESSTHAN_EQUALS:\r\n        compound = true;\r\n      case Token.LESSTHAN_LESSTHAN:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType.is(TypeFlags.FLOAT)\r\n              ? Type.i64\r\n              : contextualType,\r\n          ConversionKind.NONE,\r\n          false // retains low bits of small integers\r\n        );\r\n        right = this.compileExpression(\r\n          expression.right,\r\n          this.currentType,\r\n          ConversionKind.IMPLICIT,\r\n          false // ^\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            possiblyOverflows = true;\r\n          default:\r\n            expr = this.module.createBinary(BinaryOp.ShlI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.ShlI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.ShlI64\r\n                : BinaryOp.ShlI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.VOID:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        break;\r\n\r\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS:\r\n        compound = true;\r\n      case Token.GREATERTHAN_GREATERTHAN:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType.is(TypeFlags.FLOAT)\r\n              ? Type.i64\r\n              : contextualType,\r\n          ConversionKind.NONE,\r\n          true // must wrap small integers\r\n        );\r\n        right = this.compileExpression(\r\n          expression.right,\r\n          this.currentType,\r\n          ConversionKind.IMPLICIT,\r\n          true // ^\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          default:\r\n            // assumes signed shr on signed small integers does not overflow\r\n            expr = this.module.createBinary(BinaryOp.ShrI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n            expr = this.module.createBinary(BinaryOp.ShrI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.ShrI64\r\n                : BinaryOp.ShrI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            // assumes unsigned shr on unsigned small integers does not overflow\r\n          case TypeKind.U32:\r\n            expr = this.module.createBinary(BinaryOp.ShrU32, left, right);\r\n            break;\r\n\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.ShrU64, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.ShrU64\r\n                : BinaryOp.ShrU32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.VOID:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        break;\r\n\r\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\r\n        compound = true;\r\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType == Type.void\r\n              ? Type.u64\r\n              : contextualType,\r\n          ConversionKind.NONE,\r\n          true // modifies low bits of small integers if unsigned\r\n        );\r\n        right = this.compileExpression(\r\n          expression.right,\r\n          this.currentType,\r\n          ConversionKind.IMPLICIT,\r\n          true // ^\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n            possiblyOverflows = true;\r\n            // fall-through\r\n          default:\r\n            // assumes that unsigned shr on unsigned small integers does not overflow\r\n            expr = this.module.createBinary(BinaryOp.ShrU32, left, right);\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.ShrU64, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.ShrU64\r\n                : BinaryOp.ShrU32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.VOID:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        break;\r\n\r\n      case Token.AMPERSAND_EQUALS:\r\n        compound = true;\r\n      case Token.AMPERSAND:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType.is(TypeFlags.FLOAT)\r\n              ? Type.i64\r\n              : contextualType,\r\n          ConversionKind.NONE,\r\n          false // retains low bits of small integers\r\n        );\r\n        right = this.compileExpression(\r\n          expression.right,\r\n          this.currentType,\r\n          ConversionKind.IMPLICIT,\r\n          false // ^\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            possiblyOverflows = true; // if left or right already did\r\n          default:\r\n            expr = this.module.createBinary(BinaryOp.AndI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.AndI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.AndI64\r\n                : BinaryOp.AndI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.VOID:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        break;\r\n\r\n      case Token.BAR_EQUALS:\r\n        compound = true;\r\n      case Token.BAR:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType.is(TypeFlags.FLOAT)\r\n              ? Type.i64\r\n              : contextualType,\r\n          ConversionKind.NONE,\r\n          false // retains low bits of small integers\r\n        );\r\n        right = this.compileExpression(\r\n          expression.right,\r\n          this.currentType,\r\n          ConversionKind.IMPLICIT,\r\n          false // ^\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            possiblyOverflows = true; // if left or right already did\r\n          default:\r\n            expr = this.module.createBinary(BinaryOp.OrI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.OrI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.OrI64\r\n                : BinaryOp.OrI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.VOID:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        break;\r\n\r\n      case Token.CARET_EQUALS:\r\n        compound = true;\r\n      case Token.CARET:\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType.is(TypeFlags.FLOAT)\r\n              ? Type.i64\r\n              : contextualType,\r\n          ConversionKind.NONE,\r\n          false // retains low bits of small integers\r\n        );\r\n        right = this.compileExpression(\r\n          expression.right,\r\n          this.currentType,\r\n          ConversionKind.IMPLICIT,\r\n          false // ^\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            possiblyOverflows = true; // if left or right already did\r\n          default:\r\n            expr = this.module.createBinary(BinaryOp.XorI32, left, right);\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.XorI64, left, right);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.XorI64\r\n                : BinaryOp.XorI32,\r\n              left,\r\n              right\r\n            );\r\n            break;\r\n\r\n          case TypeKind.VOID:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        break;\r\n\r\n      // logical (no overloading)\r\n\r\n      case Token.AMPERSAND_AMPERSAND: // left && right\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE\r\n        );\r\n        right = this.compileExpression(\r\n          expression.right,\r\n          this.currentType,\r\n          ConversionKind.IMPLICIT,\r\n          false\r\n        );\r\n\r\n        // clone left if free of side effects\r\n        expr = this.module.cloneExpression(left, true, 0);\r\n\r\n        // if not possible, tee left to a temp. local\r\n        if (!expr) {\r\n          tempLocal = this.currentFunction.getAndFreeTempLocal(this.currentType);\r\n          left = this.module.createTeeLocal(tempLocal.index, left);\r\n        }\r\n\r\n        possiblyOverflows = this.currentType.is(TypeFlags.SMALL | TypeFlags.INTEGER);\r\n        condition = makeIsTrueish(left, this.currentType, this.module);\r\n\r\n        // simplify when cloning left without side effects was successful\r\n        if (expr) {\r\n          expr = this.module.createIf(\r\n            condition, // left\r\n            right,     //   ? right\r\n            expr       //   : cloned left\r\n          );\r\n        }\r\n\r\n        // otherwise make use of the temp. local\r\n        else {\r\n          expr = this.module.createIf(\r\n            condition,\r\n            right,\r\n            this.module.createGetLocal(\r\n              assert(tempLocal, \"tempLocal must be set\").index,\r\n              this.currentType.toNativeType()\r\n            )\r\n          );\r\n        }\r\n        break;\r\n\r\n      case Token.BAR_BAR:  // left || right\r\n        left = this.compileExpression(\r\n          expression.left,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE\r\n        );\r\n        right = this.compileExpression(\r\n          expression.right,\r\n          this.currentType,\r\n          ConversionKind.IMPLICIT,\r\n          false\r\n        );\r\n\r\n        // clone left if free of side effects\r\n        expr = this.module.cloneExpression(left, true, 0);\r\n\r\n        // if not possible, tee left to a temp. local\r\n        if (!expr) {\r\n          tempLocal = this.currentFunction.getAndFreeTempLocal(this.currentType);\r\n          left = this.module.createTeeLocal(tempLocal.index, left);\r\n        }\r\n\r\n        possiblyOverflows = this.currentType.is(TypeFlags.SMALL | TypeFlags.INTEGER); // if right did\r\n        condition = makeIsTrueish(left, this.currentType, this.module);\r\n\r\n        // simplify when cloning left without side effects was successful\r\n        if (expr) {\r\n          expr = this.module.createIf(\r\n            condition, // left\r\n            expr,      //   ? cloned left\r\n            right      //   : right\r\n          );\r\n        }\r\n\r\n        // otherwise make use of the temp. local\r\n        else {\r\n          expr = this.module.createIf(\r\n            condition,\r\n            this.module.createGetLocal(\r\n              assert(tempLocal, \"tempLocal must be set\").index,\r\n              this.currentType.toNativeType()\r\n            ),\r\n            right\r\n          );\r\n        }\r\n        break;\r\n\r\n      default:\r\n        this.error(\r\n          DiagnosticCode.Operation_not_supported,\r\n          expression.range\r\n        );\r\n        throw new Error(\"not implemented\");\r\n    }\r\n    if (possiblyOverflows && wrapSmallIntegers) {\r\n      assert(this.currentType.is(TypeFlags.SMALL | TypeFlags.INTEGER), \"small integer type expected\");\r\n      expr = makeSmallIntegerWrap(expr, this.currentType, this.module);\r\n    }\r\n    return compound\r\n      ? this.compileAssignmentWithValue(expression.left, expr, contextualType != Type.void)\r\n      : expr;\r\n  }\r\n\r\n  compileAssignment(expression: Expression, valueExpression: Expression, contextualType: Type): ExpressionRef {\r\n    var resolved = this.program.resolveExpression(expression, this.currentFunction); // reports\r\n    if (!resolved) return this.module.createUnreachable();\r\n\r\n    // to compile just the value, we need to know the target's type\r\n    var element = resolved.element;\r\n    var elementType: Type;\r\n    switch (element.kind) {\r\n\r\n      case ElementKind.GLOBAL:\r\n        if (!this.compileGlobal(<Global>element)) { // reports; not yet compiled if a static field compiled as a global\r\n          return this.module.createUnreachable();\r\n        }\r\n        assert((<Global>element).type != Type.void, \"concrete type expected\");\r\n        // fall-through\r\n\r\n      case ElementKind.LOCAL:\r\n      case ElementKind.FIELD:\r\n        elementType = (<VariableLikeElement>element).type;\r\n        break;\r\n\r\n      case ElementKind.PROPERTY:\r\n        var setterPrototype = (<Property>element).setterPrototype;\r\n        if (setterPrototype) {\r\n          var setterInstance = setterPrototype.resolve(); // reports\r\n          if (!setterInstance) return this.module.createUnreachable();\r\n          assert(setterInstance.parameters && setterInstance.parameters.length == 1);\r\n          elementType = (<Parameter[]>setterInstance.parameters)[0].type;\r\n          break;\r\n        }\r\n        this.error(\r\n          DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\r\n          expression.range, (<Property>element).internalName\r\n        );\r\n        return this.module.createUnreachable();\r\n\r\n      case ElementKind.FUNCTION_PROTOTYPE:\r\n        if (expression.kind == NodeKind.ELEMENTACCESS) { // @operator(\"[]\")\r\n          assert(\r\n            resolved.target &&\r\n            resolved.target.kind == ElementKind.CLASS &&\r\n            element.simpleName == (<Class>resolved.target).prototype.fnIndexedGet\r\n          );\r\n          var resolvedIndexedSet = (<FunctionPrototype>element).resolve(null);\r\n          if (resolvedIndexedSet) {\r\n            elementType = resolvedIndexedSet.returnType;\r\n            break;\r\n          }\r\n        }\r\n        // fall-through\r\n      default:\r\n        this.error(\r\n          DiagnosticCode.Operation_not_supported,\r\n          expression.range\r\n        );\r\n        return this.module.createUnreachable();\r\n    }\r\n\r\n    // now compile the value and do the assignment\r\n    this.currentType = elementType;\r\n    return this.compileAssignmentWithValue(\r\n      expression,\r\n      this.compileExpression(valueExpression, elementType),\r\n      contextualType != Type.void\r\n    );\r\n  }\r\n\r\n  compileAssignmentWithValue(\r\n    expression: Expression,\r\n    valueWithCorrectType: ExpressionRef,\r\n    tee: bool = false\r\n  ): ExpressionRef {\r\n    var resolved = this.program.resolveExpression(expression, this.currentFunction); // reports\r\n    if (!resolved) return this.module.createUnreachable();\r\n\r\n    var element = resolved.element;\r\n    var tempLocal: Local;\r\n    var targetExpr: ExpressionRef;\r\n    switch (element.kind) {\r\n\r\n      case ElementKind.LOCAL:\r\n        this.currentType = tee ? (<Local>element).type : Type.void;\r\n        if ((<Local>element).is(ElementFlags.CONSTANT)) {\r\n          this.error(\r\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\r\n            expression.range, (<Local>element).internalName\r\n          );\r\n          return this.module.createUnreachable();\r\n        }\r\n        return tee\r\n          ? this.module.createTeeLocal((<Local>element).index, valueWithCorrectType)\r\n          : this.module.createSetLocal((<Local>element).index, valueWithCorrectType);\r\n\r\n      case ElementKind.GLOBAL:\r\n        if (!this.compileGlobal(<Global>element)) { // reports; not yet compiled if a static field\r\n          return this.module.createUnreachable();\r\n        }\r\n        assert((<Global>element).type != Type.void, \"concrete type expected\");\r\n        this.currentType = tee ? (<Global>element).type : Type.void;\r\n        if ((<Local>element).is(ElementFlags.CONSTANT)) {\r\n          this.error(\r\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\r\n            expression.range,\r\n            (<Local>element).internalName\r\n          );\r\n          return this.module.createUnreachable();\r\n        }\r\n        if (!tee) {\r\n          return this.module.createSetGlobal((<Global>element).internalName, valueWithCorrectType);\r\n        }\r\n        var globalNativeType = (<Global>element).type.toNativeType();\r\n        return this.module.createBlock(null, [ // emulated teeGlobal\r\n          this.module.createSetGlobal((<Global>element).internalName, valueWithCorrectType),\r\n          this.module.createGetGlobal((<Global>element).internalName, globalNativeType)\r\n        ], globalNativeType);\r\n\r\n      case ElementKind.FIELD:\r\n        if ((<Field>element).prototype.isReadonly) {\r\n          this.error(\r\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\r\n            expression.range, (<Field>element).internalName\r\n          );\r\n          return this.module.createUnreachable();\r\n        }\r\n        assert(resolved.targetExpression != null, \"target expression expected\");\r\n        targetExpr = this.compileExpression(\r\n          <Expression>resolved.targetExpression,\r\n          this.options.isWasm64\r\n            ? Type.usize64\r\n            : Type.usize32,\r\n          ConversionKind.NONE\r\n        );\r\n        assert(this.currentType.classType, \"class type expected\");\r\n        this.currentType = tee ? (<Field>element).type : Type.void;\r\n        var elementNativeType = (<Field>element).type.toNativeType();\r\n        if (!tee) {\r\n          return this.module.createStore(\r\n            (<Field>element).type.size >> 3,\r\n            targetExpr,\r\n            valueWithCorrectType,\r\n            elementNativeType,\r\n            (<Field>element).memoryOffset\r\n          );\r\n        }\r\n        tempLocal = this.currentFunction.getAndFreeTempLocal((<Field>element).type);\r\n        // TODO: simplify if valueWithCorrectType has no side effects\r\n        return this.module.createBlock(null, [\r\n          this.module.createSetLocal(tempLocal.index, valueWithCorrectType),\r\n          this.module.createStore(\r\n            (<Field>element).type.size >> 3,\r\n            targetExpr,\r\n            this.module.createGetLocal(tempLocal.index, elementNativeType),\r\n            elementNativeType,\r\n            (<Field>element).memoryOffset\r\n          ),\r\n          this.module.createGetLocal(tempLocal.index, elementNativeType)\r\n        ], elementNativeType);\r\n\r\n      case ElementKind.PROPERTY:\r\n        var setterPrototype = (<Property>element).setterPrototype;\r\n        if (setterPrototype) {\r\n          var setterInstance = setterPrototype.resolve(); // reports\r\n          if (setterInstance) {\r\n            assert(setterInstance.parameters && setterInstance.parameters.length == 1);\r\n            if (!tee) {\r\n              if (setterInstance.is(ElementFlags.INSTANCE)) {\r\n                assert(resolved.targetExpression != null);\r\n                targetExpr = this.compileExpression(\r\n                  <Expression>resolved.targetExpression,\r\n                  this.options.isWasm64\r\n                    ? Type.usize64\r\n                    : Type.usize32,\r\n                  ConversionKind.NONE\r\n                );\r\n                assert(this.currentType.classType);\r\n                this.currentType = Type.void;\r\n                return this.makeCall(setterInstance, [ targetExpr, valueWithCorrectType ]);\r\n              } else {\r\n                this.currentType = Type.void;\r\n                return this.makeCall(setterInstance, [ valueWithCorrectType ]);\r\n              }\r\n            }\r\n            var getterPrototype = (<Property>element).getterPrototype;\r\n            assert(getterPrototype != null);\r\n            var getterInstance = (<FunctionPrototype>getterPrototype).resolve(); // reports\r\n            if (getterInstance) {\r\n              assert(!getterInstance.parameters || !getterInstance.parameters.length);\r\n              if (setterInstance.is(ElementFlags.INSTANCE)) {\r\n                assert(resolved.targetExpression != null);\r\n                targetExpr = this.compileExpression(\r\n                  <Expression>resolved.targetExpression,\r\n                  this.options.isWasm64\r\n                    ? Type.usize64\r\n                    : Type.usize32,\r\n                  ConversionKind.NONE\r\n                );\r\n                assert(this.currentType.classType);\r\n                tempLocal = this.currentFunction.getAndFreeTempLocal(getterInstance.returnType);\r\n                return this.module.createBlock(null, [\r\n                  this.makeCall(setterInstance, [\r\n                    this.module.createTeeLocal(tempLocal.index, targetExpr), valueWithCorrectType\r\n                  ]),\r\n                  this.makeCall(getterInstance, [\r\n                    this.module.createGetLocal(tempLocal.index, tempLocal.type.toNativeType())\r\n                  ])\r\n                ], (this.currentType = getterInstance.returnType).toNativeType());\r\n              } else {\r\n                return this.module.createBlock(null, [\r\n                  this.makeCall(setterInstance, [ valueWithCorrectType ]),\r\n                  this.makeCall(getterInstance)\r\n                ], (this.currentType = getterInstance.returnType).toNativeType());\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property,\r\n            expression.range, (<Property>element).internalName\r\n          );\r\n        }\r\n        return this.module.createUnreachable();\r\n\r\n      case ElementKind.FUNCTION_PROTOTYPE:\r\n        if (expression.kind == NodeKind.ELEMENTACCESS) { // @operator(\"[]\")\r\n          assert(resolved.target && resolved.target.kind == ElementKind.CLASS);\r\n          var resolvedIndexedGet = (<FunctionPrototype>element).resolve();\r\n          if (!resolvedIndexedGet) return this.module.createUnreachable();\r\n          var indexedSetName = (<Class>resolved.target).prototype.fnIndexedSet;\r\n          var indexedSet: Element | null;\r\n          if (\r\n            indexedSetName != null &&\r\n            (<Class>resolved.target).members &&\r\n            (indexedSet = (<Map<string,Element>>(<Class>resolved.target).members).get(indexedSetName)) &&\r\n            indexedSet.kind == ElementKind.FUNCTION_PROTOTYPE\r\n          ) { // @operator(\"[]=\")\r\n            var resolvedIndexedSet = (<FunctionPrototype>indexedSet).resolve();\r\n            if (!resolvedIndexedSet) return this.module.createUnreachable();\r\n            targetExpr = this.compileExpression(\r\n              <Expression>resolved.targetExpression,\r\n              this.options.isWasm64\r\n                ? Type.usize64\r\n                : Type.usize32,\r\n              ConversionKind.NONE\r\n            );\r\n            assert(this.currentType.classType);\r\n            var elementExpr = this.compileExpression(\r\n              (<ElementAccessExpression>expression).elementExpression,\r\n              Type.i32\r\n            );\r\n            if (!tee) {\r\n              this.currentType = resolvedIndexedSet.returnType;\r\n              return this.makeCall(resolvedIndexedSet, [\r\n                targetExpr,\r\n                elementExpr,\r\n                valueWithCorrectType\r\n              ]);\r\n            }\r\n            this.currentType = resolvedIndexedGet.returnType;\r\n            tempLocal = this.currentFunction.getAndFreeTempLocal(this.currentType);\r\n            return this.module.createBlock(null, [\r\n              this.makeCall(resolvedIndexedSet, [\r\n                targetExpr,\r\n                elementExpr,\r\n                this.module.createTeeLocal(tempLocal.index, valueWithCorrectType)\r\n              ]),\r\n              // TODO: could be different from an actual __get (needs 2 temp locals)\r\n              this.module.createGetLocal(tempLocal.index, tempLocal.type.toNativeType())\r\n            ], this.currentType.toNativeType());\r\n          } else {\r\n            this.error(\r\n              DiagnosticCode.Index_signature_in_type_0_only_permits_reading,\r\n              expression.range, (<Class>resolved.target).internalName\r\n            );\r\n            return this.module.createUnreachable();\r\n          }\r\n        }\r\n        // fall-through\r\n    }\r\n    this.error(\r\n      DiagnosticCode.Operation_not_supported,\r\n      expression.range\r\n    );\r\n    return this.module.createUnreachable();\r\n  }\r\n\r\n  compileCallExpression(expression: CallExpression, contextualType: Type): ExpressionRef {\r\n    var resolved = this.program.resolveExpression(expression.expression, this.currentFunction); // reports\r\n    if (!resolved) return this.module.createUnreachable();\r\n\r\n    var element = resolved.element;\r\n    if (element.kind != ElementKind.FUNCTION_PROTOTYPE) {\r\n      this.error(\r\n        DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\r\n        expression.range, element.internalName\r\n      );\r\n      return this.module.createUnreachable();\r\n    }\r\n\r\n    var functionPrototype = <FunctionPrototype>element;\r\n    var functionInstance: Function | null = null;\r\n\r\n    // TODO: generalize?\r\n    if (functionPrototype.is(ElementFlags.BUILTIN)) {\r\n      var resolvedTypeArguments: Type[] | null = null;\r\n      if (expression.typeArguments) {\r\n        var k = expression.typeArguments.length;\r\n        resolvedTypeArguments = new Array<Type>(k);\r\n        for (var i = 0; i < k; ++i) {\r\n          var resolvedType = this.program.resolveType( // reports\r\n            expression.typeArguments[i],\r\n            this.currentFunction.contextualTypeArguments,\r\n            true\r\n          );\r\n          if (!resolvedType) return this.module.createUnreachable();\r\n          resolvedTypeArguments[i] = resolvedType;\r\n        }\r\n      }\r\n      var expr = compileBuiltinCall(\r\n        this,\r\n        functionPrototype,\r\n        resolvedTypeArguments,\r\n        expression.arguments,\r\n        contextualType,\r\n        expression\r\n      );\r\n      if (!expr) {\r\n        this.error(\r\n          DiagnosticCode.Operation_not_supported,\r\n          expression.range\r\n        );\r\n        return this.module.createUnreachable();\r\n      }\r\n      return expr;\r\n    }\r\n\r\n    // TODO: infer type arguments from parameter types if omitted\r\n    functionInstance = functionPrototype.resolveInclTypeArguments( // reports\r\n      expression.typeArguments,\r\n      this.currentFunction.contextualTypeArguments,\r\n      expression\r\n    );\r\n    if (!functionInstance) return this.module.createUnreachable();\r\n\r\n    // TODO: generalize? (see above)\r\n    /* if (functionInstance.is(ElementFlags.BUILTIN)) {\r\n      var expr = compileBuiltinCall(\r\n        this,\r\n        functionPrototype,\r\n        functionInstance.typeArguments,\r\n        expression.arguments,\r\n        contextualType,\r\n        expression\r\n      );\r\n      if (!expr) {\r\n        this.error(DiagnosticCode.Operation_not_supported, expression.range);\r\n        return this.module.createUnreachable();\r\n      }\r\n      return expr;\r\n    } */\r\n\r\n    var numArguments = expression.arguments.length;\r\n    var numArgumentsInclThis = functionInstance.instanceMethodOf\r\n      ? numArguments + 1\r\n      : numArguments;\r\n    var argumentIndex = 0;\r\n\r\n    var args = new Array<Expression>(numArgumentsInclThis);\r\n    if (functionInstance.instanceMethodOf) {\r\n      assert(resolved.targetExpression != null);\r\n      args[argumentIndex++] = <Expression>resolved.targetExpression;\r\n    }\r\n    for (i = 0; i < numArguments; ++i) {\r\n      args[argumentIndex++] = expression.arguments[i];\r\n    }\r\n    return this.compileCall(functionInstance, args, expression);\r\n  }\r\n\r\n  /**\r\n   * Compiles a call to a function. If an instance method, `this` is the first element in\r\n   * `argumentExpressions` or can be specified explicitly as the last argument.\r\n   */\r\n  compileCall(\r\n    functionInstance: Function,\r\n    argumentExpressions: Expression[],\r\n    reportNode: Node,\r\n    thisArg: ExpressionRef = 0\r\n  ): ExpressionRef {\r\n\r\n    // validate and compile arguments\r\n    var parameters = functionInstance.parameters;\r\n\r\n    var numParameters = parameters ? parameters.length : 0;\r\n    var numParametersInclThis = functionInstance.instanceMethodOf != null\r\n      ? numParameters + 1\r\n      : numParameters;\r\n    var numArgumentsInclThis = argumentExpressions.length;\r\n    var numArguments = functionInstance.instanceMethodOf != null\r\n      ? numArgumentsInclThis - 1\r\n      : numArgumentsInclThis;\r\n    if (thisArg) numArgumentsInclThis++;\r\n\r\n    if (numArgumentsInclThis > numParametersInclThis) { // too many arguments\r\n      this.error(\r\n        DiagnosticCode.Expected_0_arguments_but_got_1,\r\n        reportNode.range, numParameters.toString(10), numArguments.toString(10)\r\n      );\r\n      return this.module.createUnreachable();\r\n    }\r\n    var operands = new Array<ExpressionRef>(numParametersInclThis);\r\n    var operandIndex = 0;\r\n    var argumentIndex = 0;\r\n    if (functionInstance.instanceMethodOf) {\r\n      if (thisArg) {\r\n        operands[operandIndex++] = thisArg;\r\n      } else {\r\n        operands[operandIndex++] = this.compileExpression(\r\n          argumentExpressions[argumentIndex++],\r\n          functionInstance.instanceMethodOf.type\r\n        );\r\n      }\r\n    }\r\n    if (parameters) {\r\n      for (; operandIndex < numParametersInclThis; ++operandIndex) {\r\n\r\n        // argument has been provided\r\n        if (numArgumentsInclThis > operandIndex) {\r\n          operands[operandIndex] = this.compileExpression(\r\n            argumentExpressions[argumentIndex++],\r\n            parameters[operandIndex + numParameters - numParametersInclThis].type\r\n          );\r\n\r\n        // argument has been omitted\r\n        } else {\r\n          var initializer = parameters[operandIndex + numParameters - numParametersInclThis].initializer;\r\n          if (initializer) { // fall back to provided initializer\r\n            operands[operandIndex] = this.compileExpression(\r\n              initializer,\r\n              parameters[operandIndex + numParameters - numParametersInclThis].type\r\n            );\r\n            // FIXME: here, the initializer is compiled in the caller's scope.\r\n            // a solution could be to use a stub for each possible overload, calling the\r\n            // full function with optional arguments being part of the stub's body.\r\n\r\n          } else { // too few arguments\r\n            this.error(\r\n              DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\r\n              reportNode.range,\r\n              (operandIndex + numParameters - numParametersInclThis).toString(10),\r\n              numArguments.toString(10)\r\n            );\r\n            return this.module.createUnreachable();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    this.currentType = functionInstance.returnType;\r\n    return this.makeCall(functionInstance, operands);\r\n  }\r\n\r\n  /** Makes a call operation as is. */\r\n  makeCall(functionInstance: Function, operands: ExpressionRef[] | null = null): ExpressionRef {\r\n    if (!(functionInstance.is(ElementFlags.COMPILED) || this.compileFunction(functionInstance))) {\r\n      return this.module.createUnreachable();\r\n    }\r\n\r\n    // imported function\r\n    if (functionInstance.is(ElementFlags.DECLARED)) {\r\n      return this.module.createCallImport(\r\n        functionInstance.internalName,\r\n        operands,\r\n        functionInstance.returnType.toNativeType()\r\n      );\r\n    }\r\n\r\n    // internal function\r\n    return this.module.createCall(\r\n      functionInstance.internalName,\r\n      operands,\r\n      functionInstance.returnType.toNativeType()\r\n    );\r\n  }\r\n\r\n  compileCommaExpression(expression: CommaExpression, contextualType: Type): ExpressionRef {\r\n    var expressions = expression.expressions;\r\n    var k = expressions.length;\r\n    var exprs = new Array<ExpressionRef>(k--);\r\n    for (var i = 0; i < k; ++i) {\r\n      exprs[i] = this.compileExpression(expressions[i], Type.void);    // drop all\r\n    }\r\n    exprs[i] = this.compileExpression(expressions[i], contextualType); // except last\r\n    return this.module.createBlock(null, exprs, this.currentType.toNativeType());\r\n  }\r\n\r\n  compileElementAccessExpression(expression: ElementAccessExpression, contextualType: Type): ExpressionRef {\r\n    var resolved = this.program.resolveElementAccess(expression, this.currentFunction); // reports\r\n    if (!resolved) return this.module.createUnreachable();\r\n    assert(\r\n      resolved.element.kind == ElementKind.FUNCTION_PROTOTYPE &&\r\n      resolved.target &&\r\n      resolved.target.kind == ElementKind.CLASS\r\n    );\r\n    var instance = (<FunctionPrototype>resolved.element).resolve(\r\n      null,\r\n      (<Class>resolved.target).contextualTypeArguments\r\n    );\r\n    if (!instance) return this.module.createUnreachable();\r\n    return this.compileCall(instance, [\r\n      expression.expression,\r\n      expression.elementExpression\r\n    ], expression);\r\n  }\r\n\r\n  compileFunctionExpression(expression: FunctionExpression, contextualType: Type): ExpressionRef {\r\n    var declaration = expression.declaration;\r\n    var simpleName = (declaration.name.text.length\r\n      ? declaration.name.text\r\n      : \"anonymous\") + \"|\" + this.functionTable.length.toString(10);\r\n    var prototype = new FunctionPrototype(\r\n      this.program,\r\n      simpleName,\r\n      this.currentFunction.internalName + \"~\" + simpleName,\r\n      declaration\r\n    );\r\n    var instance = this.compileFunctionUsingTypeArguments(prototype, [], null, declaration);\r\n    if (!instance) return this.module.createUnreachable();\r\n    this.currentType = Type.u32.asFunction(instance);\r\n    // NOTE that, in order to make this work in every case, the function must be represented by a\r\n    // value, so we add it and rely on the optimizer to figure out where it can be called directly.\r\n    var index = this.addFunctionTableEntry(instance);\r\n    if (index < 0) return this.module.createUnreachable();\r\n    return this.module.createI32(index);\r\n  }\r\n\r\n  compileIdentifierExpression(expression: IdentifierExpression, contextualType: Type): ExpressionRef {\r\n    // check special keywords first\r\n    switch (expression.kind) {\r\n\r\n      case NodeKind.NULL:\r\n        if (this.options.isWasm64) {\r\n          if (!contextualType.classType) {\r\n            assert(contextualType.kind == TypeKind.USIZE);\r\n            this.currentType = Type.usize64;\r\n          }\r\n          return this.module.createI64(0);\r\n        }\r\n        if (!contextualType.classType) {\r\n          assert(contextualType.kind == TypeKind.USIZE);\r\n          this.currentType = Type.usize32;\r\n        }\r\n        return this.module.createI32(0);\r\n\r\n      case NodeKind.TRUE:\r\n        this.currentType = Type.bool;\r\n        return this.module.createI32(1);\r\n\r\n      case NodeKind.FALSE:\r\n        this.currentType = Type.bool;\r\n        return this.module.createI32(0);\r\n\r\n      case NodeKind.THIS:\r\n        if (this.currentFunction.instanceMethodOf) {\r\n          this.currentType = this.currentFunction.instanceMethodOf.type;\r\n          return this.module.createGetLocal(0, this.currentType.toNativeType());\r\n        }\r\n        this.error(\r\n          DiagnosticCode._this_cannot_be_referenced_in_current_location,\r\n          expression.range\r\n        );\r\n        this.currentType = this.options.isWasm64 ? Type.usize64 : Type.usize32;\r\n        return this.module.createUnreachable();\r\n\r\n      case NodeKind.SUPER:\r\n        if (this.currentFunction.instanceMethodOf && this.currentFunction.instanceMethodOf.base) {\r\n          this.currentType = this.currentFunction.instanceMethodOf.base.type;\r\n          return this.module.createGetLocal(0, this.currentType.toNativeType());\r\n        }\r\n        this.error(\r\n          DiagnosticCode._super_can_only_be_referenced_in_a_derived_class,\r\n          expression.range\r\n        );\r\n        this.currentType = this.options.isWasm64 ? Type.usize64 : Type.usize32;\r\n        return this.module.createUnreachable();\r\n    }\r\n\r\n    // otherwise resolve\r\n    var resolved = this.program.resolveIdentifier( // reports\r\n      expression,\r\n      this.currentFunction,\r\n      this.currentEnum\r\n    );\r\n    if (!resolved) return this.module.createUnreachable();\r\n\r\n    var element = resolved.element;\r\n    switch (element.kind) {\r\n\r\n      case ElementKind.LOCAL:\r\n        if ((<Local>element).is(ElementFlags.INLINED)) {\r\n          return this.compileInlineConstant(<Local>element, contextualType);\r\n        }\r\n        assert((<Local>element).index >= 0);\r\n        this.currentType = (<Local>element).type;\r\n        return this.module.createGetLocal((<Local>element).index, this.currentType.toNativeType());\r\n\r\n      case ElementKind.GLOBAL:\r\n        if (element.is(ElementFlags.BUILTIN)) {\r\n          return compileBuiltinGetConstant(this, <Global>element, expression);\r\n        }\r\n        if (!this.compileGlobal(<Global>element)) { // reports; not yet compiled if a static field\r\n          return this.module.createUnreachable();\r\n        }\r\n        assert((<Global>element).type != Type.void);\r\n        if ((<Global>element).is(ElementFlags.INLINED)) {\r\n          return this.compileInlineConstant(<Global>element, contextualType);\r\n        }\r\n        this.currentType = (<Global>element).type;\r\n        return this.module.createGetGlobal((<Global>element).internalName, this.currentType.toNativeType());\r\n\r\n      case ElementKind.ENUMVALUE: // here: if referenced from within the same enum\r\n        if (!element.is(ElementFlags.COMPILED)) {\r\n          this.error(\r\n            DiagnosticCode.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums,\r\n            expression.range\r\n          );\r\n          this.currentType = Type.i32;\r\n          return this.module.createUnreachable();\r\n        }\r\n        this.currentType = Type.i32;\r\n        if ((<EnumValue>element).is(ElementFlags.INLINED)) {\r\n          return this.module.createI32((<EnumValue>element).constantValue);\r\n        }\r\n        return this.module.createGetGlobal((<EnumValue>element).internalName, NativeType.I32);\r\n    }\r\n    this.error(\r\n      DiagnosticCode.Operation_not_supported,\r\n      expression.range\r\n    );\r\n    return this.module.createUnreachable();\r\n  }\r\n\r\n  compileLiteralExpression(\r\n    expression: LiteralExpression,\r\n    contextualType: Type,\r\n    implicitNegate: bool = false\r\n  ): ExpressionRef {\r\n    switch (expression.literalKind) {\r\n\r\n      case LiteralKind.ARRAY:\r\n        assert(!implicitNegate);\r\n        var classType = contextualType.classType;\r\n        if (\r\n          classType &&\r\n          classType == this.program.elements.get(\"Array\") &&\r\n          classType.typeArguments && classType.typeArguments.length == 1\r\n        ) {\r\n          return this.compileStaticArray(\r\n            classType.typeArguments[0],\r\n            (<ArrayLiteralExpression>expression).elementExpressions\r\n          );\r\n        }\r\n        this.error(\r\n          DiagnosticCode.Operation_not_supported,\r\n          expression.range\r\n        );\r\n        return this.module.createUnreachable();\r\n\r\n      case LiteralKind.FLOAT: {\r\n        var floatValue = (<FloatLiteralExpression>expression).value;\r\n        if (implicitNegate) {\r\n          floatValue = -floatValue;\r\n        }\r\n        if (contextualType == Type.f32) {\r\n          return this.module.createF32(<f32>floatValue);\r\n        }\r\n        this.currentType = Type.f64;\r\n        return this.module.createF64(floatValue);\r\n      }\r\n\r\n      case LiteralKind.INTEGER:\r\n        var intValue = (<IntegerLiteralExpression>expression).value;\r\n        if (implicitNegate) {\r\n          intValue = i64_sub(\r\n            i64_new(0),\r\n            intValue\r\n          );\r\n        }\r\n        switch (contextualType.kind) {\r\n\r\n          // compile to contextualType if matching\r\n\r\n          case TypeKind.I8:\r\n            if (i64_is_i8(intValue)) {\r\n              return this.module.createI32(i64_low(intValue));\r\n            }\r\n            break;\r\n\r\n          case TypeKind.I16:\r\n            if (i64_is_i16(intValue)) {\r\n              return this.module.createI32(i64_low(intValue));\r\n            }\r\n            break;\r\n\r\n          case TypeKind.I32:\r\n            if (i64_is_i32(intValue)) {\r\n              return this.module.createI32(i64_low(intValue));\r\n            }\r\n            break;\r\n\r\n          case TypeKind.U8:\r\n            if (i64_is_u8(intValue)) {\r\n              return this.module.createI32(i64_low(intValue));\r\n            }\r\n            break;\r\n\r\n          case TypeKind.U16:\r\n            if (i64_is_u16(intValue)) {\r\n              return this.module.createI32(i64_low(intValue));\r\n            }\r\n            break;\r\n\r\n          case TypeKind.U32:\r\n            if (i64_is_u32(intValue)) {\r\n              return this.module.createI32(i64_low(intValue));\r\n            }\r\n            break;\r\n\r\n          case TypeKind.BOOL:\r\n            if (i64_is_bool(intValue)) {\r\n              return this.module.createI32(i64_low(intValue));\r\n            }\r\n            break;\r\n\r\n          case TypeKind.ISIZE:\r\n            if (!this.options.isWasm64) {\r\n              if (i64_is_u32(intValue)) {\r\n                return this.module.createI32(i64_low(intValue));\r\n              }\r\n              break;\r\n            }\r\n            return this.module.createI64(i64_low(intValue), i64_high(intValue));\r\n\r\n          case TypeKind.USIZE:\r\n            if (!this.options.isWasm64) {\r\n              if (i64_is_u32(intValue)) {\r\n                return this.module.createI32(i64_low(intValue));\r\n              }\r\n              break;\r\n            }\r\n            return this.module.createI64(i64_low(intValue), i64_high(intValue));\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            return this.module.createI64(i64_low(intValue), i64_high(intValue));\r\n\r\n          case TypeKind.F32:\r\n            if (i64_is_f32(intValue)) {\r\n              return this.module.createF32(i64_to_f32(intValue));\r\n            }\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            if (i64_is_f64(intValue)) {\r\n              return this.module.createF64(i64_to_f64(intValue));\r\n            }\r\n            break;\r\n\r\n          case TypeKind.VOID:\r\n            break;\r\n\r\n          default:\r\n            assert(false);\r\n            break;\r\n        }\r\n\r\n        // otherwise compile to best fitting native type\r\n\r\n        if (i64_is_i32(intValue)) {\r\n          this.currentType = Type.i32;\r\n          return this.module.createI32(i64_low(intValue));\r\n        } else {\r\n          this.currentType = Type.i64;\r\n          return this.module.createI64(i64_low(intValue), i64_high(intValue));\r\n        }\r\n\r\n      case LiteralKind.STRING:\r\n        assert(!implicitNegate);\r\n        return this.compileStaticString((<StringLiteralExpression>expression).value);\r\n\r\n      // case LiteralKind.OBJECT:\r\n      // case LiteralKind.REGEXP:\r\n    }\r\n    throw new Error(\"not implemented\");\r\n  }\r\n\r\n  compileStaticString(stringValue: string): ExpressionRef {\r\n    var stringSegment: MemorySegment | null = this.stringSegments.get(stringValue);\r\n    if (!stringSegment) {\r\n      var stringLength = stringValue.length;\r\n      var stringBuffer = new Uint8Array(4 + stringLength * 2);\r\n      stringBuffer[0] =  stringLength         & 0xff;\r\n      stringBuffer[1] = (stringLength >>>  8) & 0xff;\r\n      stringBuffer[2] = (stringLength >>> 16) & 0xff;\r\n      stringBuffer[3] = (stringLength >>> 24) & 0xff;\r\n      for (var i = 0; i < stringLength; ++i) {\r\n        stringBuffer[4 + i * 2] =  stringValue.charCodeAt(i)        & 0xff;\r\n        stringBuffer[5 + i * 2] = (stringValue.charCodeAt(i) >>> 8) & 0xff;\r\n      }\r\n      stringSegment = this.addMemorySegment(stringBuffer, this.options.usizeType.byteSize);\r\n      this.stringSegments.set(stringValue, stringSegment);\r\n    }\r\n    var stringOffset = stringSegment.offset;\r\n    var stringType = this.program.types.get(\"string\");\r\n    this.currentType = stringType ? stringType : this.options.usizeType;\r\n    if (this.options.isWasm64) {\r\n      return this.module.createI64(i64_low(stringOffset), i64_high(stringOffset));\r\n    }\r\n    assert(i64_is_i32(stringOffset));\r\n    return this.module.createI32(i64_low(stringOffset));\r\n  }\r\n\r\n  compileStaticArray(elementType: Type, expressions: (Expression | null)[]): ExpressionRef {\r\n    // compile as static if all element expressions are precomputable, otherwise\r\n    // initialize in place.\r\n    var isStatic = true;\r\n    var size = expressions.length;\r\n\r\n    var nativeType = elementType.toNativeType();\r\n    var values: usize;\r\n    switch (nativeType) {\r\n\r\n      case NativeType.I32:\r\n        values = changetype<usize>(new Int32Array(size));\r\n        break;\r\n\r\n      case NativeType.I64:\r\n        values = changetype<usize>(new Array<I64>(size));\r\n        break;\r\n\r\n      case NativeType.F32:\r\n        values = changetype<usize>(new Float32Array(size));\r\n        break;\r\n\r\n      case NativeType.F64:\r\n        values = changetype<usize>(new Float64Array(size));\r\n        break;\r\n\r\n      default:\r\n        throw new Error(\"concrete type expected\");\r\n    }\r\n\r\n    var exprs = new Array<ExpressionRef>(size);\r\n    var expr: BinaryenExpressionRef;\r\n    for (var i = 0; i < size; ++i) {\r\n      exprs[i] = expressions[i]\r\n        ? this.compileExpression(<Expression>expressions[i], elementType)\r\n        : elementType.toNativeZero(this.module);\r\n      if (isStatic) {\r\n        expr = this.precomputeExpressionRef(exprs[i]);\r\n        if (_BinaryenExpressionGetId(expr) == ExpressionId.Const) {\r\n          assert(_BinaryenExpressionGetType(expr) == nativeType);\r\n          switch (nativeType) {\r\n\r\n            case NativeType.I32:\r\n              changetype<i32[]>(values)[i] = _BinaryenConstGetValueI32(expr);\r\n              break;\r\n\r\n            case NativeType.I64:\r\n              changetype<I64[]>(values)[i] = i64_new(\r\n                _BinaryenConstGetValueI64Low(expr),\r\n                _BinaryenConstGetValueI64High(expr)\r\n              );\r\n              break;\r\n\r\n            case NativeType.F32:\r\n              changetype<f32[]>(values)[i] = _BinaryenConstGetValueF32(expr);\r\n              break;\r\n\r\n            case NativeType.F64:\r\n              changetype<f64[]>(values)[i] = _BinaryenConstGetValueF64(expr);\r\n              break;\r\n\r\n            default:\r\n              assert(false); // checked above\r\n          }\r\n        } else {\r\n          // TODO: emit a warning if declared 'const'\r\n          isStatic = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (isStatic) {\r\n      // TODO: convert to Uint8Array and create the segment\r\n    } else {\r\n      // TODO: initialize in place\r\n    }\r\n    // TODO: alternatively, static elements could go into data segments while\r\n    // dynamic ones are initialized on top? any benefits? (doesn't seem so)\r\n    throw new Error(\"not implemented\");\r\n  }\r\n\r\n  compileNewExpression(expression: NewExpression, contextualType: Type): ExpressionRef {\r\n    var resolved = this.program.resolveExpression( // reports\r\n      expression.expression,\r\n      this.currentFunction\r\n    );\r\n    if (resolved) {\r\n      if (resolved.element.kind == ElementKind.CLASS_PROTOTYPE) {\r\n        var prototype = <ClassPrototype>resolved.element;\r\n        var instance = prototype.resolveInclTypeArguments( // reports\r\n          expression.typeArguments,\r\n          null,\r\n          expression\r\n        );\r\n        if (instance) {\r\n          var thisExpr = compileBuiltinAllocate(this, instance, expression);\r\n          var initializers = new Array<ExpressionRef>();\r\n\r\n          // use a temp local for 'this'\r\n          var tempLocal = this.currentFunction.getTempLocal(this.options.usizeType);\r\n          initializers.push(this.module.createSetLocal(tempLocal.index, thisExpr));\r\n\r\n          // apply field initializers\r\n          if (instance.members) {\r\n            for (var member of instance.members.values()) {\r\n              if (member.kind == ElementKind.FIELD) {\r\n                var field = <Field>member;\r\n                var fieldDeclaration = field.prototype.declaration;\r\n                if (field.is(ElementFlags.CONSTANT)) {\r\n                  assert(false); // there are no built-in fields currently\r\n                } else if (fieldDeclaration && fieldDeclaration.initializer) {\r\n                  initializers.push(this.module.createStore(field.type.byteSize,\r\n                    this.module.createGetLocal(tempLocal.index, this.options.nativeSizeType),\r\n                    this.compileExpression(fieldDeclaration.initializer, field.type),\r\n                    field.type.toNativeType(),\r\n                    field.memoryOffset\r\n                  ));\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          // apply constructor\r\n          var constructorInstance = instance.constructorInstance;\r\n          if (constructorInstance) {\r\n            initializers.push(this.compileCall(constructorInstance, expression.arguments, expression,\r\n              this.module.createGetLocal(tempLocal.index, this.options.nativeSizeType)\r\n            ));\r\n          }\r\n\r\n          // return 'this'\r\n          initializers.push(this.module.createGetLocal(tempLocal.index, this.options.nativeSizeType));\r\n          this.currentFunction.freeTempLocal(tempLocal);\r\n          thisExpr = this.module.createBlock(null, initializers, this.options.nativeSizeType);\r\n\r\n          this.currentType = instance.type;\r\n          return thisExpr;\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.Cannot_use_new_with_an_expression_whose_type_lacks_a_construct_signature,\r\n          expression.expression.range\r\n        );\r\n      }\r\n    }\r\n    return this.module.createUnreachable();\r\n  }\r\n\r\n  compileParenthesizedExpression(expression: ParenthesizedExpression, contextualType: Type): ExpressionRef {\r\n    // does not change types, just order\r\n    return this.compileExpression(expression.expression, contextualType, ConversionKind.NONE);\r\n  }\r\n\r\n  compilePropertyAccessExpression(propertyAccess: PropertyAccessExpression, contextualType: Type): ExpressionRef {\r\n    var resolved = this.program.resolvePropertyAccess(propertyAccess, this.currentFunction); // reports\r\n    if (!resolved) return this.module.createUnreachable();\r\n\r\n    var element = resolved.element;\r\n    var targetExpr: ExpressionRef;\r\n    switch (element.kind) {\r\n\r\n      case ElementKind.GLOBAL: // static property\r\n        if (element.is(ElementFlags.BUILTIN)) {\r\n          return compileBuiltinGetConstant(this, <Global>element, propertyAccess);\r\n        }\r\n        if (!this.compileGlobal(<Global>element)) { // reports; not yet compiled if a static field\r\n          return this.module.createUnreachable();\r\n        }\r\n        assert((<Global>element).type != Type.void);\r\n        if ((<Global>element).is(ElementFlags.INLINED)) {\r\n          return this.compileInlineConstant(<Global>element, contextualType);\r\n        }\r\n        this.currentType = (<Global>element).type;\r\n        return this.module.createGetGlobal((<Global>element).internalName, this.currentType.toNativeType());\r\n\r\n      case ElementKind.ENUMVALUE: // enum value\r\n        if (!this.compileEnum((<EnumValue>element).enum)) {\r\n          return this.module.createUnreachable();\r\n        }\r\n        this.currentType = Type.i32;\r\n        if ((<EnumValue>element).is(ElementFlags.INLINED)) {\r\n          return this.module.createI32((<EnumValue>element).constantValue);\r\n        }\r\n        return this.module.createGetGlobal((<EnumValue>element).internalName, NativeType.I32);\r\n\r\n      case ElementKind.FIELD: // instance field\r\n        assert(resolved.target != null);\r\n        assert(resolved.targetExpression != null);\r\n        assert((<Field>element).memoryOffset >= 0);\r\n        targetExpr = this.compileExpression(\r\n          <Expression>resolved.targetExpression,\r\n          this.options.usizeType,\r\n          ConversionKind.NONE\r\n        );\r\n        this.currentType = (<Field>element).type;\r\n        return this.module.createLoad(\r\n          (<Field>element).type.size >> 3,\r\n          (<Field>element).type.is(TypeFlags.SIGNED | TypeFlags.INTEGER),\r\n          targetExpr,\r\n          (<Field>element).type.toNativeType(),\r\n          (<Field>element).memoryOffset\r\n        );\r\n\r\n      case ElementKind.PROPERTY: // instance property (here: getter)\r\n        var getter = (<Property>element).getterPrototype;\r\n        assert(getter != null);\r\n        var getterInstance = (<FunctionPrototype>getter).resolve(null); // reports\r\n        if (!getterInstance) return this.module.createUnreachable();\r\n        assert(!getterInstance.parameters || !getterInstance.parameters.length);\r\n        this.currentType = getterInstance.returnType;\r\n        if (getterInstance.is(ElementFlags.INSTANCE)) {\r\n          targetExpr = this.compileExpression(\r\n            <Expression>resolved.targetExpression,\r\n            this.options.usizeType,\r\n            ConversionKind.NONE\r\n          );\r\n          this.currentType = getterInstance.returnType;\r\n          return this.makeCall(getterInstance, [ targetExpr ]);\r\n        } else {\r\n          return this.makeCall(getterInstance);\r\n        }\r\n    }\r\n    this.error(\r\n      DiagnosticCode.Operation_not_supported,\r\n      propertyAccess.range\r\n    );\r\n    return this.module.createUnreachable();\r\n  }\r\n\r\n  compileTernaryExpression(expression: TernaryExpression, contextualType: Type): ExpressionRef {\r\n    var condition = makeIsTrueish(\r\n      this.compileExpression(expression.condition, Type.u32, ConversionKind.NONE),\r\n      this.currentType,\r\n      this.module\r\n    );\r\n    var ifThen = this.compileExpression(expression.ifThen, contextualType);\r\n    var ifElse = this.compileExpression(expression.ifElse, contextualType);\r\n    return this.module.createIf(condition, ifThen, ifElse);\r\n  }\r\n\r\n  compileUnaryPostfixExpression(expression: UnaryPostfixExpression, contextualType: Type): ExpressionRef {\r\n    // make a getter for the expression (also obtains the type)\r\n    var getValue = this.compileExpression(\r\n      expression.operand,\r\n      contextualType == Type.void\r\n        ? Type.i32\r\n        : contextualType,\r\n      ConversionKind.NONE,\r\n      false // wrapped below\r\n    );\r\n\r\n    var op: BinaryOp;\r\n    var nativeType: NativeType;\r\n    var nativeOne: ExpressionRef;\r\n    var possiblyOverflows = false;\r\n\r\n    switch (expression.operator) {\r\n\r\n      case Token.PLUS_PLUS:\r\n        if (this.currentType.isReference) {\r\n          this.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            expression.range\r\n          );\r\n          return this.module.createUnreachable();\r\n        }\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            possiblyOverflows = true;\r\n          default:\r\n            op = BinaryOp.AddI32;\r\n            nativeType = NativeType.I32;\r\n            nativeOne = this.module.createI32(1);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n          case TypeKind.ISIZE:\r\n            op = this.options.isWasm64\r\n              ? BinaryOp.AddI64\r\n              : BinaryOp.AddI32;\r\n            nativeType = this.options.isWasm64\r\n              ? NativeType.I64\r\n              : NativeType.I32;\r\n            nativeOne = this.currentType.toNativeOne(this.module);\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            op = BinaryOp.AddI64;\r\n            nativeType = NativeType.I64;\r\n            nativeOne = this.module.createI64(1);\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            op = BinaryOp.AddF32;\r\n            nativeType = NativeType.F32;\r\n            nativeOne = this.module.createF32(1);\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            op = BinaryOp.AddF64;\r\n            nativeType = NativeType.F64;\r\n            nativeOne = this.module.createF64(1);\r\n            break;\r\n\r\n          case TypeKind.VOID:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        break;\r\n\r\n      case Token.MINUS_MINUS:\r\n        if (this.currentType.isReference) {\r\n          this.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            expression.range\r\n          );\r\n          return this.module.createUnreachable();\r\n        }\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            possiblyOverflows = true;\r\n          default:\r\n            op = BinaryOp.SubI32;\r\n            nativeType = NativeType.I32;\r\n            nativeOne = this.module.createI32(1);\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            // TODO: check operator overload\r\n          case TypeKind.ISIZE:\r\n            op = this.options.isWasm64\r\n              ? BinaryOp.SubI64\r\n              : BinaryOp.SubI32;\r\n            nativeType = this.options.isWasm64\r\n              ? NativeType.I64\r\n              : NativeType.I32;\r\n            nativeOne = this.currentType.toNativeOne(this.module);\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            op = BinaryOp.SubI64;\r\n            nativeType = NativeType.I64;\r\n            nativeOne = this.module.createI64(1);\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            op = BinaryOp.SubF32;\r\n            nativeType = NativeType.F32;\r\n            nativeOne = this.module.createF32(1);\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            op = BinaryOp.SubF64;\r\n            nativeType = NativeType.F64;\r\n            nativeOne = this.module.createF64(1);\r\n            break;\r\n\r\n          case TypeKind.VOID:\r\n            this.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              expression.range\r\n            );\r\n            throw new Error(\"concrete type expected\");\r\n        }\r\n        break;\r\n\r\n      default:\r\n        this.error(\r\n          DiagnosticCode.Operation_not_supported,\r\n          expression.range\r\n        );\r\n        throw new Error(\"unary postfix operator expected\");\r\n    }\r\n\r\n    var setValue: ExpressionRef;\r\n    var tempLocal: Local | null = null;\r\n\r\n    // simplify if dropped anyway\r\n    if (contextualType == Type.void) {\r\n      setValue = this.module.createBinary(op,\r\n        getValue,\r\n        nativeOne\r\n      );\r\n\r\n    // otherwise use a temp local for the intermediate value\r\n    } else {\r\n      tempLocal = this.currentFunction.getTempLocal(this.currentType);\r\n      setValue = this.module.createBinary(op,\r\n        this.module.createGetLocal(tempLocal.index, nativeType),\r\n        nativeOne\r\n      );\r\n    }\r\n\r\n    if (possiblyOverflows) {\r\n      assert(this.currentType.is(TypeFlags.SMALL | TypeFlags.INTEGER));\r\n      setValue = makeSmallIntegerWrap(setValue, this.currentType, this.module);\r\n    }\r\n\r\n    setValue = this.compileAssignmentWithValue(expression.operand, setValue, false);\r\n    // ^ sets currentType = void\r\n    if (contextualType == Type.void) {\r\n      assert(!tempLocal);\r\n      return setValue;\r\n    }\r\n\r\n    this.currentType = assert(tempLocal).type;\r\n    this.currentFunction.freeTempLocal(<Local>tempLocal);\r\n    return this.module.createBlock(null, [\r\n      this.module.createSetLocal((<Local>tempLocal).index, getValue),\r\n      setValue,\r\n      this.module.createGetLocal((<Local>tempLocal).index, nativeType)\r\n    ], nativeType);\r\n  }\r\n\r\n  compileUnaryPrefixExpression(\r\n    expression: UnaryPrefixExpression,\r\n    contextualType: Type,\r\n    wrapSmallIntegers: bool = true\r\n  ): ExpressionRef {\r\n    var possiblyOverflows = false;\r\n    var compound = false;\r\n    var expr: ExpressionRef;\r\n\r\n    switch (expression.operator) {\r\n\r\n      case Token.PLUS:\r\n        if (this.currentType.isReference) {\r\n          this.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            expression.range\r\n          );\r\n          return this.module.createUnreachable();\r\n        }\r\n        expr = this.compileExpression(\r\n          expression.operand,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE,\r\n          false // wrapped below\r\n        );\r\n        possiblyOverflows = this.currentType.is(TypeFlags.SMALL | TypeFlags.INTEGER); // if operand already did\r\n        break;\r\n\r\n      case Token.MINUS:\r\n        if (this.currentType.isReference) {\r\n          this.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            expression.range\r\n          );\r\n          return this.module.createUnreachable();\r\n        }\r\n        if (expression.operand.kind == NodeKind.LITERAL && (\r\n          (<LiteralExpression>expression.operand).literalKind == LiteralKind.INTEGER ||\r\n          (<LiteralExpression>expression.operand).literalKind == LiteralKind.FLOAT\r\n        )) {\r\n          // implicitly negate integer and float literals. also enables proper checking of literal ranges.\r\n          expr = this.compileLiteralExpression(<LiteralExpression>expression.operand, contextualType, true);\r\n          this.addDebugLocation(expr, expression.range); // compileExpression normally does this\r\n        } else {\r\n          expr = this.compileExpression(\r\n            expression.operand,\r\n            contextualType == Type.void\r\n              ? Type.i32\r\n              : contextualType,\r\n            ConversionKind.NONE,\r\n            false // wrapped below\r\n          );\r\n          switch (this.currentType.kind) {\r\n\r\n            case TypeKind.I8:\r\n            case TypeKind.I16:\r\n            case TypeKind.U8:\r\n            case TypeKind.U16:\r\n            case TypeKind.BOOL:\r\n              possiblyOverflows = true; // or if operand already did\r\n            default:\r\n              expr = this.module.createBinary(BinaryOp.SubI32, this.module.createI32(0), expr);\r\n              break;\r\n\r\n            case TypeKind.USIZE:\r\n              if (this.currentType.isReference) {\r\n                this.error(\r\n                  DiagnosticCode.Operation_not_supported,\r\n                  expression.range\r\n                );\r\n                return this.module.createUnreachable();\r\n              }\r\n            case TypeKind.ISIZE:\r\n              expr = this.module.createBinary(\r\n                this.options.isWasm64\r\n                  ? BinaryOp.SubI64\r\n                  : BinaryOp.SubI32,\r\n                this.currentType.toNativeZero(this.module),\r\n                expr\r\n              );\r\n              break;\r\n\r\n            case TypeKind.I64:\r\n            case TypeKind.U64:\r\n              expr = this.module.createBinary(BinaryOp.SubI64, this.module.createI64(0), expr);\r\n              break;\r\n\r\n            case TypeKind.F32:\r\n              expr = this.module.createUnary(UnaryOp.NegF32, expr);\r\n              break;\r\n\r\n            case TypeKind.F64:\r\n              expr = this.module.createUnary(UnaryOp.NegF64, expr);\r\n              break;\r\n          }\r\n        }\r\n        break;\r\n\r\n      case Token.PLUS_PLUS:\r\n        if (this.currentType.isReference) {\r\n          this.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            expression.range\r\n          );\r\n          return this.module.createUnreachable();\r\n        }\r\n        compound = true;\r\n        expr = this.compileExpression(\r\n          expression.operand,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE,\r\n          false // wrapped below\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            possiblyOverflows = true; // or if operand already did\r\n          default:\r\n            expr = this.module.createBinary(BinaryOp.AddI32, expr, this.module.createI32(1));\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            if (this.currentType.isReference) {\r\n              this.error(\r\n                DiagnosticCode.Operation_not_supported,\r\n                expression.range\r\n              );\r\n              return this.module.createUnreachable();\r\n            }\r\n            // fall-through\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.AddI64\r\n                : BinaryOp.AddI32,\r\n              expr,\r\n              this.currentType.toNativeOne(this.module)\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.AddI64, expr, this.module.createI64(1));\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            expr = this.module.createBinary(BinaryOp.AddF32, expr, this.module.createF32(1));\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            expr = this.module.createBinary(BinaryOp.AddF64, expr, this.module.createF64(1));\r\n            break;\r\n        }\r\n        break;\r\n\r\n      case Token.MINUS_MINUS:\r\n        if (this.currentType.isReference) {\r\n          this.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            expression.range\r\n          );\r\n          return this.module.createUnreachable();\r\n        }\r\n        compound = true;\r\n        expr = this.compileExpression(\r\n          expression.operand,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE,\r\n          false // wrapped below\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            possiblyOverflows = true; // or if operand already did\r\n            // fall-through\r\n          default:\r\n            expr = this.module.createBinary(BinaryOp.SubI32, expr, this.module.createI32(1));\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            if (this.currentType.isReference) {\r\n              this.error(\r\n                DiagnosticCode.Operation_not_supported,\r\n                expression.range\r\n              );\r\n              return this.module.createUnreachable();\r\n            }\r\n            // fall-through\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.SubI64\r\n                : BinaryOp.SubI32,\r\n              expr,\r\n              this.currentType.toNativeOne(this.module)\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.SubI64, expr, this.module.createI64(1));\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            expr = this.module.createBinary(BinaryOp.SubF32, expr, this.module.createF32(1));\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            expr = this.module.createBinary(BinaryOp.SubF64, expr, this.module.createF64(1));\r\n            break;\r\n        }\r\n        break;\r\n\r\n      case Token.EXCLAMATION:\r\n        expr = this.compileExpression(\r\n          expression.operand,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType,\r\n          ConversionKind.NONE,\r\n          true // must wrap small integers\r\n        );\r\n        expr = makeIsFalseish(expr, this.currentType, this.module);\r\n        this.currentType = Type.bool;\r\n        break;\r\n\r\n      case Token.TILDE:\r\n        if (this.currentType.isReference) {\r\n          this.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            expression.range\r\n          );\r\n          return this.module.createUnreachable();\r\n        }\r\n        expr = this.compileExpression(\r\n          expression.operand,\r\n          contextualType == Type.void\r\n            ? Type.i32\r\n            : contextualType.is(TypeFlags.FLOAT)\r\n              ? Type.i64\r\n              : contextualType,\r\n          contextualType == Type.void\r\n            ? ConversionKind.NONE\r\n            : ConversionKind.IMPLICIT,\r\n          false // retains low bits of small integers\r\n        );\r\n\r\n        switch (this.currentType.kind) {\r\n\r\n          case TypeKind.I8:\r\n          case TypeKind.I16:\r\n          case TypeKind.U8:\r\n          case TypeKind.U16:\r\n          case TypeKind.BOOL:\r\n            possiblyOverflows = true; // or if operand already did\r\n          default:\r\n            expr = this.module.createBinary(BinaryOp.XorI32, expr, this.module.createI32(-1));\r\n            break;\r\n\r\n          case TypeKind.USIZE:\r\n            if (this.currentType.isReference) {\r\n              this.error(\r\n                DiagnosticCode.Operation_not_supported,\r\n                expression.range\r\n              );\r\n              return this.module.createUnreachable();\r\n            }\r\n            // fall-through\r\n          case TypeKind.ISIZE:\r\n            expr = this.module.createBinary(\r\n              this.options.isWasm64\r\n                ? BinaryOp.XorI64\r\n                : BinaryOp.XorI32,\r\n              expr,\r\n              this.currentType.toNativeNegOne(this.module)\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            expr = this.module.createBinary(BinaryOp.XorI64, expr, this.module.createI64(-1, -1));\r\n            break;\r\n        }\r\n        break;\r\n\r\n      case Token.TYPEOF:\r\n        // it might make sense to implement typeof in a way that a generic function can detect\r\n        // whether its type argument is a class type or string. that could then be used, for\r\n        // example, to generate hash codes for sets and maps, depending on the kind of type\r\n        // parameter we have. ideally the comparison would not involve actual string comparison and\r\n        // limit available operations to hard-coded string literals.\r\n        this.error(\r\n          DiagnosticCode.Operation_not_supported,\r\n          expression.range\r\n        );\r\n        throw new Error(\"not implemented\");\r\n\r\n      default:\r\n        this.error(\r\n          DiagnosticCode.Operation_not_supported,\r\n          expression.range\r\n        );\r\n        throw new Error(\"unary operator expected\");\r\n    }\r\n    if (possiblyOverflows && wrapSmallIntegers) {\r\n      assert(this.currentType.is(TypeFlags.SMALL | TypeFlags.INTEGER));\r\n      expr = makeSmallIntegerWrap(expr, this.currentType, this.module);\r\n    }\r\n    return compound\r\n      ? this.compileAssignmentWithValue(expression.operand, expr, contextualType != Type.void)\r\n      : expr;\r\n  }\r\n\r\n  addDebugLocation(expr: ExpressionRef, range: Range): void {\r\n    if (this.options.sourceMap != null) {\r\n      var source = range.source;\r\n      if (source.debugInfoIndex < 0) {\r\n        source.debugInfoIndex = this.module.addDebugInfoFile(source.normalizedPath);\r\n      }\r\n      range.debugInfoRef = expr;\r\n      if (!this.currentFunction.debugLocations) this.currentFunction.debugLocations = [];\r\n      this.currentFunction.debugLocations.push(range);\r\n    }\r\n  }\r\n}\r\n\r\n// helpers\r\n\r\n/** Wraps a 32-bit integer expression so it evaluates to a valid value of the specified type. */\r\nexport function makeSmallIntegerWrap(expr: ExpressionRef, type: Type, module: Module): ExpressionRef {\r\n  switch (type.kind) {\r\n\r\n    case TypeKind.I8:\r\n      expr = module.createBinary(BinaryOp.ShrI32,\r\n        module.createBinary(BinaryOp.ShlI32,\r\n          expr,\r\n          module.createI32(24)\r\n        ),\r\n        module.createI32(24)\r\n      );\r\n      break;\r\n\r\n    case TypeKind.I16:\r\n      expr = module.createBinary(BinaryOp.ShrI32,\r\n        module.createBinary(BinaryOp.ShlI32,\r\n          expr,\r\n          module.createI32(16)\r\n        ),\r\n        module.createI32(16)\r\n      );\r\n      break;\r\n\r\n    case TypeKind.U8:\r\n      expr = module.createBinary(BinaryOp.AndI32,\r\n        expr,\r\n        module.createI32(0xff)\r\n      );\r\n      break;\r\n\r\n    case TypeKind.U16:\r\n      expr = module.createBinary(BinaryOp.AndI32,\r\n        expr,\r\n        module.createI32(0xffff)\r\n      );\r\n      break;\r\n\r\n    case TypeKind.BOOL:\r\n      expr = module.createBinary(BinaryOp.AndI32,\r\n        expr,\r\n        module.createI32(0x1)\r\n      );\r\n      break;\r\n\r\n    case TypeKind.VOID:\r\n      throw new Error(\"concrete type expected\");\r\n  }\r\n  return expr;\r\n}\r\n\r\n/** Creates a comparison whether an expression is not 'true' in a broader sense. */\r\nexport function makeIsFalseish(expr: ExpressionRef, type: Type, module: Module): ExpressionRef {\r\n  switch (type.kind) {\r\n\r\n    default: // any integer up to 32 bits\r\n      expr = module.createUnary(UnaryOp.EqzI32, expr);\r\n      break;\r\n\r\n    case TypeKind.I64:\r\n    case TypeKind.U64:\r\n      expr = module.createUnary(UnaryOp.EqzI64, expr);\r\n      break;\r\n\r\n    case TypeKind.USIZE:\r\n      // TODO: strings\r\n    case TypeKind.ISIZE:\r\n      expr = module.createUnary(type.size == 64 ? UnaryOp.EqzI64 : UnaryOp.EqzI32, expr);\r\n      break;\r\n\r\n    case TypeKind.F32:\r\n      expr = module.createBinary(BinaryOp.EqF32, expr, module.createF32(0));\r\n      break;\r\n\r\n    case TypeKind.F64:\r\n      expr = module.createBinary(BinaryOp.EqF64, expr, module.createF64(0));\r\n      break;\r\n\r\n    case TypeKind.VOID:\r\n      throw new Error(\"concrete type expected\");\r\n  }\r\n  return expr;\r\n}\r\n\r\n/** Creates a comparison whether an expression is 'true' in a broader sense. */\r\nexport function makeIsTrueish(\r\n  expr: ExpressionRef,\r\n  type: Type,\r\n  module: Module\r\n): ExpressionRef {\r\n  switch (type.kind) {\r\n\r\n    case TypeKind.I64:\r\n    case TypeKind.U64:\r\n      expr = module.createBinary(BinaryOp.NeI64, expr, module.createI64(0));\r\n      break;\r\n\r\n    case TypeKind.USIZE:\r\n      // TODO: strings\r\n    case TypeKind.ISIZE:\r\n      if (type.size == 64) {\r\n        expr = module.createBinary(BinaryOp.NeI64, expr, module.createI64(0));\r\n      }\r\n      break;\r\n\r\n    case TypeKind.F32:\r\n      expr = module.createBinary(BinaryOp.NeF32, expr, module.createF32(0));\r\n      break;\r\n\r\n    case TypeKind.F64:\r\n      expr = module.createBinary(BinaryOp.NeF64, expr, module.createF64(0));\r\n      break;\r\n\r\n    case TypeKind.VOID:\r\n      throw new Error(\"concrete type expected\");\r\n  }\r\n  return expr;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/compiler.ts","import {\r\n  Class,\r\n  Function\r\n} from \"./program\";\r\n\r\nimport {\r\n  NativeType,\r\n  ExpressionRef,\r\n  Module\r\n} from \"./module\";\r\n\r\n/** Indicates the kind of a type. */\r\nexport const enum TypeKind {\r\n\r\n  // signed integers\r\n  I8,\r\n  I16,\r\n  I32,\r\n  I64,\r\n  ISIZE,\r\n\r\n  // unsigned integers\r\n  U8,\r\n  U16,\r\n  U32,\r\n  U64,\r\n  USIZE,\r\n  BOOL, // sic\r\n\r\n  // floats\r\n  F32,\r\n  F64,\r\n\r\n  // other\r\n  VOID\r\n}\r\n\r\n/** Indicates capabilities of a type. */\r\nexport const enum TypeFlags {\r\n  NONE = 0,\r\n  /** Is a signed type that can represent negative values. */\r\n  SIGNED = 1 << 0,\r\n  /** Is an unsigned type that cannot represent negative values. */\r\n  UNSIGNED = 1 << 1,\r\n  /** Is an integer type. */\r\n  INTEGER = 1 << 2,\r\n  /** Is a floating point type. */\r\n  FLOAT = 1 << 3,\r\n  /** Is a sized integer type with a target specific bit size. */\r\n  SIZE = 1 << 4,\r\n  /** Is a small type that is emulated in a larger type. */\r\n  SMALL = 1 << 5,\r\n  /** Is a long type larger than 32-bits. */\r\n  LONG = 1 << 6,\r\n  /** Is a value type. */\r\n  VALUE = 1 << 7,\r\n  /** Is a reference type. */\r\n  REFERENCE = 1 << 8,\r\n  /** Is a nullable type. */\r\n  NULLABLE = 1 << 9\r\n}\r\n\r\n/** Represents a resolved type. */\r\nexport class Type {\r\n\r\n  /** Type kind. */\r\n  kind: TypeKind;\r\n  /** Type flags. */\r\n  flags: TypeFlags;\r\n  /** Size in bits. */\r\n  size: u32;\r\n  /** Size in bytes. Ceiled to 8-bits. */\r\n  byteSize: i32;\r\n  /** Underlying class type, if a class type. */\r\n  classType: Class | null;\r\n  /** Underlying function type, if a function type. */\r\n  functionType: Function | null;\r\n  /** Respective nullable type, if non-nullable. */\r\n  nullableType: Type | null = null;\r\n  /** Respective non-nullable type, if nullable. */\r\n  nonNullableType: Type;\r\n\r\n  /** Constructs a new resolved type. */\r\n  constructor(kind: TypeKind, flags: TypeFlags, size: i32) {\r\n    this.kind = kind;\r\n    this.flags = flags;\r\n    this.size = size;\r\n    this.byteSize = <i32>ceil<f64>(<f64>size / 8);\r\n    this.classType = null;\r\n    this.nonNullableType = this;\r\n  }\r\n\r\n  /** Computes the sign-extending shift in the target type. */\r\n  computeSmallIntegerShift(targetType: Type): u32 {\r\n    return targetType.size - this.size;\r\n  }\r\n\r\n  /** Computes the truncating mask in the target type. */\r\n  computeSmallIntegerMask(targetType: Type): u32 {\r\n    return -1 >>> (targetType.size - this.size);\r\n  }\r\n\r\n  /** Tests if this type has the specified capabilities. */\r\n  is(flags: TypeFlags): bool {\r\n    return (this.flags & flags) == flags;\r\n  }\r\n\r\n  /** Tests if this type is a class type. */\r\n  get isClass(): bool { return this.classType != null; }\r\n  /** Tests if this type is a function type. */\r\n  get isFunction(): bool { return this.functionType != null; }\r\n  /** Tests if this type is a reference type. */\r\n  get isReference(): bool { return this.classType != null || this.functionType != null; }\r\n\r\n  /** Composes a class type from this type and a class. */\r\n  asClass(classType: Class): Type {\r\n    assert(this.kind == TypeKind.USIZE);\r\n    var ret = new Type(this.kind, this.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, this.size);\r\n    ret.classType = classType;\r\n    return ret;\r\n  }\r\n\r\n  /** Composes a function type from this type and a function. */\r\n  asFunction(functionType: Function): Type {\r\n    assert(this.kind == TypeKind.U32 && !this.isReference);\r\n    var ret = new Type(this.kind, this.flags & ~TypeFlags.VALUE | TypeFlags.REFERENCE, this.size);\r\n    ret.functionType = functionType;\r\n    return ret;\r\n  }\r\n\r\n  /** Composes the respective nullable type of this type. */\r\n  asNullable(): Type | null {\r\n    assert(this.kind == TypeKind.USIZE);\r\n    if (!this.nullableType) {\r\n      assert(!this.is(TypeFlags.NULLABLE) && this.isReference);\r\n      this.nullableType = new Type(this.kind, this.flags | TypeFlags.NULLABLE, this.size);\r\n      this.nullableType.classType = this.classType;\r\n      this.nullableType.functionType = this.functionType;\r\n    }\r\n    return this.nullableType;\r\n  }\r\n\r\n  /** Tests if a value of this type is assignable to a target of the specified type. */\r\n  isAssignableTo(target: Type): bool {\r\n    var currentClass: Class | null;\r\n    var targetClass: Class | null;\r\n    var currentFunction: Function | null;\r\n    var targetFunction: Function | null;\r\n    if (this.isReference) {\r\n      if (target.isReference) {\r\n        if (currentClass = this.classType) {\r\n          if (targetClass = target.classType) {\r\n            return currentClass.isAssignableTo(targetClass);\r\n          }\r\n        } else if (currentFunction = this.functionType) {\r\n          if (targetFunction = target.functionType) {\r\n            return currentFunction.isAssignableTo(targetFunction);\r\n          }\r\n        }\r\n      }\r\n    } else if (!target.isReference) {\r\n      switch (this.kind) {\r\n\r\n        case TypeKind.I8:\r\n          switch (target.kind) {\r\n            case TypeKind.I8:    // same\r\n            case TypeKind.I16:   // larger\r\n            case TypeKind.I32:   // larger\r\n            case TypeKind.I64:   // larger\r\n            case TypeKind.ISIZE: // larger\r\n            case TypeKind.U8:    // signed to unsigned\r\n            case TypeKind.U16:   // larger\r\n            case TypeKind.U32:   // larger\r\n            case TypeKind.U64:   // larger\r\n            case TypeKind.USIZE: // larger\r\n            case TypeKind.F32:   // safe\r\n            case TypeKind.F64:   // safe\r\n              return true;\r\n          }\r\n          break;\r\n\r\n        case TypeKind.I16:\r\n          switch (target.kind) {\r\n            case TypeKind.I16:   // same\r\n            case TypeKind.I32:   // larger\r\n            case TypeKind.I64:   // larger\r\n            case TypeKind.ISIZE: // larger\r\n            case TypeKind.U16:   // signed to unsigned\r\n            case TypeKind.U32:   // larger\r\n            case TypeKind.U64:   // larger\r\n            case TypeKind.USIZE: // larger\r\n            case TypeKind.F32:   // safe\r\n            case TypeKind.F64:   // safe\r\n              return true;\r\n          }\r\n          break;\r\n\r\n        case TypeKind.I32:\r\n          switch (target.kind) {\r\n            case TypeKind.I32:   // same\r\n            case TypeKind.I64:   // larger\r\n            case TypeKind.ISIZE: // same or larger\r\n            case TypeKind.U32:   // signed to unsigned\r\n            case TypeKind.U64:   // larger\r\n            case TypeKind.USIZE: // signed to unsigned or larger\r\n            case TypeKind.F64:   // safe\r\n              return true;\r\n          }\r\n          break;\r\n\r\n        case TypeKind.I64:\r\n          switch (target.kind) {\r\n            case TypeKind.I64:   // same\r\n            case TypeKind.U64:   // signed to unsigned\r\n              return true;\r\n            case TypeKind.ISIZE: // possibly same\r\n            case TypeKind.USIZE: // possibly signed to unsigned\r\n              return target.size == 64;\r\n          }\r\n          break;\r\n\r\n        case TypeKind.ISIZE:\r\n          switch (target.kind) {\r\n            case TypeKind.I32:   // possibly same\r\n            case TypeKind.U32:   // possibly signed to unsigned\r\n              return this.size == 32;\r\n            case TypeKind.I64:   // same or larger\r\n            case TypeKind.ISIZE: // same\r\n            case TypeKind.U64:   // signed to unsigned or larger\r\n            case TypeKind.USIZE: // signed to unsigned\r\n              return true;\r\n            case TypeKind.F64:   // possibly safe\r\n              return target.size == 32;\r\n          }\r\n          break;\r\n\r\n        case TypeKind.U8:\r\n          switch (target.kind) {\r\n            case TypeKind.I16:   // larger\r\n            case TypeKind.I32:   // larger\r\n            case TypeKind.I64:   // larger\r\n            case TypeKind.ISIZE: // larger\r\n            case TypeKind.U8:    // same\r\n            case TypeKind.U16:   // larger\r\n            case TypeKind.U32:   // larger\r\n            case TypeKind.U64:   // larger\r\n            case TypeKind.USIZE: // larger\r\n            case TypeKind.F32:   // safe\r\n            case TypeKind.F64:   // safe\r\n              return true;\r\n          }\r\n          break;\r\n\r\n        case TypeKind.U16:\r\n          switch (target.kind) {\r\n            case TypeKind.I32:   // larger\r\n            case TypeKind.I64:   // larger\r\n            case TypeKind.ISIZE: // larger\r\n            case TypeKind.U16:   // same\r\n            case TypeKind.U32:   // larger\r\n            case TypeKind.U64:   // larger\r\n            case TypeKind.USIZE: // larger\r\n            case TypeKind.F32:   // safe\r\n            case TypeKind.F64:   // safe\r\n              return true;\r\n          }\r\n          break;\r\n\r\n        case TypeKind.U32:\r\n          switch (target.kind) {\r\n            case TypeKind.I64:   // larger\r\n            case TypeKind.U32:   // same\r\n            case TypeKind.U64:   // larger\r\n            case TypeKind.USIZE: // same or larger\r\n            case TypeKind.F64:   // safe\r\n              return true;\r\n          }\r\n          break;\r\n\r\n        case TypeKind.U64:\r\n          switch (target.kind) {\r\n            case TypeKind.U64:   // same\r\n              return true;\r\n            case TypeKind.USIZE: // possibly same\r\n              return target.size == 64;\r\n          }\r\n          break;\r\n\r\n        case TypeKind.USIZE:\r\n          switch (target.kind) {\r\n            case TypeKind.U32:   // possibly same\r\n              return this.size == 32;\r\n            case TypeKind.U64:   // same or larger\r\n            case TypeKind.USIZE: // same\r\n              return true;\r\n            case TypeKind.F64:   // possibly safe\r\n              return target.size == 32;\r\n          }\r\n          break;\r\n\r\n        case TypeKind.BOOL:\r\n          switch (target.kind) {\r\n            case TypeKind.I8:    // larger\r\n            case TypeKind.I16:   // larger\r\n            case TypeKind.I32:   // larger\r\n            case TypeKind.I64:   // larger\r\n            case TypeKind.ISIZE: // larger\r\n            case TypeKind.U8:    // larger\r\n            case TypeKind.U16:   // larger\r\n            case TypeKind.U32:   // larger\r\n            case TypeKind.U64:   // larger\r\n            case TypeKind.USIZE: // larger\r\n            case TypeKind.BOOL:  // same\r\n              return true;\r\n          }\r\n          break;\r\n\r\n        case TypeKind.F32:\r\n          switch (target.kind) {\r\n            case TypeKind.F32:   // same\r\n            case TypeKind.F64:   // larger\r\n              return true;\r\n          }\r\n          break;\r\n\r\n        case TypeKind.F64:\r\n          return target.kind == TypeKind.F64;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Converts this type to its TypeScript representation. */\r\n  toString(kindOnly: bool = false): string {\r\n    switch (this.kind) {\r\n      case TypeKind.I8: return \"i8\";\r\n      case TypeKind.I16: return \"i16\";\r\n      case TypeKind.I32: return \"i32\";\r\n      case TypeKind.I64: return \"i64\";\r\n      case TypeKind.ISIZE: return \"isize\";\r\n      case TypeKind.U8: return \"u8\";\r\n      case TypeKind.U16: return \"u16\";\r\n      case TypeKind.U32: return \"u32\";\r\n      case TypeKind.U64: return \"u64\";\r\n      case TypeKind.USIZE:\r\n        if (kindOnly) return \"usize\";\r\n        return this.classType\r\n          ? this.classType.toString()\r\n          : this.functionType\r\n            ? this.functionType.toTypeString()\r\n            : \"usize\";\r\n      case TypeKind.BOOL: return \"bool\";\r\n      case TypeKind.F32: return \"f32\";\r\n      case TypeKind.F64: return \"f64\";\r\n      case TypeKind.VOID: return \"void\";\r\n      default: assert(false); return \"\";\r\n    }\r\n  }\r\n\r\n  // Binaryen specific\r\n\r\n  /** Converts this type to its respective native type. */\r\n  toNativeType(): NativeType {\r\n    switch (this.kind) {\r\n\r\n      default:\r\n        return NativeType.I32;\r\n\r\n      case TypeKind.I64:\r\n      case TypeKind.U64:\r\n        return NativeType.I64;\r\n\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE:\r\n        return this.size == 64 ? NativeType.I64 : NativeType.I32;\r\n\r\n      case TypeKind.F32:\r\n        return NativeType.F32;\r\n\r\n      case TypeKind.F64:\r\n        return NativeType.F64;\r\n\r\n      case TypeKind.VOID:\r\n        return NativeType.None;\r\n    }\r\n  }\r\n\r\n  /** Converts this type to its native `0` value. */\r\n  toNativeZero(module: Module): ExpressionRef {\r\n    switch (this.kind) {\r\n\r\n      case TypeKind.VOID:\r\n        assert(false);\r\n\r\n      default:\r\n        return module.createI32(0);\r\n\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE:\r\n        if (this.size != 64) return module.createI32(0);\r\n        // fall-through\r\n\r\n      case TypeKind.I64:\r\n      case TypeKind.U64:\r\n        return module.createI64(0);\r\n\r\n      case TypeKind.F32:\r\n        return module.createF32(0);\r\n\r\n      case TypeKind.F64:\r\n        return module.createF64(0);\r\n    }\r\n  }\r\n\r\n  /** Converts this type to its native `1` value. */\r\n  toNativeOne(module: Module): ExpressionRef {\r\n    switch (this.kind) {\r\n\r\n      case TypeKind.VOID:\r\n        assert(false);\r\n\r\n      default:\r\n        return module.createI32(1);\r\n\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE:\r\n        if (this.size != 64) return module.createI32(1);\r\n        // fall-through\r\n\r\n      case TypeKind.I64:\r\n      case TypeKind.U64:\r\n        return module.createI64(1);\r\n\r\n      case TypeKind.F32:\r\n        return module.createF32(1);\r\n\r\n      case TypeKind.F64:\r\n        return module.createF64(1);\r\n    }\r\n  }\r\n\r\n  /** Converts this type to its native `-1` value. */\r\n  toNativeNegOne(module: Module): ExpressionRef {\r\n    switch (this.kind) {\r\n\r\n      case TypeKind.VOID:\r\n        assert(false);\r\n\r\n      default:\r\n        return module.createI32(-1);\r\n\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE:\r\n        if (this.size != 64) return module.createI32(-1);\r\n        // fall-through\r\n\r\n      case TypeKind.I64:\r\n      case TypeKind.U64:\r\n        return module.createI64(-1, -1);\r\n\r\n      case TypeKind.F32:\r\n        return module.createF32(-1);\r\n\r\n      case TypeKind.F64:\r\n        return module.createF64(-1);\r\n    }\r\n  }\r\n\r\n  /** Converts this type to its signature string. */\r\n  toSignatureString(): string {\r\n    switch (this.kind) {\r\n\r\n      default:\r\n        return \"i\";\r\n\r\n      case TypeKind.I64:\r\n      case TypeKind.U64:\r\n        return \"I\";\r\n\r\n      case TypeKind.ISIZE:\r\n      case TypeKind.USIZE:\r\n        return this.size == 64 ? \"I\" : \"i\";\r\n\r\n      case TypeKind.F32:\r\n        return \"f\";\r\n\r\n      case TypeKind.F64:\r\n        return \"F\";\r\n\r\n      case TypeKind.VOID:\r\n        return \"v\";\r\n    }\r\n  }\r\n\r\n  // Types\r\n\r\n  /** An 8-bit signed integer. */\r\n  static readonly i8: Type  = new Type(TypeKind.I8,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.SMALL    |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,   8\r\n  );\r\n\r\n  /** A 16-bit signed integer. */\r\n  static readonly i16: Type = new Type(TypeKind.I16,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.SMALL    |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  16\r\n  );\r\n\r\n  /** A 32-bit signed integer. */\r\n  static readonly i32: Type = new Type(TypeKind.I32,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  32\r\n  );\r\n\r\n  /** A 64-bit signed integer. */\r\n  static readonly i64: Type = new Type(TypeKind.I64,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.LONG     |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  64\r\n  );\r\n\r\n  /** A 32-bit signed size. WASM32 only. */\r\n  static readonly isize32: Type = new Type(TypeKind.ISIZE,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.SIZE     |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  32\r\n  );\r\n\r\n  /** A 64-bit signed size. WASM64 only. */\r\n  static readonly isize64: Type = new Type(TypeKind.ISIZE,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.LONG     |\r\n    TypeFlags.SIZE     |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  64\r\n  );\r\n\r\n  /** An 8-bit unsigned integer. */\r\n  static readonly u8: Type = new Type(TypeKind.U8,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.SMALL    |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,   8\r\n  );\r\n\r\n  /** A 16-bit unsigned integer. */\r\n  static readonly u16: Type = new Type(TypeKind.U16,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.SMALL    |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  16\r\n  );\r\n\r\n  /** A 32-bit unsigned integer. */\r\n  static readonly u32: Type = new Type(TypeKind.U32,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  32\r\n  );\r\n\r\n  /** A 64-bit unsigned integer. */\r\n  static readonly u64: Type = new Type(TypeKind.U64,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.LONG     |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  64\r\n  );\r\n\r\n  /** A 32-bit unsigned size. WASM32 only. */\r\n  static readonly usize32: Type = new Type(TypeKind.USIZE,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.SIZE     |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  32\r\n  );\r\n\r\n  /** A 64-bit unsigned size. WASM64 only. */\r\n  static readonly usize64: Type = new Type(TypeKind.USIZE,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.LONG     |\r\n    TypeFlags.SIZE     |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,  64\r\n  );\r\n\r\n  /** A 1-bit unsigned integer. */\r\n  static readonly bool: Type = new Type(TypeKind.BOOL,\r\n    TypeFlags.UNSIGNED |\r\n    TypeFlags.SMALL    |\r\n    TypeFlags.INTEGER  |\r\n    TypeFlags.VALUE,   1\r\n  );\r\n\r\n  /** A 32-bit float. */\r\n  static readonly f32: Type = new Type(TypeKind.F32,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.FLOAT    |\r\n    TypeFlags.VALUE,  32\r\n  );\r\n\r\n  /** A 64-bit float. */\r\n  static readonly f64: Type = new Type(TypeKind.F64,\r\n    TypeFlags.SIGNED   |\r\n    TypeFlags.LONG     |\r\n    TypeFlags.FLOAT    |\r\n    TypeFlags.VALUE,  64\r\n  );\r\n\r\n  /** No return type. */\r\n  static readonly void: Type = new Type(TypeKind.VOID, TypeFlags.NONE, 0);\r\n}\r\n\r\n/** Converts an array of types to an array of native types. */\r\nexport function typesToNativeTypes(types: Type[]): NativeType[] {\r\n  var k = types.length;\r\n  var ret = new Array<NativeType>(k);\r\n  for (var i = 0; i < k; ++i) {\r\n    ret[i] = types[i].toNativeType();\r\n  }\r\n  return ret;\r\n}\r\n\r\n/** Converts an array of types to its combined string representation. */\r\nexport function typesToString(types: Type[]): string {\r\n  var k = types.length;\r\n  if (!k) return \"\";\r\n  var sb = new Array<string>(k);\r\n  for (var i = 0; i < k; ++i) {\r\n    sb[i] = types[i].toString();\r\n  }\r\n  return sb.join(\", \");\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/types.ts","import {\r\n  PATH_DELIMITER,\r\n  STATIC_DELIMITER,\r\n  INSTANCE_DELIMITER\r\n} from \"./program\";\r\n\r\nimport {\r\n  Token,\r\n  Tokenizer,\r\n  Range\r\n} from \"./tokenizer\";\r\n\r\nimport {\r\n  normalize as normalizePath,\r\n  resolve as resolvePath\r\n} from \"./util/path\";\r\n\r\nexport { Token, Range };\r\n\r\n/** Indicates the kind of a node. */\r\nexport enum NodeKind {\r\n\r\n  SOURCE,\r\n\r\n  // types\r\n  TYPE,\r\n  TYPEPARAMETER,\r\n\r\n  // expressions\r\n  IDENTIFIER,\r\n  ASSERTION,\r\n  BINARY,\r\n  CALL,\r\n  COMMA,\r\n  ELEMENTACCESS,\r\n  FALSE,\r\n  FUNCTION,\r\n  FUNCTIONARROW,\r\n  LITERAL,\r\n  NEW,\r\n  NULL,\r\n  PARENTHESIZED,\r\n  PROPERTYACCESS,\r\n  TERNARY,\r\n  SUPER,\r\n  THIS,\r\n  TRUE,\r\n  CONSTRUCTOR,\r\n  UNARYPOSTFIX,\r\n  UNARYPREFIX,\r\n\r\n  // statements\r\n  BLOCK,\r\n  BREAK,\r\n  CONTINUE,\r\n  DO,\r\n  EMPTY,\r\n  EXPORT,\r\n  EXPORTIMPORT,\r\n  EXPRESSION,\r\n  FOR,\r\n  IF,\r\n  IMPORT,\r\n  RETURN,\r\n  SWITCH,\r\n  THROW,\r\n  TRY,\r\n  VARIABLE,\r\n  WHILE,\r\n\r\n  // declaration statements\r\n  CLASSDECLARATION,\r\n  ENUMDECLARATION,\r\n  ENUMVALUEDECLARATION,\r\n  FIELDDECLARATION,\r\n  FUNCTIONDECLARATION,\r\n  IMPORTDECLARATION,\r\n  INTERFACEDECLARATION,\r\n  METHODDECLARATION,\r\n  NAMESPACEDECLARATION,\r\n  TYPEDECLARATION,\r\n  VARIABLEDECLARATION,\r\n\r\n  // other\r\n  DECORATOR,\r\n  EXPORTMEMBER,\r\n  MODIFIER,\r\n  PARAMETER,\r\n  SWITCHCASE\r\n}\r\n\r\n/** Base class of all nodes. */\r\nexport abstract class Node {\r\n\r\n  /** Node kind indicator. */\r\n  kind: NodeKind;\r\n  /** Source range. */\r\n  range: Range;\r\n  /** Parent node. */\r\n  parent: Node | null = null;\r\n\r\n  // types\r\n\r\n  static createType(\r\n    identifier: IdentifierExpression,\r\n    typeArguments: TypeNode[],\r\n    isNullable: bool,\r\n    range: Range\r\n  ): TypeNode {\r\n    var type = new TypeNode();\r\n    type.range = range;\r\n    type.name = identifier;\r\n    type.typeArguments = typeArguments;\r\n    type.isNullable = isNullable;\r\n    return type;\r\n  }\r\n\r\n  // expressions\r\n\r\n  static createIdentifierExpression(\r\n    name: string,\r\n    range: Range\r\n  ): IdentifierExpression {\r\n    var expr = new IdentifierExpression();\r\n    expr.range = range;\r\n    expr.text = name;\r\n    return expr;\r\n  }\r\n\r\n  static createArrayLiteralExpression(\r\n    elements: (Expression | null)[],\r\n    range: Range\r\n  ): ArrayLiteralExpression {\r\n    var expr = new ArrayLiteralExpression();\r\n    expr.range = range;\r\n    expr.elementExpressions = elements; setParentOpt(elements, expr);\r\n    return expr;\r\n  }\r\n\r\n  static createAssertionExpression(\r\n    assertionKind: AssertionKind,\r\n    expression: Expression,\r\n    toType: TypeNode,\r\n    range: Range\r\n  ): AssertionExpression {\r\n    var expr = new AssertionExpression();\r\n    expr.range = range;\r\n    expr.assertionKind = assertionKind;\r\n    expr.expression = expression; expression.parent = expr;\r\n    expr.toType = toType; toType.parent = expr;\r\n    return expr;\r\n  }\r\n\r\n  static createBinaryExpression(\r\n    operator: Token,\r\n    left: Expression,\r\n    right: Expression,\r\n    range: Range\r\n  ): BinaryExpression {\r\n    var expr = new BinaryExpression();\r\n    expr.range = range;\r\n    expr.operator = operator;\r\n    expr.left = left; left.parent = expr;\r\n    expr.right = right; right.parent = expr;\r\n    return expr;\r\n  }\r\n\r\n  static createCallExpression(\r\n    expression: Expression,\r\n    typeArgs: TypeNode[] | null,\r\n    args: Expression[],\r\n    range: Range\r\n  ): CallExpression {\r\n    var expr = new CallExpression();\r\n    expr.range = range;\r\n    expr.expression = expression; expression.parent = expr;\r\n    expr.typeArguments = typeArgs; if (typeArgs) setParent(typeArgs, expr);\r\n    expr.arguments = args; setParent(args, expr);\r\n    return expr;\r\n  }\r\n\r\n  static createCommaExpression(\r\n    expressions: Expression[],\r\n    range: Range\r\n  ): CommaExpression {\r\n    var expr = new CommaExpression();\r\n    expr.range = range;\r\n    expr.expressions = expressions; setParent(expressions, expr);\r\n    return expr;\r\n  }\r\n\r\n  static createConstructorExpression(\r\n    range: Range\r\n  ): ConstructorExpression {\r\n    var expr = new ConstructorExpression();\r\n    expr.range = range;\r\n    return expr;\r\n  }\r\n\r\n  static createElementAccessExpression(\r\n    expression: Expression,\r\n    element: Expression,\r\n    range: Range\r\n  ): ElementAccessExpression {\r\n    var expr = new ElementAccessExpression();\r\n    expr.range = range;\r\n    expr.expression = expression; expression.parent = expr;\r\n    expr.elementExpression = element; element.parent = expr;\r\n    return expr;\r\n  }\r\n\r\n  static createFalseExpression(\r\n    range: Range\r\n  ): FalseExpression {\r\n    var expr = new FalseExpression();\r\n    expr.range = range;\r\n    return expr;\r\n  }\r\n\r\n  static createFloatLiteralExpression(\r\n    value: f64,\r\n    range: Range\r\n  ): FloatLiteralExpression {\r\n    var expr = new FloatLiteralExpression();\r\n    expr.range = range;\r\n    expr.value = value;\r\n    return expr;\r\n  }\r\n\r\n  static createFunctionExpression(\r\n    declaration: FunctionDeclaration,\r\n    isArrow: bool = false\r\n  ): FunctionExpression {\r\n    var expr = isArrow\r\n      ? new FunctionArrowExpression()\r\n      : new FunctionExpression();\r\n    expr.range = declaration.range;\r\n    expr.declaration = declaration;\r\n    return expr;\r\n  }\r\n\r\n  static createIntegerLiteralExpression(\r\n    value: I64,\r\n    range: Range\r\n  ): IntegerLiteralExpression {\r\n    var expr = new IntegerLiteralExpression();\r\n    expr.range = range;\r\n    expr.value = value;\r\n    return expr;\r\n  }\r\n\r\n  static createNewExpression(\r\n    expression: Expression,\r\n    typeArgs: TypeNode[] | null,\r\n    args: Expression[],\r\n    range: Range\r\n  ): NewExpression {\r\n    var expr = new NewExpression();\r\n    expr.range = range;\r\n    expr.expression = expression; expression.parent = expr;\r\n    expr.typeArguments = typeArgs; if (typeArgs) setParent(typeArgs, expr);\r\n    expr.arguments = args; setParent(args, expr);\r\n    return expr;\r\n  }\r\n\r\n  static createNullExpression(\r\n    range: Range\r\n  ): NullExpression {\r\n    var expr = new NullExpression();\r\n    expr.range = range;\r\n    return expr;\r\n  }\r\n\r\n  static createParenthesizedExpression(\r\n    expression: Expression,\r\n    range: Range\r\n  ): ParenthesizedExpression {\r\n    var expr = new ParenthesizedExpression();\r\n    expr.range = range;\r\n    expr.expression = expression; expression.parent = expr;\r\n    return expr;\r\n  }\r\n\r\n  static createPropertyAccessExpression(\r\n    expression: Expression,\r\n    property: IdentifierExpression,\r\n    range: Range\r\n  ): PropertyAccessExpression {\r\n    var expr = new PropertyAccessExpression();\r\n    expr.range = range;\r\n    expr.expression = expression; expression.parent = expr;\r\n    expr.property = property; property.parent = expr;\r\n    return expr;\r\n  }\r\n\r\n  static createRegexpLiteralExpression(\r\n    pattern: string,\r\n    flags: string,\r\n    range: Range\r\n  ): RegexpLiteralExpression {\r\n    var expr = new RegexpLiteralExpression();\r\n    expr.range = range;\r\n    expr.pattern = pattern;\r\n    expr.patternFlags = flags;\r\n    return expr;\r\n  }\r\n\r\n  static createTernaryExpression(\r\n    condition: Expression,\r\n    ifThen: Expression,\r\n    ifElse: Expression,\r\n    range: Range\r\n  ): TernaryExpression {\r\n    var expr = new TernaryExpression();\r\n    expr.range = range;\r\n    expr.condition = condition; condition.parent = expr;\r\n    expr.ifThen = ifThen; ifThen.parent = expr;\r\n    expr.ifElse = ifElse; ifElse.parent = expr;\r\n    return expr;\r\n  }\r\n\r\n  static createStringLiteralExpression(\r\n    value: string,\r\n    range: Range\r\n  ): StringLiteralExpression {\r\n    var expr = new StringLiteralExpression();\r\n    expr.range = range;\r\n    expr.value = value;\r\n    return expr;\r\n  }\r\n\r\n  static createSuperExpression(\r\n    range: Range\r\n  ): SuperExpression {\r\n    var expr = new SuperExpression();\r\n    expr.range = range;\r\n    return expr;\r\n  }\r\n\r\n  static createThisExpression(\r\n    range: Range\r\n  ): ThisExpression {\r\n    var expr = new ThisExpression();\r\n    expr.range = range;\r\n    return expr;\r\n  }\r\n\r\n  static createTrueExpression(\r\n    range: Range\r\n  ): TrueExpression {\r\n    var expr = new TrueExpression();\r\n    expr.range = range;\r\n    return expr;\r\n  }\r\n\r\n  static createUnaryPostfixExpression(\r\n    operator: Token,\r\n    operand: Expression,\r\n    range: Range\r\n  ): UnaryPostfixExpression {\r\n    var expr = new UnaryPostfixExpression();\r\n    expr.range = range;\r\n    expr.operator = operator;\r\n    expr.operand = operand; operand.parent = expr;\r\n    return expr;\r\n  }\r\n\r\n  static createUnaryPrefixExpression(\r\n    operator: Token,\r\n    operand: Expression,\r\n    range: Range\r\n  ): UnaryPrefixExpression {\r\n    var expr = new UnaryPrefixExpression();\r\n    expr.range = range;\r\n    expr.operator = operator;\r\n    expr.operand = operand; operand.parent = expr;\r\n    return expr;\r\n  }\r\n\r\n  // statements\r\n\r\n  static createBlockStatement(\r\n    statements: Statement[],\r\n    range: Range\r\n  ): BlockStatement {\r\n    var stmt = new BlockStatement();\r\n    stmt.range = range;\r\n    stmt.statements = statements; setParent(statements, stmt);\r\n    return stmt;\r\n  }\r\n\r\n  static createBreakStatement(\r\n    label: IdentifierExpression | null,\r\n    range: Range\r\n  ): BreakStatement {\r\n    var stmt = new BreakStatement();\r\n    stmt.range = range;\r\n    stmt.label = label; if (label) label.parent = stmt;\r\n    return stmt;\r\n  }\r\n\r\n  static createClassDeclaration(\r\n    identifier: IdentifierExpression,\r\n    typeParameters: TypeParameter[],\r\n    extendsType: TypeNode | null,\r\n    implementsTypes: TypeNode[],\r\n    members: DeclarationStatement[],\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null,\r\n    range: Range\r\n  ): ClassDeclaration {\r\n    var stmt = new ClassDeclaration();\r\n    stmt.range = range;\r\n    stmt.name = identifier; identifier.parent = stmt;\r\n    stmt.typeParameters = typeParameters; setParent(typeParameters, stmt);\r\n    stmt.extendsType = extendsType; if (extendsType) extendsType.parent = stmt;\r\n    stmt.implementsTypes = implementsTypes; setParent(implementsTypes, stmt);\r\n    stmt.members = members; setParent(members, stmt);\r\n    stmt.modifiers = modifiers; if (modifiers) setParent(modifiers, stmt);\r\n    stmt.decorators = decorators; if (decorators) setParent(decorators, stmt);\r\n    return stmt;\r\n  }\r\n\r\n  static createContinueStatement(\r\n    label: IdentifierExpression | null,\r\n    range: Range\r\n  ): ContinueStatement {\r\n    var stmt = new ContinueStatement();\r\n    stmt.range = range;\r\n    stmt.label = label; if (label) label.parent = stmt;\r\n    return stmt;\r\n  }\r\n\r\n  static createDecorator(\r\n    expression: Expression,\r\n    args: Expression[] | null,\r\n    range: Range\r\n  ): Decorator {\r\n    var stmt = new Decorator();\r\n    stmt.range = range;\r\n    stmt.name = expression; expression.parent = stmt;\r\n    stmt.arguments = args; if (args) setParent(args, stmt);\r\n    if (expression.kind == NodeKind.IDENTIFIER) {\r\n      switch ((<IdentifierExpression>expression).text) {\r\n        case \"global\": stmt.decoratorKind = DecoratorKind.GLOBAL; break;\r\n        case \"operator\": stmt.decoratorKind = DecoratorKind.OPERATOR; break;\r\n        case \"unmanaged\": stmt.decoratorKind = DecoratorKind.UNMANAGED; break;\r\n        case \"offset\": stmt.decoratorKind = DecoratorKind.OFFSET; break;\r\n        default: stmt.decoratorKind = DecoratorKind.CUSTOM; break;\r\n      }\r\n    } else {\r\n      stmt.decoratorKind = DecoratorKind.CUSTOM;\r\n    }\r\n    return stmt;\r\n  }\r\n\r\n  static createDoStatement(\r\n    statement: Statement,\r\n    condition: Expression,\r\n    range: Range\r\n  ): DoStatement {\r\n    var stmt = new DoStatement();\r\n    stmt.range = range;\r\n    stmt.statement = statement; statement.parent = stmt;\r\n    stmt.condition = condition; condition.parent = stmt;\r\n    return stmt;\r\n  }\r\n\r\n  static createEmptyStatement(\r\n    range: Range\r\n  ): EmptyStatement {\r\n    var stmt = new EmptyStatement();\r\n    stmt.range = range;\r\n    return stmt;\r\n  }\r\n\r\n  static createEnumDeclaration(\r\n    name: IdentifierExpression,\r\n    members: EnumValueDeclaration[],\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null,\r\n    range: Range\r\n  ): EnumDeclaration {\r\n    var stmt = new EnumDeclaration();\r\n    stmt.range = range;\r\n    stmt.name = name; name.parent = stmt;\r\n    stmt.values = members; setParent(members, stmt);\r\n    stmt.modifiers = modifiers; if (modifiers) setParent(modifiers, stmt);\r\n    stmt.decorators = decorators; if (decorators) setParent(decorators, stmt);\r\n    return stmt;\r\n  }\r\n\r\n  static createEnumValueDeclaration(\r\n    name: IdentifierExpression,\r\n    value: Expression | null,\r\n    range: Range\r\n  ): EnumValueDeclaration {\r\n    var stmt = new EnumValueDeclaration();\r\n    stmt.range = range;\r\n    stmt.name = name; name.parent = stmt;\r\n    stmt.value = value; if (value) value.parent = stmt;\r\n    return stmt;\r\n  }\r\n\r\n  static createExportStatement(\r\n    members: ExportMember[],\r\n    path: StringLiteralExpression | null,\r\n    modifiers: Modifier[] | null,\r\n    range: Range\r\n  ): ExportStatement {\r\n    var stmt = new ExportStatement();\r\n    stmt.range = range;\r\n    stmt.members = members; setParent(members, stmt);\r\n    stmt.path = path;\r\n    if (path) {\r\n      var normalizedPath = normalizePath(path.value);\r\n      if (path.value.startsWith(\".\")) { // relative\r\n        stmt.normalizedPath = resolvePath(\r\n          normalizedPath,\r\n          range.source.normalizedPath\r\n        );\r\n      } else { // absolute\r\n        stmt.normalizedPath = normalizedPath;\r\n      }\r\n      stmt.internalPath = mangleInternalPath(stmt.normalizedPath);\r\n    } else {\r\n      stmt.normalizedPath = null;\r\n      stmt.internalPath = null;\r\n    }\r\n    stmt.modifiers = modifiers; if (modifiers) setParent(modifiers, stmt);\r\n    return stmt;\r\n  }\r\n\r\n  static createExportImportStatement(\r\n    name: IdentifierExpression,\r\n    externalName: IdentifierExpression,\r\n    range: Range\r\n  ): ExportImportStatement {\r\n    var stmt = new ExportImportStatement();\r\n    stmt.range = range;\r\n    stmt.name = name; name.parent = stmt;\r\n    stmt.externalName = externalName; externalName.parent = stmt;\r\n    return stmt;\r\n  }\r\n\r\n  static createExportMember(\r\n    name: IdentifierExpression,\r\n    externalName: IdentifierExpression | null,\r\n    range: Range\r\n  ): ExportMember {\r\n    var elem = new ExportMember();\r\n    elem.range = range;\r\n    elem.name = name; name.parent = elem;\r\n    if (!externalName) {\r\n      externalName = name;\r\n    } else {\r\n      externalName.parent = elem;\r\n    }\r\n    elem.externalName = externalName;\r\n    return elem;\r\n  }\r\n\r\n  static createExpressionStatement(\r\n    expression: Expression\r\n  ): ExpressionStatement {\r\n    var stmt = new ExpressionStatement();\r\n    stmt.range = expression.range;\r\n    stmt.expression = expression; expression.parent = stmt;\r\n    return stmt;\r\n  }\r\n\r\n  static createIfStatement(\r\n    condition: Expression,\r\n    ifTrue: Statement,\r\n    ifFalse: Statement | null,\r\n    range: Range\r\n  ): IfStatement {\r\n    var stmt = new IfStatement();\r\n    stmt.range = range;\r\n    stmt.condition = condition; condition.parent = stmt;\r\n    stmt.ifTrue = ifTrue; ifTrue.parent = stmt;\r\n    stmt.ifFalse = ifFalse; if (ifFalse) ifFalse.parent = stmt;\r\n    return stmt;\r\n  }\r\n\r\n  static createImportStatement(\r\n    decls: ImportDeclaration[] | null,\r\n    path: StringLiteralExpression,\r\n    range: Range\r\n  ): ImportStatement {\r\n    var stmt = new ImportStatement();\r\n    stmt.range = range;\r\n    stmt.declarations = decls; if (decls) setParent(decls, stmt);\r\n    stmt.namespaceName = null;\r\n    stmt.path = path;\r\n    var normalizedPath = normalizePath(path.value);\r\n    if (path.value.startsWith(\".\")) { // relative\r\n      stmt.normalizedPath = resolvePath(\r\n        normalizedPath,\r\n        range.source.normalizedPath\r\n      );\r\n    } else { // absolute\r\n      stmt.normalizedPath = normalizedPath;\r\n    }\r\n    stmt.internalPath = mangleInternalPath(stmt.normalizedPath);\r\n    return stmt;\r\n  }\r\n\r\n  static createImportStatementWithWildcard(\r\n    identifier: IdentifierExpression,\r\n    path: StringLiteralExpression,\r\n    range: Range\r\n  ): ImportStatement {\r\n    var stmt = new ImportStatement();\r\n    stmt.range = range;\r\n    stmt.declarations = null;\r\n    stmt.namespaceName = identifier;\r\n    stmt.path = path;\r\n    stmt.normalizedPath = resolvePath(\r\n      normalizePath(path.value),\r\n      range.source.normalizedPath\r\n    );\r\n    stmt.internalPath = mangleInternalPath(stmt.normalizedPath);\r\n    return stmt;\r\n  }\r\n\r\n  static createImportDeclaration(\r\n    externalName: IdentifierExpression,\r\n    name: IdentifierExpression | null,\r\n    range: Range\r\n  ): ImportDeclaration {\r\n    var elem = new ImportDeclaration();\r\n    elem.range = range;\r\n    elem.externalName = externalName; externalName.parent = elem;\r\n    if (!name) {\r\n      name = externalName;\r\n    } else {\r\n      name.parent = elem;\r\n    }\r\n    elem.name = name;\r\n    return elem;\r\n  }\r\n\r\n  static createInterfaceDeclaration(\r\n    name: IdentifierExpression,\r\n    extendsType: TypeNode | null,\r\n    members: DeclarationStatement[],\r\n    modifiers: Modifier[] | null,\r\n    range: Range\r\n  ): InterfaceDeclaration {\r\n    var stmt = new InterfaceDeclaration();\r\n    stmt.range = range;\r\n    stmt.name = name; name.parent = stmt;\r\n    stmt.extendsType = extendsType; if (extendsType) extendsType.parent = stmt;\r\n    stmt.members = members; setParent(members, stmt);\r\n    stmt.modifiers = modifiers; if (modifiers) setParent(modifiers, stmt);\r\n    return stmt;\r\n  }\r\n\r\n  static createFieldDeclaration(\r\n    name: IdentifierExpression,\r\n    type: TypeNode | null,\r\n    initializer: Expression | null,\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null,\r\n    range: Range\r\n  ): FieldDeclaration {\r\n    var stmt = new FieldDeclaration();\r\n    stmt.range = range;\r\n    stmt.name = name; name.parent = stmt;\r\n    stmt.type = type; if (type) type.parent = stmt;\r\n    stmt.initializer = initializer; if (initializer) initializer.parent = stmt;\r\n    stmt.modifiers = modifiers; if (modifiers) setParent(modifiers, stmt);\r\n    stmt.decorators = decorators; if (decorators) setParent(decorators, stmt);\r\n    return stmt;\r\n  }\r\n\r\n  static createForStatement(\r\n    initializer: Statement | null,\r\n    condition: Expression | null,\r\n    incrementor: Expression | null,\r\n    statement: Statement,\r\n    range: Range\r\n  ): ForStatement {\r\n    var stmt = new ForStatement();\r\n    stmt.range = range;\r\n    stmt.initializer = initializer; if (initializer) initializer.parent = stmt;\r\n    stmt.condition = condition; if (condition) condition.parent = stmt;\r\n    stmt.incrementor = incrementor; if (incrementor) incrementor.parent = stmt;\r\n    stmt.statement = statement; statement.parent = stmt;\r\n    return stmt;\r\n  }\r\n\r\n  static createTypeParameter(\r\n    name: IdentifierExpression,\r\n    extendsType: TypeNode | null,\r\n    range: Range\r\n  ): TypeParameter {\r\n    var elem = new TypeParameter();\r\n    elem.range = range;\r\n    elem.name = name; name.parent = elem;\r\n    elem.extendsType = extendsType; if (extendsType) extendsType.parent = elem;\r\n    return elem;\r\n  }\r\n\r\n  static createParameter(\r\n    name: IdentifierExpression,\r\n    type: TypeNode | null,\r\n    initializer: Expression | null,\r\n    kind: ParameterKind,\r\n    range: Range\r\n  ): Parameter {\r\n    var elem = new Parameter();\r\n    elem.range = range;\r\n    elem.name = name; name.parent = elem;\r\n    elem.type = type; if (type) type.parent = elem;\r\n    elem.initializer = initializer; if (initializer) initializer.parent = elem;\r\n    elem.parameterKind = kind;\r\n    return elem;\r\n  }\r\n\r\n  static createFunctionDeclaration(\r\n    name: IdentifierExpression,\r\n    typeParameters: TypeParameter[] | null,\r\n    parameters: Parameter[],\r\n    returnType: TypeNode | null,\r\n    body: Statement | null,\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null,\r\n    range: Range\r\n  ): FunctionDeclaration {\r\n    var stmt = new FunctionDeclaration();\r\n    stmt.range = range;\r\n    stmt.name = name; name.parent = stmt;\r\n    stmt.typeParameters = typeParameters; if (typeParameters) setParent(typeParameters, stmt);\r\n    stmt.parameters = parameters; setParent(parameters, stmt);\r\n    stmt.returnType = returnType; if (returnType) returnType.parent = stmt;\r\n    stmt.body = body; if (body) body.parent = stmt;\r\n    stmt.modifiers = modifiers; if (modifiers) setParent(modifiers, stmt);\r\n    stmt.decorators = decorators; if (decorators) setParent(decorators, stmt);\r\n    return stmt;\r\n  }\r\n\r\n  static createMethodDeclaration(\r\n    name: IdentifierExpression,\r\n    typeParameters: TypeParameter[] | null,\r\n    parameters: Parameter[],\r\n    returnType: TypeNode | null,\r\n    body: Statement | null,\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null,\r\n    range: Range\r\n  ): MethodDeclaration {\r\n    var stmt = new MethodDeclaration();\r\n    stmt.range = range;\r\n    stmt.name = name; name.parent = stmt;\r\n    stmt.typeParameters = typeParameters; if (typeParameters) setParent(typeParameters, stmt);\r\n    stmt.parameters = parameters; setParent(parameters, stmt);\r\n    stmt.returnType = returnType; if (returnType) returnType.parent = stmt;\r\n    stmt.body = body; if (body) body.parent = stmt;\r\n    stmt.modifiers = modifiers; if (modifiers) setParent(modifiers, stmt);\r\n    stmt.decorators = decorators; if (decorators) setParent(decorators, stmt);\r\n    return stmt;\r\n  }\r\n\r\n  static createModifier(kind: ModifierKind, range: Range): Modifier {\r\n    var elem = new Modifier();\r\n    elem.range = range;\r\n    elem.modifierKind = kind;\r\n    return elem;\r\n  }\r\n\r\n  static createNamespaceDeclaration(\r\n    name: IdentifierExpression,\r\n    members: Statement[],\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null,\r\n    range: Range\r\n  ): NamespaceDeclaration {\r\n    var stmt = new NamespaceDeclaration();\r\n    stmt.range = range;\r\n    stmt.name = name; name.parent = stmt;\r\n    stmt.members = members; setParent(members, stmt);\r\n    stmt.modifiers = modifiers; if (modifiers) setParent(modifiers, stmt);\r\n    stmt.decorators = decorators; if (decorators) setParent(decorators, stmt);\r\n    return stmt;\r\n  }\r\n\r\n  static createReturnStatement(\r\n    value: Expression | null,\r\n    range: Range\r\n  ): ReturnStatement {\r\n    var stmt = new ReturnStatement();\r\n    stmt.range = range;\r\n    stmt.value = value; if (value) value.parent = stmt;\r\n    return stmt;\r\n  }\r\n\r\n  static createSwitchStatement(\r\n    condition: Expression,\r\n    cases: SwitchCase[],\r\n    range: Range\r\n  ): SwitchStatement {\r\n    var stmt = new SwitchStatement();\r\n    stmt.range = range;\r\n    stmt.condition = condition; condition.parent = stmt;\r\n    stmt.cases = cases; setParent(cases, stmt);\r\n    return stmt;\r\n  }\r\n\r\n  static createSwitchCase(\r\n    label: Expression | null,\r\n    statements: Statement[],\r\n    range: Range\r\n  ): SwitchCase {\r\n    var elem = new SwitchCase();\r\n    elem.range = range;\r\n    elem.label = label; if (label) label.parent = elem;\r\n    elem.statements = statements; setParent(statements, elem);\r\n    return elem;\r\n  }\r\n\r\n  static createThrowStatement(\r\n    value: Expression,\r\n    range: Range\r\n  ): ThrowStatement {\r\n    var stmt = new ThrowStatement();\r\n    stmt.range = range;\r\n    stmt.value = value; value.parent = stmt;\r\n    return stmt;\r\n  }\r\n\r\n  static createTryStatement(\r\n    statements: Statement[],\r\n    catchVariable: IdentifierExpression | null,\r\n    catchStatements: Statement[] | null,\r\n    finallyStatements: Statement[] | null,\r\n    range: Range\r\n  ): TryStatement {\r\n    var stmt = new TryStatement();\r\n    stmt.range = range;\r\n    stmt.statements = statements; setParent(statements, stmt);\r\n    stmt.catchVariable = catchVariable;\r\n    if (catchVariable) catchVariable.parent = stmt;\r\n    stmt.catchStatements = catchStatements;\r\n    if (catchStatements) setParent(catchStatements, stmt);\r\n    stmt.finallyStatements = finallyStatements;\r\n    if (finallyStatements) setParent(finallyStatements, stmt);\r\n    return stmt;\r\n  }\r\n\r\n  static createTypeDeclaration(\r\n    name: IdentifierExpression,\r\n    alias: TypeNode,\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null,\r\n    range: Range\r\n  ): TypeDeclaration {\r\n    var stmt = new TypeDeclaration();\r\n    stmt.range = range;\r\n    stmt.name = name; name.parent = stmt;\r\n    stmt.alias = alias; alias.parent = stmt;\r\n    stmt.modifiers = modifiers; if (modifiers) setParent(modifiers, stmt);\r\n    stmt.decorators = decorators; if (decorators) setParent(decorators, stmt);\r\n    return stmt;\r\n  }\r\n\r\n  static createVariableStatement(\r\n    declarations: VariableDeclaration[],\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null,\r\n    range: Range\r\n  ): VariableStatement {\r\n    var stmt = new VariableStatement();\r\n    stmt.range = range;\r\n    stmt.declarations = declarations; setParent(declarations, stmt);\r\n    stmt.modifiers = modifiers; if (modifiers) setParent(modifiers, stmt);\r\n    stmt.decorators = decorators; if (decorators) setParent(decorators, stmt);\r\n    return stmt;\r\n  }\r\n\r\n  static createVariableDeclaration(\r\n    name: IdentifierExpression,\r\n    type: TypeNode | null,\r\n    initializer: Expression | null,\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null,\r\n    range: Range\r\n  ): VariableDeclaration {\r\n    var elem = new VariableDeclaration();\r\n    elem.range = range;\r\n    elem.name = name; name.parent = elem;\r\n    elem.type = type; if (type) type.parent = elem;\r\n    elem.initializer = initializer; if (initializer) initializer.parent = elem;\r\n    elem.modifiers = modifiers; // inherited from parent VariableStatement\r\n    elem.decorators = decorators; // inherited\r\n    return elem;\r\n  }\r\n\r\n  static createWhileStatement(\r\n    condition: Expression,\r\n    statement: Statement,\r\n    range: Range\r\n  ): WhileStatement {\r\n    var stmt = new WhileStatement();\r\n    stmt.range = range;\r\n    stmt.condition = condition; condition.parent = stmt;\r\n    stmt.statement = statement; statement.parent = stmt;\r\n    return stmt;\r\n  }\r\n}\r\n\r\n// types\r\n\r\n/** Represents a type annotation. */\r\nexport class TypeNode extends Node {\r\n  kind = NodeKind.TYPE;\r\n\r\n  /** Identifier reference. */\r\n  name: IdentifierExpression;\r\n  /** Type argument references. */\r\n  typeArguments: TypeNode[];\r\n  /** Whether nullable or not. */\r\n  isNullable: bool;\r\n}\r\n\r\n/** Represents a type parameter. */\r\nexport class TypeParameter extends Node {\r\n  kind = NodeKind.TYPEPARAMETER;\r\n\r\n  /** Identifier reference. */\r\n  name: IdentifierExpression;\r\n  /** Extended type reference, if any. */\r\n  extendsType: TypeNode | null;\r\n}\r\n\r\n// expressions\r\n\r\n/** Base class of all expression nodes. */\r\nexport abstract class Expression extends Node { }\r\n\r\n/** Represents an identifier expression. */\r\nexport class IdentifierExpression extends Expression {\r\n  kind = NodeKind.IDENTIFIER;\r\n\r\n  /** Textual name. */\r\n  text: string;\r\n}\r\n\r\n/** Indicates the kind of a literal. */\r\nexport const enum LiteralKind {\r\n  FLOAT,\r\n  INTEGER,\r\n  STRING,\r\n  REGEXP,\r\n  ARRAY,\r\n  OBJECT\r\n}\r\n\r\n/** Base class of all literal expressions. */\r\nexport abstract class LiteralExpression extends Expression {\r\n  kind = NodeKind.LITERAL;\r\n\r\n  /** Specific literal kind. */\r\n  literalKind: LiteralKind;\r\n}\r\n\r\n/** Represents an `[]` literal expression. */\r\nexport class ArrayLiteralExpression extends LiteralExpression {\r\n  literalKind = LiteralKind.ARRAY;\r\n\r\n  /** Nested element expressions. */\r\n  elementExpressions: (Expression | null)[];\r\n}\r\n\r\n/** Indicates the kind of an assertion. */\r\nexport const enum AssertionKind {\r\n  PREFIX,\r\n  AS\r\n}\r\n\r\n/** Represents an assertion expression. */\r\nexport class AssertionExpression extends Expression {\r\n  kind = NodeKind.ASSERTION;\r\n\r\n  /** Specific kind of this assertion. */\r\n  assertionKind: AssertionKind;\r\n  /** Expression being asserted. */\r\n  expression: Expression;\r\n  /** Target type. */\r\n  toType: TypeNode;\r\n}\r\n\r\n/** Represents a binary expression. */\r\nexport class BinaryExpression extends Expression {\r\n  kind = NodeKind.BINARY;\r\n\r\n  /** Operator token. */\r\n  operator: Token;\r\n  /** Left-hand side expression */\r\n  left: Expression;\r\n  /** Right-hand side expression. */\r\n  right: Expression;\r\n}\r\n\r\n/** Represents a call expression. */\r\nexport class CallExpression extends Expression {\r\n  kind = NodeKind.CALL;\r\n\r\n  /** Called expression. Usually an identifier or property access expression. */\r\n  expression: Expression;\r\n  /** Provided type arguments. */\r\n  typeArguments: TypeNode[] | null;\r\n  /** Provided arguments. */\r\n  arguments: Expression[];\r\n}\r\n\r\n/** Represents a comma expression composed of multiple expressions. */\r\nexport class CommaExpression extends Expression {\r\n  kind = NodeKind.COMMA;\r\n\r\n  /** Sequential expressions. */\r\n  expressions: Expression[];\r\n}\r\n\r\n/** Represents a `constructor` expression. */\r\nexport class ConstructorExpression extends IdentifierExpression {\r\n  kind = NodeKind.CONSTRUCTOR;\r\n  text = \"constructor\";\r\n}\r\n\r\n/** Represents an element access expression, e.g., array access. */\r\nexport class ElementAccessExpression extends Expression {\r\n  kind = NodeKind.ELEMENTACCESS;\r\n\r\n  /** Expression being accessed. */\r\n  expression: Expression;\r\n  /** Element of the expression being accessed. */\r\n  elementExpression: Expression;\r\n}\r\n\r\n/** Represents a float literal expression. */\r\nexport class FloatLiteralExpression extends LiteralExpression {\r\n  literalKind = LiteralKind.FLOAT;\r\n\r\n  /** Float value. */\r\n  value: f64;\r\n}\r\n\r\n/** Represents a function expression using the 'function' keyword. */\r\nexport class FunctionExpression extends Expression {\r\n  kind = NodeKind.FUNCTION;\r\n\r\n  /** Inline function declaration. */\r\n  declaration: FunctionDeclaration;\r\n}\r\n\r\n/** Represents an arrow function expression. */\r\nexport class FunctionArrowExpression extends FunctionExpression {\r\n  kind = NodeKind.FUNCTIONARROW;\r\n}\r\n\r\n/** Represents an integer literal expression. */\r\nexport class IntegerLiteralExpression extends LiteralExpression {\r\n  literalKind = LiteralKind.INTEGER;\r\n\r\n  /** Integer value. */\r\n  value: I64;\r\n}\r\n\r\n/** Represents a `new` expression. Like a call but with its own kind. */\r\nexport class NewExpression extends CallExpression {\r\n  kind = NodeKind.NEW;\r\n}\r\n\r\n/** Represents a `null` expression. */\r\nexport class NullExpression extends IdentifierExpression {\r\n  kind = NodeKind.NULL;\r\n  text = \"null\";\r\n}\r\n\r\n/** Represents a parenthesized expression. */\r\nexport class ParenthesizedExpression extends Expression {\r\n  kind = NodeKind.PARENTHESIZED;\r\n\r\n  /** Expression in parenthesis. */\r\n  expression: Expression;\r\n}\r\n\r\n/** Represents a property access expression. */\r\nexport class PropertyAccessExpression extends Expression {\r\n  kind = NodeKind.PROPERTYACCESS;\r\n\r\n  /** Expression being accessed. */\r\n  expression: Expression;\r\n  /** Property of the expression being accessed. */\r\n  property: IdentifierExpression;\r\n}\r\n\r\n/** Represents a regular expression literal expression. */\r\nexport class RegexpLiteralExpression extends LiteralExpression {\r\n  literalKind = LiteralKind.REGEXP;\r\n\r\n  /** Regular expression pattern. */\r\n  pattern: string;\r\n  /** Regular expression flags. */\r\n  patternFlags: string;\r\n}\r\n\r\n/** Represents a ternary expression, i.e., short if notation. */\r\nexport class TernaryExpression extends Expression {\r\n  kind = NodeKind.TERNARY;\r\n\r\n  /** Condition expression. */\r\n  condition: Expression;\r\n  /** Expression executed when condition is `true`. */\r\n  ifThen: Expression;\r\n  /** Expression executed when condition is `false`. */\r\n  ifElse: Expression;\r\n}\r\n\r\n/** Represents a string literal expression. */\r\nexport class StringLiteralExpression extends LiteralExpression {\r\n  literalKind = LiteralKind.STRING;\r\n\r\n  /** String value without quotes. */\r\n  value: string;\r\n}\r\n\r\n/** Represents a `super` expression. */\r\nexport class SuperExpression extends IdentifierExpression {\r\n  kind = NodeKind.SUPER;\r\n  text = \"super\";\r\n}\r\n\r\n/** Represents a `this` expression. */\r\nexport class ThisExpression extends IdentifierExpression {\r\n  kind = NodeKind.THIS;\r\n  text = \"this\";\r\n}\r\n\r\n/** Represents a `true` expression. */\r\nexport class TrueExpression extends IdentifierExpression {\r\n  kind = NodeKind.TRUE;\r\n  text = \"true\";\r\n}\r\n\r\n/** Represents a `false` expression. */\r\nexport class FalseExpression extends IdentifierExpression {\r\n  kind = NodeKind.FALSE;\r\n  text = \"false\";\r\n}\r\n\r\n/** Base class of all unary expressions. */\r\nexport abstract class UnaryExpression extends Expression {\r\n\r\n  /** Operator token. */\r\n  operator: Token;\r\n  /** Operand expression. */\r\n  operand: Expression;\r\n}\r\n\r\n/** Represents a unary postfix expression, e.g. a postfix increment. */\r\nexport class UnaryPostfixExpression extends UnaryExpression {\r\n  kind = NodeKind.UNARYPOSTFIX;\r\n}\r\n\r\n/** Represents a unary prefix expression, e.g. a negation. */\r\nexport class UnaryPrefixExpression extends UnaryExpression {\r\n  kind = NodeKind.UNARYPREFIX;\r\n}\r\n\r\n// statements\r\n\r\n/** Indicates the specific kind of a modifier. */\r\nexport enum ModifierKind {\r\n  ASYNC,\r\n  CONST,\r\n  LET,\r\n  DECLARE,\r\n  EXPORT,\r\n  IMPORT,\r\n  STATIC,\r\n  ABSTRACT,\r\n  PUBLIC,\r\n  PRIVATE,\r\n  PROTECTED,\r\n  READONLY,\r\n  GET,\r\n  SET,\r\n}\r\n\r\n/** Base class of all statement nodes. */\r\nexport abstract class Statement extends Node { }\r\n\r\n/** Indicates the specific kind of a source. */\r\nexport enum SourceKind {\r\n  /** Default source. Usually imported from an entry file. */\r\n  DEFAULT,\r\n  /** Entry file. */\r\n  ENTRY,\r\n  /** Library file. */\r\n  LIBRARY\r\n}\r\n\r\n/** A top-level source node. */\r\nexport class Source extends Node {\r\n  kind = NodeKind.SOURCE;\r\n  parent = null;\r\n\r\n  /** Source kind. */\r\n  sourceKind: SourceKind;\r\n  /** Normalized path. */\r\n  normalizedPath: string;\r\n  /** Path used internally. */\r\n  internalPath: string;\r\n  /** Contained statements. */\r\n  statements: Statement[];\r\n  /** Full source text. */\r\n  text: string;\r\n  /** Tokenizer reference. */\r\n  tokenizer: Tokenizer | null = null;\r\n  /** Source map index. */\r\n  debugInfoIndex: i32 = -1;\r\n\r\n  /** Constructs a new source node. */\r\n  constructor(normalizedPath: string, text: string, kind: SourceKind) {\r\n    super();\r\n    this.sourceKind = kind;\r\n    this.normalizedPath = normalizedPath;\r\n    this.internalPath = mangleInternalPath(this.normalizedPath);\r\n    this.statements = new Array();\r\n    this.range = new Range(this, 0, text.length);\r\n    this.text = text;\r\n  }\r\n\r\n  /** Tests if this source is an entry file. */\r\n  get isEntry(): bool { return this.sourceKind == SourceKind.ENTRY; }\r\n  /** Tests if this source is a stdlib file. */\r\n  get isLibrary(): bool { return this.sourceKind == SourceKind.LIBRARY; }\r\n}\r\n\r\n/** Base class of all declaration statements. */\r\nexport abstract class DeclarationStatement extends Statement {\r\n\r\n  /** Simple name being declared. */\r\n  name: IdentifierExpression;\r\n  /** Array of modifiers. */\r\n  modifiers: Modifier[] | null;\r\n  /** Array of decorators. */\r\n  decorators: Decorator[] | null = null;\r\n\r\n  protected cachedProgramLevelInternalName: string | null = null;\r\n  protected cachedFileLevelInternalName: string | null = null;\r\n\r\n  /** Gets the mangled program-level internal name of this declaration. */\r\n  get programLevelInternalName(): string {\r\n    if (!this.cachedProgramLevelInternalName) {\r\n      this.cachedProgramLevelInternalName = mangleInternalName(this, true);\r\n    }\r\n    return this.cachedProgramLevelInternalName;\r\n  }\r\n\r\n  /** Gets the mangled file-level internal name of this declaration. */\r\n  get fileLevelInternalName(): string {\r\n    if (!this.cachedFileLevelInternalName) {\r\n      this.cachedFileLevelInternalName = mangleInternalName(this, false);\r\n    }\r\n    return this.cachedFileLevelInternalName;\r\n  }\r\n\r\n  /** Tests if this is a top-level declaration within its source file. */\r\n  get isTopLevel(): bool {\r\n    var parent = this.parent;\r\n    if (!parent) {\r\n      return false;\r\n    }\r\n    if (parent.kind == NodeKind.VARIABLE && !(parent = parent.parent)) {\r\n      return false;\r\n    }\r\n    return parent.kind == NodeKind.SOURCE;\r\n  }\r\n\r\n  /** Tests if this declaration is a top-level export within its source file. */\r\n  get isTopLevelExport(): bool {\r\n    var parent = this.parent;\r\n    if (!parent || (parent.kind == NodeKind.VARIABLE && !(parent = parent.parent))) {\r\n      return false;\r\n    }\r\n    if (parent.kind == NodeKind.NAMESPACEDECLARATION) {\r\n      return (\r\n        hasModifier(ModifierKind.EXPORT, this.modifiers) &&\r\n        (<NamespaceDeclaration>parent).isTopLevelExport\r\n      );\r\n    }\r\n    if (parent.kind == NodeKind.CLASSDECLARATION) {\r\n      return (\r\n        hasModifier(ModifierKind.STATIC, this.modifiers) &&\r\n        (<ClassDeclaration>parent).isTopLevelExport\r\n      );\r\n    }\r\n    return (\r\n      parent.kind == NodeKind.SOURCE &&\r\n      hasModifier(ModifierKind.EXPORT, this.modifiers)\r\n    );\r\n  }\r\n\r\n  /** Tests if this declaration needs an explicit export. */\r\n  needsExplicitExport(member: ExportMember): bool {\r\n    // This is necessary because module-level exports are automatically created\r\n    // for top level declarations of all sorts. This function essentially tests\r\n    // that there isn't a otherwise duplicate top-level export already.\r\n    return (\r\n      member.name.text != member.externalName.text || // if aliased\r\n      this.range.source != member.range.source ||     // if a re-export\r\n      !this.isTopLevelExport                          // if not top-level\r\n    );\r\n  }\r\n}\r\n\r\n/** Base class of all variable-like declaration statements. */\r\nexport abstract class VariableLikeDeclarationStatement extends DeclarationStatement {\r\n\r\n  /** Variable type. */\r\n  type: TypeNode | null;\r\n  /** Variable initializer. */\r\n  initializer: Expression | null;\r\n}\r\n\r\n/** Represents a block statement. */\r\nexport class BlockStatement extends Statement {\r\n  kind = NodeKind.BLOCK;\r\n\r\n  /** Contained statements. */\r\n  statements: Statement[];\r\n}\r\n\r\n/** Represents a `break` statement. */\r\nexport class BreakStatement extends Statement {\r\n  kind = NodeKind.BREAK;\r\n\r\n  /** Target label, if applicable. */\r\n  label: IdentifierExpression | null;\r\n}\r\n\r\n/** Represents a `class` declaration. */\r\nexport class ClassDeclaration extends DeclarationStatement {\r\n  kind = NodeKind.CLASSDECLARATION;\r\n\r\n  /** Accepted type parameters. */\r\n  typeParameters: TypeParameter[];\r\n  /** Base class type being extended. */\r\n  extendsType: TypeNode | null;\r\n  /** Interface types being implemented. */\r\n  implementsTypes: TypeNode[];\r\n  /** Class member declarations. */\r\n  members: DeclarationStatement[];\r\n}\r\n\r\n/** Represents a `continue` statement. */\r\nexport class ContinueStatement extends Statement {\r\n  kind = NodeKind.CONTINUE;\r\n\r\n  /** Target label, if applicable. */\r\n  label: IdentifierExpression | null;\r\n}\r\n\r\n/** Built-in decorator kinds. */\r\nexport const enum DecoratorKind {\r\n  CUSTOM,\r\n  GLOBAL,\r\n  OPERATOR,\r\n  UNMANAGED,\r\n  OFFSET\r\n}\r\n\r\n/** Depresents a decorator. */\r\nexport class Decorator extends Statement {\r\n  kind = NodeKind.DECORATOR;\r\n\r\n  /** Name expression. */\r\n  name: Expression;\r\n  /** Argument expressions. */\r\n  arguments: Expression[] | null;\r\n  /** Built-in kind, if applicable. */\r\n  decoratorKind: DecoratorKind;\r\n}\r\n\r\n/** Represents a `do` statement. */\r\nexport class DoStatement extends Statement {\r\n  kind = NodeKind.DO;\r\n\r\n  /** Statement being looped over. */\r\n  statement: Statement;\r\n  /** Condition when to repeat. */\r\n  condition: Expression;\r\n}\r\n\r\n/** Represents an empty statement, i.e., a semicolon terminating nothing. */\r\nexport class EmptyStatement extends Statement {\r\n  kind = NodeKind.EMPTY;\r\n}\r\n\r\n/** Represents an `enum` declaration. */\r\nexport class EnumDeclaration extends DeclarationStatement {\r\n  kind = NodeKind.ENUMDECLARATION;\r\n\r\n  /** Enum value declarations. */\r\n  values: EnumValueDeclaration[];\r\n}\r\n\r\n/** Represents a value of an `enum` declaration. */\r\nexport class EnumValueDeclaration extends DeclarationStatement {\r\n  kind = NodeKind.ENUMVALUEDECLARATION;\r\n  modifiers = null;\r\n  // name is inherited\r\n\r\n  /** Value expression. */\r\n  value: Expression | null;\r\n}\r\n\r\n/** Represents an `export import` statement of an interface. */\r\nexport class ExportImportStatement extends Node {\r\n  kind = NodeKind.EXPORTIMPORT;\r\n\r\n  /** Identifier being imported. */\r\n  name: IdentifierExpression;\r\n  /** Identifier being exported. */\r\n  externalName: IdentifierExpression;\r\n}\r\n\r\n/** Represents a member of an `export` statement. */\r\nexport class ExportMember extends Node {\r\n  kind = NodeKind.EXPORTMEMBER;\r\n\r\n  /** Identifier being exported. */\r\n  name: IdentifierExpression;\r\n  /** Identifier seen when imported again. */\r\n  externalName: IdentifierExpression;\r\n}\r\n\r\n/** Represents an `export` statement. */\r\nexport class ExportStatement extends Statement {\r\n  kind = NodeKind.EXPORT;\r\n\r\n  /** Array of modifiers. */\r\n  modifiers: Modifier[] | null;\r\n  /** Array of members. */\r\n  members: ExportMember[];\r\n  /** Path being exported from, if applicable. */\r\n  path: StringLiteralExpression | null;\r\n  /** Normalized path, if `path` is set. */\r\n  normalizedPath: string | null;\r\n  /** Mangled internal path being referenced, if `path` is set. */\r\n  internalPath: string | null;\r\n}\r\n\r\n/** Represents an expression that is used as a statement. */\r\nexport class ExpressionStatement extends Statement {\r\n  kind = NodeKind.EXPRESSION;\r\n\r\n  /** Expression being used as a statement.*/\r\n  expression: Expression;\r\n}\r\n\r\n/** Represents a field declaration within a `class`. */\r\nexport class FieldDeclaration extends VariableLikeDeclarationStatement {\r\n  kind = NodeKind.FIELDDECLARATION;\r\n}\r\n\r\n/** Represents a `for` statement. */\r\nexport class ForStatement extends Statement {\r\n  kind = NodeKind.FOR;\r\n\r\n  /**\r\n   * Initializer statement, if present.\r\n   * Either a {@link VariableStatement} or {@link ExpressionStatement}.\r\n   */\r\n  initializer: Statement | null;\r\n  /** Condition expression, if present. */\r\n  condition: Expression | null;\r\n  /** Incrementor expression, if present. */\r\n  incrementor: Expression | null;\r\n  /** Statement being looped over. */\r\n  statement: Statement;\r\n}\r\n\r\n/** Represents a `function` declaration. */\r\nexport class FunctionDeclaration extends DeclarationStatement {\r\n  kind = NodeKind.FUNCTIONDECLARATION;\r\n\r\n  /** Accepted type parameters. */\r\n  typeParameters: TypeParameter[] | null;\r\n  /** Accepted parameters. */\r\n  parameters: Parameter[];\r\n  /** Return type. */\r\n  returnType: TypeNode | null;\r\n  /** Body statement. Usually a block. */\r\n  body: Statement | null;\r\n\r\n  get isGeneric(): bool {\r\n    return this.typeParameters != null && this.typeParameters.length > 0;\r\n  }\r\n}\r\n\r\n/** Represents an `if` statement. */\r\nexport class IfStatement extends Statement {\r\n  kind = NodeKind.IF;\r\n\r\n  /** Condition. */\r\n  condition: Expression;\r\n  /** Statement executed when condition is `true`. */\r\n  ifTrue: Statement;\r\n  /** Statement executed when condition is `false`. */\r\n  ifFalse: Statement | null;\r\n}\r\n\r\n/** Represents an `import` declaration part of an {@link ImportStatement}. */\r\nexport class ImportDeclaration extends DeclarationStatement {\r\n  kind = NodeKind.IMPORTDECLARATION;\r\n  modifiers = null;\r\n\r\n  /** Identifier being imported. */\r\n  externalName: IdentifierExpression;\r\n}\r\n\r\n/** Represents an `import` statement. */\r\nexport class ImportStatement extends Statement {\r\n  kind = NodeKind.IMPORT;\r\n\r\n  /** Array of member declarations or `null` if an asterisk import. */\r\n  declarations: ImportDeclaration[] | null;\r\n  /** Name of the local namespace, if an asterisk import. */\r\n  namespaceName: IdentifierExpression | null;\r\n  /** Path being imported from. */\r\n  path: StringLiteralExpression;\r\n  /** Normalized path. */\r\n  normalizedPath: string;\r\n  /** Mangled internal path being referenced. */\r\n  internalPath: string;\r\n}\r\n\r\n/** Represents an `interfarce` declaration. */\r\nexport class InterfaceDeclaration extends ClassDeclaration {\r\n  kind = NodeKind.INTERFACEDECLARATION;\r\n}\r\n\r\n/** Represents a method declaration within a `class`. */\r\nexport class MethodDeclaration extends FunctionDeclaration {\r\n  kind = NodeKind.METHODDECLARATION;\r\n}\r\n\r\n/** Represents a `namespace` declaration. */\r\nexport class NamespaceDeclaration extends DeclarationStatement {\r\n  kind = NodeKind.NAMESPACEDECLARATION;\r\n\r\n  /** Array of namespace members. */\r\n  members: Statement[];\r\n}\r\n\r\n/** Represents the kind of a parameter. */\r\nexport enum ParameterKind {\r\n  /** No specific flags. */\r\n  DEFAULT,\r\n  /** Is an optional parameter. */\r\n  OPTIONAL,\r\n  /** Is a rest parameter. */\r\n  REST\r\n}\r\n\r\n/** Represents a function parameter. */\r\nexport class Parameter extends Node {\r\n  kind = NodeKind.PARAMETER;\r\n\r\n  /** Parameter name. */\r\n  name: IdentifierExpression;\r\n  /** Parameter type. */\r\n  type: TypeNode | null;\r\n  /** Parameter kind. */\r\n  parameterKind: ParameterKind;\r\n  /** Initializer expression, if present. */\r\n  initializer: Expression | null;\r\n}\r\n\r\n/** Represents a single modifier. */\r\nexport class Modifier extends Node {\r\n  kind = NodeKind.MODIFIER;\r\n\r\n  /** Specific modifier kind. */\r\n  modifierKind: ModifierKind;\r\n}\r\n\r\n/** Represents a `return` statement. */\r\nexport class ReturnStatement extends Statement {\r\n  kind = NodeKind.RETURN;\r\n\r\n  /** Value expression being returned, if present. */\r\n  value: Expression | null;\r\n}\r\n\r\n/** Represents a single `case` within a `switch` statement. */\r\nexport class SwitchCase extends Node {\r\n  kind = NodeKind.SWITCHCASE;\r\n\r\n  /** Label expression. `null` indicates the default case. */\r\n  label: Expression | null;\r\n  /** Contained statements. */\r\n  statements: Statement[];\r\n}\r\n\r\n/** Represents a `switch` statement. */\r\nexport class SwitchStatement extends Statement {\r\n  kind = NodeKind.SWITCH;\r\n\r\n  /** Condition expression. */\r\n  condition: Expression;\r\n  /** Contained cases. */\r\n  cases: SwitchCase[];\r\n}\r\n\r\n/** Represents a `throw` statement. */\r\nexport class ThrowStatement extends Statement {\r\n  kind = NodeKind.THROW;\r\n\r\n  /** Value expression being thrown. */\r\n  value: Expression;\r\n}\r\n\r\n/** Represents a `try` statement. */\r\nexport class TryStatement extends Statement {\r\n  kind = NodeKind.TRY;\r\n\r\n  /** Contained statements. */\r\n  statements: Statement[];\r\n  /** Exception variable name, if a `catch` clause is present. */\r\n  catchVariable: IdentifierExpression | null;\r\n  /** Statements being executed on catch, if a `catch` clause is present. */\r\n  catchStatements: Statement[] | null;\r\n  /** Statements being executed afterwards, if a `finally` clause is present. */\r\n  finallyStatements: Statement[] | null;\r\n}\r\n\r\n/** Represents a `type` declaration. */\r\nexport class TypeDeclaration extends DeclarationStatement {\r\n  kind = NodeKind.TYPEDECLARATION;\r\n\r\n  /** Type being aliased. */\r\n  alias: TypeNode;\r\n}\r\n\r\n/** Represents a variable declaration part of a {@link VariableStatement}. */\r\nexport class VariableDeclaration extends VariableLikeDeclarationStatement {\r\n  kind = NodeKind.VARIABLEDECLARATION;\r\n\r\n  /** Array of modifiers. */\r\n  modifiers: Modifier[] | null;\r\n}\r\n\r\n/** Represents a variable statement wrapping {@link VariableDeclaration}s. */\r\nexport class VariableStatement extends Statement {\r\n  kind = NodeKind.VARIABLE;\r\n\r\n  /** Array of modifiers. */\r\n  modifiers: Modifier[] | null;\r\n  /** Array of decorators. */\r\n  decorators: Decorator[] | null;\r\n  /** Array of member declarations. */\r\n  declarations: VariableDeclaration[];\r\n}\r\n\r\n/** Represents a `while` statement. */\r\nexport class WhileStatement extends Statement {\r\n  kind = NodeKind.WHILE;\r\n\r\n  /** Condition expression. */\r\n  condition: Expression;\r\n  /** Statement being looped over. */\r\n  statement: Statement;\r\n}\r\n\r\n/** Cached unused modifiers for reuse. */\r\nvar reusableModifiers: Modifier[] | null = null;\r\n\r\nexport function setReusableModifiers(modifiers: Modifier[]): void {\r\n  reusableModifiers = modifiers;\r\n}\r\n\r\n/** Creates a new modifiers array. */\r\nexport function createModifiers(): Modifier[] {\r\n  var ret: Modifier[];\r\n  if (reusableModifiers != null) {\r\n    ret = reusableModifiers;\r\n    reusableModifiers = null;\r\n  } else {\r\n    ret = [];\r\n  }\r\n  ret.length = 0;\r\n  return ret;\r\n}\r\n\r\n// Utility\r\n\r\n/** Adds a modifier to a set of modifiers. Creates a new set if `null`. */\r\nexport function addModifier(modifier: Modifier, modifiers: Modifier[] | null): Modifier[] {\r\n  if (modifiers == null) modifiers = createModifiers();\r\n  modifiers.push(modifier);\r\n  return modifiers;\r\n}\r\n\r\n/** Gets a specific modifier from the specified set of modifiers. */\r\nexport function getModifier(kind: ModifierKind, modifiers: Modifier[] | null): Modifier | null {\r\n  if (modifiers) {\r\n    for (var i = 0, k = modifiers.length; i < k; ++i) {\r\n      if (modifiers[i].modifierKind == kind) {\r\n        return modifiers[i];\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/** Tests whether a modifier exists in the specified set of modifiers. */\r\nexport function hasModifier(kind: ModifierKind, modifiers: Modifier[] | null): bool {\r\n  return getModifier(kind, modifiers) != null;\r\n}\r\n\r\n/** Gets the first decorator by name within at set of decorators, if present. */\r\nexport function getFirstDecorator(name: string, decorators: Decorator[] | null): Decorator | null {\r\n  if (decorators) {\r\n    for (var i = 0, k = decorators.length; i < k; ++i) {\r\n      var decorator = decorators[i];\r\n      var expression = decorator.name;\r\n      if (expression.kind == NodeKind.IDENTIFIER && (<IdentifierExpression>expression).text == name) {\r\n        return decorator;\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/** Tests if a specific decorator is present within the specified decorators. */\r\nexport function hasDecorator(name: string, decorators: Decorator[] | null): bool {\r\n  return getFirstDecorator(name, decorators) != null;\r\n}\r\n\r\n/** Mangles a declaration's name to an internal name. */\r\nexport function mangleInternalName(declaration: DeclarationStatement, asGlobal: bool = false): string {\r\n  var name = declaration.name.text;\r\n  var parent = declaration.parent;\r\n  if (!parent) return name;\r\n  if (\r\n    declaration.kind == NodeKind.VARIABLEDECLARATION &&\r\n    parent.kind == NodeKind.VARIABLE\r\n  ) { // skip over\r\n    if (!(parent = parent.parent)) return name;\r\n  }\r\n  if (parent.kind == NodeKind.CLASSDECLARATION) {\r\n    return mangleInternalName(<ClassDeclaration>parent, asGlobal) + (\r\n      hasModifier(ModifierKind.STATIC, declaration.modifiers)\r\n        ? STATIC_DELIMITER\r\n        : INSTANCE_DELIMITER\r\n    ) + name;\r\n  }\r\n  if (\r\n    parent.kind == NodeKind.NAMESPACEDECLARATION ||\r\n    parent.kind == NodeKind.ENUMDECLARATION\r\n  ) {\r\n    return mangleInternalName(<DeclarationStatement>parent, asGlobal) +\r\n           STATIC_DELIMITER + name;\r\n  }\r\n  return asGlobal\r\n    ? name\r\n    : declaration.range.source.internalPath + PATH_DELIMITER + name;\r\n}\r\n\r\n/** Mangles an external to an internal path. */\r\nexport function mangleInternalPath(path: string): string {\r\n  if (path.endsWith(\".ts\")) path = path.substring(0, path.length - 3);\r\n  return path;\r\n}\r\n\r\n// Helpers\r\n\r\nfunction setParent(nodes: Node[], parent: Node): void {\r\n  for (var i = 0, k = nodes.length; i < k; ++i) {\r\n    nodes[i].parent = parent;\r\n  }\r\n}\r\n\r\nfunction setParentOpt(nodes: (Node | null)[], parent: Node): void {\r\n  for (var i = 0, k = nodes.length; i < k; ++i) {\r\n    var node = nodes[i];\r\n    if (node) node.parent = parent;\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/ast.ts","/*\r\n\r\n This is a modified version of TypeScript's scanner that doesn't perform as much bookkeeping, simply\r\n skips over trivia and provides a more general mark/reset mechanism for the parser to utilize on\r\n ambiguous tokens.\r\n\r\n next()                 advances the token\r\n peek()                 peeks for the next token\r\n skip(token)            skips over a token if possible\r\n mark()                 marks at current token\r\n reset()                resets to marked state\r\n range()                gets the range of the current token\r\n\r\n readFloat()            on FLOATLITERAL\r\n readIdentifier()       on IDENTIFIER\r\n readInteger()          on INTEGERLITERAL\r\n readString()           on STRINGLITERAL\r\n\r\n*/\r\n\r\nimport {\r\n  DiagnosticCode,\r\n  DiagnosticMessage,\r\n  DiagnosticEmitter\r\n} from \"./diagnostics\";\r\n\r\nimport {\r\n  Source\r\n} from \"./ast\";\r\n\r\nimport {\r\n  CharCode,\r\n  isLineBreak,\r\n  isWhiteSpace,\r\n  isIdentifierStart,\r\n  isIdentifierPart,\r\n  isDecimalDigit,\r\n  isOctalDigit,\r\n  isKeywordCharacter\r\n} from \"./util/charcode\";\r\n\r\n/** Named token types. */\r\nexport enum Token {\r\n\r\n  // keywords\r\n  // discarded: ANY, BOOLEAN, NEVER, NUMBER, STRING, SYMBOL, UNDEFINED, LESSTHAN_SLASH\r\n\r\n  ABSTRACT,\r\n  AS,\r\n  ASYNC,\r\n  AWAIT,        // ES2017\r\n  BREAK,        // ES2017\r\n  CASE,         // ES2017\r\n  CATCH,        // ES2017\r\n  CLASS,        // ES2017\r\n  CONST,        // ES2017\r\n  CONTINUE,     // ES2017\r\n  CONSTRUCTOR,\r\n  DEBUGGER,     // ES2017\r\n  DECLARE,\r\n  DEFAULT,      // ES2017\r\n  DELETE,       // ES2017\r\n  DO,           // ES2017\r\n  ELSE,         // ES2017\r\n  ENUM,         // ES2017 future\r\n  EXPORT,       // ES2017\r\n  EXTENDS,      // ES2017\r\n  FALSE,        // ES\r\n  FINALLY,      // ES2017\r\n  FOR,          // ES2017\r\n  FROM,         // AS possible identifier\r\n  FUNCTION,     // ES2017\r\n  GET,\r\n  IF,           // ES2017\r\n  IMPLEMENTS,   // ES2017 non-lexical\r\n  IMPORT,       // ES2017\r\n  IN,           // ES2017\r\n  INSTANCEOF,   // ES2017\r\n  INTERFACE,    // ES2017 non-lexical\r\n  IS,\r\n  KEYOF,\r\n  LET,          // ES2017 non-lexical\r\n  MODULE,       // AS possible identifier\r\n  NAMESPACE,    // AS possible identifier\r\n  NEW,          // ES2017\r\n  NULL,         // ES\r\n  OF,\r\n  PACKAGE,      // ES2017 non-lexical\r\n  PRIVATE,      // ES2017 non-lexical\r\n  PROTECTED,    // ES2017 non-lexical\r\n  PUBLIC,       // ES2017 non-lexical\r\n  READONLY,\r\n  RETURN,       // ES2017\r\n  SET,\r\n  STATIC,       // ES2017 non-lexical\r\n  SUPER,        // ES2017\r\n  SWITCH,       // ES2017\r\n  THIS,         // ES2017\r\n  THROW,        // ES2017\r\n  TRUE,         // ES\r\n  TRY,          // ES2017\r\n  TYPE,         // AS possible identifier\r\n  TYPEOF,       // ES2017\r\n  VAR,          // ES2017\r\n  VOID,         // ES2017\r\n  WHILE,        // ES2017\r\n  WITH,         // ES2017\r\n  YIELD,        // ES2017\r\n\r\n  // punctuation\r\n\r\n  OPENBRACE,\r\n  CLOSEBRACE,\r\n  OPENPAREN,\r\n  CLOSEPAREN,\r\n  OPENBRACKET,\r\n  CLOSEBRACKET,\r\n  DOT,\r\n  DOT_DOT_DOT,\r\n  SEMICOLON,\r\n  COMMA,\r\n  LESSTHAN,\r\n  GREATERTHAN,\r\n  LESSTHAN_EQUALS,\r\n  GREATERTHAN_EQUALS,\r\n  EQUALS_EQUALS,\r\n  EXCLAMATION_EQUALS,\r\n  EQUALS_EQUALS_EQUALS,\r\n  EXCLAMATION_EQUALS_EQUALS,\r\n  EQUALS_GREATERTHAN,\r\n  PLUS,\r\n  MINUS,\r\n  ASTERISK_ASTERISK,\r\n  ASTERISK,\r\n  SLASH,\r\n  PERCENT,\r\n  PLUS_PLUS,\r\n  MINUS_MINUS,\r\n  LESSTHAN_LESSTHAN,\r\n  GREATERTHAN_GREATERTHAN,\r\n  GREATERTHAN_GREATERTHAN_GREATERTHAN,\r\n  AMPERSAND,\r\n  BAR,\r\n  CARET,\r\n  EXCLAMATION,\r\n  TILDE,\r\n  AMPERSAND_AMPERSAND,\r\n  BAR_BAR,\r\n  QUESTION,\r\n  COLON,\r\n  EQUALS,\r\n  PLUS_EQUALS,\r\n  MINUS_EQUALS,\r\n  ASTERISK_EQUALS,\r\n  ASTERISK_ASTERISK_EQUALS,\r\n  SLASH_EQUALS,\r\n  PERCENT_EQUALS,\r\n  LESSTHAN_LESSTHAN_EQUALS,\r\n  GREATERTHAN_GREATERTHAN_EQUALS,\r\n  GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS,\r\n  AMPERSAND_EQUALS,\r\n  BAR_EQUALS,\r\n  CARET_EQUALS,\r\n  AT,\r\n\r\n  // literals\r\n\r\n  IDENTIFIER,\r\n  STRINGLITERAL,\r\n  INTEGERLITERAL,\r\n  FLOATLITERAL,\r\n\r\n  // meta\r\n\r\n  INVALID,\r\n  ENDOFFILE\r\n}\r\n\r\nexport namespace Token {\r\n\r\n  export function fromKeyword(text: string): Token {\r\n    switch (text) {\r\n      case \"abstract\": return Token.ABSTRACT;\r\n      case \"as\": return Token.AS;\r\n      case \"async\": return Token.ASYNC;\r\n      case \"await\": return Token.AWAIT;\r\n      case \"break\": return Token.BREAK;\r\n      case \"case\": return Token.CASE;\r\n      case \"catch\": return Token.CATCH;\r\n      case \"class\": return Token.CLASS;\r\n      case \"continue\": return Token.CONTINUE;\r\n      case \"const\": return Token.CONST;\r\n      case \"constructor\": return Token.CONSTRUCTOR;\r\n      case \"debugger\": return Token.DEBUGGER;\r\n      case \"declare\": return Token.DECLARE;\r\n      case \"default\": return Token.DEFAULT;\r\n      case \"delete\": return Token.DELETE;\r\n      case \"do\": return Token.DO;\r\n      case \"else\": return Token.ELSE;\r\n      case \"enum\": return Token.ENUM;\r\n      case \"export\": return Token.EXPORT;\r\n      case \"extends\": return Token.EXTENDS;\r\n      case \"false\": return Token.FALSE;\r\n      case \"finally\": return Token.FINALLY;\r\n      case \"for\": return Token.FOR;\r\n      case \"from\": return Token.FROM;\r\n      case \"function\": return Token.FUNCTION;\r\n      case \"get\": return Token.GET;\r\n      case \"if\": return Token.IF;\r\n      case \"implements\": return Token.IMPLEMENTS;\r\n      case \"import\": return Token.IMPORT;\r\n      case \"in\": return Token.IN;\r\n      case \"instanceof\": return Token.INSTANCEOF;\r\n      case \"interface\": return Token.INTERFACE;\r\n      case \"is\": return Token.IS;\r\n      case \"keyof\": return Token.KEYOF;\r\n      case \"let\": return Token.LET;\r\n      case \"module\": return Token.MODULE;\r\n      case \"namespace\": return Token.NAMESPACE;\r\n      case \"new\": return Token.NEW;\r\n      case \"null\": return Token.NULL;\r\n      case \"of\": return Token.OF;\r\n      case \"package\": return Token.PACKAGE;\r\n      case \"private\": return Token.PRIVATE;\r\n      case \"protected\": return Token.PROTECTED;\r\n      case \"public\": return Token.PUBLIC;\r\n      case \"readonly\": return Token.READONLY;\r\n      case \"return\": return Token.RETURN;\r\n      case \"set\": return Token.SET;\r\n      case \"static\": return Token.STATIC;\r\n      case \"super\": return Token.SUPER;\r\n      case \"switch\": return Token.SWITCH;\r\n      case \"this\": return Token.THIS;\r\n      case \"throw\": return Token.THROW;\r\n      case \"true\": return Token.TRUE;\r\n      case \"try\": return Token.TRY;\r\n      case \"type\": return Token.TYPE;\r\n      case \"typeof\": return Token.TYPEOF;\r\n      case \"var\": return Token.VAR;\r\n      case \"void\": return Token.VOID;\r\n      case \"while\": return Token.WHILE;\r\n      case \"with\": return Token.WITH;\r\n      case \"yield\": return Token.YIELD;\r\n      default: return Token.INVALID;\r\n    }\r\n  }\r\n\r\n  export function isAlsoIdentifier(token: Token): bool {\r\n    switch (token) {\r\n      case Token.ABSTRACT:\r\n      case Token.AS:\r\n      case Token.CONSTRUCTOR:\r\n      case Token.DECLARE:\r\n      case Token.DELETE:\r\n      case Token.FROM:\r\n      case Token.GET:\r\n      case Token.IS:\r\n      case Token.KEYOF:\r\n      case Token.MODULE:\r\n      case Token.NAMESPACE:\r\n      case Token.READONLY:\r\n      case Token.SET:\r\n      case Token.TYPE:\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  export function operatorToString(token: Token): string {\r\n    switch (token) {\r\n      case Token.DELETE: return \"delete\";\r\n      case Token.IN: return \"in\";\r\n      case Token.INSTANCEOF: return \"instanceof\";\r\n      case Token.NEW: return \"new\";\r\n      case Token.TYPEOF: return \"typeof\";\r\n      case Token.VOID: return \"void\";\r\n      case Token.YIELD: return \"yield\";\r\n      case Token.DOT_DOT_DOT: return \"...\";\r\n      case Token.COMMA: return \",\";\r\n      case Token.LESSTHAN: return \"<\";\r\n      case Token.GREATERTHAN: return \">\";\r\n      case Token.LESSTHAN_EQUALS: return \"<=\";\r\n      case Token.GREATERTHAN_EQUALS: return \">=\";\r\n      case Token.EQUALS_EQUALS: return \"==\";\r\n      case Token.EXCLAMATION_EQUALS: return \"!=\";\r\n      case Token.EQUALS_EQUALS_EQUALS: return \"===\";\r\n      case Token.EXCLAMATION_EQUALS_EQUALS: return \"!==\";\r\n      case Token.PLUS: return \"+\";\r\n      case Token.MINUS: return \"-\";\r\n      case Token.ASTERISK_ASTERISK: return \"**\";\r\n      case Token.ASTERISK: return \"*\";\r\n      case Token.SLASH: return \"/\";\r\n      case Token.PERCENT: return \"%\";\r\n      case Token.PLUS_PLUS: return \"++\";\r\n      case Token.MINUS_MINUS: return \"--\";\r\n      case Token.LESSTHAN_LESSTHAN: return \"<<\";\r\n      case Token.GREATERTHAN_GREATERTHAN: return \">>\";\r\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN: return \">>>\";\r\n      case Token.AMPERSAND: return \"&\";\r\n      case Token.BAR: return \"|\";\r\n      case Token.CARET: return \"^\";\r\n      case Token.EXCLAMATION: return \"!\";\r\n      case Token.TILDE: return \"~\";\r\n      case Token.AMPERSAND_AMPERSAND: return \"&&\";\r\n      case Token.BAR_BAR: return \"||\";\r\n      case Token.EQUALS: return \"=\";\r\n      case Token.PLUS_EQUALS: return \"+=\";\r\n      case Token.MINUS_EQUALS: return \"-=\";\r\n      case Token.ASTERISK_EQUALS: return \"*=\";\r\n      case Token.ASTERISK_ASTERISK_EQUALS: return \"**=\";\r\n      case Token.SLASH_EQUALS: return \"/=\";\r\n      case Token.PERCENT_EQUALS: return \"%=\";\r\n      case Token.LESSTHAN_LESSTHAN_EQUALS: return \"<<=\";\r\n      case Token.GREATERTHAN_GREATERTHAN_EQUALS: return \">>=\";\r\n      case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS: return \">>>=\";\r\n      case Token.AMPERSAND_EQUALS: return \"&=\";\r\n      case Token.BAR_EQUALS: return \"|=\";\r\n      case Token.CARET_EQUALS: return \"^=\";\r\n      default: assert(false); return \"\";\r\n    }\r\n  }\r\n}\r\n\r\nexport class Range {\r\n\r\n  source: Source;\r\n  start: i32;\r\n  end: i32;\r\n\r\n  // TODO: set these while tokenizing\r\n  // line: i32;\r\n  // column: i32;\r\n\r\n  constructor(source: Source, start: i32, end: i32) {\r\n    this.source = source;\r\n    this.start = start;\r\n    this.end = end;\r\n  }\r\n\r\n  static join(a: Range, b: Range): Range {\r\n    if (a.source != b.source) throw new Error(\"source mismatch\");\r\n    return new Range(a.source,\r\n      a.start < b.start ? a.start : b.start,\r\n      a.end > b.end ? a.end : b.end\r\n    );\r\n  }\r\n\r\n  get atStart(): Range {\r\n    return new Range(this.source, this.start, this.start);\r\n  }\r\n  get atEnd(): Range {\r\n    return new Range(this.source, this.end, this.end);\r\n  }\r\n\r\n  get line(): i32 {\r\n    var text = this.source.text;\r\n    var pos = this.start;\r\n    var line = 1;\r\n    while (pos-- > 0) {\r\n      if (text.charCodeAt(pos) == CharCode.LINEFEED) {\r\n        line++;\r\n      }\r\n    }\r\n    return line;\r\n  }\r\n\r\n  get column(): i32 {\r\n    var text = this.source.text;\r\n    var pos = this.start;\r\n    var column = 0;\r\n    while (pos-- > 0) {\r\n      if (text.charCodeAt(pos) == CharCode.LINEFEED) break;\r\n      column++;\r\n    }\r\n    return column;\r\n  }\r\n\r\n  toString(): string {\r\n    return this.source.text.substring(this.start, this.end);\r\n  }\r\n\r\n  debugInfoRef: usize = 0;\r\n}\r\n\r\ndeclare function parseFloat(str: string): f64;\r\n\r\nexport class Tokenizer extends DiagnosticEmitter {\r\n\r\n  source: Source;\r\n  end: i32 = 0;\r\n\r\n  pos: i32 = 0;\r\n  token: Token = -1;\r\n  tokenPos: i32 = 0;\r\n\r\n  markedPos: i32 = 0;\r\n  markedToken: Token = -1;\r\n  markedTokenPos: i32 = 0;\r\n\r\n  nextToken: Token = -1;\r\n  nextTokenOnNewLine: bool = false;\r\n\r\n  constructor(source: Source, diagnostics: DiagnosticMessage[] | null = null) {\r\n    super(diagnostics);\r\n    this.source = source;\r\n    this.pos = 0;\r\n    this.end = source.text.length;\r\n    this.diagnostics = diagnostics ? diagnostics : new Array();\r\n\r\n    var text = source.text;\r\n\r\n    // skip bom\r\n    if (\r\n      this.pos < this.end &&\r\n      text.charCodeAt(this.pos) == CharCode.BYTEORDERMARK\r\n    ) {\r\n      ++this.pos;\r\n    }\r\n\r\n    // skip shebang\r\n    if (\r\n      this.pos + 1 < this.end &&\r\n      text.charCodeAt(this.pos) == CharCode.HASH &&\r\n      text.charCodeAt(this.pos + 1) == CharCode.EXCLAMATION\r\n    ) {\r\n      this.pos += 2;\r\n      while (\r\n        this.pos < this.end &&\r\n        text.charCodeAt(this.pos) != CharCode.LINEFEED\r\n      ) {\r\n        ++this.pos;\r\n      }\r\n      // 'next' now starts at lf or eof\r\n    }\r\n  }\r\n\r\n  next(preferIdentifier: bool = false): Token {\r\n    this.nextToken = -1;\r\n    return this.token = this.unsafeNext(preferIdentifier);\r\n  }\r\n\r\n  private unsafeNext(preferIdentifier: bool = false, maxTokenLength: i32 = i32.MAX_VALUE): Token {\r\n    var text = this.source.text;\r\n    while (this.pos < this.end) {\r\n      this.tokenPos = this.pos;\r\n      var c = text.charCodeAt(this.pos);\r\n      switch (c) {\r\n\r\n        case CharCode.CARRIAGERETURN:\r\n          if (\r\n            ++this.pos < this.end &&\r\n            text.charCodeAt(this.pos) == CharCode.LINEFEED\r\n          ) {\r\n            ++this.pos;\r\n          }\r\n          break;\r\n\r\n        case CharCode.LINEFEED:\r\n        case CharCode.TAB:\r\n        case CharCode.VERTICALTAB:\r\n        case CharCode.FORMFEED:\r\n        case CharCode.SPACE:\r\n          ++this.pos;\r\n          break;\r\n\r\n        case CharCode.EXCLAMATION:\r\n          ++this.pos;\r\n          if (\r\n            maxTokenLength > 1 && this.pos < this.end &&\r\n            text.charCodeAt(this.pos) == CharCode.EQUALS\r\n          ) {\r\n            ++this.pos;\r\n            if (\r\n              maxTokenLength > 2 && this.pos < this.end &&\r\n              text.charCodeAt(this.pos) == CharCode.EQUALS\r\n            ) {\r\n              ++this.pos;\r\n              return Token.EXCLAMATION_EQUALS_EQUALS;\r\n            }\r\n            return Token.EXCLAMATION_EQUALS;\r\n          }\r\n          return Token.EXCLAMATION;\r\n\r\n        case CharCode.DOUBLEQUOTE:\r\n        case CharCode.SINGLEQUOTE:\r\n        case CharCode.BACKTICK: // TODO\r\n          return Token.STRINGLITERAL; // expects a call to readString\r\n\r\n        case CharCode.PERCENT:\r\n          ++this.pos;\r\n          if (\r\n            maxTokenLength > 1 && this.pos < this.end &&\r\n            text.charCodeAt(this.pos) == CharCode.EQUALS\r\n          ) {\r\n            ++this.pos;\r\n            return Token.PERCENT_EQUALS;\r\n          }\r\n          return Token.PERCENT;\r\n\r\n        case CharCode.AMPERSAND:\r\n          ++this.pos;\r\n          if (maxTokenLength > 1 && this.pos < this.end) {\r\n            if (text.charCodeAt(this.pos) == CharCode.AMPERSAND) {\r\n              ++this.pos;\r\n              return Token.AMPERSAND_AMPERSAND;\r\n            }\r\n            if (text.charCodeAt(this.pos) == CharCode.EQUALS) {\r\n              ++this.pos;\r\n              return Token.AMPERSAND_EQUALS;\r\n            }\r\n          }\r\n          return Token.AMPERSAND;\r\n\r\n        case CharCode.OPENPAREN:\r\n          ++this.pos;\r\n          return Token.OPENPAREN;\r\n\r\n        case CharCode.CLOSEPAREN:\r\n          ++this.pos;\r\n          return Token.CLOSEPAREN;\r\n\r\n        case CharCode.ASTERISK:\r\n          ++this.pos;\r\n          if (maxTokenLength > 1 && this.pos < this.end) {\r\n            if (text.charCodeAt(this.pos) == CharCode.EQUALS) {\r\n              ++this.pos;\r\n              return Token.ASTERISK_EQUALS;\r\n            }\r\n            if (text.charCodeAt(this.pos) == CharCode.ASTERISK) {\r\n              ++this.pos;\r\n              if (\r\n                maxTokenLength > 2 && this.pos < this.end &&\r\n                text.charCodeAt(this.pos) == CharCode.EQUALS\r\n              ) {\r\n                ++this.pos;\r\n                return Token.ASTERISK_ASTERISK_EQUALS;\r\n              }\r\n              return Token.ASTERISK_ASTERISK;\r\n            }\r\n          }\r\n          return Token.ASTERISK;\r\n\r\n        case CharCode.PLUS:\r\n          ++this.pos;\r\n          if (maxTokenLength > 1 && this.pos < this.end) {\r\n            if (text.charCodeAt(this.pos) == CharCode.PLUS) {\r\n              ++this.pos;\r\n              return Token.PLUS_PLUS;\r\n            }\r\n            if (text.charCodeAt(this.pos) == CharCode.EQUALS) {\r\n              ++this.pos;\r\n              return Token.PLUS_EQUALS;\r\n            }\r\n          }\r\n          return Token.PLUS;\r\n\r\n        case CharCode.COMMA:\r\n          ++this.pos;\r\n          return Token.COMMA;\r\n\r\n        case CharCode.MINUS:\r\n          ++this.pos;\r\n          if (maxTokenLength > 1 && this.pos < this.end) {\r\n            if (text.charCodeAt(this.pos) == CharCode.MINUS) {\r\n              ++this.pos;\r\n              return Token.MINUS_MINUS;\r\n            }\r\n            if (text.charCodeAt(this.pos) == CharCode.EQUALS) {\r\n              ++this.pos;\r\n              return Token.MINUS_EQUALS;\r\n            }\r\n          }\r\n          return Token.MINUS;\r\n\r\n        case CharCode.DOT:\r\n          ++this.pos;\r\n          if (maxTokenLength > 1 && this.pos < this.end) {\r\n            if (isDecimalDigit(text.charCodeAt(this.pos))) {\r\n              --this.pos;\r\n              return Token.FLOATLITERAL; // expects a call to readFloat\r\n            }\r\n            if (\r\n              maxTokenLength > 2 && this.pos + 1 < this.end &&\r\n              text.charCodeAt(this.pos) == CharCode.DOT &&\r\n              text.charCodeAt(this.pos + 1) == CharCode.DOT\r\n            ) {\r\n              this.pos += 2;\r\n              return Token.DOT_DOT_DOT;\r\n            }\r\n          }\r\n          return Token.DOT;\r\n\r\n        case CharCode.SLASH:\r\n          ++this.pos;\r\n          if (maxTokenLength > 1 && this.pos < this.end) {\r\n            if (text.charCodeAt(this.pos) == CharCode.SLASH) { // single-line\r\n              // TODO: triple-slash?\r\n              // if (\r\n              //   this.pos + 1 < this.end &&\r\n              //   text.charCodeAt(this.pos + 1) == CharCode.SLASH\r\n              // ) {\r\n              // }\r\n              while (++this.pos < this.end) {\r\n                if (isLineBreak(text.charCodeAt(this.pos))) break;\r\n              }\r\n              continue;\r\n            }\r\n            if (text.charCodeAt(this.pos) == CharCode.ASTERISK) { // multi-line\r\n              var closed = false;\r\n              while (++this.pos < this.end) {\r\n                c = text.charCodeAt(this.pos);\r\n                if (\r\n                  c == CharCode.ASTERISK &&\r\n                  this.pos + 1 < this.end &&\r\n                  text.charCodeAt(this.pos + 1) == CharCode.SLASH\r\n                ) {\r\n                  this.pos += 2;\r\n                  closed = true;\r\n                  break;\r\n                }\r\n              }\r\n              if (!closed) {\r\n                this.error(\r\n                  DiagnosticCode._0_expected,\r\n                  this.range(this.pos), \"*/\"\r\n                );\r\n              }\r\n              continue;\r\n            }\r\n            if (text.charCodeAt(this.pos) == CharCode.EQUALS) {\r\n              ++this.pos;\r\n              return Token.SLASH_EQUALS;\r\n            }\r\n          }\r\n          return Token.SLASH;\r\n\r\n        case CharCode._0:\r\n        case CharCode._1:\r\n        case CharCode._2:\r\n        case CharCode._3:\r\n        case CharCode._4:\r\n        case CharCode._5:\r\n        case CharCode._6:\r\n        case CharCode._7:\r\n        case CharCode._8:\r\n        case CharCode._9:\r\n          return this.testInteger()\r\n            ? Token.INTEGERLITERAL // expects a call to readInteger\r\n            : Token.FLOATLITERAL;  // expects a call to readFloat\r\n\r\n        case CharCode.COLON:\r\n          ++this.pos;\r\n          return Token.COLON;\r\n\r\n        case CharCode.SEMICOLON:\r\n          ++this.pos;\r\n          return Token.SEMICOLON;\r\n\r\n        case CharCode.LESSTHAN:\r\n          ++this.pos;\r\n          if (maxTokenLength > 1 && this.pos < this.end) {\r\n            if (text.charCodeAt(this.pos) == CharCode.LESSTHAN) {\r\n              ++this.pos;\r\n              if (\r\n                maxTokenLength > 2 &&\r\n                this.pos < this.end &&\r\n                text.charCodeAt(this.pos) == CharCode.EQUALS\r\n              ) {\r\n                ++this.pos;\r\n                return Token.LESSTHAN_LESSTHAN_EQUALS;\r\n              }\r\n              return Token.LESSTHAN_LESSTHAN;\r\n            }\r\n            if (text.charCodeAt(this.pos) == CharCode.EQUALS) {\r\n              ++this.pos;\r\n              return Token.LESSTHAN_EQUALS;\r\n            }\r\n          }\r\n          return Token.LESSTHAN;\r\n\r\n        case CharCode.EQUALS:\r\n          ++this.pos;\r\n          if (maxTokenLength > 1 && this.pos < this.end) {\r\n            if (text.charCodeAt(this.pos) == CharCode.EQUALS) {\r\n              ++this.pos;\r\n              if (\r\n                maxTokenLength > 2 &&\r\n                this.pos < this.end &&\r\n                text.charCodeAt(this.pos) == CharCode.EQUALS\r\n              ) {\r\n                ++this.pos;\r\n                return Token.EQUALS_EQUALS_EQUALS;\r\n              }\r\n              return Token.EQUALS_EQUALS;\r\n            }\r\n            if (text.charCodeAt(this.pos) == CharCode.GREATERTHAN) {\r\n              ++this.pos;\r\n              return Token.EQUALS_GREATERTHAN;\r\n            }\r\n          }\r\n          return Token.EQUALS;\r\n\r\n        case CharCode.GREATERTHAN:\r\n          ++this.pos;\r\n          if (maxTokenLength > 1 && this.pos < this.end) {\r\n            if (text.charCodeAt(this.pos) == CharCode.GREATERTHAN) {\r\n              ++this.pos;\r\n              if (maxTokenLength > 2 && this.pos < this.end) {\r\n                if (text.charCodeAt(this.pos) == CharCode.GREATERTHAN) {\r\n                  ++this.pos;\r\n                  if (\r\n                    maxTokenLength > 3 && this.pos < this.end &&\r\n                    text.charCodeAt(this.pos) == CharCode.EQUALS\r\n                  ) {\r\n                    ++this.pos;\r\n                    return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS;\r\n                  }\r\n                  return Token.GREATERTHAN_GREATERTHAN_GREATERTHAN;\r\n                }\r\n                if (text.charCodeAt(this.pos) == CharCode.EQUALS) {\r\n                  ++this.pos;\r\n                  return Token.GREATERTHAN_GREATERTHAN_EQUALS;\r\n                }\r\n              }\r\n              return Token.GREATERTHAN_GREATERTHAN;\r\n            }\r\n            if (text.charCodeAt(this.pos) == CharCode.EQUALS) {\r\n              ++this.pos;\r\n              return Token.GREATERTHAN_EQUALS;\r\n            }\r\n          }\r\n          return Token.GREATERTHAN;\r\n\r\n        case CharCode.QUESTION:\r\n          ++this.pos;\r\n          return Token.QUESTION;\r\n\r\n        case CharCode.OPENBRACKET:\r\n          ++this.pos;\r\n          return Token.OPENBRACKET;\r\n\r\n        case CharCode.CLOSEBRACKET:\r\n          ++this.pos;\r\n          return Token.CLOSEBRACKET;\r\n\r\n        case CharCode.CARET:\r\n          ++this.pos;\r\n          if (\r\n            maxTokenLength > 1 && this.pos < this.end &&\r\n            text.charCodeAt(this.pos) == CharCode.EQUALS\r\n          ) {\r\n            ++this.pos;\r\n            return Token.CARET_EQUALS;\r\n          }\r\n          return Token.CARET;\r\n\r\n        case CharCode.OPENBRACE:\r\n          ++this.pos;\r\n          return Token.OPENBRACE;\r\n\r\n        case CharCode.BAR:\r\n          ++this.pos;\r\n          if (maxTokenLength > 1 && this.pos < this.end) {\r\n            if (text.charCodeAt(this.pos) == CharCode.BAR) {\r\n              ++this.pos;\r\n              return Token.BAR_BAR;\r\n            }\r\n            if (text.charCodeAt(this.pos) == CharCode.EQUALS) {\r\n              ++this.pos;\r\n              return Token.BAR_EQUALS;\r\n            }\r\n          }\r\n          return Token.BAR;\r\n\r\n        case CharCode.CLOSEBRACE:\r\n          ++this.pos;\r\n          return Token.CLOSEBRACE;\r\n\r\n        case CharCode.TILDE:\r\n          ++this.pos;\r\n          return Token.TILDE;\r\n\r\n        case CharCode.AT:\r\n          ++this.pos;\r\n          return Token.AT;\r\n\r\n        default:\r\n          if (isIdentifierStart(c)) {\r\n            if (isKeywordCharacter(c)) {\r\n              var posBefore = this.pos;\r\n              while (\r\n                ++this.pos < this.end &&\r\n                isIdentifierPart(c = text.charCodeAt(this.pos))\r\n              ) {\r\n                if (!isKeywordCharacter(c)) {\r\n                  this.pos = posBefore;\r\n                  return Token.IDENTIFIER;\r\n                }\r\n              }\r\n              var keywordText = text.substring(posBefore, this.pos);\r\n              var keywordToken = Token.fromKeyword(keywordText);\r\n              if (\r\n                keywordToken != Token.INVALID &&\r\n                !(preferIdentifier && Token.isAlsoIdentifier(keywordToken))\r\n              ) {\r\n                return keywordToken;\r\n              }\r\n              this.pos = posBefore;\r\n            }\r\n            return Token.IDENTIFIER; // expects a call to readIdentifier\r\n          } else if (isWhiteSpace(c)) {\r\n            ++this.pos;\r\n            break;\r\n          }\r\n          this.error(\r\n            DiagnosticCode.Invalid_character,\r\n            this.range(this.pos, this.pos + 1)\r\n          );\r\n          ++this.pos;\r\n          return Token.INVALID;\r\n      }\r\n    }\r\n    return Token.ENDOFFILE;\r\n  }\r\n\r\n  peek(\r\n    checkOnNewLine: bool = false,\r\n    preferIdentifier: bool = false,\r\n    maxCompoundLength: i32 = i32.MAX_VALUE\r\n  ): Token {\r\n    var text = this.source.text;\r\n    if (this.nextToken < 0) {\r\n      var posBefore = this.pos;\r\n      var tokenBefore = this.token;\r\n      var tokenPosBefore = this.tokenPos;\r\n      this.nextToken = this.unsafeNext(preferIdentifier, maxCompoundLength);\r\n      if (checkOnNewLine) {\r\n        this.nextTokenOnNewLine = false;\r\n        while (--this.tokenPos > posBefore) {\r\n          if (isLineBreak(text.charCodeAt(this.tokenPos))) {\r\n            this.nextTokenOnNewLine = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      this.pos = posBefore;\r\n      this.token = tokenBefore;\r\n      this.tokenPos = tokenPosBefore;\r\n    }\r\n    return this.nextToken;\r\n  }\r\n\r\n  skip(token: Token): bool {\r\n    var posBefore = this.pos;\r\n    var tokenBefore = this.token;\r\n    var tokenPosBefore = this.tokenPos;\r\n    var maxCompoundLength = i32.MAX_VALUE;\r\n    switch (token) {\r\n      case Token.GREATERTHAN: // where parsing type arguments\r\n        maxCompoundLength = 1;\r\n        break;\r\n    }\r\n    this.token = this.unsafeNext(token == Token.IDENTIFIER, maxCompoundLength);\r\n    if (this.token == token) {\r\n      this.nextToken = -1;\r\n      return true;\r\n    } else {\r\n      this.pos = posBefore;\r\n      this.token = tokenBefore;\r\n      this.tokenPos = tokenPosBefore;\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // skipUntil(token1: Token, token2: Token = -1): bool {\r\n  //   var next: Token;\r\n  //   do {\r\n  //     if ((next = this.peek()) == Token.ENDOFFILE)\r\n  //       return false;\r\n  //     if (next == token1 || next == token2)\r\n  //       return true;\r\n  //     this.next();\r\n  //   } while (true);\r\n  // }\r\n\r\n  mark(): void {\r\n    this.markedPos = this.pos;\r\n    this.markedToken = this.token;\r\n    this.markedTokenPos = this.tokenPos;\r\n  }\r\n\r\n  reset(): void {\r\n    this.pos = this.markedPos;\r\n    this.token = this.markedToken;\r\n    this.tokenPos = this.markedTokenPos;\r\n    this.nextToken = -1;\r\n  }\r\n\r\n  range(start: i32 = -1, end: i32 = -1): Range {\r\n    if (start < 0) {\r\n      start = this.tokenPos;\r\n      end = this.pos;\r\n    } else if (end < 0) {\r\n      end = start;\r\n    }\r\n    return new Range(this.source, start, end);\r\n  }\r\n\r\n  readIdentifier(): string {\r\n    var text = this.source.text;\r\n    var start = this.pos;\r\n    while (\r\n      ++this.pos < this.end &&\r\n      isIdentifierPart(text.charCodeAt(this.pos))\r\n    );\r\n    return text.substring(start, this.pos);\r\n  }\r\n\r\n  readString(): string {\r\n    var text = this.source.text;\r\n    var quote = text.charCodeAt(this.pos++);\r\n    var start = this.pos;\r\n    var result = \"\";\r\n    while (true) {\r\n      if (this.pos >= this.end) {\r\n        result += text.substring(start, this.pos);\r\n        this.error(\r\n          DiagnosticCode.Unterminated_string_literal,\r\n          this.range(start - 1, this.end)\r\n        );\r\n        break;\r\n      }\r\n      var c = text.charCodeAt(this.pos);\r\n      if (c == quote) {\r\n        result += text.substring(start, this.pos++);\r\n        break;\r\n      }\r\n      if (c == CharCode.BACKSLASH) {\r\n        result += text.substring(start, this.pos);\r\n        result += this.readEscapeSequence();\r\n        start = this.pos;\r\n        continue;\r\n      }\r\n      if (isLineBreak(c)) {\r\n        result += text.substring(start, this.pos);\r\n        this.error(\r\n          DiagnosticCode.Unterminated_string_literal,\r\n          this.range(start - 1, this.pos)\r\n        );\r\n        break;\r\n      }\r\n      ++this.pos;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  readEscapeSequence(): string {\r\n    if (++this.pos >= this.end) {\r\n      this.error(\r\n        DiagnosticCode.Unexpected_end_of_text,\r\n        this.range(this.end)\r\n      );\r\n      return \"\";\r\n    }\r\n\r\n    var text = this.source.text;\r\n    var c = text.charCodeAt(this.pos++);\r\n    switch (c) {\r\n\r\n      case CharCode._0:\r\n        return \"\\0\";\r\n\r\n      case CharCode.b:\r\n        return \"\\b\";\r\n\r\n      case CharCode.t:\r\n        return \"\\t\";\r\n\r\n      case CharCode.n:\r\n        return \"\\n\";\r\n\r\n      case CharCode.v:\r\n        return \"\\v\";\r\n\r\n      case CharCode.f:\r\n        return \"\\f\";\r\n\r\n      case CharCode.r:\r\n        return \"\\r\";\r\n\r\n      case CharCode.SINGLEQUOTE:\r\n        return \"'\";\r\n\r\n      case CharCode.DOUBLEQUOTE:\r\n        return \"\\\"\";\r\n\r\n      case CharCode.u: {\r\n        if (\r\n          this.pos < this.end &&\r\n          text.charCodeAt(this.pos) == CharCode.OPENBRACE\r\n        ) {\r\n          ++this.pos;\r\n          return this.readExtendedUnicodeEscape(); // \\u{DDDDDDDD}\r\n        }\r\n        return this.readUnicodeEscape(); // \\uDDDD\r\n      }\r\n\r\n      case CharCode.CARRIAGERETURN:\r\n        if (\r\n          this.pos < this.end &&\r\n          text.charCodeAt(this.pos) == CharCode.LINEFEED\r\n        ) {\r\n          ++this.pos;\r\n        }\r\n        // fall through\r\n\r\n      case CharCode.LINEFEED:\r\n      case CharCode.LINESEPARATOR:\r\n      case CharCode.PARAGRAPHSEPARATOR:\r\n        return \"\";\r\n      default:\r\n        return String.fromCharCode(c);\r\n    }\r\n  }\r\n\r\n  readRegexpPattern(): string {\r\n    var text = this.source.text;\r\n    var start = this.pos;\r\n    var escaped = false;\r\n    while (true) {\r\n      if (this.pos >= this.end) {\r\n        this.error(\r\n          DiagnosticCode.Unterminated_regular_expression_literal,\r\n          this.range(start, this.end)\r\n        );\r\n        break;\r\n      }\r\n      if (text.charCodeAt(this.pos) == CharCode.BACKSLASH) {\r\n        ++this.pos;\r\n        escaped = true;\r\n        continue;\r\n      }\r\n      var c = text.charCodeAt(this.pos);\r\n      if (c == CharCode.SLASH && !escaped) break;\r\n      if (isLineBreak(c)) {\r\n        this.error(\r\n          DiagnosticCode.Unterminated_regular_expression_literal,\r\n          this.range(start, this.pos)\r\n        );\r\n        break;\r\n      }\r\n      ++this.pos;\r\n      escaped = false;\r\n    }\r\n    return text.substring(start, this.pos);\r\n  }\r\n\r\n  readRegexpFlags(): string {\r\n    var text = this.source.text;\r\n    var start = this.pos;\r\n    var flags = 0;\r\n    while (this.pos < this.end) {\r\n      var c: i32 = text.charCodeAt(this.pos);\r\n      if (!isIdentifierPart(c)) break;\r\n      ++this.pos;\r\n\r\n      // make sure each supported flag is unique\r\n      switch (c) {\r\n\r\n        case CharCode.g:\r\n          flags |= flags & 1 ? -1 : 1;\r\n          break;\r\n\r\n        case CharCode.i:\r\n          flags |= flags & 2 ? -1 : 2;\r\n          break;\r\n\r\n        case CharCode.m:\r\n          flags |= flags & 4 ? -1 : 4;\r\n          break;\r\n\r\n        default:\r\n          flags = -1;\r\n          break;\r\n      }\r\n    }\r\n    if (flags == -1) {\r\n      this.error(\r\n        DiagnosticCode.Invalid_regular_expression_flags,\r\n        this.range(start, this.pos)\r\n      );\r\n    }\r\n    return text.substring(start, this.pos);\r\n  }\r\n\r\n  testInteger(): bool {\r\n    var text = this.source.text;\r\n    if (text.charCodeAt(this.pos) == CharCode._0 && this.pos + 1 < this.end) {\r\n      switch (text.charCodeAt(this.pos + 2)) {\r\n        case CharCode.X:\r\n        case CharCode.x:\r\n        case CharCode.B:\r\n        case CharCode.b:\r\n        case CharCode.O:\r\n        case CharCode.o:\r\n          return true;\r\n      }\r\n    }\r\n    var pos = this.pos;\r\n    while (pos < this.end) {\r\n      var c = text.charCodeAt(pos);\r\n      if (c == CharCode.DOT || c == CharCode.E || c == CharCode.e) {\r\n        return false;\r\n      }\r\n      if (c < CharCode._0 || c > CharCode._9) break;\r\n      pos++;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  readInteger(): I64 {\r\n    var text = this.source.text;\r\n    if (text.charCodeAt(this.pos) == CharCode._0 && this.pos + 2 < this.end) {\r\n      switch (text.charCodeAt(this.pos + 1)) {\r\n\r\n        case CharCode.X:\r\n        case CharCode.x:\r\n          this.pos += 2;\r\n          return this.readHexInteger();\r\n\r\n        case CharCode.B:\r\n        case CharCode.b:\r\n          this.pos += 2;\r\n          return this.readBinaryInteger();\r\n\r\n        case CharCode.O:\r\n        case CharCode.o:\r\n          this.pos += 2;\r\n          return this.readOctalInteger();\r\n      }\r\n      if (isOctalDigit(text.charCodeAt(this.pos + 1))) {\r\n        var start = this.pos;\r\n        ++this.pos;\r\n        var value = this.readOctalInteger();\r\n        this.error(\r\n          DiagnosticCode.Octal_literals_are_not_allowed_in_strict_mode,\r\n          this.range(start, this.pos)\r\n        );\r\n        return value;\r\n      }\r\n    }\r\n    return this.readDecimalInteger();\r\n  }\r\n\r\n  readHexInteger(): I64 {\r\n    var text = this.source.text;\r\n    var start = this.pos;\r\n    var value = i64_new(0, 0);\r\n    var i64_16 = i64_new(16, 0);\r\n    while (this.pos < this.end) {\r\n      var c = text.charCodeAt(this.pos);\r\n      if (c >= CharCode._0 && c <= CharCode._9) {\r\n        // value = value * 16 + c - CharCode._0;\r\n        value = i64_add(\r\n          i64_mul(value, i64_16),\r\n          i64_new(c - CharCode._0, 0)\r\n        );\r\n       } else if (c >= CharCode.A && c <= CharCode.F) {\r\n        // value = value * 16 + 10 + c - CharCode.A;\r\n        value = i64_add(\r\n          i64_mul(value, i64_16),\r\n          i64_new(10 + c - CharCode.A, 0)\r\n        );\r\n      } else if (c >= CharCode.a && c <= CharCode.f) {\r\n        // value = value * 16 + 10 + c - CharCode.a;\r\n        value = i64_add(\r\n          i64_mul(value, i64_16),\r\n          i64_new(10 + c - CharCode.a, 0)\r\n        );\r\n      } else {\r\n        break;\r\n      }\r\n      ++this.pos;\r\n    }\r\n    if (this.pos == start) {\r\n      this.error(\r\n        DiagnosticCode.Hexadecimal_digit_expected,\r\n        this.range(start)\r\n      );\r\n    }\r\n    return value;\r\n  }\r\n\r\n  readDecimalInteger(): I64 {\r\n    var text = this.source.text;\r\n    var start = this.pos;\r\n    var value = i64_new(0, 0);\r\n    var i64_10 = i64_new(10, 0);\r\n    while (this.pos < this.end) {\r\n      var c = text.charCodeAt(this.pos);\r\n      if (c >= CharCode._0 && c <= CharCode._9) {\r\n        // value = value * 10 + c - CharCode._0;\r\n        value = i64_add(\r\n          i64_mul(value, i64_10),\r\n          i64_new(c - CharCode._0, 0)\r\n        );\r\n      } else {\r\n        break;\r\n      }\r\n      ++this.pos;\r\n    }\r\n    if (this.pos == start) {\r\n      this.error(\r\n        DiagnosticCode.Digit_expected,\r\n        this.range(start)\r\n      );\r\n    }\r\n    return value;\r\n  }\r\n\r\n  readOctalInteger(): I64 {\r\n    var text = this.source.text;\r\n    var start = this.pos;\r\n    var value = i64_new(0, 0);\r\n    var i64_8 = i64_new(8, 0);\r\n    while (this.pos < this.end) {\r\n      var c = text.charCodeAt(this.pos);\r\n      if (c >= CharCode._0 && c <= CharCode._7) {\r\n        // value = value * 8 + c - CharCode._0;\r\n        value = i64_add(\r\n          i64_mul(value, i64_8),\r\n          i64_new(c - CharCode._0, 0)\r\n        );\r\n      } else {\r\n        break;\r\n      }\r\n      ++this.pos;\r\n    }\r\n    if (this.pos == start) {\r\n      this.error(\r\n        DiagnosticCode.Octal_digit_expected,\r\n        this.range(start)\r\n      );\r\n    }\r\n    return value;\r\n  }\r\n\r\n  readBinaryInteger(): I64 {\r\n    var text = this.source.text;\r\n    var start = this.pos;\r\n    var value = i64_new(0, 0);\r\n    var i64_2 = i64_new(2, 0);\r\n    var i64_1 = i64_new(1, 0);\r\n    while (this.pos < this.end) {\r\n      var c = text.charCodeAt(this.pos);\r\n      if (c == CharCode._0) {\r\n        // value = value * 2;\r\n        value = i64_mul(\r\n          value,\r\n          i64_2\r\n        );\r\n      } else if (c == CharCode._1) {\r\n        // value = value * 2 + 1;\r\n        value = i64_add(\r\n          i64_mul(value, i64_2),\r\n          i64_1\r\n        );\r\n      } else {\r\n        break;\r\n      }\r\n      ++this.pos;\r\n    }\r\n    if (this.pos == start) {\r\n      this.error(\r\n        DiagnosticCode.Binary_digit_expected,\r\n        this.range(start)\r\n      );\r\n    }\r\n    return value;\r\n  }\r\n\r\n  readFloat(): f64 {\r\n    var start = this.pos;\r\n    var text = this.source.text;\r\n    while (this.pos < this.end && isDecimalDigit(text.charCodeAt(this.pos))) {\r\n      ++this.pos;\r\n    }\r\n    if (this.pos < this.end && text.charCodeAt(this.pos) == CharCode.DOT) {\r\n      ++this.pos;\r\n      while (this.pos < this.end && isDecimalDigit(text.charCodeAt(this.pos))) {\r\n        ++this.pos;\r\n      }\r\n    }\r\n    if (this.pos < this.end) {\r\n      var c = text.charCodeAt(this.pos);\r\n      if (c == CharCode.E || c == CharCode.e) {\r\n        if (\r\n          ++this.pos < this.end && (\r\n            text.charCodeAt(this.pos) == CharCode.MINUS ||\r\n            text.charCodeAt(this.pos) == CharCode.PLUS\r\n          ) &&\r\n          isDecimalDigit(text.charCodeAt(this.pos + 1))\r\n        ) {\r\n          ++this.pos;\r\n        }\r\n        while (this.pos < this.end && isDecimalDigit(text.charCodeAt(this.pos))) {\r\n          ++this.pos;\r\n        }\r\n      }\r\n    }\r\n    return parseFloat(text.substring(start, this.pos));\r\n  }\r\n\r\n  readUnicodeEscape(): string {\r\n    var remain = 4;\r\n    var value = 0;\r\n    var text = this.source.text;\r\n    while (this.pos < this.end) {\r\n      var c = text.charCodeAt(this.pos++);\r\n      if (c >= CharCode._0 && c <= CharCode._9) {\r\n        value = value * 16 + c - CharCode._0;\r\n      } else if (c >= CharCode.A && c <= CharCode.F) {\r\n        value = value * 16 + 10 + c - CharCode.A;\r\n      } else if (c >= CharCode.a && c <= CharCode.f) {\r\n        value = value * 16 + 10 + c - CharCode.a;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.Hexadecimal_digit_expected,\r\n          this.range(this.pos - 1, this.pos)\r\n        );\r\n        return \"\";\r\n      }\r\n      if (--remain == 0) break;\r\n    }\r\n    if (remain) {\r\n      this.error(\r\n        DiagnosticCode.Unexpected_end_of_text,\r\n        this.range(this.pos)\r\n      );\r\n      return \"\";\r\n    }\r\n    return String.fromCharCode(value);\r\n  }\r\n\r\n  private readExtendedUnicodeEscape(): string {\r\n    var start = this.pos;\r\n    var value = this.readHexInteger();\r\n    var value32 = i64_low(value);\r\n    var invalid = false;\r\n\r\n    assert(!i64_high(value));\r\n    if (value32 > 0x10FFFF) {\r\n      this.error(\r\n        DiagnosticCode.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive,\r\n        this.range(start, this.pos)\r\n      );\r\n      invalid = true;\r\n    }\r\n\r\n    var text = this.source.text;\r\n    if (this.pos >= this.end) {\r\n      this.error(\r\n        DiagnosticCode.Unexpected_end_of_text,\r\n        this.range(start, this.end)\r\n      );\r\n      invalid = true;\r\n    } else if (text.charCodeAt(this.pos) == CharCode.CLOSEBRACE) {\r\n      ++this.pos;\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Unterminated_Unicode_escape_sequence,\r\n        this.range(start, this.pos)\r\n      );\r\n      invalid = true;\r\n    }\r\n\r\n    if (invalid) return \"\";\r\n    return value32 < 65536\r\n      ? String.fromCharCode(value32)\r\n      : String.fromCharCode(\r\n        (((value32 - 65536) / 1024 | 0) + 0xD800) as i32,\r\n        ( (value32 - 65536) % 1024      + 0xDC00) as i32\r\n      );\r\n  }\r\n\r\n  finish(): void {\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/tokenizer.ts","// code below is generated from diagnosticsMessages.json by scripts/build-diagnostics\n/* tslint:disable:max-line-length */\n\nexport enum DiagnosticCode {\n  Operation_not_supported = 100,\n  Operation_is_unsafe = 101,\n  Conversion_from_type_0_to_1_requires_an_explicit_cast = 200,\n  Conversion_from_type_0_to_1_will_require_an_explicit_cast_when_switching_between_32_64_bit = 201,\n  Type_0_cannot_be_changed_to_type_1 = 202,\n  Type_0_cannot_be_reinterpreted_as_type_1 = 203,\n  Basic_type_0_cannot_be_nullable = 204,\n  Cannot_export_a_mutable_global = 205,\n  Compiling_constant_with_non_constant_initializer_as_mutable = 206,\n  Structs_cannot_extend_classes_and_vice_versa = 207,\n  Structs_cannot_implement_interfaces = 208,\n  Invalid_regular_expression_flags = 209,\n  Implementation_0_must_match_the_signature_1 = 210,\n  Unterminated_string_literal = 1002,\n  Identifier_expected = 1003,\n  _0_expected = 1005,\n  A_file_cannot_have_a_reference_to_itself = 1006,\n  Trailing_comma_not_allowed = 1009,\n  Unexpected_token = 1012,\n  A_rest_parameter_must_be_last_in_a_parameter_list = 1014,\n  Parameter_cannot_have_question_mark_and_initializer = 1015,\n  A_required_parameter_cannot_follow_an_optional_parameter = 1016,\n  Enum_member_must_have_initializer = 1061,\n  Statements_are_not_allowed_in_ambient_contexts = 1036,\n  Initializers_are_not_allowed_in_ambient_contexts = 1039,\n  _0_modifier_cannot_be_used_here = 1042,\n  A_rest_parameter_cannot_be_optional = 1047,\n  A_rest_parameter_cannot_have_an_initializer = 1048,\n  A_set_accessor_must_have_exactly_one_parameter = 1049,\n  A_set_accessor_parameter_cannot_have_an_initializer = 1052,\n  A_get_accessor_cannot_have_parameters = 1054,\n  Type_parameters_cannot_appear_on_a_constructor_declaration = 1092,\n  Type_annotation_cannot_appear_on_a_constructor_declaration = 1093,\n  An_accessor_cannot_have_type_parameters = 1094,\n  A_set_accessor_cannot_have_a_return_type_annotation = 1095,\n  Type_parameter_list_cannot_be_empty = 1098,\n  A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement = 1104,\n  A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement = 1105,\n  A_return_statement_can_only_be_used_within_a_function_body = 1108,\n  Expression_expected = 1109,\n  Type_expected = 1110,\n  A_default_clause_cannot_appear_more_than_once_in_a_switch_statement = 1113,\n  Duplicate_label_0 = 1114,\n  Octal_literals_are_not_allowed_in_strict_mode = 1121,\n  Digit_expected = 1124,\n  Hexadecimal_digit_expected = 1125,\n  Unexpected_end_of_text = 1126,\n  Invalid_character = 1127,\n  _case_or_default_expected = 1130,\n  Type_argument_expected = 1140,\n  String_literal_expected = 1141,\n  Line_break_not_permitted_here = 1142,\n  Declaration_expected = 1146,\n  _const_declarations_must_be_initialized = 1155,\n  Unterminated_regular_expression_literal = 1161,\n  Binary_digit_expected = 1177,\n  Octal_digit_expected = 1178,\n  An_implementation_cannot_be_declared_in_ambient_contexts = 1183,\n  An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive = 1198,\n  Unterminated_Unicode_escape_sequence = 1199,\n  Decorators_are_not_valid_here = 1206,\n  _abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration = 1242,\n  A_class_may_only_extend_another_class = 1311,\n  Duplicate_identifier_0 = 2300,\n  Cannot_find_name_0 = 2304,\n  Module_0_has_no_exported_member_1 = 2305,\n  Generic_type_0_requires_1_type_argument_s = 2314,\n  Type_0_is_not_generic = 2315,\n  Type_0_is_not_assignable_to_type_1 = 2322,\n  Index_signature_is_missing_in_type_0 = 2329,\n  _this_cannot_be_referenced_in_current_location = 2332,\n  _super_can_only_be_referenced_in_a_derived_class = 2335,\n  Property_0_does_not_exist_on_type_1 = 2339,\n  Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures = 2349,\n  Cannot_use_new_with_an_expression_whose_type_lacks_a_construct_signature = 2351,\n  A_function_whose_declared_type_is_not_void_must_return_a_value = 2355,\n  The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access = 2357,\n  The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access = 2364,\n  Operator_0_cannot_be_applied_to_types_1_and_2 = 2365,\n  _get_and_set_accessor_must_have_the_same_type = 2380,\n  Constructor_implementation_is_missing = 2390,\n  Function_implementation_is_missing_or_not_immediately_following_the_declaration = 2391,\n  Multiple_constructor_implementations_are_not_allowed = 2392,\n  Duplicate_function_implementation = 2393,\n  The_0_operator_cannot_be_applied_to_type_1 = 2469,\n  Export_declaration_conflicts_with_exported_declaration_of_0 = 2484,\n  Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property = 2540,\n  The_target_of_an_assignment_must_be_a_variable_or_a_property_access = 2541,\n  Index_signature_in_type_0_only_permits_reading = 2542,\n  Expected_0_arguments_but_got_1 = 2554,\n  Expected_at_least_0_arguments_but_got_1 = 2555,\n  Expected_0_type_arguments_but_got_1 = 2558,\n  A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums = 2651,\n  Namespace_0_has_no_exported_member_1 = 2694,\n  File_0_not_found = 6054\n}\n\nexport function diagnosticCodeToString(code: DiagnosticCode): string {\n  switch (code) {\n    case 100: return \"Operation not supported.\";\n    case 101: return \"Operation is unsafe.\";\n    case 200: return \"Conversion from type '{0}' to '{1}' requires an explicit cast.\";\n    case 201: return \"Conversion from type '{0}' to '{1}' will require an explicit cast when switching between 32/64-bit.\";\n    case 202: return \"Type '{0}' cannot be changed to type '{1}'.\";\n    case 203: return \"Type '{0}' cannot be reinterpreted as type '{1}'.\";\n    case 204: return \"Basic type '{0}' cannot be nullable.\";\n    case 205: return \"Cannot export a mutable global.\";\n    case 206: return \"Compiling constant with non-constant initializer as mutable.\";\n    case 207: return \"Structs cannot extend classes and vice-versa.\";\n    case 208: return \"Structs cannot implement interfaces.\";\n    case 209: return \"Invalid regular expression flags.\";\n    case 210: return \"Implementation '{0}' must match the signature '{1}'.\";\n    case 1002: return \"Unterminated string literal.\";\n    case 1003: return \"Identifier expected.\";\n    case 1005: return \"'{0}' expected.\";\n    case 1006: return \"A file cannot have a reference to itself.\";\n    case 1009: return \"Trailing comma not allowed.\";\n    case 1012: return \"Unexpected token.\";\n    case 1014: return \"A rest parameter must be last in a parameter list.\";\n    case 1015: return \"Parameter cannot have question mark and initializer.\";\n    case 1016: return \"A required parameter cannot follow an optional parameter.\";\n    case 1061: return \"Enum member must have initializer.\";\n    case 1036: return \"Statements are not allowed in ambient contexts.\";\n    case 1039: return \"Initializers are not allowed in ambient contexts.\";\n    case 1042: return \"'{0}' modifier cannot be used here.\";\n    case 1047: return \"A rest parameter cannot be optional.\";\n    case 1048: return \"A rest parameter cannot have an initializer.\";\n    case 1049: return \"A 'set' accessor must have exactly one parameter.\";\n    case 1052: return \"A 'set' accessor parameter cannot have an initializer.\";\n    case 1054: return \"A 'get' accessor cannot have parameters.\";\n    case 1092: return \"Type parameters cannot appear on a constructor declaration.\";\n    case 1093: return \"Type annotation cannot appear on a constructor declaration.\";\n    case 1094: return \"An accessor cannot have type parameters.\";\n    case 1095: return \"A 'set' accessor cannot have a return type annotation.\";\n    case 1098: return \"Type parameter list cannot be empty.\";\n    case 1104: return \"A 'continue' statement can only be used within an enclosing iteration statement.\";\n    case 1105: return \"A 'break' statement can only be used within an enclosing iteration or switch statement.\";\n    case 1108: return \"A 'return' statement can only be used within a function body.\";\n    case 1109: return \"Expression expected.\";\n    case 1110: return \"Type expected.\";\n    case 1113: return \"A 'default' clause cannot appear more than once in a 'switch' statement.\";\n    case 1114: return \"Duplicate label '{0}'.\";\n    case 1121: return \"Octal literals are not allowed in strict mode.\";\n    case 1124: return \"Digit expected.\";\n    case 1125: return \"Hexadecimal digit expected.\";\n    case 1126: return \"Unexpected end of text.\";\n    case 1127: return \"Invalid character.\";\n    case 1130: return \"'case' or 'default' expected.\";\n    case 1140: return \"Type argument expected.\";\n    case 1141: return \"String literal expected.\";\n    case 1142: return \"Line break not permitted here.\";\n    case 1146: return \"Declaration expected.\";\n    case 1155: return \"'const' declarations must be initialized.\";\n    case 1161: return \"Unterminated regular expression literal.\";\n    case 1177: return \"Binary digit expected.\";\n    case 1178: return \"Octal digit expected.\";\n    case 1183: return \"An implementation cannot be declared in ambient contexts.\";\n    case 1198: return \"An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.\";\n    case 1199: return \"Unterminated Unicode escape sequence.\";\n    case 1206: return \"Decorators are not valid here.\";\n    case 1242: return \"'abstract' modifier can only appear on a class, method, or property declaration.\";\n    case 1311: return \"A class may only extend another class.\";\n    case 2300: return \"Duplicate identifier '{0}'.\";\n    case 2304: return \"Cannot find name '{0}'.\";\n    case 2305: return \"Module '{0}' has no exported member '{1}'.\";\n    case 2314: return \"Generic type '{0}' requires {1} type argument(s).\";\n    case 2315: return \"Type '{0}' is not generic.\";\n    case 2322: return \"Type '{0}' is not assignable to type '{1}'.\";\n    case 2329: return \"Index signature is missing in type '{0}'.\";\n    case 2332: return \"'this' cannot be referenced in current location.\";\n    case 2335: return \"'super' can only be referenced in a derived class.\";\n    case 2339: return \"Property '{0}' does not exist on type '{1}'.\";\n    case 2349: return \"Cannot invoke an expression whose type lacks a call signature. Type '{0}' has no compatible call signatures.\";\n    case 2351: return \"Cannot use 'new' with an expression whose type lacks a construct signature.\";\n    case 2355: return \"A function whose declared type is not 'void' must return a value.\";\n    case 2357: return \"The operand of an increment or decrement operator must be a variable or a property access.\";\n    case 2364: return \"The left-hand side of an assignment expression must be a variable or a property access.\";\n    case 2365: return \"Operator '{0}' cannot be applied to types '{1}' and '{2}'.\";\n    case 2380: return \"'get' and 'set' accessor must have the same type.\";\n    case 2390: return \"Constructor implementation is missing.\";\n    case 2391: return \"Function implementation is missing or not immediately following the declaration.\";\n    case 2392: return \"Multiple constructor implementations are not allowed.\";\n    case 2393: return \"Duplicate function implementation.\";\n    case 2469: return \"The '{0}' operator cannot be applied to type '{1}'.\";\n    case 2484: return \"Export declaration conflicts with exported declaration of '{0}'.\";\n    case 2540: return \"Cannot assign to '{0}' because it is a constant or a read-only property.\";\n    case 2541: return \"The target of an assignment must be a variable or a property access.\";\n    case 2542: return \"Index signature in type '{0}' only permits reading.\";\n    case 2554: return \"Expected {0} arguments, but got {1}.\";\n    case 2555: return \"Expected at least {0} arguments, but got {1}.\";\n    case 2558: return \"Expected {0} type arguments, but got {1}.\";\n    case 2651: return \"A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.\";\n    case 2694: return \"Namespace '{0}' has no exported member '{1}'.\";\n    case 6054: return \"File '{0}' not found.\";\n    default: return \"\";\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/diagnosticMessages.generated.ts","/** An enum of named character codes. */\r\nexport const enum CharCode {\r\n\r\n  NULL = 0,\r\n  LINEFEED = 0x0A,\r\n  CARRIAGERETURN = 0x0D,\r\n  LINESEPARATOR = 0x2028,\r\n  PARAGRAPHSEPARATOR = 0x2029,\r\n  NEXTLINE = 0x0085,\r\n\r\n  SPACE = 0x20,\r\n  NONBREAKINGSPACE = 0xA0,\r\n  ENQUAD = 0x2000,\r\n  EMQUAD = 0x2001,\r\n  ENSPACE = 0x2002,\r\n  EMSPACE = 0x2003,\r\n  THREEPEREMSPACE = 0x2004,\r\n  FOURPEREMSPACE = 0x2005,\r\n  SIXPEREMSPACE = 0x2006,\r\n  FIGURESPACE = 0x2007,\r\n  PUNCTUATIONSPACE = 0x2008,\r\n  THINSPACE = 0x2009,\r\n  HAIRSPACE = 0x200A,\r\n  ZEROWIDTHSPACE = 0x200B,\r\n  NARROWNOBREAKSPACE = 0x202F,\r\n  IDEOGRAPHICSPACE = 0x3000,\r\n  MATHEMATICALSPACE = 0x205F,\r\n  OGHAM = 0x1680,\r\n\r\n  _ = 0x5F,\r\n\r\n  _0 = 0x30,\r\n  _1 = 0x31,\r\n  _2 = 0x32,\r\n  _3 = 0x33,\r\n  _4 = 0x34,\r\n  _5 = 0x35,\r\n  _6 = 0x36,\r\n  _7 = 0x37,\r\n  _8 = 0x38,\r\n  _9 = 0x39,\r\n\r\n  a = 0x61,\r\n  b = 0x62,\r\n  c = 0x63,\r\n  d = 0x64,\r\n  e = 0x65,\r\n  f = 0x66,\r\n  g = 0x67,\r\n  h = 0x68,\r\n  i = 0x69,\r\n  j = 0x6A,\r\n  k = 0x6B,\r\n  l = 0x6C,\r\n  m = 0x6D,\r\n  n = 0x6E,\r\n  o = 0x6F,\r\n  p = 0x70,\r\n  q = 0x71,\r\n  r = 0x72,\r\n  s = 0x73,\r\n  t = 0x74,\r\n  u = 0x75,\r\n  v = 0x76,\r\n  w = 0x77,\r\n  x = 0x78,\r\n  y = 0x79,\r\n  z = 0x7A,\r\n\r\n  A = 0x41,\r\n  B = 0x42,\r\n  C = 0x43,\r\n  D = 0x44,\r\n  E = 0x45,\r\n  F = 0x46,\r\n  G = 0x47,\r\n  H = 0x48,\r\n  I = 0x49,\r\n  J = 0x4A,\r\n  K = 0x4B,\r\n  L = 0x4C,\r\n  M = 0x4D,\r\n  N = 0x4E,\r\n  O = 0x4F,\r\n  P = 0x50,\r\n  Q = 0x51,\r\n  R = 0x52,\r\n  S = 0x53,\r\n  T = 0x54,\r\n  U = 0x55,\r\n  V = 0x56,\r\n  W = 0x57,\r\n  X = 0x58,\r\n  Y = 0x59,\r\n  Z = 0x5a,\r\n\r\n  AMPERSAND = 0x26,\r\n  ASTERISK = 0x2A,\r\n  AT = 0x40,\r\n  BACKSLASH = 0x5C,\r\n  BACKTICK = 0x60,\r\n  BAR = 0x7C,\r\n  CARET = 0x5E,\r\n  CLOSEBRACE = 0x7D,\r\n  CLOSEBRACKET = 0x5D,\r\n  CLOSEPAREN = 0x29,\r\n  COLON = 0x3A,\r\n  COMMA = 0x2C,\r\n  DOLLAR = 0x24,\r\n  DOT = 0x2E,\r\n  DOUBLEQUOTE = 0x22,\r\n  EQUALS = 0x3D,\r\n  EXCLAMATION = 0x21,\r\n  GREATERTHAN = 0x3E,\r\n  HASH = 0x23,\r\n  LESSTHAN = 0x3C,\r\n  MINUS = 0x2D,\r\n  OPENBRACE = 0x7B,\r\n  OPENBRACKET = 0x5B,\r\n  OPENPAREN = 0x28,\r\n  PERCENT = 0x25,\r\n  PLUS = 0x2B,\r\n  QUESTION = 0x3F,\r\n  SEMICOLON = 0x3B,\r\n  SINGLEQUOTE = 0x27,\r\n  SLASH = 0x2F,\r\n  TILDE = 0x7E,\r\n\r\n  BACKSPACE = 0x08,\r\n  FORMFEED = 0x0C,\r\n  BYTEORDERMARK = 0xFEFF,\r\n  TAB = 0x09,\r\n  VERTICALTAB = 0x0B\r\n}\r\n\r\n/** Tests if the specified character code is some sort of line break. */\r\nexport function isLineBreak(c: CharCode): bool {\r\n  switch (c) {\r\n    case CharCode.LINEFEED:\r\n    case CharCode.CARRIAGERETURN:\r\n    case CharCode.LINESEPARATOR:\r\n    case CharCode.PARAGRAPHSEPARATOR:\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\n/** Tests if the specified character code is some sort of white space. */\r\nexport function isWhiteSpace(c: i32): bool {\r\n  switch (c) {\r\n    case CharCode.SPACE:\r\n    case CharCode.TAB:\r\n    case CharCode.VERTICALTAB:\r\n    case CharCode.FORMFEED:\r\n    case CharCode.NONBREAKINGSPACE:\r\n    case CharCode.NEXTLINE:\r\n    case CharCode.OGHAM:\r\n    case CharCode.NARROWNOBREAKSPACE:\r\n    case CharCode.MATHEMATICALSPACE:\r\n    case CharCode.IDEOGRAPHICSPACE:\r\n    case CharCode.BYTEORDERMARK:\r\n      return true;\r\n    default:\r\n      return c >= CharCode.ENQUAD && c <= CharCode.ZEROWIDTHSPACE;\r\n  }\r\n}\r\n\r\n/** Tests if the specified character code is a decimal digit. */\r\nexport function isDecimalDigit(c: i32): bool {\r\n  return c >= CharCode._0 && c <= CharCode._9;\r\n}\r\n\r\n/** Tests if the specified character code is an octal digit. */\r\nexport function isOctalDigit(c: i32): bool {\r\n  return c >= CharCode._0 && c <= CharCode._7;\r\n}\r\n\r\n/** Tests if the specified character code is a valid start of an identifier. */\r\nexport function isIdentifierStart(c: i32): bool {\r\n  return c >= CharCode.A && c <= CharCode.Z\r\n      || c >= CharCode.a && c <= CharCode.z\r\n      || c == CharCode.DOLLAR\r\n      || c == CharCode._\r\n      || c > 0x7f && isUnicodeIdentifierStart(c);\r\n}\r\n\r\n/** Tests if the specified character code is a valid keyword character. */\r\nexport function isKeywordCharacter(c: i32): bool {\r\n  return c >= CharCode.a && c <= CharCode.z;\r\n}\r\n\r\n/** Tests if the specified character code is a valid part of an identifier. */\r\nexport function isIdentifierPart(c: i32): bool {\r\n  return c >= CharCode.A && c <= CharCode.Z\r\n      || c >= CharCode.a && c <= CharCode.z\r\n      || c >= CharCode._0 && c <= CharCode._9\r\n      || c == CharCode.DOLLAR\r\n      || c == CharCode._\r\n      || c > 0x7f && isUnicodeIdentifierPart(c);\r\n}\r\n\r\n// storing as u16 to save memory\r\nconst unicodeIdentifierStart: u16[] = [\r\n  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\r\n  740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906,\r\n  908, 908, 910, 929, 931,\r\n  1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514,\r\n  1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774,\r\n  1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969,\r\n  1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088,\r\n  2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384,\r\n  2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474,\r\n  2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529,\r\n  2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613,\r\n  2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705,\r\n  2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784,\r\n  2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873,\r\n  2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958,\r\n  2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986,\r\n  2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125,\r\n  3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240,\r\n  3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333,\r\n  3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455,\r\n  3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634,\r\n  3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725,\r\n  3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757,\r\n  3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840,\r\n  3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186,\r\n  4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293,\r\n  4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696,\r\n  4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798,\r\n  4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992,\r\n  5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872,\r\n  5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016,\r\n  6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389,\r\n  6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688,\r\n  6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141,\r\n  7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424,\r\n  7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025,\r\n  8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130,\r\n  8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188,\r\n  8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469,\r\n  8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505,\r\n  8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584,\r\n  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520,\r\n  11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670,\r\n  11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720,\r\n  11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329,\r\n  12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540,\r\n  12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893,\r\n  19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538,\r\n  42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888,\r\n  42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015,\r\n  43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259,\r\n  43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520,\r\n  43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695,\r\n  43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739,\r\n  43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798,\r\n  43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243,\r\n  55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285,\r\n  64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323,\r\n  64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019,\r\n  65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474,\r\n  65479, 65482, 65487, 65490, 65495, 65498, 65500,\r\n];\r\nconst unicodeIdentifierPart: u16[] = [\r\n  170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736,\r\n  740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906,\r\n  908, 908, 910, 929, 931,\r\n  1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415,\r\n  1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520,\r\n  1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788,\r\n  1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112,\r\n  2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423,\r\n  2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482,\r\n  2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525,\r\n  2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602,\r\n  2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632,\r\n  2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693,\r\n  2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757,\r\n  2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821,\r\n  2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884,\r\n  2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929,\r\n  2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972,\r\n  2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018,\r\n  3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088,\r\n  3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157,\r\n  3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216,\r\n  3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285,\r\n  3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340,\r\n  3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424,\r\n  3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515,\r\n  3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570,\r\n  3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720,\r\n  3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751,\r\n  3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789,\r\n  3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895,\r\n  3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028,\r\n  4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304,\r\n  4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744,\r\n  4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808,\r\n  4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108,\r\n  5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902,\r\n  5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099,\r\n  6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272,\r\n  6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516,\r\n  6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783,\r\n  6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155,\r\n  7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676,\r\n  7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027,\r\n  8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134,\r\n  8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205,\r\n  8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417,\r\n  8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477,\r\n  8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517,\r\n  8521, 8526, 8526, 8544, 8584,\r\n  11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559,\r\n  11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686,\r\n  11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728,\r\n  11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335,\r\n  12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449,\r\n  12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799,\r\n  13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512,\r\n  42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783,\r\n  42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072,\r\n  43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309,\r\n  43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584,\r\n  43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741,\r\n  43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808,\r\n  43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203,\r\n  55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275,\r\n  64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321,\r\n  64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008,\r\n  65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140,\r\n  65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382,\r\n  65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,\r\n];\r\n\r\nfunction lookupInUnicodeMap(code: u16, map: u16[]): bool {\r\n  if (code < map[0]) return false;\r\n\r\n  var lo = 0;\r\n  var hi = map.length;\r\n  var mid: i32;\r\n\r\n  while (lo + 1 < hi) {\r\n    mid = lo + (hi - lo) / 2;\r\n    mid -= mid % 2;\r\n    if (map[mid] <= code && code <= map[mid + 1]) {\r\n      return true;\r\n    }\r\n    if (code < map[mid]) {\r\n      hi = mid;\r\n    } else {\r\n      lo = mid + 2;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction isUnicodeIdentifierStart(code: i32): bool {\r\n  return code < 0 || code > 0xffff ? false\r\n       : lookupInUnicodeMap(code as u16, unicodeIdentifierStart);\r\n}\r\n\r\nfunction isUnicodeIdentifierPart(code: i32): bool {\r\n  return code < 0 || code > 0xffff ? false\r\n       : lookupInUnicodeMap(code as u16, unicodeIdentifierPart);\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/charcode.ts","import {\r\n  CharCode\r\n} from \"./charcode\";\r\n\r\nconst separator = CharCode.SLASH;\r\n\r\n/**\r\n * Normalizes the specified path, removing interior placeholders.\r\n * Expects a posix-compatible relative path (not Windows compatible).\r\n */\r\nexport function normalize(path: string): string {\r\n  var pos = 0;\r\n  var len = path.length;\r\n\r\n  // trim leading './'\r\n  while (pos + 1 < len &&\r\n    path.charCodeAt(pos) == CharCode.DOT &&\r\n    path.charCodeAt(pos + 1) == separator\r\n  ) {\r\n    pos += 2;\r\n  }\r\n\r\n  if (pos > 0 || len < path.length) {\r\n    path = path.substring(pos, len);\r\n    len -= pos;\r\n    pos = 0;\r\n  }\r\n\r\n  var atEnd: bool;\r\n  while (pos + 1 < len) {\r\n    atEnd = false;\r\n\r\n    // we are only interested in '/.' sequences ...\r\n    if (\r\n      path.charCodeAt(pos) == separator &&\r\n      path.charCodeAt(pos + 1) == CharCode.DOT\r\n    ) {\r\n      // '/.' ( '/' | $ )\r\n      atEnd = pos + 2 == len;\r\n      if (atEnd ||\r\n        pos + 2 < len &&\r\n        path.charCodeAt(pos + 2) == separator\r\n      ) {\r\n        path = atEnd\r\n          ? path.substring(0, pos)\r\n          : path.substring(0, pos) + path.substring(pos + 2);\r\n        len -= 2;\r\n        continue;\r\n      }\r\n\r\n      // '/.' ( './' | '.' $ )\r\n      atEnd = pos + 3 == len;\r\n      if (atEnd && path.charCodeAt(pos + 2) == CharCode.DOT ||\r\n        pos + 3 < len &&\r\n        path.charCodeAt(pos + 2) == CharCode.DOT &&\r\n        path.charCodeAt(pos + 3) == separator\r\n      ) {\r\n        // find preceeding '/'\r\n        var ipos = pos;\r\n        while (--ipos >= 0) {\r\n          if (path.charCodeAt(ipos) == separator) {\r\n            if (pos - ipos != 3 ||\r\n              path.charCodeAt(ipos + 1) != CharCode.DOT ||\r\n              path.charCodeAt(ipos + 2) != CharCode.DOT\r\n            ) { // exclude '..' itself\r\n              path = atEnd\r\n                ? path.substring(0, ipos)\r\n                : path.substring(0, ipos) + path.substring(pos + 3);\r\n              len -= pos + 3 - ipos;\r\n              pos = ipos - 1; // incremented again at end of loop\r\n            }\r\n            break;\r\n          }\r\n        }\r\n\r\n        // if there's no preceeding '/', trim start if non-empty\r\n        if (ipos < 0 && pos > 0) {\r\n          if (pos != 2 ||\r\n            path.charCodeAt(0) != CharCode.DOT ||\r\n            path.charCodeAt(1) != CharCode.DOT\r\n          ) { // exclude '..' itself\r\n            path = path.substring(pos + 4);\r\n            len = path.length;\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    pos++;\r\n  }\r\n  return len > 0 ? path : \".\";\r\n}\r\n\r\n/** Resolves the specified path relative to the specified origin. */\r\nexport function resolve(normalizedPath: string, origin: string): string {\r\n  if (normalizedPath.startsWith(\"std/\")) {\r\n    return normalizedPath;\r\n  }\r\n  return normalize(\r\n    dirname(origin) + String.fromCharCode(separator) + normalizedPath\r\n  );\r\n}\r\n\r\n/** Obtains the directory portion of a normalized path. */\r\nexport function dirname(normalizedPath: string): string {\r\n  var pos = normalizedPath.length;\r\n  while (--pos > 0) {\r\n    if (normalizedPath.charCodeAt(pos) == separator) {\r\n      return normalizedPath.substring(0, pos);\r\n    }\r\n  }\r\n  return \".\";\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/util/path.ts","import \"../../../std/portable\";\r\nimport \"./binaryen\";\r\nimport \"./i64\";\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/glue/js/index.ts","var globalScope = typeof window !== \"undefined\" && window || typeof global !== \"undefined\" && global || self;\r\n\r\nObject.defineProperties(\r\n  globalScope[\"i8\"] = function i8(value) { return value << 24 >> 24; }\r\n, {\r\n  \"MIN_VALUE\": { value: -128, writable: false },\r\n  \"MAX_VALUE\": { value: 127, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"i16\"] = function i16(value) { return value << 16 >> 16; }\r\n, {\r\n  \"MIN_VALUE\": { value: -32768, writable: false },\r\n  \"MAX_VALUE\": { value: 32767, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"i32\"] = globalScope[\"isize\"] = function i32(value) { return value | 0; }\r\n, {\r\n  \"MIN_VALUE\": { value: -2147483648, writable: false },\r\n  \"MAX_VALUE\": { value: 2147483647, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"u8\"] = function u8(value) { return value & 0xff; }\r\n, {\r\n  \"MIN_VALUE\": { value: 0, writable: false },\r\n  \"MAX_VALUE\": { value: 255, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"u16\"] = function u16(value) { return value & 0xffff; }\r\n, {\r\n  \"MIN_VALUE\": { value: 0, writable: false },\r\n  \"MAX_VALUE\": { value: 65535, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"u32\"] = globalScope[\"usize\"] = function u32(value) { return value >>> 0; }\r\n, {\r\n  \"MIN_VALUE\": { value: 0, writable: false },\r\n  \"MAX_VALUE\": { value: 4294967295, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"bool\"] = function bool(value) { return !!value; }\r\n, {\r\n  \"MIN_VALUE\": { value: 0, writable: false },\r\n  \"MAX_VALUE\": { value: 1, writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"f32\"] = function f32(value) { return Math.fround(value); }\r\n, {\r\n  \"MIN_VALUE\": { value: Math.fround(-3.40282347e+38), writable: false },\r\n  \"MAX_VALUE\": { value: Math.fround(3.40282347e+38), writable: false },\r\n  \"MIN_SAFE_INTEGER\": { value: -16777215, writable: false },\r\n  \"MAX_SAFE_INTEGER\": { value: 16777215, writable: false },\r\n  \"EPSILON\": { value: Math.fround(1.19209290e-07), writable: false }\r\n});\r\n\r\nObject.defineProperties(\r\n  globalScope[\"f64\"] = function f64(value) { return +value; }\r\n, {\r\n  \"MIN_VALUE\": { value: -1.7976931348623157e+308, writable: false },\r\n  \"MAX_VALUE\": { value: 1.7976931348623157e+308, writable: false },\r\n  \"MIN_SAFE_INTEGER\": { value: -9007199254740991, writable: false },\r\n  \"MAX_SAFE_INTEGER\": { value: 9007199254740991, writable: false },\r\n  \"EPSILON\": { value: 2.2204460492503131e-16, writable: false }\r\n});\r\n\r\nglobalScope[\"clz\"] = Math.clz32;\r\n\r\nglobalScope[\"abs\"] = Math.abs;\r\n\r\nglobalScope[\"max\"] = Math.max;\r\n\r\nglobalScope[\"min\"] = Math.min;\r\n\r\nglobalScope[\"ceil\"] = Math.ceil;\r\n\r\nglobalScope[\"floor\"] = Math.floor;\r\n\r\nglobalScope[\"select\"] = function select(ifTrue, ifFalse, condition) {\r\n  return condition ? ifTrue : ifFalse;\r\n};\r\n\r\nglobalScope[\"sqrt\"] = Math.sqrt;\r\n\r\nglobalScope[\"trunc\"] = Math.trunc;\r\n\r\nglobalScope[\"bswap\"] = function bswap(value) {\r\n  var a = value >> 8 & 0x00FF00FF;\r\n  var b = (value & 0x00FF00FF) << 8;\r\n  value = a | b;\r\n  a = value >> 16 & 0x0000FFFF;\r\n  b = (value & 0x0000FFFF) << 16;\r\n  return a | b;\r\n};\r\n\r\nglobalScope[\"bswap16\"] = function bswap16(value) {\r\n  return ((value << 8) & 0xFF00) | ((value >> 8) & 0x00FF) | (value & 0xFFFF0000);\r\n};\r\n\r\nfunction UnreachableError() {\r\n  if (Error.captureStackTrace) {\r\n    Error.captureStackTrace(this, UnreachableError);\r\n  } else {\r\n    this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\r\n  }\r\n}\r\nUnreachableError.prototype = Object.create(Error.prototype);\r\nUnreachableError.prototype.name = \"UnreachableError\";\r\nUnreachableError.prototype.message = \"unreachable\";\r\n\r\nglobalScope[\"unreachable\"] = function unreachable() {\r\n  throw new UnreachableError();\r\n};\r\n\r\nfunction AssertionError(message) {\r\n  this.message = message || \"assertion failed\";\r\n  if (Error.captureStackTrace) {\r\n    Error.captureStackTrace(this, AssertionError);\r\n  } else {\r\n    this.stack = this.name + \": \" + this.message + \"\\n\" + new Error().stack;\r\n  }\r\n}\r\nAssertionError.prototype = Object.create(Error.prototype);\r\nAssertionError.prototype.name = \"AssertionError\";\r\n\r\nglobalScope[\"assert\"] = function assert(isTrueish, message) {\r\n  if (isTrueish) return isTrueish;\r\n  throw new AssertionError(message);\r\n};\r\n\r\nglobalScope[\"changetype\"] = function changetype(value) {\r\n  return value;\r\n};\r\n\r\nglobalScope[\"parseI32\"] = function parseI32(str, radix) {\r\n  return parseInt(str, undefined) | 0;\r\n};\r\n\r\nString[\"fromCharCodes\"] = function fromCharCodes(arr) {\r\n  return String.fromCharCode.apply(String, arr);\r\n};\r\n\r\nString[\"fromCodePoints\"] = function fromCodePoints(arr) {\r\n  return String.fromCodePoint.apply(String, arr);\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./std/portable.js\n// module id = 13\n// module chunks = 0","// Copy Binaryen exports to global scope\r\n\r\nconst binaryen = global.Binaryen || require(\"binaryen\");\r\n\r\nfor (var key in binaryen)\r\n  if (key.startsWith(\"_Binaryen\") || key.startsWith(\"_Relooper\"))\r\n    global[key] = binaryen[key];\r\n\r\n// Utilize Binaryen's heap\r\n\r\nglobal.allocate_memory = function(size) {\r\n  if (!size) return 0; // should be safe in our case\r\n  return binaryen._malloc(size);\r\n};\r\n\r\nglobal.free_memory = function(ptr) {\r\n  if (ptr) binaryen._free(ptr);\r\n};\r\n\r\nglobal.move_memory = function(dest, src, n) {\r\n  return binaryen._memmove(dest, src, n);\r\n};\r\n\r\nglobal.store = function(ptr, val) {\r\n  binaryen.HEAPU8[ptr] = val;\r\n};\r\n\r\nglobal.load = function(ptr) {\r\n  return binaryen.HEAPU8[ptr];\r\n};\r\n\r\n// Implement module stubs\r\n\r\nconst Module = require(\"../../module\").Module;\r\n\r\nModule.prototype.toText = function toText() {\r\n  var previousPrint = binaryen.print;\r\n  var ret = \"\";\r\n  binaryen.print = function(x) { ret += x + \"\\n\" };\r\n  _BinaryenModulePrint(this.ref);\r\n  binaryen.print = previousPrint;\r\n  return ret;\r\n};\r\n\r\nModule.prototype.toAsmjs = function toAsmjs() {\r\n  var previousPrint = binaryen.print;\r\n  var ret = \"\";\r\n  binaryen.print = function(x) { ret += x + \"\\n\" };\r\n  _BinaryenModulePrintAsmjs(this.ref);\r\n  binaryen.print = previousPrint;\r\n  return ret;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/glue/js/binaryen.js\n// module id = 14\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_15__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"binaryen\"\n// module id = 15\n// module chunks = 0","import {\r\n  Compiler,\r\n  ConversionKind,\r\n\r\n  makeSmallIntegerWrap\r\n} from \"./compiler\";\r\n\r\nimport {\r\n  DiagnosticCode\r\n} from \"./diagnostics\";\r\n\r\nimport {\r\n  Node,\r\n  Expression\r\n} from \"./ast\";\r\n\r\nimport {\r\n  Type,\r\n  TypeKind,\r\n  TypeFlags\r\n} from \"./types\";\r\n\r\nimport {\r\n  UnaryOp,\r\n  BinaryOp,\r\n  HostOp,\r\n  NativeType,\r\n  ExpressionRef,\r\n  ExpressionId\r\n} from \"./module\";\r\n\r\nimport {\r\n  Global,\r\n  FunctionPrototype,\r\n  Local,\r\n  ElementFlags,\r\n  Class,\r\n  ElementKind\r\n} from \"./program\";\r\n\r\n/** Compiles a get of a built-in global. */\r\nexport function compileGetConstant(\r\n  compiler: Compiler,\r\n  global: Global,\r\n  reportNode: Node\r\n): ExpressionRef {\r\n  switch (global.internalName) {\r\n\r\n    case \"NaN\": // context-sensitive\r\n      if (compiler.currentType == Type.f32) {\r\n        return compiler.module.createF32(NaN);\r\n      } else {\r\n        compiler.currentType = Type.f64;\r\n        return compiler.module.createF64(NaN);\r\n      }\r\n\r\n    case \"Infinity\": // context-sensitive\r\n      if (compiler.currentType == Type.f32) {\r\n        return compiler.module.createF32(Infinity);\r\n      } else {\r\n        compiler.currentType = Type.f64;\r\n        return compiler.module.createF64(Infinity);\r\n      }\r\n\r\n    case \"HEAP_BASE\": // never inlined for linking purposes\r\n      compiler.currentType = compiler.options.usizeType;\r\n      return compiler.module.createGetGlobal(\"HEAP_BASE\", compiler.currentType.toNativeType());\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_not_supported,\r\n    reportNode.range\r\n  );\r\n  return compiler.module.createUnreachable();\r\n}\r\n\r\n/** Compiles a call to a built-in function. */\r\nexport function compileCall(\r\n  compiler: Compiler,\r\n  prototype: FunctionPrototype,\r\n  typeArguments: Type[] | null,\r\n  operands: Expression[],\r\n  contextualType: Type,\r\n  reportNode: Node\r\n): ExpressionRef {\r\n  var module = compiler.module;\r\n\r\n  var arg0: ExpressionRef,\r\n      arg1: ExpressionRef,\r\n      arg2: ExpressionRef,\r\n      ret: ExpressionRef;\r\n\r\n  var tempLocal0: Local,\r\n      tempLocal1: Local;\r\n\r\n  var type: Type,\r\n      offset: i32;\r\n\r\n  // NOTE that some implementations below make use of the select expression where straight-forward.\r\n  // whether worth or not should probably be tested once/ it's known if/how embedders handle it.\r\n  // search: createSelect\r\n\r\n  switch (prototype.internalName) {\r\n\r\n    // math\r\n\r\n    case \"isNaN\": // isNaN<T?>(value: T) -> bool\r\n      compiler.currentType = Type.bool;\r\n      if (operands.length != 1) {\r\n        if (typeArguments && typeArguments.length != 1) {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.f64, ConversionKind.NONE);\r\n      }\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        case TypeKind.F32:\r\n          tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(Type.f32);\r\n          ret = module.createBinary(BinaryOp.NeF32,\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createGetLocal(tempLocal0.index, NativeType.F32)\r\n          );\r\n          break;\r\n\r\n        case TypeKind.F64:\r\n          tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(Type.f64);\r\n          ret = module.createBinary(BinaryOp.NeF64,\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createGetLocal(tempLocal0.index, NativeType.F64)\r\n          );\r\n          break;\r\n\r\n        case TypeKind.VOID:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n\r\n        default: // every other type is never NaN\r\n          ret = module.createI32(0);\r\n          break;\r\n\r\n      }\r\n      compiler.currentType = Type.bool;\r\n      return ret;\r\n\r\n    case \"isFinite\": // isFinite<T?>(value: T) -> bool\r\n      compiler.currentType = Type.bool;\r\n      if (operands.length != 1) {\r\n        if (typeArguments && typeArguments.length != 1) {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.f64, ConversionKind.NONE);\r\n      }\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        case TypeKind.F32:\r\n          tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(Type.f32);\r\n          ret = module.createSelect(\r\n            module.createBinary(BinaryOp.NeF32,\r\n              module.createUnary(UnaryOp.AbsF32,\r\n                module.createTeeLocal(tempLocal0.index, arg0)\r\n              ),\r\n              module.createF32(Infinity)\r\n            ),\r\n            module.createI32(0),\r\n            module.createBinary(BinaryOp.EqF32,\r\n              module.createGetLocal(tempLocal0.index, NativeType.F32),\r\n              module.createGetLocal(tempLocal0.index, NativeType.F32)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.F64:\r\n          tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(Type.f64);\r\n          ret = module.createSelect(\r\n            module.createBinary(BinaryOp.NeF64,\r\n              module.createUnary(UnaryOp.AbsF64,\r\n                module.createTeeLocal(tempLocal0.index, arg0)\r\n              ),\r\n              module.createF64(Infinity)\r\n            ),\r\n            module.createI32(0),\r\n            module.createBinary(BinaryOp.EqF64,\r\n              module.createGetLocal(tempLocal0.index, NativeType.F64),\r\n              module.createGetLocal(tempLocal0.index, NativeType.F64)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.VOID:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n\r\n        default: // every other type is always finite\r\n          ret = module.createI32(1);\r\n          break;\r\n      }\r\n      compiler.currentType = Type.bool;\r\n      return ret;\r\n\r\n    case \"clz\": // clz<T?>(value: T) -> T\r\n      if (operands.length != 1) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.i32, ConversionKind.NONE);\r\n      }\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        default: // any integer up to 32-bits incl. bool\r\n          ret = module.createUnary(UnaryOp.ClzI32, arg0);\r\n          break;\r\n\r\n        case TypeKind.USIZE:\r\n          if (compiler.currentType.isReference) {\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = module.createUnreachable();\r\n            break;\r\n          }\r\n          // fall-through\r\n        case TypeKind.ISIZE:\r\n          ret = module.createUnary(\r\n            compiler.options.isWasm64\r\n              ? UnaryOp.ClzI64\r\n              : UnaryOp.ClzI32,\r\n            arg0\r\n          );\r\n          break;\r\n\r\n        case TypeKind.I64:\r\n        case TypeKind.U64:\r\n          ret = module.createUnary(UnaryOp.ClzI64, arg0);\r\n          break;\r\n\r\n        case TypeKind.F32:\r\n        case TypeKind.F64:\r\n        case TypeKind.VOID:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"ctz\": // ctz<T?>(value: T) -> T\r\n      if (operands.length != 1) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.i32, ConversionKind.NONE);\r\n      }\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        default: // any integer up to 32-bits incl. bool\r\n          ret = module.createUnary(UnaryOp.CtzI32, arg0);\r\n          break;\r\n\r\n        case TypeKind.USIZE:\r\n          if (compiler.currentType.isReference) {\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = module.createUnreachable();\r\n            break;\r\n          }\r\n          // fall-through\r\n        case TypeKind.ISIZE:\r\n          ret = module.createUnary(\r\n            compiler.options.isWasm64\r\n              ? UnaryOp.CtzI64\r\n              : UnaryOp.CtzI32,\r\n            arg0\r\n          );\r\n          break;\r\n\r\n        case TypeKind.I64:\r\n        case TypeKind.U64:\r\n          ret = module.createUnary(UnaryOp.CtzI64, arg0);\r\n          break;\r\n\r\n        case TypeKind.F32:\r\n        case TypeKind.F64:\r\n        case TypeKind.VOID:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"popcnt\": // popcnt<T?>(value: T) -> T\r\n      if (operands.length != 1) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.i32, ConversionKind.NONE);\r\n      }\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        default: // any integer up to 32-bits incl. bool\r\n          ret = module.createUnary(UnaryOp.PopcntI32, arg0);\r\n          break;\r\n\r\n        case TypeKind.USIZE:\r\n          if (compiler.currentType.isReference) {\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = module.createUnreachable();\r\n            break;\r\n          }\r\n          // fall-through\r\n        case TypeKind.ISIZE:\r\n          ret = module.createUnary(\r\n            compiler.options.isWasm64\r\n              ? UnaryOp.PopcntI64\r\n              : UnaryOp.PopcntI32,\r\n            arg0\r\n          );\r\n          break;\r\n\r\n        case TypeKind.I64:\r\n        case TypeKind.U64:\r\n          ret = module.createUnary(UnaryOp.PopcntI64, arg0);\r\n          break;\r\n\r\n        case TypeKind.F32:\r\n        case TypeKind.F64:\r\n        case TypeKind.VOID:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"rotl\": // rotl<T?>(value: T, shift: T) -> T\r\n      if (operands.length != 2) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"2\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.i32, ConversionKind.NONE);\r\n      }\r\n      arg1 = compiler.compileExpression(operands[1], compiler.currentType);\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        case TypeKind.I8:\r\n        case TypeKind.I16:\r\n        case TypeKind.U8:\r\n        case TypeKind.U16:\r\n        case TypeKind.BOOL:\r\n          ret = makeSmallIntegerWrap(\r\n            module.createBinary(BinaryOp.RotlI32, arg0, arg1),\r\n            compiler.currentType,\r\n            module\r\n          );\r\n          // fall-through\r\n        case TypeKind.I32:\r\n        case TypeKind.U32:\r\n          ret = module.createBinary(BinaryOp.RotlI32, arg0, arg1);\r\n          break;\r\n\r\n        case TypeKind.USIZE:\r\n          if (compiler.currentType.isReference) {\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = module.createUnreachable();\r\n            break;\r\n          }\r\n          // fall-through\r\n        case TypeKind.ISIZE:\r\n          ret = module.createBinary(\r\n            compiler.options.isWasm64\r\n              ? BinaryOp.RotlI64\r\n              : BinaryOp.RotlI32,\r\n            arg0,\r\n            arg1\r\n          );\r\n          break;\r\n\r\n        case TypeKind.I64:\r\n        case TypeKind.U64:\r\n          ret = module.createBinary(BinaryOp.RotlI64, arg0, arg1);\r\n          break;\r\n\r\n        default:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"rotr\": // rotr<T?>(value: T, shift: T) -> T\r\n      if (operands.length != 2) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"2\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.i32, ConversionKind.NONE);\r\n      }\r\n      arg1 = compiler.compileExpression(operands[1], compiler.currentType);\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        case TypeKind.I8:\r\n        case TypeKind.I16:\r\n        case TypeKind.U8:\r\n        case TypeKind.U16:\r\n        case TypeKind.BOOL:\r\n          ret = makeSmallIntegerWrap(\r\n            module.createBinary(BinaryOp.RotrI32, arg0, arg1),\r\n            compiler.currentType,\r\n            module\r\n          );\r\n          break;\r\n\r\n        case TypeKind.I32:\r\n        case TypeKind.U32:\r\n          ret = module.createBinary(BinaryOp.RotrI32, arg0, arg1);\r\n          break;\r\n\r\n        case TypeKind.USIZE:\r\n          if (compiler.currentType.isReference) {\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = module.createUnreachable();\r\n            break;\r\n          }\r\n          // fall-through\r\n        case TypeKind.ISIZE:\r\n          ret = module.createBinary(\r\n            compiler.options.isWasm64\r\n              ? BinaryOp.RotrI64\r\n              : BinaryOp.RotrI32,\r\n            arg0,\r\n            arg1\r\n          );\r\n          break;\r\n\r\n        case TypeKind.I64:\r\n        case TypeKind.U64:\r\n          ret = module.createBinary(BinaryOp.RotrI64, arg0, arg1);\r\n          break;\r\n\r\n        default:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"abs\": // abs<T?>(value: T) -> T\r\n      if (operands.length != 1) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.f64, ConversionKind.NONE);\r\n      }\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        case TypeKind.I8:\r\n        case TypeKind.I16:\r\n          // doesn't need sign-extension here because ifFalse below is either positive\r\n          // or MIN_VALUE (-MIN_VALUE == MIN_VALUE) if selected\r\n        case TypeKind.I32:\r\n          tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(Type.i32);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createBinary(BinaryOp.SubI32, // ifFalse\r\n              module.createI32(0),\r\n              module.createGetLocal(tempLocal0.index, NativeType.I32)\r\n            ),\r\n            module.createBinary(BinaryOp.GtI32,\r\n              module.createGetLocal(tempLocal0.index, NativeType.I32),\r\n              module.createI32(0)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.ISIZE:\r\n          tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(compiler.options.usizeType);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createBinary(\r\n              compiler.options.isWasm64\r\n                ? BinaryOp.SubI64\r\n                : BinaryOp.SubI32,\r\n              compiler.options.usizeType.toNativeZero(module),\r\n              module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType)\r\n            ),\r\n            module.createBinary(\r\n              compiler.options.isWasm64\r\n                ? BinaryOp.GtI64\r\n                : BinaryOp.GtI32,\r\n              module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType),\r\n              compiler.options.usizeType.toNativeZero(module)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.I64:\r\n          tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(Type.i64);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createBinary(BinaryOp.SubI64,\r\n              module.createI64(0, 0),\r\n              module.createGetLocal(tempLocal0.index, NativeType.I64),\r\n            ),\r\n            module.createBinary(BinaryOp.GtI64,\r\n              module.createGetLocal(tempLocal0.index, NativeType.I64),\r\n              module.createI64(0, 0)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.USIZE:\r\n          if (compiler.currentType.isReference) {\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = module.createUnreachable();\r\n            break;\r\n          }\r\n          // fall-through\r\n        case TypeKind.U8:\r\n        case TypeKind.U16:\r\n        case TypeKind.U32:\r\n        case TypeKind.U64:\r\n        case TypeKind.BOOL:\r\n          ret = arg0;\r\n          break;\r\n\r\n        case TypeKind.F32:\r\n          ret = module.createUnary(UnaryOp.AbsF32, arg0);\r\n          break;\r\n\r\n        case TypeKind.F64:\r\n          ret = module.createUnary(UnaryOp.AbsF64, arg0);\r\n          break;\r\n\r\n        case TypeKind.VOID:\r\n          ret = module.createUnreachable();\r\n          break;\r\n\r\n        default: // void\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"max\": // max<T?>(left: T, right: T) -> T\r\n      if (operands.length != 2) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"2\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.f64, ConversionKind.NONE);\r\n      }\r\n      arg1 = compiler.compileExpression(operands[1], compiler.currentType);\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        case TypeKind.I8:\r\n        case TypeKind.I16:\r\n        case TypeKind.I32:\r\n          tempLocal0 = compiler.currentFunction.getTempLocal(Type.i32);\r\n          tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(Type.i32);\r\n          compiler.currentFunction.freeTempLocal(tempLocal0);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createTeeLocal(tempLocal1.index, arg1),\r\n            module.createBinary(BinaryOp.GtI32,\r\n              module.createGetLocal(tempLocal0.index, NativeType.I32),\r\n              module.createGetLocal(tempLocal1.index, NativeType.I32)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.U8:\r\n        case TypeKind.U16:\r\n        case TypeKind.U32:\r\n        case TypeKind.BOOL:\r\n          tempLocal0 = compiler.currentFunction.getTempLocal(Type.i32);\r\n          tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(Type.i32);\r\n          compiler.currentFunction.freeTempLocal(tempLocal0);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createTeeLocal(tempLocal1.index, arg1),\r\n            module.createBinary(BinaryOp.GtU32,\r\n              module.createGetLocal(tempLocal0.index, NativeType.I32),\r\n              module.createGetLocal(tempLocal1.index, NativeType.I32)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.I64:\r\n          tempLocal0 = compiler.currentFunction.getTempLocal(Type.i64);\r\n          tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(Type.i64);\r\n          compiler.currentFunction.freeTempLocal(tempLocal0);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createTeeLocal(tempLocal1.index, arg1),\r\n            module.createBinary(BinaryOp.GtI64,\r\n              module.createGetLocal(tempLocal0.index, NativeType.I64),\r\n              module.createGetLocal(tempLocal1.index, NativeType.I64)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.U64:\r\n          tempLocal0 = compiler.currentFunction.getTempLocal(Type.i64);\r\n          tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(Type.i64);\r\n          compiler.currentFunction.freeTempLocal(tempLocal0);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createTeeLocal(tempLocal1.index, arg1),\r\n            module.createBinary(BinaryOp.GtU64,\r\n              module.createGetLocal(tempLocal0.index, NativeType.I64),\r\n              module.createGetLocal(tempLocal1.index, NativeType.I64)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.ISIZE:\r\n          tempLocal0 = compiler.currentFunction.getTempLocal(compiler.options.usizeType);\r\n          tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(compiler.options.usizeType);\r\n          compiler.currentFunction.freeTempLocal(tempLocal0);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createTeeLocal(tempLocal1.index, arg1),\r\n            module.createBinary(\r\n              compiler.options.isWasm64\r\n                ? BinaryOp.GtI64\r\n                : BinaryOp.GtI32,\r\n              module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType),\r\n              module.createGetLocal(tempLocal1.index, compiler.options.nativeSizeType)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.USIZE:\r\n          if (compiler.currentType.isReference) {\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = module.createUnreachable();\r\n            break;\r\n          }\r\n          tempLocal0 = compiler.currentFunction.getTempLocal(compiler.options.usizeType);\r\n          tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(compiler.options.usizeType);\r\n          compiler.currentFunction.freeTempLocal(tempLocal0);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createTeeLocal(tempLocal1.index, arg1),\r\n            module.createBinary(\r\n              compiler.options.isWasm64\r\n                ? BinaryOp.GtU64\r\n                : BinaryOp.GtU32,\r\n              module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType),\r\n              module.createGetLocal(tempLocal1.index, compiler.options.nativeSizeType)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.F32:\r\n          ret = module.createBinary(BinaryOp.MaxF32, arg0, arg1);\r\n          break;\r\n\r\n        case TypeKind.F64:\r\n          ret = module.createBinary(BinaryOp.MaxF64, arg0, arg1);\r\n          break;\r\n\r\n        default: // void\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"min\": // min<T?>(left: T, right: T) -> T\r\n      if (operands.length != 2) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"2\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.f64, ConversionKind.NONE);\r\n      }\r\n      arg1 = compiler.compileExpression(operands[1], compiler.currentType);\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        case TypeKind.I8:\r\n        case TypeKind.I16:\r\n        case TypeKind.I32:\r\n          tempLocal0 = compiler.currentFunction.getTempLocal(Type.i32);\r\n          tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(Type.i32);\r\n          compiler.currentFunction.freeTempLocal(tempLocal0);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createTeeLocal(tempLocal1.index, arg1),\r\n            module.createBinary(BinaryOp.LtI32,\r\n              module.createGetLocal(tempLocal0.index, NativeType.I32),\r\n              module.createGetLocal(tempLocal1.index, NativeType.I32)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.U8:\r\n        case TypeKind.U16:\r\n        case TypeKind.U32:\r\n        case TypeKind.BOOL:\r\n          tempLocal0 = compiler.currentFunction.getTempLocal(Type.i32);\r\n          tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(Type.i32);\r\n          compiler.currentFunction.freeTempLocal(tempLocal0);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createTeeLocal(tempLocal1.index, arg1),\r\n            module.createBinary(BinaryOp.LtU32,\r\n              module.createGetLocal(tempLocal0.index, NativeType.I32),\r\n              module.createGetLocal(tempLocal1.index, NativeType.I32)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.I64:\r\n          tempLocal0 = compiler.currentFunction.getTempLocal(Type.i64);\r\n          tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(Type.i64);\r\n          compiler.currentFunction.freeTempLocal(tempLocal0);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createTeeLocal(tempLocal1.index, arg1),\r\n            module.createBinary(BinaryOp.LtI64,\r\n              module.createGetLocal(tempLocal0.index, NativeType.I64),\r\n              module.createGetLocal(tempLocal1.index, NativeType.I64)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.U64:\r\n          tempLocal0 = compiler.currentFunction.getTempLocal(Type.i64);\r\n          tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(Type.i64);\r\n          compiler.currentFunction.freeTempLocal(tempLocal0);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createTeeLocal(tempLocal1.index, arg1),\r\n            module.createBinary(BinaryOp.LtU64,\r\n              module.createGetLocal(tempLocal0.index, NativeType.I64),\r\n              module.createGetLocal(tempLocal1.index, NativeType.I64)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.ISIZE:\r\n          tempLocal0 = compiler.currentFunction.getTempLocal(compiler.options.usizeType);\r\n          tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(compiler.options.usizeType);\r\n          compiler.currentFunction.freeTempLocal(tempLocal0);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createTeeLocal(tempLocal1.index, arg1),\r\n            module.createBinary(\r\n              compiler.options.isWasm64\r\n                ? BinaryOp.LtI64\r\n                : BinaryOp.LtI32,\r\n              module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType),\r\n              module.createGetLocal(tempLocal1.index, compiler.options.nativeSizeType)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.USIZE:\r\n          if (compiler.currentType.isReference) {\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = module.createUnreachable();\r\n            break;\r\n          }\r\n          tempLocal0 = compiler.currentFunction.getTempLocal(compiler.options.usizeType);\r\n          tempLocal1 = compiler.currentFunction.getAndFreeTempLocal(compiler.options.usizeType);\r\n          compiler.currentFunction.freeTempLocal(tempLocal0);\r\n          ret = module.createSelect(\r\n            module.createTeeLocal(tempLocal0.index, arg0),\r\n            module.createTeeLocal(tempLocal1.index, arg1),\r\n            module.createBinary(\r\n              compiler.options.isWasm64\r\n                ? BinaryOp.LtU64\r\n                : BinaryOp.LtU32,\r\n              module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType),\r\n              module.createGetLocal(tempLocal1.index, compiler.options.nativeSizeType)\r\n            )\r\n          );\r\n          break;\r\n\r\n        case TypeKind.F32:\r\n          ret = module.createBinary(BinaryOp.MinF32, arg0, arg1);\r\n          break;\r\n\r\n        case TypeKind.F64:\r\n          ret = module.createBinary(BinaryOp.MinF64, arg0, arg1);\r\n          break;\r\n\r\n        default: // void\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"ceil\": // ceil<T?>(value: T) -> T\r\n      if (operands.length != 1) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.f64, ConversionKind.NONE);\r\n      }\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        case TypeKind.USIZE:\r\n          if (compiler.currentType.isReference) {\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = module.createUnreachable();\r\n            break;\r\n          }\r\n          // fall-through\r\n        default: // any integer\r\n          ret = arg0;\r\n          break;\r\n\r\n        case TypeKind.F32:\r\n          ret = module.createUnary(UnaryOp.CeilF32, arg0);\r\n          break;\r\n\r\n        case TypeKind.F64:\r\n          ret = module.createUnary(UnaryOp.CeilF64, arg0);\r\n          break;\r\n\r\n        case TypeKind.VOID:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"floor\": // floor<T?>(value: T) -> T\r\n      if (operands.length != 1) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.f64, ConversionKind.NONE);\r\n      }\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        case TypeKind.USIZE:\r\n          if (compiler.currentType.isReference) {\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = module.createUnreachable();\r\n            break;\r\n          }\r\n          // fall-through\r\n        default: // any integer\r\n          ret = arg0;\r\n          break;\r\n\r\n        case TypeKind.F32:\r\n          ret = module.createUnary(UnaryOp.FloorF32, arg0);\r\n          break;\r\n\r\n        case TypeKind.F64:\r\n          ret = module.createUnary(UnaryOp.FloorF64, arg0);\r\n          break;\r\n\r\n        case TypeKind.VOID:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"copysign\": // copysign<T?>(left: T, right: T) -> T\r\n      if (operands.length != 2) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"2\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.f64, ConversionKind.NONE);\r\n      }\r\n      arg1 = compiler.compileExpression(operands[1], compiler.currentType);\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        // TODO: does an integer version make sense?\r\n\r\n        case TypeKind.F32:\r\n          ret = module.createBinary(BinaryOp.CopysignF32, arg0, arg1);\r\n          break;\r\n\r\n        case TypeKind.F64:\r\n          ret = module.createBinary(BinaryOp.CopysignF64, arg0, arg1);\r\n          break;\r\n\r\n        default:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"nearest\": // nearest<T?>(value: T) -> T\r\n      if (operands.length != 1) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.f64, ConversionKind.NONE);\r\n      }\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        case TypeKind.USIZE:\r\n          if (compiler.currentType.isReference) {\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = module.createUnreachable();\r\n            break;\r\n          }\r\n          // fall-through\r\n        default: // any integer\r\n          ret = arg0;\r\n          break;\r\n\r\n        case TypeKind.F32:\r\n          ret = module.createUnary(UnaryOp.NearestF32, arg0);\r\n          break;\r\n\r\n        case TypeKind.F64:\r\n          ret = module.createUnary(UnaryOp.NearestF64, arg0);\r\n          break;\r\n\r\n        case TypeKind.VOID:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"reinterpret\": // reinterpret<T!>(value: *) -> T\r\n      if (operands.length != 1) {\r\n        if (!(typeArguments && typeArguments.length == 1)) {\r\n          if (typeArguments && typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\"\r\n          );\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (!(typeArguments && typeArguments.length == 1)) {\r\n        if (typeArguments && typeArguments.length) compiler.currentType = typeArguments[0];\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n          reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\"\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n\r\n      switch (typeArguments[0].kind) {\r\n\r\n        case TypeKind.I32:\r\n        case TypeKind.U32:\r\n          arg0 = compiler.compileExpression(operands[0], Type.f32);\r\n          ret = module.createUnary(UnaryOp.ReinterpretF32, arg0);\r\n          break;\r\n\r\n        case TypeKind.I64:\r\n        case TypeKind.U64:\r\n          arg0 = compiler.compileExpression(operands[0], Type.f64);\r\n          ret = module.createUnary(UnaryOp.ReinterpretF64, arg0);\r\n          break;\r\n\r\n        case TypeKind.USIZE:\r\n          if (typeArguments[0].isReference) {\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            compiler.currentType = typeArguments[0];\r\n            return module.createUnreachable();\r\n          }\r\n          // fall-through\r\n        case TypeKind.ISIZE:\r\n          arg0 = compiler.compileExpression(\r\n            operands[0],\r\n            compiler.options.isWasm64\r\n              ? Type.f64\r\n              : Type.f32\r\n            );\r\n          ret = module.createUnary(\r\n            compiler.options.isWasm64\r\n              ? UnaryOp.ReinterpretF64\r\n              : UnaryOp.ReinterpretF32,\r\n            arg0\r\n          );\r\n          break;\r\n\r\n        case TypeKind.F32:\r\n          arg0 = compiler.compileExpression(operands[0], Type.u32);\r\n          ret = module.createUnary(UnaryOp.ReinterpretI32, arg0);\r\n          break;\r\n\r\n        case TypeKind.F64:\r\n          arg0 = compiler.compileExpression(operands[0], Type.u64);\r\n          ret = module.createUnary(UnaryOp.ReinterpretI64, arg0);\r\n          break;\r\n\r\n        default: // small integers and void\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      compiler.currentType = typeArguments[0];\r\n      return ret;\r\n\r\n    case \"sqrt\": // sqrt<T?>(value: T) -> T\r\n      if (operands.length != 1) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.f64, ConversionKind.NONE);\r\n      }\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        // TODO: integer versions (that return f64 or convert)?\r\n\r\n        case TypeKind.F32:\r\n          ret = module.createUnary(UnaryOp.SqrtF32, arg0);\r\n          break;\r\n\r\n        case TypeKind.F64:\r\n          ret = module.createUnary(UnaryOp.SqrtF64, arg0);\r\n          break;\r\n\r\n        default:\r\n        // case TypeKind.VOID:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"trunc\": // trunc<T?>(value: T) -> T\r\n      if (operands.length != 1) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments && typeArguments.length) {\r\n        compiler.currentType = typeArguments[0];\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.f64, ConversionKind.NONE);\r\n      }\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        case TypeKind.USIZE:\r\n          if (compiler.currentType.isReference) {\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = module.createUnreachable();\r\n            break;\r\n          }\r\n          // fall-through\r\n        default: // any integer\r\n          ret = arg0;\r\n          break;\r\n\r\n        // TODO: truncate to contextual type directly (if not void etc.)?\r\n\r\n        case TypeKind.F32:\r\n          ret = module.createUnary(UnaryOp.TruncF32, arg0);\r\n          break;\r\n\r\n        case TypeKind.F64:\r\n          ret = module.createUnary(UnaryOp.TruncF64, arg0);\r\n          break;\r\n\r\n        case TypeKind.VOID:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    // memory access\r\n\r\n    case \"load\": // load<T!>(offset: usize, constantOffset?: usize) -> *\r\n      if (operands.length < 1 || operands.length > 2) {\r\n        if (!(typeArguments && typeArguments.length == 1)) {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\"\r\n          );\r\n        }\r\n        if (operands.length < 1) {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\r\n            reportNode.range, \"1\", operands.length.toString(10)\r\n          );\r\n        } else {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_arguments_but_got_1,\r\n            reportNode.range, \"2\", operands.length.toString(10)\r\n          );\r\n        }\r\n        return module.createUnreachable();\r\n      }\r\n      if (!(typeArguments && typeArguments.length == 1)) {\r\n        if (typeArguments && typeArguments.length) compiler.currentType = typeArguments[0];\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n          reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\"\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType);\r\n      offset = operands.length == 2 ? evaluateConstantOffset(compiler, operands[1]) : 0; // reports\r\n      if (offset < 0) { // reported in evaluateConstantOffset\r\n        return module.createUnreachable();\r\n      }\r\n      return module.createLoad(\r\n        typeArguments[0].byteSize,\r\n        typeArguments[0].is(TypeFlags.SIGNED | TypeFlags.INTEGER),\r\n        arg0,\r\n        typeArguments[0].is(TypeFlags.INTEGER) &&\r\n        contextualType.is(TypeFlags.INTEGER) &&\r\n        contextualType.size >= typeArguments[0].size\r\n          ? (compiler.currentType = contextualType).toNativeType()\r\n          : (compiler.currentType = typeArguments[0]).toNativeType(),\r\n        offset\r\n      );\r\n\r\n    case \"store\": // store<T!>(offset: usize, value: *, constantOffset?: usize) -> void\r\n      compiler.currentType = Type.void;\r\n      if (operands.length < 2 || operands.length > 3) {\r\n        if (!(typeArguments && typeArguments.length == 1)) {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\"\r\n          );\r\n        }\r\n        if (operands.length < 2) {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\r\n            reportNode.range, \"2\", operands.length.toString(10)\r\n          );\r\n        } else {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_arguments_but_got_1,\r\n            reportNode.range, \"3\", operands.length.toString(10)\r\n          );\r\n        }\r\n        return module.createUnreachable();\r\n      }\r\n      if (!(typeArguments && typeArguments.length == 1)) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n          reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\"\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType);\r\n      arg1 = compiler.compileExpression(\r\n        operands[1],\r\n        typeArguments[0],\r\n        typeArguments[0].is(TypeFlags.INTEGER)\r\n          ? ConversionKind.NONE // wraps a larger integer type to a smaller one, i.e. i32.store8\r\n          : ConversionKind.IMPLICIT\r\n      );\r\n      if (\r\n        compiler.currentType.is(TypeFlags.INTEGER) &&\r\n        typeArguments[0].is(TypeFlags.INTEGER) &&\r\n        typeArguments[0].size > compiler.currentType.size\r\n      ) {\r\n        arg1 = compiler.convertExpression(\r\n          arg1,\r\n          compiler.currentType, typeArguments[0],\r\n          ConversionKind.IMPLICIT,\r\n          operands[1]\r\n        );\r\n        type = typeArguments[0];\r\n      } else {\r\n        type = compiler.currentType;\r\n      }\r\n      offset = operands.length == 3 ? evaluateConstantOffset(compiler, operands[2]) : 0; // reports\r\n      if (offset < 0) { // reported in evaluateConstantOffset\r\n        return module.createUnreachable();\r\n      }\r\n      compiler.currentType = Type.void;\r\n      return module.createStore(typeArguments[0].byteSize, arg0, arg1, type.toNativeType(), offset);\r\n\r\n    case \"sizeof\": // sizeof<T!>() -> usize\r\n      compiler.currentType = compiler.options.usizeType;\r\n      if (operands.length != 0) {\r\n        if (!(typeArguments && typeArguments.length == 1)) {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\"\r\n          );\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"0\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        ret = compiler.options.isWasm64\r\n          ? module.createI64(typeArguments[0].byteSize, 0)\r\n          : module.createI32(typeArguments[0].byteSize);\r\n      } else {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n          reportNode.range, \"1\", \"0\"\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      return ret;\r\n\r\n    // control flow\r\n\r\n    case \"select\": // select<T?>(ifTrue: T, ifFalse: T, condition: bool) -> T\r\n      if (operands.length != 3) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"3\", operands.length.toString(10)\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length != 1) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0];\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.i32, ConversionKind.NONE);\r\n      }\r\n      arg1 = compiler.compileExpression(operands[1], type = compiler.currentType);\r\n      arg2 = compiler.compileExpression(operands[2], Type.bool);\r\n      compiler.currentType = type;\r\n\r\n      switch (compiler.currentType.kind) {\r\n\r\n        default: // any value type\r\n          ret = module.createSelect(arg0, arg1, arg2);\r\n          break;\r\n\r\n        case TypeKind.VOID:\r\n          compiler.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            reportNode.range\r\n          );\r\n          ret = module.createUnreachable();\r\n          break;\r\n      }\r\n      return ret;\r\n\r\n    case \"unreachable\": // unreachable() -> *\r\n      if (operands.length != 0) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"0\", operands.length.toString(10)\r\n        );\r\n      }\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      return module.createUnreachable();\r\n\r\n    // host operations\r\n\r\n    case \"current_memory\": // current_memory() -> i32\r\n      compiler.currentType = Type.i32;\r\n      if (operands.length != 0) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"0\", operands.length.toString(10)\r\n        );\r\n      }\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      return module.createHost(HostOp.CurrentMemory);\r\n\r\n    case \"grow_memory\": // grow_memory(pages: i32) -> i32\r\n      compiler.currentType = Type.i32;\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"0\", operands.length.toString(10)\r\n        );\r\n        arg0 = module.createUnreachable();\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.i32);\r\n      }\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      return module.createHost(HostOp.GrowMemory, null, [ arg0 ]);\r\n\r\n    // see: https://github.com/WebAssembly/bulk-memory-operations\r\n    case \"move_memory\": // move_memory(dest: usize, src: usize: n: usize) -> void\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 3) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"3\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = Type.void;\r\n        return module.createUnreachable();\r\n      }\r\n      arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType);\r\n      arg1 = compiler.compileExpression(operands[1], compiler.options.usizeType);\r\n      arg2 = compiler.compileExpression(operands[2], compiler.options.usizeType);\r\n      compiler.currentType = Type.void;\r\n      throw new Error(\"not implemented\");\r\n      // return module.createHost(HostOp.MoveMemory, null, [ arg0, arg1, arg2 ]);\r\n\r\n    case \"set_memory\": // set_memory(dest: usize, value: u32, n: usize) -> void\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 3) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"3\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = Type.void;\r\n        return module.createUnreachable();\r\n      }\r\n      arg0 = compiler.compileExpression(operands[0], compiler.options.usizeType);\r\n      arg1 = compiler.compileExpression(operands[1], Type.u32);\r\n      arg2 = compiler.compileExpression(operands[2], compiler.options.usizeType);\r\n      compiler.currentType = Type.void;\r\n      throw new Error(\"not implemented\");\r\n      // return module.createHost(HostOp.SetMemory, null, [ arg0, arg1, arg2 ]);\r\n\r\n    // other\r\n\r\n    case \"changetype\": // changetype<T!>(value: *) -> T\r\n      if (!(typeArguments && typeArguments.length == 1)) {\r\n        if (typeArguments && typeArguments.length) compiler.currentType = typeArguments[0];\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n          reportNode.range, \"1\", typeArguments ? typeArguments.length.toString(10) : \"0\"\r\n        );\r\n        return module.createUnreachable();\r\n      } else if (typeArguments[0].kind != TypeKind.USIZE) { // any usize\r\n        compiler.error(\r\n          DiagnosticCode.Operation_not_supported,\r\n          reportNode.range\r\n        );\r\n        compiler.currentType = typeArguments[0];\r\n        return module.createUnreachable();\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = typeArguments[0];\r\n        return module.createUnreachable();\r\n      }\r\n      arg0 = compiler.compileExpression(\r\n        operands[0],\r\n        compiler.options.usizeType,\r\n        ConversionKind.NONE\r\n      );\r\n      compiler.currentType = typeArguments[0];\r\n      if (compiler.currentType.kind != TypeKind.USIZE) {\r\n        compiler.error(\r\n          DiagnosticCode.Operation_not_supported,\r\n          reportNode.range\r\n        );\r\n        return module.createUnreachable();\r\n      }\r\n      // if (reportNode.range.source.sourceKind != SourceKind.STDLIB)\r\n      //  compiler.warning(DiagnosticCode.Operation_is_unsafe, reportNode.range);\r\n      return arg0; // any usize to any usize\r\n\r\n    case \"assert\": // assert<T?>(isTrueish: T, message?: string) -> T with T != null\r\n      if (operands.length < 1 || operands.length > 2) {\r\n        if (typeArguments) {\r\n          if (typeArguments.length) compiler.currentType = typeArguments[0].nonNullableType;\r\n          if (typeArguments.length != 1) {\r\n            compiler.error(\r\n              DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n              reportNode.range, \"1\", typeArguments.length.toString(10)\r\n            );\r\n          }\r\n        }\r\n        if (operands.length < 1) {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_at_least_0_arguments_but_got_1,\r\n            reportNode.range, \"1\", operands.length.toString(10)\r\n          );\r\n        } else if (operands.length > 2) {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_arguments_but_got_1,\r\n            reportNode.range, \"2\", operands.length.toString(10)\r\n          );\r\n        }\r\n        return module.createUnreachable();\r\n      }\r\n      if (typeArguments) {\r\n        if (typeArguments.length) compiler.currentType = typeArguments[0].nonNullableType;\r\n        if (typeArguments.length != 1) {\r\n          compiler.error(\r\n            DiagnosticCode.Expected_0_type_arguments_but_got_1,\r\n            reportNode.range, \"1\", typeArguments.length.toString(10)\r\n          );\r\n          return module.createUnreachable();\r\n        }\r\n        arg0 = compiler.compileExpression(operands[0], typeArguments[0]);\r\n      } else {\r\n        arg0 = compiler.compileExpression(operands[0], Type.i32, ConversionKind.NONE);\r\n      }\r\n\r\n      type = compiler.currentType;\r\n      compiler.currentType = type.nonNullableType;\r\n\r\n      // just return ifTrueish if assertions are disabled, or simplify if dropped anyway\r\n      if (compiler.options.noAssert) {\r\n        if (contextualType == Type.void) {\r\n          compiler.currentType = Type.void;\r\n          return module.createNop();\r\n        }\r\n        return arg0;\r\n      }\r\n\r\n      var abort = compileAbort(compiler, operands.length == 2 ? operands[1] : null, reportNode);\r\n\r\n      compiler.currentType = type.nonNullableType;\r\n\r\n      if (contextualType == Type.void) { // simplify if dropped anyway\r\n        switch (compiler.currentType.kind) {\r\n\r\n          default: // any integer up to 32-bits incl. bool\r\n            ret = module.createIf(\r\n              module.createUnary(UnaryOp.EqzI32,\r\n                arg0\r\n              ),\r\n              abort\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            ret = module.createIf(\r\n              module.createUnary(UnaryOp.EqzI64,\r\n                arg0\r\n              ),\r\n              abort\r\n            );\r\n            break;\r\n\r\n          case TypeKind.ISIZE:\r\n          case TypeKind.USIZE:\r\n            ret = module.createIf(\r\n              module.createUnary(\r\n                compiler.options.isWasm64\r\n                  ? UnaryOp.EqzI64\r\n                  : UnaryOp.EqzI32,\r\n                arg0\r\n              ),\r\n              abort\r\n            );\r\n            break;\r\n\r\n          // TODO: also check for NaN in float assertions, as in `Boolean(NaN) -> false`?\r\n\r\n          case TypeKind.F32:\r\n            ret = module.createIf(\r\n              module.createBinary(BinaryOp.EqF32,\r\n                arg0,\r\n                module.createF32(0)\r\n              ),\r\n              abort\r\n            );\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            ret = module.createIf(\r\n              module.createBinary(BinaryOp.EqF64,\r\n                arg0,\r\n                module.createF64(0)\r\n              ),\r\n              abort\r\n            );\r\n            break;\r\n\r\n          case TypeKind.VOID:\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = abort;\r\n            break;\r\n        }\r\n        compiler.currentType = Type.void;\r\n      } else {\r\n        switch (compiler.currentType.kind) {\r\n\r\n          default: // any integer up to 32-bits incl. bool\r\n            tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(Type.i32);\r\n            ret = module.createIf(\r\n              module.createUnary(UnaryOp.EqzI32,\r\n                module.createTeeLocal(tempLocal0.index, arg0)\r\n              ),\r\n              abort,\r\n              module.createGetLocal(tempLocal0.index, NativeType.I32)\r\n            );\r\n            break;\r\n\r\n          case TypeKind.I64:\r\n          case TypeKind.U64:\r\n            tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(Type.i64);\r\n            ret = module.createIf(\r\n              module.createUnary(UnaryOp.EqzI64,\r\n                module.createTeeLocal(tempLocal0.index, arg0)\r\n              ),\r\n              abort,\r\n              module.createGetLocal(tempLocal0.index, NativeType.I64)\r\n            );\r\n            break;\r\n\r\n          case TypeKind.ISIZE:\r\n          case TypeKind.USIZE:\r\n            tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(compiler.options.usizeType);\r\n            ret = module.createIf(\r\n              module.createUnary(\r\n                compiler.options.isWasm64\r\n                  ? UnaryOp.EqzI64\r\n                  : UnaryOp.EqzI32,\r\n                module.createTeeLocal(tempLocal0.index, arg0)\r\n              ),\r\n              abort,\r\n              module.createGetLocal(tempLocal0.index, compiler.options.nativeSizeType)\r\n            );\r\n            break;\r\n\r\n          case TypeKind.F32:\r\n            tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(Type.f32);\r\n            ret = module.createIf(\r\n              module.createBinary(BinaryOp.EqF32,\r\n                module.createTeeLocal(tempLocal0.index, arg0),\r\n                module.createF32(0)\r\n              ),\r\n              abort,\r\n              module.createGetLocal(tempLocal0.index, NativeType.F32)\r\n            );\r\n            break;\r\n\r\n          case TypeKind.F64:\r\n            tempLocal0 = compiler.currentFunction.getAndFreeTempLocal(Type.f64);\r\n            ret = module.createIf(\r\n              module.createBinary(BinaryOp.EqF64,\r\n                module.createTeeLocal(tempLocal0.index, arg0),\r\n                module.createF64(0)\r\n              ),\r\n              abort,\r\n              module.createGetLocal(tempLocal0.index, NativeType.F64)\r\n            );\r\n            break;\r\n\r\n          case TypeKind.VOID:\r\n            compiler.error(\r\n              DiagnosticCode.Operation_not_supported,\r\n              reportNode.range\r\n            );\r\n            ret = abort;\r\n            break;\r\n        }\r\n      }\r\n      return ret;\r\n\r\n    // conversions\r\n\r\n    case \"i8\":\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = Type.i8;\r\n        return module.createUnreachable();\r\n      }\r\n      return compiler.compileExpression(operands[0], Type.i8, ConversionKind.EXPLICIT);\r\n\r\n    case \"i16\":\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = Type.i16;\r\n        return module.createUnreachable();\r\n      }\r\n      return compiler.compileExpression(operands[0], Type.i16, ConversionKind.EXPLICIT);\r\n\r\n    case \"i32\":\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = Type.i32;\r\n        return module.createUnreachable();\r\n      }\r\n      return compiler.compileExpression(operands[0], Type.i32, ConversionKind.EXPLICIT);\r\n\r\n    case \"i64\":\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = Type.i64;\r\n        return module.createUnreachable();\r\n      }\r\n      return compiler.compileExpression(operands[0], Type.i64, ConversionKind.EXPLICIT);\r\n\r\n    case \"isize\":\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = compiler.options.isWasm64\r\n          ? Type.isize64\r\n          : Type.isize32;\r\n        return module.createUnreachable();\r\n      }\r\n      return compiler.compileExpression(\r\n        operands[0],\r\n        compiler.options.isWasm64\r\n          ? Type.isize64\r\n          : Type.isize32,\r\n        ConversionKind.EXPLICIT\r\n      );\r\n\r\n    case \"u8\":\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = Type.u8;\r\n        return module.createUnreachable();\r\n      }\r\n      return compiler.compileExpression(operands[0], Type.u8, ConversionKind.EXPLICIT);\r\n\r\n    case \"u16\":\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = Type.u16;\r\n        return module.createUnreachable();\r\n      }\r\n      return compiler.compileExpression(operands[0], Type.u16, ConversionKind.EXPLICIT);\r\n\r\n    case \"u32\":\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = Type.u32;\r\n        return module.createUnreachable();\r\n      }\r\n      return compiler.compileExpression(operands[0], Type.u32, ConversionKind.EXPLICIT);\r\n\r\n    case \"u64\":\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = Type.u64;\r\n        return module.createUnreachable();\r\n      }\r\n      return compiler.compileExpression(operands[0], Type.u64, ConversionKind.EXPLICIT);\r\n\r\n    case \"usize\":\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = compiler.options.usizeType;\r\n        return module.createUnreachable();\r\n      }\r\n      return compiler.compileExpression(\r\n        operands[0],\r\n        compiler.options.usizeType,\r\n        ConversionKind.EXPLICIT\r\n      );\r\n\r\n    case \"bool\":\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = Type.bool;\r\n        return module.createUnreachable();\r\n      }\r\n      return compiler.compileExpression(operands[0], Type.bool, ConversionKind.EXPLICIT);\r\n\r\n    case \"f32\":\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = Type.f32;\r\n        return module.createUnreachable();\r\n      }\r\n      return compiler.compileExpression(operands[0], Type.f32, ConversionKind.EXPLICIT);\r\n\r\n    case \"f64\":\r\n      if (typeArguments) {\r\n        compiler.error(\r\n          DiagnosticCode.Type_0_is_not_generic,\r\n          reportNode.range, prototype.internalName\r\n        );\r\n      }\r\n      if (operands.length != 1) {\r\n        compiler.error(\r\n          DiagnosticCode.Expected_0_arguments_but_got_1,\r\n          reportNode.range, \"1\", operands.length.toString(10)\r\n        );\r\n        compiler.currentType = Type.f64;\r\n        return module.createUnreachable();\r\n      }\r\n      return compiler.compileExpression(operands[0], Type.f64, ConversionKind.EXPLICIT);\r\n  }\r\n  compiler.error(\r\n    DiagnosticCode.Operation_not_supported,\r\n    reportNode.range\r\n  );\r\n  return module.createUnreachable();\r\n}\r\n\r\nfunction evaluateConstantOffset(compiler: Compiler, expression: Expression): i32 {\r\n  var expr: ExpressionRef;\r\n  var value: i32;\r\n  if (compiler.options.isWasm64) {\r\n    expr = compiler.precomputeExpression(expression, Type.usize64);\r\n    if (\r\n      _BinaryenExpressionGetId(expr) != ExpressionId.Const ||\r\n      _BinaryenExpressionGetType(expr) != NativeType.I64 ||\r\n      _BinaryenConstGetValueI64High(expr) != 0 ||\r\n      (value = _BinaryenConstGetValueI64Low(expr)) < 0\r\n    ) {\r\n      compiler.error(\r\n        DiagnosticCode.Operation_not_supported,\r\n        expression.range\r\n      );\r\n      value = -1;\r\n    }\r\n  } else {\r\n    expr = compiler.precomputeExpression(expression, Type.usize32);\r\n    if (\r\n      _BinaryenExpressionGetId(expr) != ExpressionId.Const ||\r\n      _BinaryenExpressionGetType(expr) != NativeType.I32 ||\r\n      (value = _BinaryenConstGetValueI32(expr)) < 0\r\n    ) {\r\n      compiler.error(\r\n        DiagnosticCode.Operation_not_supported,\r\n        expression.range\r\n      );\r\n      value = -1;\r\n    }\r\n  }\r\n  return value;\r\n}\r\n\r\n/** Compiles a memory allocation for an instance of the specified class. */\r\nexport function compileAllocate(\r\n  compiler: Compiler,\r\n  cls: Class,\r\n  reportNode: Node\r\n): ExpressionRef {\r\n  var program = cls.program;\r\n  var prototype = program.elements.get(compiler.options.allocateImpl);\r\n  if (prototype) {\r\n    if (prototype.kind == ElementKind.FUNCTION_PROTOTYPE) {\r\n      var instance = (<FunctionPrototype>prototype).resolve(); // reports\r\n      if (instance) {\r\n        if (\r\n          !instance.is(ElementFlags.GENERIC) &&\r\n          instance.returnType == compiler.options.usizeType &&\r\n          instance.parameters &&\r\n          instance.parameters.length == 1 &&\r\n          instance.parameters[0].type == compiler.options.usizeType\r\n        ) {\r\n          if (compiler.compileFunction(instance)) { // reports\r\n            return compiler.makeCall(instance, [\r\n              compiler.options.isWasm64\r\n                ? compiler.module.createI64(cls.currentMemoryOffset)\r\n                : compiler.module.createI32(cls.currentMemoryOffset)\r\n            ]);\r\n          }\r\n        } else {\r\n          program.error(\r\n            DiagnosticCode.Implementation_0_must_match_the_signature_1,\r\n            reportNode.range, compiler.options.allocateImpl, \"(size: usize): usize\"\r\n          );\r\n        }\r\n      }\r\n    } else {\r\n      program.error(\r\n        DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures,\r\n        reportNode.range, prototype.internalName\r\n      );\r\n    }\r\n  } else {\r\n    program.error(\r\n      DiagnosticCode.Cannot_find_name_0,\r\n      reportNode.range, compiler.options.allocateImpl\r\n    );\r\n  }\r\n  return compiler.module.createUnreachable();\r\n}\r\n\r\n/** Compiles an abort wired to the conditionally imported 'abort' function. */\r\nexport function compileAbort(\r\n  compiler: Compiler,\r\n  message: Expression | null,\r\n  reportNode: Node\r\n): ExpressionRef {\r\n  var module = compiler.module;\r\n  var abort: ExpressionRef = module.createUnreachable();\r\n  var abortPrototype = compiler.program.elements.get(\"abort\");\r\n  var stringType = compiler.program.types.get(\"string\");\r\n  if (\r\n    abortPrototype &&\r\n    abortPrototype.kind == ElementKind.FUNCTION_PROTOTYPE &&\r\n    stringType\r\n  ) {\r\n    var abortInstance = (<FunctionPrototype>abortPrototype).resolve(); // reports\r\n    if (\r\n      abortInstance &&\r\n      compiler.compileFunction(abortInstance) // reports\r\n    ) {\r\n      assert(abortInstance.parameters && abortInstance.parameters.length == 4); // to be sure\r\n      abort = module.createBlock(null, [\r\n        compiler.makeCall(abortInstance, [\r\n          message != null\r\n            ? compiler.compileExpression(message, stringType)\r\n            : compiler.options.usizeType.toNativeZero(module),\r\n          compiler.compileStaticString(reportNode.range.source.normalizedPath),\r\n          module.createI32(reportNode.range.line),\r\n          module.createI32(reportNode.range.column)\r\n        ]),\r\n        abort\r\n      ]);\r\n    }\r\n  }\r\n  return abort;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/builtins.ts","const Long = global.Long || require(\"long\");\r\n\r\nglobal.i64_new = function(lo, hi) {\r\n  return Long.fromBits(lo, hi);\r\n};\r\n\r\nglobal.i64_low = function(value) {\r\n  return value.low;\r\n};\r\n\r\nglobal.i64_high = function(value) {\r\n  return value.high;\r\n};\r\n\r\nglobal.i64_add = function(left, right) {\r\n  return left.add(right);\r\n};\r\n\r\nglobal.i64_sub = function(left, right) {\r\n  return left.sub(right);\r\n};\r\n\r\nglobal.i64_mul = function(left, right) {\r\n  return left.mul(right);\r\n};\r\n\r\nglobal.i64_div = function(left, right) {\r\n  return left.div(right);\r\n};\r\n\r\nglobal.i64_div_u = function(left, right) {\r\n  return left.toUnsigned().div(right.toUnsigned()).toSigned();\r\n};\r\n\r\nglobal.i64_rem = function(left, right) {\r\n  return left.mod(right);\r\n};\r\n\r\nglobal.i64_rem_u = function(left, right) {\r\n  return left.toUnsigned().mod(right.toUnsigned()).toSigned();\r\n};\r\n\r\nglobal.i64_and = function(left, right) {\r\n  return left.and(right);\r\n};\r\n\r\nglobal.i64_or = function(left, right) {\r\n  return left.or(right);\r\n};\r\n\r\nglobal.i64_xor = function(left, right) {\r\n  return left.xor(right);\r\n};\r\n\r\nglobal.i64_shl = function(left, right) {\r\n  return left.shl(right);\r\n};\r\n\r\nglobal.i64_shr = function(left, right) {\r\n  return left.shr(right);\r\n};\r\n\r\nglobal.i64_shr_u = function(left, right) {\r\n  return left.shru(right);\r\n};\r\n\r\nglobal.i64_not = function(value) {\r\n  return value.not();\r\n};\r\n\r\nglobal.i64_align = function(value, alignment) {\r\n  assert(alignment && (alignment & (alignment - 1)) == 0);\r\n  var mask = Long.fromInt(alignment - 1);\r\n  return value.add(mask).and(mask.not());\r\n};\r\n\r\nglobal.i64_is_i8 = function(value) {\r\n  return value.high === 0 && (value.low >= 0 && value.low <= i8.MAX_VALUE)\r\n      || value.high === -1 && (value.low >= i8.MIN_VALUE && value.low < 0);\r\n};\r\n\r\nglobal.i64_is_i16 = function(value) {\r\n  return value.high === 0 && (value.low >= 0 && value.low <= i16.MAX_VALUE)\r\n      || value.high === -1 && (value.low >= i16.MIN_VALUE && value.low < 0);\r\n};\r\n\r\nglobal.i64_is_i32 = function(value) {\r\n  return (value.high === 0 && value.low >= 0)\r\n      || (value.high === -1 && value.low < 0);\r\n};\r\n\r\nglobal.i64_is_u8 = function(value) {\r\n  return value.high === 0 && value.low >= 0 && value.low <= u8.MAX_VALUE;\r\n};\r\n\r\nglobal.i64_is_u16 = function(value) {\r\n  return value.high === 0 && value.low >= 0 && value.low <= u16.MAX_VALUE;\r\n};\r\n\r\nglobal.i64_is_u32 = function(value) {\r\n  return value.high === 0;\r\n};\r\n\r\nglobal.i64_is_bool = function(value) {\r\n  return value.high === 0 && (value.low === 0 || value.low === 1);\r\n};\r\n\r\nconst minSafeF32 = Long.fromNumber(f32.MIN_SAFE_INTEGER);\r\nconst maxSafeF32 = Long.fromNumber(f32.MAX_SAFE_INTEGER);\r\n\r\nglobal.i64_is_f32 = function(value) {\r\n  return value.gte(minSafeF32) && value.lte(maxSafeF32);\r\n};\r\n\r\nconst minSafeF64 = Long.fromNumber(f64.MIN_SAFE_INTEGER);\r\nconst maxSafeF64 = Long.fromNumber(f64.MAX_SAFE_INTEGER);\r\n\r\nglobal.i64_is_f64 = function(value) {\r\n  return value.gte(minSafeF64) && value.lte(maxSafeF64);\r\n};\r\n\r\nglobal.i64_to_f32 = function(value) {\r\n  return global.Math.fround(value.toNumber());\r\n};\r\n\r\nglobal.i64_to_f64 = function(value) {\r\n  return value.toNumber();\r\n};\r\n\r\nglobal.i64_to_string = function(value, unsigned) {\r\n  return (unsigned ? value.toUnsigned() : value).toString(10);\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/glue/js/i64.js\n// module id = 17\n// module chunks = 0","module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/long/src/long.js\n// module id = 18\n// module chunks = 0","//////////////////////// Low-level C-Like Compiler API /////////////////////////\r\n\r\nimport {\r\n  Compiler,\r\n  Options,\r\n  Target\r\n} from \"./compiler\";\r\n\r\nimport {\r\n  Decompiler\r\n} from \"./decompiler\";\r\n\r\nimport {\r\n  DiagnosticMessage,\r\n  DiagnosticCategory,\r\n  formatDiagnosticMessage\r\n} from \"./diagnostics\";\r\n\r\nimport {\r\n  Module\r\n} from \"./module\";\r\n\r\nimport {\r\n  Parser\r\n} from \"./parser\";\r\n\r\n/** Parses a source file. If `parser` has been omitted a new one is created. */\r\nexport function parseFile(text: string, path: string, isEntry: bool = false,\r\n  parser: Parser | null = null\r\n): Parser {\r\n  if (!parser) {\r\n    parser = new Parser();\r\n    isEntry = true;\r\n  }\r\n  parser.parseFile(text, path, isEntry);\r\n  return parser;\r\n}\r\n\r\n/** Obtains the next required file's path. Returns `null` once complete. */\r\nexport function nextFile(parser: Parser): string | null {\r\n  return parser.nextFile();\r\n}\r\n\r\n/** Obtains the next diagnostic message. Returns `null` once complete. */\r\nexport function nextDiagnostic(parser: Parser): DiagnosticMessage | null {\r\n  var program = parser.program;\r\n  return program.diagnosticsOffset < program.diagnostics.length\r\n    ? program.diagnostics[program.diagnosticsOffset++]\r\n    : null;\r\n}\r\n\r\n/** Formats a diagnostic message to a string. */\r\nexport { formatDiagnosticMessage as formatDiagnostic };\r\n\r\n/** Tests whether a diagnostic is informatory. */\r\nexport function isInfo(message: DiagnosticMessage): bool {\r\n  return message.category == DiagnosticCategory.INFO;\r\n}\r\n\r\n/** Tests whether a diagnostic is a warning. */\r\nexport function isWarning(message: DiagnosticMessage): bool {\r\n  return message.category == DiagnosticCategory.WARNING;\r\n}\r\n\r\n/** Tests whether a diagnostic is an error. */\r\nexport function isError(message: DiagnosticMessage): bool {\r\n  return message.category == DiagnosticCategory.ERROR;\r\n}\r\n\r\n/** Creates a new set of compiler options. */\r\nexport function createOptions(): Options {\r\n  return new Options();\r\n}\r\n\r\n/** Sets the `target` option. */\r\nexport function setTarget(options: Options, target: Target): void {\r\n  options.target = target;\r\n}\r\n\r\n/** Sets the `noTreeShaking` option. */\r\nexport function setNoTreeShaking(options: Options, noTreeShaking: bool): void {\r\n  options.noTreeShaking = noTreeShaking;\r\n}\r\n\r\n/** Sets the `noAssert` option. */\r\nexport function setNoAssert(options: Options, noAssert: bool): void {\r\n  options.noAssert = noAssert;\r\n}\r\n\r\n/** Sets the `noMemory` option. */\r\nexport function setNoMemory(options: Options, noMemory: bool): void {\r\n  options.noMemory = noMemory;\r\n}\r\n\r\n/** Sets the `importMemory` option. */\r\nexport function setImportMemory(options: Options, importMemory: bool): void {\r\n  options.importMemory = importMemory;\r\n}\r\n\r\n/** Sets the `sourceMap` option. */\r\nexport function setSourceMap(options: Options, sourceMap: bool): void {\r\n  options.sourceMap = sourceMap;\r\n}\r\n\r\n/** Sets the `memoryBase` option. */\r\nexport function setMemoryBase(options: Options, memoryBase: u32): void {\r\n  options.memoryBase = memoryBase;\r\n}\r\n\r\n/** Compiles the sources computed by the parser to a module. */\r\nexport function compile(parser: Parser, options: Options | null = null): Module {\r\n  var program = parser.finish();\r\n  var compiler = new Compiler(program, options);\r\n  return compiler.compile();\r\n}\r\n\r\n/** Decompiles a module to its (low level) source. */\r\nexport function decompile(module: Module): string {\r\n  var decompiler = new Decompiler();\r\n  decompiler.decompile(module);\r\n  return decompiler.finish();\r\n}\r\n\r\n/** Prefix indicating a library file. */\r\nexport { LIBRARY_PREFIX } from \"./program\";\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","import {\r\n  Module,\r\n  NativeType,\r\n  ExpressionId,\r\n  UnaryOp,\r\n  BinaryOp,\r\n  HostOp,\r\n  FunctionRef,\r\n  ExpressionRef,\r\n  Index,\r\n  readString\r\n} from \"./module\";\r\n\r\n// TODO :-)\r\n\r\nexport class Decompiler {\r\n\r\n  static decompile(module: Module): string {\r\n    var decompiler = new Decompiler();\r\n    decompiler.decompile(module);\r\n    return decompiler.finish();\r\n  }\r\n\r\n  text: string[] = [];\r\n  functionId: i32 = 0;\r\n\r\n  constructor() { }\r\n\r\n  /** Decompiles a module to an AST that can then be serialized. */\r\n  decompile(module: Module) {\r\n    throw new Error(\"not implemented\");\r\n  }\r\n\r\n  decompileFunction(func: FunctionRef): void {\r\n    var name = readString(_BinaryenFunctionGetName(func)) || \"$\" + this.functionId.toString(10);\r\n    var body = _BinaryenFunctionGetBody(func);\r\n    this.push(\"function \");\r\n    this.push(name);\r\n    this.push(\"(\");\r\n     for (var i: Index = 0, k: Index = _BinaryenFunctionGetNumParams(func); i < k; ++i) {\r\n      if (i > 0) this.push(\", \");\r\n      this.push(\"$\");\r\n      this.push(i.toString(10));\r\n      this.push(\": \");\r\n      this.push(nativeTypeToType(_BinaryenFunctionGetParam(func, i)));\r\n    }\r\n    this.push(\"): \");\r\n    this.push(nativeTypeToType(_BinaryenFunctionGetResult(func)));\r\n    this.push(\" \");\r\n    if (_BinaryenExpressionGetId(body) != ExpressionId.Block) {\r\n      this.push(\"{\\n\");\r\n    }\r\n    this.decompileExpression(body);\r\n    if (_BinaryenExpressionGetId(body) != ExpressionId.Block) {\r\n      this.push(\"\\n}\\n\");\r\n    }\r\n    ++this.functionId;\r\n  }\r\n\r\n  decompileExpression(expr: ExpressionRef): void {\r\n    var id = _BinaryenExpressionGetId(expr);\r\n    var type = _BinaryenExpressionGetType(expr);\r\n\r\n    var nested: ExpressionRef;\r\n    var string: string | null;\r\n    var i: Index, k: Index;\r\n\r\n    switch (id) {\r\n\r\n      case ExpressionId.Block: // TODO: magic\r\n        if ((string = readString(_BinaryenBlockGetName(expr))) != null) {\r\n          this.push(string);\r\n          this.push(\": \");\r\n        }\r\n        this.push(\"{\\n\");\r\n        k = _BinaryenBlockGetNumChildren(expr);\r\n        for (i = 0; i < k; ++i) {\r\n          this.decompileExpression(_BinaryenBlockGetChild(expr, i));\r\n        }\r\n        this.push(\"}\\n\");\r\n        return;\r\n\r\n      case ExpressionId.If:\r\n        if (type == NativeType.None) {\r\n          this.push(\"if (\");\r\n          this.decompileExpression(_BinaryenIfGetCondition(expr));\r\n          this.push(\") \");\r\n          this.decompileExpression(_BinaryenIfGetIfTrue(expr));\r\n          if (nested = _BinaryenIfGetIfFalse(expr)) {\r\n            this.push(\" else \");\r\n            this.decompileExpression(nested);\r\n          }\r\n        } else {\r\n          this.decompileExpression(_BinaryenIfGetCondition(expr));\r\n          this.push(\" ? \");\r\n          this.decompileExpression(_BinaryenIfGetIfTrue(expr));\r\n          this.push(\" : \");\r\n          this.decompileExpression(_BinaryenIfGetIfFalse(expr));\r\n        }\r\n        return;\r\n\r\n      case ExpressionId.Loop:\r\n        if ((string = readString(_BinaryenLoopGetName(expr))) != null) {\r\n          this.push(string);\r\n          this.push(\": \");\r\n        }\r\n        this.push(\"do \");\r\n        this.decompileExpression(_BinaryenLoopGetBody(expr));\r\n        this.push(\"while (0);\\n\");\r\n\r\n      case ExpressionId.Break:\r\n        if (nested = _BinaryenBreakGetCondition(expr)) {\r\n          this.push(\"if (\");\r\n          this.decompileExpression(nested);\r\n          this.push(\") \");\r\n        }\r\n        if ((string = readString(_BinaryenBreakGetName(expr))) != null) {\r\n          this.push(\"break \");\r\n          this.push(string);\r\n          this.push(\";\\n\");\r\n        } else {\r\n          this.push(\"break;\\n\");\r\n        }\r\n        return;\r\n\r\n      case ExpressionId.Switch:\r\n\r\n      case ExpressionId.Call:\r\n\r\n      case ExpressionId.CallImport:\r\n\r\n      case ExpressionId.CallIndirect:\r\n\r\n      case ExpressionId.GetLocal:\r\n        this.push(\"$\");\r\n        this.push(_BinaryenGetLocalGetIndex(expr).toString(10));\r\n        return;\r\n\r\n      case ExpressionId.SetLocal:\r\n        this.push(\"$\");\r\n        this.push(_BinaryenSetLocalGetIndex(expr).toString(10));\r\n        this.push(\" = \");\r\n        this.decompileExpression(_BinaryenSetLocalGetValue(expr));\r\n        return;\r\n\r\n      case ExpressionId.GetGlobal:\r\n\r\n      case ExpressionId.SetGlobal:\r\n\r\n      case ExpressionId.Load:\r\n        this.push(\"load<\");\r\n        this.push(nativeTypeToType(type));\r\n        this.push(\">(\");\r\n        this.push(_BinaryenLoadGetOffset(expr).toString(10));\r\n        this.push(\" + \");\r\n        this.decompileExpression(_BinaryenLoadGetPtr(expr));\r\n        this.push(\")\");\r\n        return;\r\n\r\n      case ExpressionId.Store:\r\n        this.push(\"store<\");\r\n        this.push(nativeTypeToType(type));\r\n        this.push(\">(\");\r\n        this.push(_BinaryenStoreGetOffset(expr).toString(10));\r\n        this.push(\" + \");\r\n        this.decompileExpression(_BinaryenStoreGetPtr(expr));\r\n        this.push(\", \");\r\n        this.decompileExpression(_BinaryenStoreGetValue(expr));\r\n        this.push(\")\");\r\n        return;\r\n\r\n      case ExpressionId.Const:\r\n        switch (type) {\r\n\r\n          case NativeType.I32:\r\n            this.push(_BinaryenConstGetValueI32(expr).toString(10));\r\n            return;\r\n\r\n          case NativeType.I64:\r\n            this.push(\r\n              i64_to_string(\r\n                i64_new(\r\n                  _BinaryenConstGetValueI64Low(expr),\r\n                  _BinaryenConstGetValueI64High(expr)\r\n                )\r\n              )\r\n            );\r\n            return;\r\n\r\n          case NativeType.F32:\r\n            this.push(_BinaryenConstGetValueF32(expr).toString(10));\r\n            return;\r\n\r\n          case NativeType.F64:\r\n            this.push(_BinaryenConstGetValueF64(expr).toString(10));\r\n            return;\r\n        }\r\n        break;\r\n\r\n      case ExpressionId.Unary:\r\n        switch (_BinaryenUnaryGetOp(expr)) {\r\n\r\n          case UnaryOp.ClzI32:\r\n            this.push(\"clz<i32>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.CtzI32:\r\n            this.push(\"ctz<i32>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.PopcntI32:\r\n            this.push(\"popcnt<i32>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.NegF32:\r\n          case UnaryOp.NegF64:\r\n            this.push(\"-\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.AbsF32:\r\n            this.push(\"abs<f32>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.CeilF32:\r\n            this.push(\"ceil<f32>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.FloorF32:\r\n            this.push(\"floor<f32>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.TruncF32:\r\n            this.push(\"trunc<f32>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.NearestF32:\r\n            this.push(\"nearest<i32>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.SqrtF32:\r\n            this.push(\"sqrt<f32>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.EqzI32:\r\n          case UnaryOp.EqzI64:\r\n            this.push(\"!\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.ClzI64:\r\n            this.push(\"clz<i64>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.CtzI64:\r\n            this.push(\"ctz<i64>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.PopcntI64:\r\n            this.push(\"popcnt<i64>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.AbsF64:\r\n            this.push(\"abs<f64>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.CeilF64:\r\n            this.push(\"ceil<f64>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.FloorF64:\r\n            this.push(\"floor<f64>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.TruncF64:\r\n            this.push(\"trunc<f64>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.NearestF64:\r\n            this.push(\"nearest<f64>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.SqrtF64:\r\n            this.push(\"sqrt<f64>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.ExtendI32:\r\n            this.push(\"<i64>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.ExtendU32:\r\n            this.push(\"<i64><u64>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.WrapI64:\r\n            this.push(\"<i32>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.TruncF32ToI32:\r\n            this.push(\"<i32>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.TruncF32ToI64:\r\n            this.push(\"<i64>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.TruncF32ToU32:\r\n            this.push(\"<i32><u32>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.TruncF32ToU64:\r\n            this.push(\"<i64><u64>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.TruncF64ToI32:\r\n            this.push(\"<i32>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.TruncF64ToI64:\r\n            this.push(\"<i64>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.TruncF64ToU32:\r\n            this.push(\"<i32><u32>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.TruncF64ToU64:\r\n            this.push(\"<i64><u64>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.ReinterpretF32:\r\n            this.push(\"reinterpret<f32,i32>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.ReinterpretF64:\r\n            this.push(\"reinterpret<f64,i64>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.ConvertI32ToF32:\r\n            this.push(\"<f32>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.ConvertI32ToF64:\r\n            this.push(\"<f64>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.ConvertU32ToF32:\r\n            this.push(\"<f32><u32>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.ConvertU32ToF64:\r\n            this.push(\"<f64><u32>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.ConvertI64ToF32:\r\n            this.push(\"<f32>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.ConvertI64ToF64:\r\n            this.push(\"<f64>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.ConvertU64ToF32:\r\n            this.push(\"<f32><u64>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.ConvertU64ToF64:\r\n            this.push(\"<f64><u64>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.PromoteF32:\r\n            this.push(\"<f64>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.DemoteF64:\r\n            this.push(\"<f32>\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            return;\r\n\r\n          case UnaryOp.ReinterpretI32:\r\n            this.push(\"reinterpret<i32,f32>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case UnaryOp.ReinterpretI64:\r\n            this.push(\"reinterpret<i64,f64>(\");\r\n            this.decompileExpression(_BinaryenUnaryGetValue(expr));\r\n            this.push(\")\");\r\n            return;\r\n        }\r\n        break;\r\n\r\n      case ExpressionId.Binary: // TODO: precedence\r\n        switch (_BinaryenBinaryGetOp(expr)) {\r\n\r\n          case BinaryOp.AddI32:\r\n          case BinaryOp.AddI64:\r\n          case BinaryOp.AddF32:\r\n          case BinaryOp.AddF64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" + \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.SubI32:\r\n          case BinaryOp.SubI64:\r\n          case BinaryOp.SubF32:\r\n          case BinaryOp.SubF64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" - \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.MulI32:\r\n          case BinaryOp.MulI64:\r\n          case BinaryOp.MulF32:\r\n          case BinaryOp.MulF64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" * \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.DivI32:\r\n          case BinaryOp.DivI64:\r\n          case BinaryOp.DivF32:\r\n          case BinaryOp.DivF64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" / \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.DivU32:\r\n            this.push(\"<i32>(<u32>\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" / <u32>\");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case BinaryOp.RemI32:\r\n          case BinaryOp.RemI64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" % \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.RemU32:\r\n            this.push(\"<i32>(<u32>\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" / <u32>\");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case BinaryOp.AndI32:\r\n          case BinaryOp.AndI64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" & \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.OrI32:\r\n          case BinaryOp.OrI64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" | \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.XorI32:\r\n          case BinaryOp.XorI64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" ^ \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.ShlI32:\r\n          case BinaryOp.ShlI64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" << \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.ShrU32:\r\n          case BinaryOp.ShrU64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" >>> \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.ShrI32:\r\n          case BinaryOp.ShrI64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" >> \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.RotlI32:\r\n            this.push(\"rotl<i32>(\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\", \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case BinaryOp.RotrI32:\r\n            this.push(\"rotr<i32>(\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\", \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case BinaryOp.EqI32:\r\n          case BinaryOp.EqI64:\r\n          case BinaryOp.EqF32:\r\n          case BinaryOp.EqF64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" == \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.NeI32:\r\n          case BinaryOp.NeI64:\r\n          case BinaryOp.NeF32:\r\n          case BinaryOp.NeF64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" != \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.LtI32:\r\n          case BinaryOp.LtI64:\r\n          case BinaryOp.LtF32:\r\n          case BinaryOp.LtF64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" < \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.LtU32:\r\n            this.push(\"<u32>\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" < <u32>\");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.LeI32:\r\n          case BinaryOp.LeI64:\r\n          case BinaryOp.LeF32:\r\n          case BinaryOp.LeF64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" <= \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.LeU32:\r\n            this.push(\"<u32>\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" <= <u32>\");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.GtI32:\r\n          case BinaryOp.GtI64:\r\n          case BinaryOp.GtF32:\r\n          case BinaryOp.GtF64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" > \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.GtU32:\r\n            this.push(\"<u32>\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" > <u32>\");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.GeI32:\r\n          case BinaryOp.GeI64:\r\n          case BinaryOp.GeF32:\r\n          case BinaryOp.GeF64:\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" >= \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.GeU32:\r\n            this.push(\"<u32>\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" >= <u32>\");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.DivU64:\r\n            this.push(\"<u64>\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" / <u64>\");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.RemU64:\r\n            this.push(\"<u64>\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" % <u64>\");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n           case BinaryOp.RotlI64:\r\n            this.push(\"rotl<i64>(\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\", \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case BinaryOp.RotrI64:\r\n            this.push(\"rotr<i64>(\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\", \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case BinaryOp.LtU64:\r\n            this.push(\"<u64>\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" < <u64>\");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.LeU64:\r\n            this.push(\"<u64>\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" <= <u64>\");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.GtU64:\r\n            this.push(\"<u64>\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" > <u64>\");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.GeU64:\r\n            this.push(\"<u64>\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\" >= <u64>\");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            return;\r\n\r\n          case BinaryOp.CopysignF32:\r\n            this.push(\"copysign<f32>(\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\", \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case BinaryOp.MinF32:\r\n            this.push(\"min<f32>(\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\", \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case BinaryOp.MaxF32:\r\n            this.push(\"max<f32>(\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\", \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n            case BinaryOp.CopysignF64:\r\n            this.push(\"copysign<f64>(\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\", \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case BinaryOp.MinF64:\r\n            this.push(\"min<f64>(\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\", \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            this.push(\")\");\r\n            return;\r\n\r\n          case BinaryOp.MaxF64:\r\n            this.push(\"max<f64>(\");\r\n            this.decompileExpression(_BinaryenBinaryGetLeft(expr));\r\n            this.push(\", \");\r\n            this.decompileExpression(_BinaryenBinaryGetRight(expr));\r\n            this.push(\")\");\r\n            return;\r\n        }\r\n        return;\r\n\r\n      case ExpressionId.Select:\r\n        this.push(\"select<\");\r\n        this.push(nativeTypeToType(type));\r\n        this.push(\">(\");\r\n        this.decompileExpression(_BinaryenSelectGetIfTrue(expr));\r\n        this.push(\", \");\r\n        this.decompileExpression(_BinaryenSelectGetIfFalse(expr));\r\n        this.push(\", \");\r\n        this.decompileExpression(_BinaryenSelectGetCondition(expr));\r\n        this.push(\")\");\r\n        return;\r\n\r\n      case ExpressionId.Drop:\r\n        this.decompileExpression(_BinaryenDropGetValue(expr));\r\n        this.push(\";\\n\");\r\n        return;\r\n\r\n      case ExpressionId.Return:\r\n        if (nested = _BinaryenReturnGetValue(expr)) {\r\n          this.push(\"return \");\r\n          this.decompileExpression(nested);\r\n          this.push(\";\\n\");\r\n        } else {\r\n          this.push(\"return;\\n\");\r\n        }\r\n        return;\r\n\r\n      case ExpressionId.Host:\r\n        switch (_BinaryenHostGetOp(expr)) {\r\n          case HostOp.CurrentMemory:\r\n            this.push(\"current_memory()\");\r\n            return;\r\n          case HostOp.GrowMemory:\r\n            this.push(\"grow_memory(\");\r\n            this.decompileExpression(_BinaryenHostGetOperand(expr, 0));\r\n            this.push(\")\");\r\n            return;\r\n        }\r\n        break;\r\n\r\n      case ExpressionId.Nop:\r\n        this.push(\";\\n\");\r\n        return;\r\n\r\n      case ExpressionId.Unreachable:\r\n        this.push(\"unreachable()\");\r\n        return;\r\n\r\n      case ExpressionId.AtomicCmpxchg:\r\n\r\n      case ExpressionId.AtomicRMW:\r\n\r\n      case ExpressionId.AtomicWait:\r\n\r\n      case ExpressionId.AtomicWake:\r\n    }\r\n    throw new Error(\"not implemented\");\r\n  }\r\n\r\n  private push(text: string): void {\r\n    // mostly here so we can add debugging if necessary\r\n    this.text.push(text);\r\n  }\r\n\r\n  finish(): string {\r\n    var ret = this.text.join(\"\");\r\n    this.text = [];\r\n    return ret;\r\n  }\r\n}\r\n\r\nfunction nativeTypeToType(type: NativeType): string {\r\n  switch (type) {\r\n    case NativeType.None: return \"void\";\r\n    case NativeType.I32: return \"i32\";\r\n    case NativeType.I64: return \"i64\";\r\n    case NativeType.F32: return \"f32\";\r\n    case NativeType.F64: return \"f64\";\r\n    case NativeType.Unreachable: throw new Error(\"unreachable type\");\r\n    case NativeType.Auto: throw new Error(\"auto type\");\r\n    default: throw new Error(\"unexpected type\");\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/decompiler.ts","/*\r\n\r\n This is a custom parser specifically written for the AssemblyScript subset. It accepts some of the\r\n most common TypeScript-only patterns that it knows an appropriate error message for but, though it\r\n uses TypeScript's codes for diagnostics, doesn't ultimately aim at full compatibility.\r\n\r\n*/\r\n\r\nimport {\r\n  Program,\r\n  LIBRARY_PREFIX,\r\n  PATH_DELIMITER\r\n} from \"./program\";\r\n\r\nimport {\r\n  Tokenizer,\r\n  Token,\r\n  Range\r\n} from \"./tokenizer\";\r\n\r\nimport {\r\n  DiagnosticCode,\r\n  DiagnosticEmitter\r\n} from \"./diagnostics\";\r\n\r\nimport {\r\n  normalize as normalizePath\r\n} from \"./util/path\";\r\n\r\nimport {\r\n\r\n  Node,\r\n  NodeKind,\r\n  Source,\r\n  SourceKind,\r\n  TypeNode,\r\n\r\n  Expression,\r\n  AssertionKind,\r\n  CallExpression,\r\n  IdentifierExpression,\r\n  StringLiteralExpression,\r\n\r\n  Statement,\r\n  BlockStatement,\r\n  BreakStatement,\r\n  ClassDeclaration,\r\n  ContinueStatement,\r\n  DeclarationStatement,\r\n  Decorator,\r\n  DoStatement,\r\n  EnumDeclaration,\r\n  EnumValueDeclaration,\r\n  ExportImportStatement,\r\n  ExportMember,\r\n  ExportStatement,\r\n  ExpressionStatement,\r\n  ForStatement,\r\n  FunctionExpression,\r\n  FunctionDeclaration,\r\n  IfStatement,\r\n  ImportDeclaration,\r\n  ImportStatement,\r\n  Modifier,\r\n  ModifierKind,\r\n  NamespaceDeclaration,\r\n  Parameter,\r\n  ParameterKind,\r\n  ReturnStatement,\r\n  SwitchCase,\r\n  SwitchStatement,\r\n  ThrowStatement,\r\n  TryStatement,\r\n  TypeDeclaration,\r\n  TypeParameter,\r\n  VariableStatement,\r\n  VariableDeclaration,\r\n  WhileStatement,\r\n\r\n  addModifier,\r\n  getModifier,\r\n  hasModifier,\r\n  setReusableModifiers\r\n\r\n} from \"./ast\";\r\n\r\n/** Parser interface. */\r\nexport class Parser extends DiagnosticEmitter {\r\n\r\n  /** Program being created. */\r\n  program: Program;\r\n  /** Log of source file names to be requested. */\r\n  backlog: string[] = new Array();\r\n  /** Log of source file names already processed. */\r\n  seenlog: Set<string> = new Set();\r\n\r\n  /** Constructs a new parser. */\r\n  constructor() {\r\n    super();\r\n    this.program = new Program(this.diagnostics);\r\n  }\r\n\r\n  /** Parses a file and adds its definitions to the program. */\r\n  parseFile(\r\n    text: string,\r\n    path: string,\r\n    isEntry: bool\r\n  ): void {\r\n\r\n    // check if already parsed\r\n    var normalizedPath = normalizePath(path);\r\n    for (var i = 0, k = this.program.sources.length; i < k; ++i) {\r\n      if (this.program.sources[i].normalizedPath == normalizedPath) return;\r\n    }\r\n    this.seenlog.add(normalizedPath);\r\n\r\n    // create the source element\r\n    var source = new Source(\r\n      normalizedPath,\r\n      text,\r\n      isEntry\r\n        ? SourceKind.ENTRY\r\n        : path.startsWith(LIBRARY_PREFIX) && path.indexOf(PATH_DELIMITER, LIBRARY_PREFIX.length) < 0\r\n          ? SourceKind.LIBRARY\r\n          : SourceKind.DEFAULT\r\n    );\r\n    this.program.sources.push(source);\r\n\r\n    // tokenize and parse\r\n    var tn = new Tokenizer(source, this.program.diagnostics);\r\n    source.tokenizer = tn;\r\n    while (!tn.skip(Token.ENDOFFILE)) {\r\n      var statement = this.parseTopLevelStatement(tn);\r\n      if (statement) {\r\n        statement.parent = source;\r\n        source.statements.push(statement);\r\n      }\r\n    }\r\n    tn.finish();\r\n  }\r\n\r\n  /** Parses a top-level statement. */\r\n  parseTopLevelStatement(\r\n    tn: Tokenizer,\r\n    isNamespaceMember: bool = false\r\n  ): Statement | null {\r\n\r\n    // check decorators\r\n    var decorators: Decorator[] | null = null;\r\n    while (tn.skip(Token.AT)) {\r\n      var decorator = this.parseDecorator(tn);\r\n      if (!decorator) break;\r\n      if (!decorators) decorators = [];\r\n      decorators.push(decorator);\r\n    }\r\n\r\n    // check modifiers\r\n    var modifiers: Modifier[] | null = null;\r\n    if (tn.skip(Token.EXPORT)) {\r\n      modifiers = addModifier(Node.createModifier(ModifierKind.EXPORT, tn.range()), modifiers);\r\n    }\r\n    if (tn.skip(Token.DECLARE)) {\r\n      modifiers = addModifier(Node.createModifier(ModifierKind.DECLARE, tn.range()), modifiers);\r\n      tn.peek(true);\r\n      if (tn.nextTokenOnNewLine) {\r\n        this.error(\r\n          DiagnosticCode.Line_break_not_permitted_here,\r\n          tn.range(tn.pos)\r\n        ); // recoverable, compatibility\r\n      }\r\n    }\r\n\r\n    // remember where we took off\r\n    tn.mark();\r\n\r\n    // parse the statement\r\n    var statement: Statement | null = null;\r\n    var modifier: Modifier | null;\r\n\r\n    // handle declarations\r\n    switch (tn.next()) {\r\n\r\n      case Token.CONST:\r\n        modifiers = addModifier(Node.createModifier(ModifierKind.CONST, tn.range()), modifiers);\r\n        if (tn.skip(Token.ENUM)) {\r\n          statement = this.parseEnum(tn, modifiers, decorators);\r\n          break;\r\n        }\r\n        statement = this.parseVariable(tn, modifiers, decorators);\r\n        decorators = null;\r\n        break;\r\n\r\n      case Token.LET:\r\n        modifiers = addModifier(Node.createModifier(ModifierKind.LET, tn.range()), modifiers);\r\n        // fall-through\r\n\r\n      case Token.VAR:\r\n        statement = this.parseVariable(tn, modifiers, decorators);\r\n        decorators = null;\r\n        break;\r\n\r\n      case Token.ENUM:\r\n        statement = this.parseEnum(tn, modifiers, decorators);\r\n        decorators = null;\r\n        break;\r\n\r\n      case Token.FUNCTION:\r\n        statement = this.parseFunction(tn, modifiers, decorators);\r\n        decorators = null;\r\n        break;\r\n\r\n      case Token.ABSTRACT:\r\n        if (!tn.skip(Token.CLASS)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(tn.pos), \"class\"\r\n          );\r\n          break;\r\n        }\r\n        modifiers = addModifier(\r\n          Node.createModifier(ModifierKind.ABSTRACT, tn.range()), modifiers\r\n        );\r\n        // fall through\r\n\r\n      case Token.CLASS:\r\n        statement = this.parseClass(tn, modifiers, decorators);\r\n        decorators = null;\r\n        break;\r\n\r\n      case Token.NAMESPACE:\r\n        statement = this.parseNamespace(tn, modifiers, decorators);\r\n        decorators = null;\r\n        break;\r\n\r\n      case Token.IMPORT:\r\n        if (modifier = getModifier(ModifierKind.EXPORT, modifiers)) {\r\n          statement = this.parseExportImport(tn, modifier.range);\r\n        } else {\r\n          statement = this.parseImport(tn);\r\n        }\r\n        if (modifiers) setReusableModifiers(modifiers);\r\n        break;\r\n\r\n      case Token.TYPE:\r\n        statement = this.parseTypeDeclaration(tn, modifiers, decorators);\r\n        decorators = null;\r\n        break;\r\n\r\n      default:\r\n\r\n        // handle plain exports\r\n        if (hasModifier(ModifierKind.EXPORT, modifiers)) {\r\n          tn.reset();\r\n          statement = this.parseExport(tn, modifiers); // TODO: why exactly does this have modifiers again? 'declare'?\r\n\r\n        // handle non-declaration statements\r\n        } else {\r\n          if (modifiers) {\r\n            if (modifier = getModifier(ModifierKind.DECLARE, modifiers)) {\r\n              this.error(\r\n                DiagnosticCode._0_modifier_cannot_be_used_here,\r\n                modifier.range, \"declare\"\r\n              ); // recoverable\r\n            }\r\n            setReusableModifiers(modifiers);\r\n          }\r\n          tn.reset();\r\n          if (!isNamespaceMember) {\r\n            statement = this.parseStatement(tn, true);\r\n          }\r\n        }\r\n        break;\r\n    }\r\n\r\n    // check for decorators that weren't consumed\r\n    if (decorators) {\r\n      for (var i = 0, k = decorators.length; i < k; ++i) {\r\n        this.error(\r\n          DiagnosticCode.Decorators_are_not_valid_here,\r\n          decorators[i].range\r\n        );\r\n      }\r\n    }\r\n    return statement;\r\n  }\r\n\r\n  /** Obtains the next file to parse. */\r\n  nextFile(): string | null {\r\n    return this.backlog.length ? this.backlog.shift() : null;\r\n  }\r\n\r\n  /** Finishes parsing and returns the program. */\r\n  finish(): Program {\r\n    if (this.backlog.length) throw new Error(\"backlog is not empty\");\r\n    this.backlog = [];\r\n    this.seenlog.clear();\r\n    return this.program;\r\n  }\r\n\r\n  /** Parses a type. */\r\n  parseType(\r\n    tn: Tokenizer,\r\n    acceptParenthesized: bool = true,\r\n    suppressErrors: bool = false\r\n  ): TypeNode | null {\r\n\r\n    // NOTE: this parses our limited subset\r\n    var token = tn.next();\r\n    var startPos = tn.tokenPos;\r\n\r\n    // void\r\n    if (token == Token.VOID) {\r\n      return Node.createType(\r\n        Node.createIdentifierExpression(\"void\", tn.range()), [], false, tn.range(startPos, tn.pos)\r\n      );\r\n    }\r\n\r\n    var type: TypeNode;\r\n\r\n    // ( ... )\r\n    if (acceptParenthesized && token == Token.OPENPAREN) {\r\n      var innerType = this.parseType(tn, false, suppressErrors);\r\n      if (!innerType) return null;\r\n      if (!tn.skip(Token.CLOSEPAREN)) {\r\n        if (!suppressErrors) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(tn.pos), \"}\"\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n      type = innerType;\r\n      type.range.start = startPos;\r\n      type.range.end = tn.pos;\r\n\r\n    // this\r\n    } else if (token == Token.THIS) {\r\n      type = Node.createType(\r\n        Node.createThisExpression(tn.range()), [], false, tn.range(startPos, tn.pos)\r\n      );\r\n\r\n    // true\r\n    } else if (token == Token.TRUE || token == Token.FALSE) {\r\n      type = Node.createType(\r\n        Node.createIdentifierExpression(\"bool\", tn.range()), [], false, tn.range(startPos, tn.pos)\r\n      );\r\n\r\n    // string literal\r\n    } else if (token == Token.STRINGLITERAL) {\r\n      tn.readString();\r\n      type = Node.createType(\r\n        Node.createIdentifierExpression(\"string\", tn.range()), [], false, tn.range(startPos, tn.pos)\r\n      );\r\n\r\n    // Name\r\n    } else if (token == Token.IDENTIFIER) {\r\n      var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      var parameters = new Array<TypeNode>();\r\n      var nullable = false;\r\n\r\n      // Name<T>\r\n      if (tn.skip(Token.LESSTHAN)) {\r\n        do {\r\n          var parameter = this.parseType(tn, true, suppressErrors);\r\n          if (!parameter) return null;\r\n          parameters.push(<TypeNode>parameter);\r\n        } while (tn.skip(Token.COMMA));\r\n        if (!tn.skip(Token.GREATERTHAN)) {\r\n          if (!suppressErrors) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(tn.pos), \">\"\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n      }\r\n      // ... | null\r\n      if (tn.skip(Token.BAR)) {\r\n        if (tn.skip(Token.NULL)) {\r\n          nullable = true;\r\n        } else {\r\n          if (!suppressErrors) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(tn.pos), \"null\"\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n      }\r\n      type = Node.createType(identifier, parameters, nullable, tn.range(startPos, tn.pos));\r\n\r\n    } else {\r\n      if (!suppressErrors) {\r\n        this.error(\r\n          DiagnosticCode.Identifier_expected,\r\n          tn.range()\r\n        );\r\n      }\r\n      return null;\r\n    }\r\n    // ... [][]\r\n    while (tn.skip(Token.OPENBRACKET)) {\r\n      var bracketStart = tn.tokenPos;\r\n      if (!tn.skip(Token.CLOSEBRACKET)) {\r\n        if (!suppressErrors) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"]\"\r\n          );\r\n        }\r\n        return null;\r\n      }\r\n      var bracketRange = tn.range(bracketStart, tn.pos);\r\n\r\n      // ...[] | null\r\n      nullable = false;\r\n      if (tn.skip(Token.BAR)) {\r\n        if (tn.skip(Token.NULL)) {\r\n          nullable = true;\r\n        } else {\r\n          if (!suppressErrors) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \"null\"\r\n            );\r\n          }\r\n          return null;\r\n        }\r\n      }\r\n      type = Node.createType(\r\n        Node.createIdentifierExpression(\"Array\", bracketRange),\r\n        [ type ],\r\n        nullable,\r\n        tn.range(startPos, tn.pos)\r\n      );\r\n      if (nullable) break;\r\n    }\r\n\r\n    return type;\r\n  }\r\n\r\n  // statements\r\n\r\n  parseDecorator(\r\n    tn: Tokenizer\r\n  ): Decorator | null {\r\n\r\n    // at '@': Identifier ('.' Identifier)* '(' Arguments\r\n\r\n    var startPos = tn.tokenPos;\r\n    if (tn.skip(Token.IDENTIFIER)) {\r\n      var name = tn.readIdentifier();\r\n      var expression: Expression = Node.createIdentifierExpression(name, tn.range(startPos, tn.pos));\r\n      while (tn.skip(Token.DOT)) {\r\n        if (tn.skip(Token.IDENTIFIER)) {\r\n          name = tn.readIdentifier();\r\n          expression = Node.createPropertyAccessExpression(\r\n            expression,\r\n            Node.createIdentifierExpression(name, tn.range()),\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            tn.range()\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n      var args: Expression[] | null;\r\n      if (tn.skip(Token.OPENPAREN)) {\r\n        args = this.parseArguments(tn);\r\n        if (args) {\r\n          return Node.createDecorator(expression, args, tn.range(startPos, tn.pos));\r\n        }\r\n      } else {\r\n        return Node.createDecorator(expression, null, tn.range(startPos, tn.pos));\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseVariable(\r\n    tn: Tokenizer,\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null\r\n  ): VariableStatement | null {\r\n\r\n    // at ('const' | 'let' | 'var'): VariableDeclaration (',' VariableDeclaration)* ';'?\r\n\r\n    var startPos = modifiers && modifiers.length ? modifiers[0].range.start : tn.tokenPos;\r\n    var members = new Array<VariableDeclaration>();\r\n    var isDeclare = hasModifier(ModifierKind.DECLARE, modifiers);\r\n    do {\r\n      var member = this.parseVariableDeclaration(tn, isDeclare, modifiers, decorators);\r\n      if (!member) return null;\r\n      members.push(<VariableDeclaration>member);\r\n    } while (tn.skip(Token.COMMA));\r\n\r\n    var ret = Node.createVariableStatement(members, modifiers, decorators, tn.range(startPos, tn.pos));\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseVariableDeclaration(\r\n    tn: Tokenizer,\r\n    isDeclare: bool = false,\r\n    parentModifiers: Modifier[] | null,\r\n    parentDecorators: Decorator[] | null\r\n  ): VariableDeclaration | null {\r\n\r\n    // before: Identifier (':' Type)? ('=' Expression)?\r\n\r\n    if (!tn.skip(Token.IDENTIFIER)) {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n      return null;\r\n    }\r\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n\r\n    var type: TypeNode | null = null;\r\n    if (tn.skip(Token.COLON)) {\r\n      type = this.parseType(tn);\r\n    }\r\n\r\n    var initializer: Expression | null = null;\r\n    if (tn.skip(Token.EQUALS)) {\r\n      if (isDeclare) {\r\n        this.error(\r\n          DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts,\r\n          tn.range()\r\n        ); // recoverable\r\n      }\r\n      initializer = this.parseExpression(tn, Precedence.COMMA + 1);\r\n      if (!initializer) return null;\r\n    } else {\r\n      if (hasModifier(ModifierKind.CONST, parentModifiers)) {\r\n        if (!hasModifier(ModifierKind.DECLARE, parentModifiers)) {\r\n          this.error(\r\n            DiagnosticCode._const_declarations_must_be_initialized,\r\n            identifier.range\r\n          );\r\n        }\r\n      } else if (!type) { // neither type nor initializer\r\n        this.error(\r\n          DiagnosticCode.Type_expected,\r\n          tn.range(tn.pos)\r\n        ); // recoverable\r\n      }\r\n    }\r\n    return Node.createVariableDeclaration(\r\n      identifier,\r\n      type,\r\n      initializer,\r\n      parentModifiers,\r\n      parentDecorators,\r\n      Range.join(identifier.range, tn.range())\r\n    );\r\n  }\r\n\r\n  parseEnum(\r\n    tn: Tokenizer,\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null\r\n  ): EnumDeclaration | null {\r\n\r\n    // at 'enum': Identifier '{' (EnumValueDeclaration (',' EnumValueDeclaration )*)? '}' ';'?\r\n\r\n    var startPos = modifiers && modifiers.length ? modifiers[0].range.start : tn.tokenPos;\r\n    if (tn.next() != Token.IDENTIFIER) {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n      return null;\r\n    }\r\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n    if (tn.next() != Token.OPENBRACE) {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"{\"\r\n      );\r\n      return null;\r\n    }\r\n    var members = new Array<EnumValueDeclaration>();\r\n    if (!tn.skip(Token.CLOSEBRACE)) {\r\n      do {\r\n        var member = this.parseEnumValue(tn);\r\n        if (!member) return null;\r\n        members.push(<EnumValueDeclaration>member);\r\n      } while (tn.skip(Token.COMMA));\r\n      if (!tn.skip(Token.CLOSEBRACE)) {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"}\"\r\n        );\r\n        return null;\r\n      }\r\n    }\r\n    var ret = Node.createEnumDeclaration(\r\n      identifier,\r\n      members,\r\n      modifiers,\r\n      decorators,\r\n      tn.range(startPos, tn.pos)\r\n    );\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseEnumValue(\r\n    tn: Tokenizer\r\n  ): EnumValueDeclaration | null {\r\n\r\n    // before: Identifier ('=' Expression)?\r\n\r\n    if (!tn.skip(Token.IDENTIFIER)) {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n      return null;\r\n    }\r\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n    var value: Expression | null = null;\r\n    if (tn.skip(Token.EQUALS)) {\r\n      value = this.parseExpression(tn, Precedence.COMMA + 1);\r\n      if (!value) return null;\r\n    }\r\n    return Node.createEnumValueDeclaration(\r\n      identifier,\r\n      value,\r\n      Range.join(identifier.range, tn.range())\r\n    );\r\n  }\r\n\r\n  parseReturn(\r\n    tn: Tokenizer\r\n  ): ReturnStatement | null {\r\n\r\n    // at 'return': Expression | (';' | '}' | ...'\\n')\r\n\r\n    var expr: Expression | null = null;\r\n    if (\r\n      tn.peek(true) != Token.SEMICOLON &&\r\n      tn.nextToken != Token.CLOSEBRACE &&\r\n      !tn.nextTokenOnNewLine\r\n    ) {\r\n      if (!(expr = this.parseExpression(tn))) return null;\r\n    }\r\n\r\n    var ret = Node.createReturnStatement(expr, tn.range());\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseTypeParameters(\r\n    tn: Tokenizer\r\n  ): TypeParameter[] | null {\r\n\r\n    // at '<': TypeParameter (',' TypeParameter)* '>'\r\n\r\n    var typeParameters = new Array<TypeParameter>();\r\n    if (!tn.skip(Token.GREATERTHAN)) {\r\n      do {\r\n        var typeParameter = this.parseTypeParameter(tn);\r\n        if (!typeParameter) return null;\r\n        typeParameters.push(<TypeParameter>typeParameter);\r\n      } while (tn.skip(Token.COMMA));\r\n      if (!tn.skip(Token.GREATERTHAN)) {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \">\"\r\n        );\r\n        return null;\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Type_parameter_list_cannot_be_empty,\r\n        tn.range()\r\n      ); // recoverable\r\n    }\r\n    return typeParameters;\r\n  }\r\n\r\n  parseTypeParameter(\r\n    tn: Tokenizer\r\n  ): TypeParameter | null {\r\n\r\n    // before: Identifier ('extends' Type)?\r\n\r\n    if (tn.next() == Token.IDENTIFIER) {\r\n      var identifier = Node.createIdentifierExpression(\r\n        tn.readIdentifier(),\r\n        tn.range()\r\n      );\r\n      var extendsType: TypeNode | null = null;\r\n      if (tn.skip(Token.EXTENDS)) {\r\n        if (!(extendsType = this.parseType(tn))) return null;\r\n      }\r\n      return Node.createTypeParameter(\r\n        identifier,\r\n        extendsType,\r\n        Range.join(identifier.range, tn.range())\r\n      );\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseParameters(\r\n    tn: Tokenizer\r\n  ): Parameter[] | null {\r\n\r\n    // at '(': (Parameter (',' Parameter)*)? ')'\r\n\r\n    var parameters = new Array<Parameter>();\r\n    var seenRest: Parameter | null = null;\r\n    var seenOptional = false;\r\n    var reportedRest = false;\r\n\r\n    if (tn.peek() != Token.CLOSEPAREN) {\r\n      do {\r\n        var param = this.parseParameter(tn);\r\n        if (!param) return null;\r\n        if (seenRest && !reportedRest) {\r\n          this.error(\r\n            DiagnosticCode.A_rest_parameter_must_be_last_in_a_parameter_list,\r\n            seenRest.name.range\r\n          );\r\n          reportedRest = true;\r\n        }\r\n        switch (param.parameterKind) {\r\n\r\n          default:\r\n            if (seenOptional) {\r\n              this.error(\r\n                DiagnosticCode.A_required_parameter_cannot_follow_an_optional_parameter,\r\n                param.name.range\r\n              );\r\n            }\r\n            break;\r\n\r\n          case ParameterKind.OPTIONAL:\r\n            seenOptional = true;\r\n            break;\r\n\r\n          case ParameterKind.REST:\r\n            seenRest = param;\r\n            break;\r\n        }\r\n        parameters.push(param);\r\n      } while (tn.skip(Token.COMMA));\r\n    }\r\n    if (!tn.skip(Token.CLOSEPAREN)) {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \")\"\r\n      );\r\n      return null;\r\n    }\r\n    return parameters;\r\n  }\r\n\r\n  parseParameter(\r\n    tn: Tokenizer,\r\n    suppressErrors: bool = false\r\n  ): Parameter | null {\r\n\r\n    // before: '...'? Identifier '?'? (':' Type)? ('=' Expression)?\r\n\r\n    var isRest = false;\r\n    var isOptional = false;\r\n    var startRange: Range | null = null;\r\n    if (tn.skip(Token.DOT_DOT_DOT)) {\r\n      isRest = true;\r\n      startRange = tn.range();\r\n    }\r\n    if (tn.skip(Token.IDENTIFIER)) {\r\n      if (!isRest) startRange = tn.range();\r\n      var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      var type: TypeNode | null = null;\r\n      if (isOptional = tn.skip(Token.QUESTION)) {\r\n        if (isRest) {\r\n          this.error(\r\n            DiagnosticCode.A_rest_parameter_cannot_be_optional,\r\n            identifier.range\r\n          );\r\n        }\r\n      }\r\n      if (tn.skip(Token.COLON)) {\r\n        type = this.parseType(tn);\r\n        if (!type) return null;\r\n      }\r\n      var initializer: Expression | null = null;\r\n      if (tn.skip(Token.EQUALS)) {\r\n        if (isRest) {\r\n          this.error(\r\n            DiagnosticCode.A_rest_parameter_cannot_have_an_initializer,\r\n            identifier.range\r\n          );\r\n        }\r\n        if (isOptional) {\r\n          this.error(\r\n            DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer,\r\n            identifier.range\r\n          );\r\n        } else {\r\n          isOptional = true;\r\n        }\r\n        initializer = this.parseExpression(tn, Precedence.COMMA + 1);\r\n        if (!initializer) return null;\r\n      }\r\n      return Node.createParameter(\r\n        identifier,\r\n        type,\r\n        initializer,\r\n        isRest\r\n          ? ParameterKind.REST\r\n          : isOptional\r\n            ? ParameterKind.OPTIONAL\r\n            : ParameterKind.DEFAULT,\r\n        Range.join(<Range>startRange, tn.range())\r\n      );\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseFunction(\r\n    tn: Tokenizer,\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null\r\n  ): FunctionDeclaration | null {\r\n\r\n    // at 'function':\r\n    //  Identifier\r\n    //  ('<' TypeParameters)?\r\n    //  '(' Parameters (':' Type)?\r\n    //  '{' Statement* '}'\r\n    //  ';'?\r\n\r\n    var startPos = modifiers && modifiers.length ? modifiers[0].range.start : tn.tokenPos;\r\n\r\n    if (!tn.skip(Token.IDENTIFIER)) {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range(tn.pos)\r\n      );\r\n      return null;\r\n    }\r\n\r\n    var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n\r\n    var typeParameters: TypeParameter[] | null = null;\r\n    if (tn.skip(Token.LESSTHAN)) {\r\n      typeParameters = this.parseTypeParameters(tn);\r\n      if (!typeParameters) return null;\r\n    }\r\n\r\n    if (!tn.skip(Token.OPENPAREN)) {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(tn.pos), \"(\"\r\n      );\r\n      return null;\r\n    }\r\n\r\n    var parameters = this.parseParameters(tn);\r\n    if (!parameters) return null;\r\n\r\n    var isSetter = hasModifier(ModifierKind.SET, modifiers);\r\n    if (isSetter) {\r\n\r\n      if (parameters.length != 1) {\r\n        this.error(\r\n          DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\r\n          identifier.range\r\n        ); // recoverable\r\n      }\r\n\r\n      if (parameters.length && parameters[0].initializer) {\r\n        this.error(\r\n          DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\r\n          identifier.range\r\n        ); // recoverable\r\n      }\r\n    }\r\n\r\n    var isGetter = hasModifier(ModifierKind.GET, modifiers);\r\n    if (isGetter && parameters.length) {\r\n      this.error(\r\n        DiagnosticCode.A_get_accessor_cannot_have_parameters,\r\n        identifier.range\r\n      ); // recoverable\r\n    }\r\n\r\n    var returnType: TypeNode | null = null;\r\n    if (tn.skip(Token.COLON)) {\r\n      returnType = this.parseType(tn, isSetter);\r\n      if (!returnType) return null;\r\n\r\n    } else if (!isSetter) {\r\n      this.error(\r\n        DiagnosticCode.Type_expected,\r\n        tn.range(tn.pos)\r\n      ); // recoverable\r\n    }\r\n\r\n    var isDeclare = hasModifier(ModifierKind.DECLARE, modifiers);\r\n\r\n    var body: Statement | null = null;\r\n    if (tn.skip(Token.OPENBRACE)) {\r\n      if (isDeclare) {\r\n        this.error(\r\n          DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\r\n          tn.range()\r\n        ); // recoverable\r\n      }\r\n\r\n      body = this.parseBlockStatement(tn, false);\r\n      if (!body) return null;\r\n    } else if (!isDeclare) {\r\n      this.error(\r\n        DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\r\n        tn.range(tn.pos)\r\n      );\r\n    }\r\n\r\n    var ret = Node.createFunctionDeclaration(\r\n      identifier,\r\n      typeParameters,\r\n      <Parameter[]>parameters,\r\n      returnType,\r\n      body,\r\n      modifiers,\r\n      decorators,\r\n      tn.range(startPos, tn.pos)\r\n    );\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseFunctionExpression(tn: Tokenizer): FunctionExpression | null {\r\n    var startPos = tn.tokenPos;\r\n    var identifier: IdentifierExpression;\r\n    var isArrow = false;\r\n\r\n    // either at 'function':\r\n    //  Identifier?\r\n    //  '(' Parameters (':' Type)?\r\n    //  Statement\r\n\r\n    if (tn.token == Token.FUNCTION) {\r\n      isArrow = false;\r\n      if (tn.skip(Token.IDENTIFIER)) {\r\n        identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      } else { // empty name\r\n        identifier = Node.createIdentifierExpression(\"\", tn.range(tn.pos, tn.pos));\r\n      }\r\n      if (!tn.skip(Token.OPENPAREN)) {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(tn.pos), \"(\"\r\n        );\r\n        return null;\r\n      }\r\n\r\n    // or at '(' of arrow function:\r\n    //  Parameters (':' Type)?\r\n    //  Statement\r\n\r\n    } else {\r\n      isArrow = true;\r\n      assert(tn.token == Token.OPENPAREN);\r\n      identifier = Node.createIdentifierExpression(\"\", tn.range(tn.tokenPos, tn.tokenPos));\r\n    }\r\n\r\n    // TODO: type parameters? doesn't seem worth it.\r\n\r\n    var parameters = this.parseParameters(tn);\r\n    if (!parameters) return null;\r\n\r\n    return this.parseFunctionExpressionCommon(tn, identifier, parameters, isArrow, startPos);\r\n  }\r\n\r\n  private parseFunctionExpressionCommon(\r\n    tn: Tokenizer,\r\n    identifier: IdentifierExpression,\r\n    parameters: Parameter[],\r\n    isArrow: bool,\r\n    startPos: i32 = -1\r\n  ): FunctionExpression | null {\r\n    if (startPos < 0) startPos = identifier.range.start;\r\n\r\n    var returnType: TypeNode | null = null;\r\n    if (tn.skip(Token.COLON)) {\r\n      returnType = this.parseType(tn);\r\n      if (!returnType) return null;\r\n    }\r\n\r\n    if (isArrow) {\r\n      if (!tn.skip(Token.EQUALS_GREATERTHAN)) {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(tn.pos), \"=>\"\r\n        );\r\n        return null;\r\n      }\r\n    }\r\n\r\n    var body: Statement | null;\r\n    if (isArrow) {\r\n      body = this.parseStatement(tn, false);\r\n    } else {\r\n      if (!tn.skip(Token.OPENBRACE)) {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(tn.pos), \"{\"\r\n        );\r\n        return null;\r\n      }\r\n      body = this.parseBlockStatement(tn, false);\r\n    }\r\n    if (!body) return null;\r\n\r\n    var declaration = Node.createFunctionDeclaration(\r\n      identifier,\r\n      null,\r\n      parameters,\r\n      returnType,\r\n      body,\r\n      null,\r\n      null,\r\n      tn.range(startPos, tn.pos)\r\n    );\r\n    return Node.createFunctionExpression(declaration, isArrow);\r\n  }\r\n\r\n  parseClass(\r\n    tn: Tokenizer,\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null\r\n  ): ClassDeclaration | null {\r\n\r\n    // at 'class':\r\n    //   Identifier\r\n    //   ('<' TypeParameters)?\r\n    //   ('extends' Type)?\r\n    //   ('implements' Type (',' Type)*)?\r\n    //   '{' ClassMember* '}'\r\n\r\n    var startPos = decorators && decorators.length\r\n      ? decorators[0].range.start\r\n      : modifiers && modifiers.length\r\n      ? modifiers[0].range.start\r\n      : tn.tokenPos;\r\n\r\n    if (tn.skip(Token.IDENTIFIER)) {\r\n\r\n      var identifier = Node.createIdentifierExpression(\r\n        tn.readIdentifier(),\r\n        tn.range()\r\n      );\r\n\r\n      var typeParameters: TypeParameter[] | null;\r\n      if (tn.skip(Token.LESSTHAN)) {\r\n        typeParameters = this.parseTypeParameters(tn);\r\n        if (!typeParameters) return null;\r\n      } else {\r\n        typeParameters = [];\r\n      }\r\n\r\n      var extendsType: TypeNode | null = null;\r\n      if (tn.skip(Token.EXTENDS)) {\r\n        extendsType = this.parseType(tn);\r\n        if (!extendsType) return null;\r\n      }\r\n\r\n      var implementsTypes = new Array<TypeNode>();\r\n      if (tn.skip(Token.IMPLEMENTS)) {\r\n        do {\r\n          var type = this.parseType(tn);\r\n          if (!type) return null;\r\n          implementsTypes.push(<TypeNode>type);\r\n        } while (tn.skip(Token.COMMA));\r\n      }\r\n\r\n      if (tn.skip(Token.OPENBRACE)) {\r\n\r\n        var members = new Array<DeclarationStatement>();\r\n        if (!tn.skip(Token.CLOSEBRACE)) {\r\n          var isDeclare = hasModifier(ModifierKind.DECLARE, modifiers);\r\n          do {\r\n            var member = this.parseClassMember(tn, isDeclare);\r\n            if (!member) return null;\r\n            members.push(<DeclarationStatement>member);\r\n          } while (!tn.skip(Token.CLOSEBRACE));\r\n        }\r\n        return Node.createClassDeclaration(\r\n          identifier,\r\n          typeParameters,\r\n          extendsType,\r\n          implementsTypes,\r\n          members,\r\n          modifiers,\r\n          decorators,\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"{\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseClassMember(\r\n    tn: Tokenizer,\r\n    parentIsDeclare: bool\r\n  ): DeclarationStatement | null {\r\n\r\n    // before:\r\n    //   ('public' | 'private' | 'protected')?\r\n    //   ('static' | 'abstract')?\r\n    //   ('get' | 'set')?\r\n    //   Identifier ...\r\n\r\n    var startPos = tn.pos;\r\n\r\n    var decorators = new Array<Decorator>();\r\n    while (tn.skip(Token.AT)) {\r\n      var decorator = this.parseDecorator(tn);\r\n      if (!decorator) break;\r\n      decorators.push(<Decorator>decorator);\r\n    }\r\n\r\n    var modifiers: Modifier[] | null = null;\r\n\r\n    if (tn.skip(Token.PUBLIC)) {\r\n      modifiers = addModifier(Node.createModifier(ModifierKind.PUBLIC, tn.range()), modifiers);\r\n    } else if (tn.skip(Token.PRIVATE)) {\r\n      modifiers = addModifier(Node.createModifier(ModifierKind.PRIVATE, tn.range()), modifiers);\r\n    } else if (tn.skip(Token.PROTECTED)) {\r\n      modifiers = addModifier(Node.createModifier(ModifierKind.PROTECTED, tn.range()), modifiers);\r\n    }\r\n\r\n    if (tn.skip(Token.STATIC)) {\r\n      modifiers = addModifier(Node.createModifier(ModifierKind.STATIC, tn.range()), modifiers);\r\n    } else if (tn.skip(Token.ABSTRACT)) {\r\n      modifiers = addModifier(Node.createModifier(ModifierKind.ABSTRACT, tn.range()), modifiers);\r\n    }\r\n\r\n    if (tn.skip(Token.READONLY)) {\r\n      modifiers = addModifier(Node.createModifier(ModifierKind.READONLY, tn.range()), modifiers);\r\n    }\r\n\r\n    // check if accessor: ('get' | 'set') ^\\n Identifier\r\n    tn.mark();\r\n\r\n    var isGetter = false;\r\n    var isSetter = false;\r\n\r\n    if (isGetter = tn.skip(Token.GET)) {\r\n      if (tn.peek(true, true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\r\n        modifiers = addModifier(Node.createModifier(ModifierKind.GET, tn.range()), modifiers);\r\n      } else {\r\n        tn.reset();\r\n        isGetter = false;\r\n      }\r\n\r\n    } else if (isSetter = tn.skip(Token.SET)) { // can't be both\r\n      if (tn.peek(true, true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\r\n        modifiers = addModifier(Node.createModifier(ModifierKind.SET, tn.range()), modifiers);\r\n      } else {\r\n        tn.reset();\r\n        isSetter = false;\r\n      }\r\n    }\r\n\r\n    var isConstructor = tn.skip(Token.CONSTRUCTOR);\r\n    if (isConstructor || tn.skip(Token.IDENTIFIER)) {\r\n\r\n      var identifier = isConstructor\r\n        ? Node.createConstructorExpression(tn.range())\r\n        : Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n\r\n      var typeParameters: TypeParameter[] | null = null;\r\n      if (tn.skip(Token.LESSTHAN)) {\r\n        if (isConstructor) {\r\n          this.error(\r\n            DiagnosticCode.Type_parameters_cannot_appear_on_a_constructor_declaration,\r\n            tn.range()\r\n          ); // recoverable\r\n        }\r\n        typeParameters = this.parseTypeParameters(tn);\r\n        if (!typeParameters) return null;\r\n      }\r\n\r\n      // method: '(' Parameters (':' Type)? '{' Statement* '}' ';'?\r\n      if (tn.skip(Token.OPENPAREN)) {\r\n        var parameters = this.parseParameters(tn);\r\n        if (!parameters) return null;\r\n\r\n        if (isGetter && parameters.length) {\r\n          this.error(\r\n            DiagnosticCode.A_get_accessor_cannot_have_parameters,\r\n            identifier.range\r\n          );\r\n        }\r\n\r\n        if (isSetter) {\r\n          if (parameters.length != 1) {\r\n            this.error(\r\n              DiagnosticCode.A_set_accessor_must_have_exactly_one_parameter,\r\n              identifier.range\r\n            );\r\n          }\r\n          if (parameters.length && parameters[0].initializer) {\r\n            this.error(\r\n              DiagnosticCode.A_set_accessor_parameter_cannot_have_an_initializer,\r\n              identifier.range\r\n            );\r\n          }\r\n        }\r\n\r\n        var returnType: TypeNode | null = null;\r\n        if (tn.skip(Token.COLON)) {\r\n          if (identifier.kind == NodeKind.CONSTRUCTOR) {\r\n            this.error(\r\n              DiagnosticCode.Type_annotation_cannot_appear_on_a_constructor_declaration,\r\n              tn.range()\r\n            );\r\n          } else if (isSetter) {\r\n            this.error(\r\n              DiagnosticCode.A_set_accessor_cannot_have_a_return_type_annotation,\r\n              tn.range()\r\n            );\r\n          }\r\n          returnType = this.parseType(tn, identifier.kind == NodeKind.CONSTRUCTOR || isSetter);\r\n          if (!returnType) return null;\r\n        } else if (!isSetter && identifier.kind != NodeKind.CONSTRUCTOR) {\r\n          this.error(\r\n            DiagnosticCode.Type_expected,\r\n            tn.range()\r\n          ); // recoverable\r\n        }\r\n\r\n        var body: Statement | null = null;\r\n        if (tn.skip(Token.OPENBRACE)) {\r\n          if (parentIsDeclare) {\r\n            this.error(\r\n              DiagnosticCode.An_implementation_cannot_be_declared_in_ambient_contexts,\r\n              tn.range()\r\n            ); // recoverable\r\n          }\r\n          body = this.parseBlockStatement(tn, false);\r\n          if (!body) return null;\r\n        } else if (!parentIsDeclare) {\r\n          this.error(\r\n            DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\r\n            tn.range()\r\n          ); // recoverable\r\n        }\r\n\r\n        var retMethod = Node.createMethodDeclaration(\r\n          identifier,\r\n          typeParameters,\r\n          parameters,\r\n          returnType,\r\n          body,\r\n          modifiers,\r\n          decorators,\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n        tn.skip(Token.SEMICOLON);\r\n        return retMethod;\r\n\r\n      } else if (isConstructor) {\r\n        this.error(\r\n          DiagnosticCode.Constructor_implementation_is_missing,\r\n          identifier.range\r\n        );\r\n\r\n      } else if (isGetter || isSetter) {\r\n        this.error(\r\n          DiagnosticCode.Function_implementation_is_missing_or_not_immediately_following_the_declaration,\r\n          identifier.range\r\n        );\r\n\r\n      // field: (':' Type)? ('=' Expression)? ';'?\r\n      } else {\r\n        var modifier: Modifier | null;\r\n\r\n        if (modifier = getModifier(ModifierKind.ABSTRACT, modifiers)) {\r\n          this.error(\r\n            DiagnosticCode._0_modifier_cannot_be_used_here,\r\n            modifier.range, \"abstract\"\r\n          ); // recoverable\r\n        }\r\n\r\n        if (modifier = getModifier(ModifierKind.GET, modifiers)) {\r\n          this.error(\r\n            DiagnosticCode._0_modifier_cannot_be_used_here,\r\n            modifier.range, \"get\"\r\n          ); // recoverable\r\n        }\r\n\r\n        if (modifier = getModifier(ModifierKind.SET, modifiers)) {\r\n          this.error(\r\n            DiagnosticCode._0_modifier_cannot_be_used_here,\r\n            modifier.range, \"set\"\r\n          ); // recoverable\r\n        }\r\n\r\n        var type: TypeNode | null = null;\r\n        if (tn.skip(Token.COLON)) {\r\n          type = this.parseType(tn);\r\n          if (!type) return null;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Type_expected,\r\n            tn.range()\r\n          ); // recoverable\r\n        }\r\n        var initializer: Expression | null = null;\r\n        if (tn.skip(Token.EQUALS)) {\r\n          initializer = this.parseExpression(tn);\r\n          if (!initializer) return null;\r\n        }\r\n        var retField = Node.createFieldDeclaration(\r\n          identifier,\r\n          type,\r\n          initializer,\r\n          modifiers,\r\n          decorators,\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n        tn.skip(Token.SEMICOLON);\r\n        return retField;\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseNamespace(\r\n    tn: Tokenizer,\r\n    modifiers: Modifier[] | null,\r\n    decorators: Decorator[] | null\r\n  ): NamespaceDeclaration | null {\r\n\r\n    // at 'namespace': Identifier '{' (Variable | Function)* '}'\r\n\r\n    var startPos = modifiers && modifiers.length ? modifiers[0].range.start : tn.tokenPos;\r\n    if (tn.skip(Token.IDENTIFIER)) {\r\n      var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      if (tn.skip(Token.OPENBRACE)) {\r\n        var members = new Array<Statement>();\r\n        while (!tn.skip(Token.CLOSEBRACE)) {\r\n          var member = this.parseTopLevelStatement(tn, true);\r\n          if (!member) return null;\r\n          members.push(member);\r\n        }\r\n        var ret = Node.createNamespaceDeclaration(\r\n          identifier,\r\n          members,\r\n          modifiers,\r\n          decorators,\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n        tn.skip(Token.SEMICOLON);\r\n        return ret;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"{\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseExport(\r\n    tn: Tokenizer,\r\n    modifiers: Modifier[] | null\r\n  ): ExportStatement | null {\r\n\r\n    // at 'export': '{' ExportMember (',' ExportMember)* }' ('from' StringLiteral)? ';'?\r\n\r\n    var startPos = modifiers && modifiers.length ? modifiers[0].range.start : tn.tokenPos;\r\n\r\n    if (tn.skip(Token.OPENBRACE)) {\r\n      var members = new Array<ExportMember>();\r\n      if (!tn.skip(Token.CLOSEBRACE)) {\r\n        do {\r\n          var member = this.parseExportMember(tn);\r\n          if (!member) return null;\r\n          members.push(member);\r\n        } while (tn.skip(Token.COMMA));\r\n        if (!tn.skip(Token.CLOSEBRACE)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"}\"\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n      var path: StringLiteralExpression | null = null;\r\n      if (tn.skip(Token.FROM)) {\r\n        if (tn.skip(Token.STRINGLITERAL)) {\r\n          path = Node.createStringLiteralExpression(tn.readString(), tn.range());\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.String_literal_expected,\r\n            tn.range()\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n      var ret = Node.createExportStatement(members, path, modifiers, tn.range(startPos, tn.pos));\r\n      if (ret.normalizedPath && !this.seenlog.has(<string>ret.normalizedPath)) {\r\n        this.backlog.push(<string>ret.normalizedPath);\r\n        this.seenlog.add(<string>ret.normalizedPath);\r\n      }\r\n      tn.skip(Token.SEMICOLON);\r\n      return ret;\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"{\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseExportMember(\r\n    tn: Tokenizer\r\n  ): ExportMember | null {\r\n\r\n    // before: Identifier ('as' Identifier)?\r\n\r\n    if (tn.skip(Token.IDENTIFIER)) {\r\n      var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      var asIdentifier: IdentifierExpression | null = null;\r\n      if (tn.skip(Token.AS)) {\r\n        if (tn.skip(Token.IDENTIFIER)) {\r\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            tn.range()\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n      return Node.createExportMember(\r\n        identifier,\r\n        asIdentifier,\r\n        asIdentifier\r\n          ? Range.join(identifier.range, asIdentifier.range)\r\n          : identifier.range\r\n      );\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseImport(\r\n    tn: Tokenizer\r\n  ): ImportStatement | null {\r\n\r\n    // at 'import':\r\n    //  ('{' (ImportMember (',' ImportMember)* '}') | ('*' 'as' Identifier)?\r\n    //  'from' StringLiteral ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    var members: ImportDeclaration[] | null = null;\r\n    var namespaceName: IdentifierExpression | null = null;\r\n    var skipFrom = false;\r\n    if (tn.skip(Token.OPENBRACE)) {\r\n      members = new Array();\r\n      if (!tn.skip(Token.CLOSEBRACE)) {\r\n        do {\r\n          var member = this.parseImportDeclaration(tn);\r\n          if (!member) return null;\r\n          members.push(member);\r\n        } while (tn.skip(Token.COMMA));\r\n        if (!tn.skip(Token.CLOSEBRACE)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"}\"\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n    } else if (tn.skip(Token.ASTERISK)) {\r\n      if (tn.skip(Token.AS)) {\r\n        if (tn.skip(Token.IDENTIFIER)) {\r\n          namespaceName = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            tn.range()\r\n          );\r\n          return null;\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"as\"\r\n        );\r\n        return null;\r\n      }\r\n    } else {\r\n      skipFrom = true;\r\n    }\r\n\r\n    if (skipFrom || tn.skip(Token.FROM)) {\r\n      if (tn.skip(Token.STRINGLITERAL)) {\r\n        var path = Node.createStringLiteralExpression(tn.readString(), tn.range());\r\n        var ret: ImportStatement;\r\n        if (namespaceName) {\r\n          assert(!members);\r\n          ret = Node.createImportStatementWithWildcard(namespaceName, path, tn.range(startPos, tn.pos));\r\n        } else {\r\n          ret = Node.createImportStatement(members, path, tn.range(startPos, tn.pos));\r\n        }\r\n        if (!this.seenlog.has(ret.normalizedPath)) {\r\n          this.backlog.push(ret.normalizedPath);\r\n          this.seenlog.add(ret.normalizedPath);\r\n        }\r\n        tn.skip(Token.SEMICOLON);\r\n        return ret;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode.String_literal_expected,\r\n          tn.range()\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"from\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseImportDeclaration(\r\n    tn: Tokenizer\r\n  ): ImportDeclaration | null {\r\n\r\n    // before: Identifier ('as' Identifier)?\r\n\r\n    if (tn.skip(Token.IDENTIFIER)) {\r\n      var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      var asIdentifier: IdentifierExpression | null = null;\r\n      if (tn.skip(Token.AS)) {\r\n        if (tn.skip(Token.IDENTIFIER)) {\r\n          asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            tn.range()\r\n          );\r\n          return null;\r\n        }\r\n      }\r\n      return Node.createImportDeclaration(\r\n        identifier,\r\n        asIdentifier,\r\n        asIdentifier\r\n          ? Range.join(identifier.range, asIdentifier.range)\r\n          : identifier.range\r\n      );\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseExportImport(\r\n    tn: Tokenizer,\r\n    startRange: Range\r\n  ): ExportImportStatement | null {\r\n\r\n    // at 'export' 'import': Identifier ('=' Identifier)? ';'?\r\n\r\n    if (tn.skip(Token.IDENTIFIER)) {\r\n      var asIdentifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      if (tn.skip(Token.EQUALS)) {\r\n        if (tn.skip(Token.IDENTIFIER)) {\r\n          var identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n          var ret = Node.createExportImportStatement(identifier, asIdentifier, Range.join(startRange, tn.range()));\r\n          tn.skip(Token.SEMICOLON);\r\n          return ret;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            tn.range()\r\n          );\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"=\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseStatement(\r\n    tn: Tokenizer,\r\n    topLevel: bool = false\r\n  ): Statement | null {\r\n\r\n    // at previous token\r\n\r\n    tn.mark();\r\n    var token = tn.next();\r\n    switch (token) {\r\n\r\n      case Token.BREAK:\r\n        return this.parseBreak(tn);\r\n\r\n      case Token.CONST:\r\n        return this.parseVariable(tn, [\r\n          Node.createModifier(ModifierKind.CONST, tn.range())\r\n        ], null);\r\n\r\n      case Token.CONTINUE:\r\n        return this.parseContinue(tn);\r\n\r\n      case Token.DO:\r\n        return this.parseDoStatement(tn);\r\n\r\n      case Token.FOR:\r\n        return this.parseForStatement(tn);\r\n\r\n      case Token.IF:\r\n        return this.parseIfStatement(tn);\r\n\r\n      case Token.LET:\r\n        return this.parseVariable(tn, [\r\n          Node.createModifier(ModifierKind.LET, tn.range())\r\n        ], null);\r\n\r\n      case Token.VAR:\r\n        return this.parseVariable(tn, null, null);\r\n\r\n      case Token.OPENBRACE:\r\n        return this.parseBlockStatement(tn, topLevel);\r\n\r\n      case Token.RETURN:\r\n        if (topLevel) {\r\n          this.error(\r\n            DiagnosticCode.A_return_statement_can_only_be_used_within_a_function_body,\r\n            tn.range()\r\n          ); // recoverable\r\n        }\r\n        return this.parseReturn(tn);\r\n\r\n      case Token.SEMICOLON:\r\n        return Node.createEmptyStatement(tn.range(tn.tokenPos));\r\n\r\n      case Token.SWITCH:\r\n        return this.parseSwitchStatement(tn);\r\n\r\n      case Token.THROW:\r\n        return this.parseThrowStatement(tn);\r\n\r\n      case Token.TRY:\r\n        return this.parseTryStatement(tn);\r\n\r\n      case Token.TYPE:\r\n        return this.parseTypeDeclaration(tn, null);\r\n\r\n      case Token.WHILE:\r\n        return this.parseWhileStatement(tn);\r\n\r\n      default:\r\n        tn.reset();\r\n        return this.parseExpressionStatement(tn);\r\n    }\r\n  }\r\n\r\n  parseBlockStatement(\r\n    tn: Tokenizer,\r\n    topLevel: bool\r\n  ): BlockStatement | null {\r\n\r\n    // at '{': Statement* '}' ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    var statements = new Array<Statement>();\r\n    while (!tn.skip(Token.CLOSEBRACE)) {\r\n      var statement = this.parseStatement(tn, topLevel);\r\n      if (!statement) return null;\r\n      statements.push(statement);\r\n    }\r\n    var ret = Node.createBlockStatement(statements, tn.range(startPos, tn.pos));\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseBreak(\r\n    tn: Tokenizer\r\n  ): BreakStatement | null {\r\n\r\n    // at 'break': Identifier? ';'?\r\n\r\n    var identifier: IdentifierExpression | null = null;\r\n    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\r\n      tn.next(true);\r\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n    }\r\n    var ret = Node.createBreakStatement(identifier, tn.range());\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseContinue(\r\n    tn: Tokenizer\r\n  ): ContinueStatement | null {\r\n\r\n    // at 'continue': Identifier? ';'?\r\n\r\n    var identifier: IdentifierExpression | null = null;\r\n    if (tn.peek(true) == Token.IDENTIFIER && !tn.nextTokenOnNewLine) {\r\n      tn.next(true);\r\n      identifier = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n    }\r\n    var ret = Node.createContinueStatement(identifier, tn.range());\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseDoStatement(\r\n    tn: Tokenizer\r\n  ): DoStatement | null {\r\n\r\n    // at 'do': Statement 'while' '(' Expression ')' ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    var statement = this.parseStatement(tn);\r\n    if (!statement) return null;\r\n\r\n    if (tn.skip(Token.WHILE)) {\r\n\r\n      if (tn.skip(Token.OPENPAREN)) {\r\n        var condition = this.parseExpression(tn);\r\n        if (!condition) return null;\r\n\r\n        if (tn.skip(Token.CLOSEPAREN)) {\r\n          var ret = Node.createDoStatement(<Statement>statement, <Expression>condition, tn.range(startPos, tn.pos));\r\n          tn.skip(Token.SEMICOLON);\r\n          return ret;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \")\"\r\n          );\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"(\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"while\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseExpressionStatement(\r\n    tn: Tokenizer\r\n  ): ExpressionStatement | null {\r\n\r\n    // at previous token\r\n\r\n    var expr = this.parseExpression(tn);\r\n    if (!expr) return null;\r\n\r\n    var ret = Node.createExpressionStatement(expr);\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseForStatement(\r\n    tn: Tokenizer\r\n  ): ForStatement | null {\r\n\r\n    // at 'for': '(' Statement? Expression? ';' Expression? ')' Statement\r\n\r\n    var startPos = tn.tokenPos;\r\n\r\n    if (tn.skip(Token.OPENPAREN)) {\r\n\r\n      var initializer: Statement | null = null;\r\n\r\n      if (tn.skip(Token.LET) || tn.skip(Token.CONST) || tn.skip(Token.VAR)) {\r\n        initializer = this.parseVariable(tn, null, null);\r\n\r\n      } else if (!tn.skip(Token.SEMICOLON)) {\r\n        initializer = this.parseExpressionStatement(tn);\r\n        if (!initializer) return null;\r\n      }\r\n\r\n      if (tn.token == Token.SEMICOLON) {\r\n        var condition: ExpressionStatement | null = null;\r\n        if (!tn.skip(Token.SEMICOLON)) {\r\n          condition = this.parseExpressionStatement(tn);\r\n          if (!condition) return null;\r\n        }\r\n\r\n        if (tn.token == Token.SEMICOLON) {\r\n          var incrementor: Expression | null = null;\r\n          if (!tn.skip(Token.CLOSEPAREN)) {\r\n            incrementor = this.parseExpression(tn);\r\n            if (!incrementor) return null;\r\n\r\n            if (!tn.skip(Token.CLOSEPAREN)) {\r\n              this.error(\r\n                DiagnosticCode._0_expected,\r\n                tn.range(), \")\"\r\n              );\r\n              return null;\r\n            }\r\n          }\r\n\r\n          var statement = this.parseStatement(tn);\r\n          if (!statement) return null;\r\n\r\n          return Node.createForStatement(\r\n            initializer,\r\n            condition\r\n              ? condition.expression\r\n              : null,\r\n            incrementor,\r\n            statement,\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \";\"\r\n          );\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \";\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"(\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseIfStatement(\r\n    tn: Tokenizer\r\n  ): IfStatement | null {\r\n\r\n    // at 'if': '(' Expression ')' Statement ('else' Statement)?\r\n\r\n    var startPos = tn.tokenPos;\r\n    if (tn.skip(Token.OPENPAREN)) {\r\n      var condition = this.parseExpression(tn);\r\n      if (!condition) return null;\r\n      if (tn.skip(Token.CLOSEPAREN)) {\r\n        var statement = this.parseStatement(tn);\r\n        if (!statement) return null;\r\n        var elseStatement: Statement | null = null;\r\n        if (tn.skip(Token.ELSE)) {\r\n          elseStatement = this.parseStatement(tn);\r\n          if (!elseStatement) return null;\r\n        }\r\n        return Node.createIfStatement(\r\n          condition,\r\n          statement,\r\n          elseStatement,\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \")\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"(\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseSwitchStatement(\r\n    tn: Tokenizer\r\n  ): SwitchStatement | null {\r\n\r\n    // at 'switch': '(' Expression ')' '{' SwitchCase* '}' ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    if (tn.skip(Token.OPENPAREN)) {\r\n      var condition = this.parseExpression(tn);\r\n      if (!condition) return null;\r\n      if (tn.skip(Token.CLOSEPAREN)) {\r\n        if (tn.skip(Token.OPENBRACE)) {\r\n          var cases = new Array<SwitchCase>();\r\n          while (!tn.skip(Token.CLOSEBRACE)) {\r\n            var case_ = this.parseSwitchCase(tn);\r\n            if (!case_) return null;\r\n            cases.push(<SwitchCase>case_);\r\n          }\r\n          var ret = Node.createSwitchStatement(condition, cases, tn.range(startPos, tn.pos));\r\n          tn.skip(Token.SEMICOLON);\r\n          return ret;\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"{\"\r\n          );\r\n        }\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \")\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"(\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseSwitchCase(\r\n    tn: Tokenizer\r\n  ): SwitchCase | null {\r\n\r\n    var startPos = tn.tokenPos;\r\n    var statements: Statement[],\r\n        statement: Statement | null;\r\n\r\n    // 'case' Expression ':' Statement*\r\n\r\n    if (tn.skip(Token.CASE)) {\r\n      var label = this.parseExpression(tn);\r\n      if (!label) return null;\r\n      if (tn.skip(Token.COLON)) {\r\n        statements = new Array<Statement>();\r\n        while (tn.peek() != Token.CASE && tn.nextToken != Token.DEFAULT && tn.nextToken != Token.CLOSEBRACE) {\r\n          statement = this.parseStatement(tn);\r\n          if (!statement) return null;\r\n          statements.push(statement);\r\n        }\r\n        return Node.createSwitchCase(label, statements, tn.range(startPos, tn.pos));\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \":\"\r\n        );\r\n      }\r\n\r\n    // 'default' ':' Statement*\r\n\r\n    } else if (tn.skip(Token.DEFAULT)) {\r\n      if (tn.skip(Token.COLON)) {\r\n        statements = new Array<Statement>();\r\n        while (tn.peek() != Token.CASE && tn.nextToken != Token.DEFAULT && tn.nextToken != Token.CLOSEBRACE) {\r\n          statement = this.parseStatement(tn);\r\n          if (!statement) return null;\r\n          statements.push(statement);\r\n        }\r\n        return Node.createSwitchCase(null, statements, tn.range(startPos, tn.pos));\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \":\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._case_or_default_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseThrowStatement(\r\n    tn: Tokenizer\r\n  ): ThrowStatement | null {\r\n\r\n    // at 'throw': Expression ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    var expression = this.parseExpression(tn);\r\n    if (!expression) return null;\r\n    var ret = Node.createThrowStatement(<Expression>expression, tn.range(startPos, tn.pos));\r\n    tn.skip(Token.SEMICOLON);\r\n    return ret;\r\n  }\r\n\r\n  parseTryStatement(\r\n    tn: Tokenizer\r\n  ): TryStatement | null {\r\n\r\n    // at 'try':\r\n    //   '{' Statement* '}'\r\n    //   ('catch' '(' VariableMember ')' '{' Statement* '}')?\r\n    //   ('finally' '{' Statement* '}'? ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    var stmt: Statement | null;\r\n    if (tn.skip(Token.OPENBRACE)) {\r\n      var statements = new Array<Statement>();\r\n      while (!tn.skip(Token.CLOSEBRACE)) {\r\n        stmt = this.parseStatement(tn);\r\n        if (!stmt) return null;\r\n        statements.push(<Statement>stmt);\r\n      }\r\n      var catchVariable: IdentifierExpression | null = null;\r\n      var catchStatements: Statement[] | null = null;\r\n      var finallyStatements: Statement[] | null = null;\r\n      if (tn.skip(Token.CATCH)) {\r\n        if (!tn.skip(Token.OPENPAREN)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"(\"\r\n          );\r\n          return null;\r\n        }\r\n        if (!tn.skip(Token.IDENTIFIER)) {\r\n          this.error(\r\n            DiagnosticCode.Identifier_expected,\r\n            tn.range()\r\n          );\r\n          return null;\r\n        }\r\n        catchVariable = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n        if (!tn.skip(Token.CLOSEPAREN)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \")\"\r\n          );\r\n          return null;\r\n        }\r\n        if (!tn.skip(Token.OPENBRACE)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"{\"\r\n          );\r\n          return null;\r\n        }\r\n        catchStatements = [];\r\n        while (!tn.skip(Token.CLOSEBRACE)) {\r\n          stmt = this.parseStatement(tn);\r\n          if (!stmt) return null;\r\n          catchStatements.push(<Statement>stmt);\r\n        }\r\n      }\r\n      if (tn.skip(Token.FINALLY)) {\r\n        if (!tn.skip(Token.OPENBRACE)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"{\"\r\n          );\r\n          return null;\r\n        }\r\n        finallyStatements = [];\r\n        while (!tn.skip(Token.CLOSEBRACE)) {\r\n          stmt = this.parseStatement(tn);\r\n          if (!stmt) return null;\r\n          finallyStatements.push(<Statement>stmt);\r\n        }\r\n      }\r\n      if (!(catchStatements || finallyStatements)) {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"catch\"\r\n        );\r\n        return null;\r\n      }\r\n      var ret = Node.createTryStatement(\r\n        statements,\r\n        catchVariable,\r\n        catchStatements,\r\n        finallyStatements,\r\n        tn.range(startPos, tn.pos)\r\n      );\r\n      tn.skip(Token.SEMICOLON);\r\n      return ret;\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"{\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseTypeDeclaration(\r\n    tn: Tokenizer,\r\n    modifiers: Modifier[] | null = null,\r\n    decorators: Decorator[] | null = null\r\n  ): TypeDeclaration | null {\r\n\r\n    // at 'type': Identifier '=' Type ';'?\r\n\r\n    var startPos = decorators && decorators.length ? decorators[0].range.start\r\n                 : modifiers && modifiers.length ? modifiers[0].range.start\r\n                 : tn.tokenPos;\r\n    if (tn.skip(Token.IDENTIFIER)) {\r\n      var name = Node.createIdentifierExpression(tn.readIdentifier(), tn.range());\r\n      if (tn.skip(Token.EQUALS)) {\r\n        var type = this.parseType(tn);\r\n        if (!type) return null;\r\n        var ret = Node.createTypeDeclaration(name, type, modifiers, decorators, tn.range(startPos, tn.pos));\r\n        tn.skip(Token.SEMICOLON);\r\n        return ret;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \"=\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode.Identifier_expected,\r\n        tn.range()\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  parseWhileStatement(\r\n    tn: Tokenizer\r\n  ): WhileStatement | null {\r\n\r\n    // at 'while': '(' Expression ')' Statement ';'?\r\n\r\n    var startPos = tn.tokenPos;\r\n    if (tn.skip(Token.OPENPAREN)) {\r\n      var expression = this.parseExpression(tn);\r\n      if (!expression) return null;\r\n      if (tn.skip(Token.CLOSEPAREN)) {\r\n        var statement = this.parseStatement(tn);\r\n        if (!statement) return null;\r\n        var ret = Node.createWhileStatement(<Expression>expression, <Statement>statement, tn.range(startPos, tn.pos));\r\n        tn.skip(Token.SEMICOLON);\r\n        return ret;\r\n      } else {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \")\"\r\n        );\r\n      }\r\n    } else {\r\n      this.error(\r\n        DiagnosticCode._0_expected,\r\n        tn.range(), \"(\"\r\n      );\r\n    }\r\n    return null;\r\n  }\r\n\r\n  // expressions\r\n  // see: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing\r\n\r\n  parseExpressionStart(\r\n    tn: Tokenizer\r\n  ): Expression | null {\r\n\r\n    var token = tn.next(true);\r\n    var startPos = tn.tokenPos;\r\n    var expr: Expression | null = null;\r\n\r\n    if (token == Token.NULL) {\r\n      return Node.createNullExpression(tn.range());\r\n    }\r\n    if (token == Token.TRUE) {\r\n      return Node.createTrueExpression(tn.range());\r\n    }\r\n    if (token == Token.FALSE) {\r\n      return Node.createFalseExpression(tn.range());\r\n    }\r\n\r\n    var p = determinePrecedenceStart(token);\r\n    if (p != Precedence.INVALID) {\r\n      var operand: Expression | null;\r\n\r\n      // TODO: SpreadExpression, YieldExpression (currently become unsupported UnaryPrefixExpressions)\r\n\r\n      // NewExpression\r\n      if (token == Token.NEW) {\r\n        operand = this.parseExpression(tn, Precedence.CALL);\r\n        if (!operand) return null;\r\n        if (operand.kind == NodeKind.CALL) {\r\n          return Node.createNewExpression(\r\n            (<CallExpression>operand).expression,\r\n            (<CallExpression>operand).typeArguments,\r\n            (<CallExpression>operand).arguments,\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n        } else {\r\n          this.error(\r\n            DiagnosticCode.Operation_not_supported,\r\n            tn.range()\r\n          );\r\n        }\r\n        return null;\r\n      } else {\r\n        operand = this.parseExpression(tn, p);\r\n        if (!operand) return null;\r\n      }\r\n\r\n      // UnaryPrefixExpression\r\n      if (token == Token.PLUS_PLUS || token == Token.MINUS_MINUS) {\r\n        if (\r\n          operand.kind != NodeKind.IDENTIFIER &&\r\n          operand.kind != NodeKind.ELEMENTACCESS &&\r\n          operand.kind != NodeKind.PROPERTYACCESS\r\n        ) {\r\n          this.error(\r\n            DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\r\n            operand.range\r\n          );\r\n        }\r\n      }\r\n      return Node.createUnaryPrefixExpression(token, operand, tn.range(startPos, tn.pos));\r\n    }\r\n\r\n    switch (token) {\r\n\r\n      // ParenthesizedExpression\r\n      // FunctionExpression\r\n      case Token.OPENPAREN:\r\n\r\n        // determine whether this is a function expression\r\n        if (tn.skip(Token.CLOSEPAREN)) { // must be a function expression (fast route)\r\n          return this.parseFunctionExpressionCommon(\r\n            tn,\r\n            Node.createIdentifierExpression(\"\", tn.range(startPos, startPos)),\r\n            [],\r\n            true\r\n          );\r\n        }\r\n        tn.mark();\r\n        var again = true;\r\n        do {\r\n          switch (tn.next(true)) {\r\n\r\n            // function expression\r\n            case Token.DOT_DOT_DOT:\r\n              tn.reset();\r\n              return this.parseFunctionExpression(tn);\r\n\r\n            // can be both\r\n            case Token.IDENTIFIER:\r\n              tn.readIdentifier();\r\n              switch (tn.next()) {\r\n\r\n                // if we got here, check for arrow\r\n                case Token.CLOSEPAREN:\r\n                  if (!tn.skip(Token.EQUALS_GREATERTHAN)) {\r\n                    again = false;\r\n                    break;\r\n                  }\r\n                  // fall-through\r\n\r\n                // function expression\r\n                case Token.QUESTION:   // optional parameter\r\n                case Token.COLON:      // type annotation\r\n                  tn.reset();\r\n                  return this.parseFunctionExpression(tn);\r\n\r\n                // can be both\r\n                case Token.COMMA:\r\n                  break; // continue\r\n\r\n                // parenthesized expression\r\n                // case Token.EQUALS:  // missing type annotation for simplicity\r\n                default:\r\n                  again = false;\r\n                  break;\r\n              }\r\n              break;\r\n\r\n            // parenthesized expression\r\n            default:\r\n              again = false;\r\n              break;\r\n          }\r\n        } while (again);\r\n        tn.reset();\r\n\r\n        // parse parenthesized\r\n        expr = this.parseExpression(tn);\r\n        if (!expr) return null;\r\n        if (!tn.skip(Token.CLOSEPAREN)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \")\"\r\n          );\r\n          return null;\r\n        }\r\n        return Node.createParenthesizedExpression(expr, tn.range(startPos, tn.pos));\r\n\r\n      // ArrayLiteralExpression\r\n      case Token.OPENBRACKET:\r\n        var elementExpressions = new Array<Expression | null>();\r\n\r\n        if (!tn.skip(Token.CLOSEBRACKET)) {\r\n          do {\r\n            if (tn.peek() == Token.COMMA) {\r\n              expr = null; // omitted\r\n            } else {\r\n              expr = this.parseExpression(tn, Precedence.COMMA + 1);\r\n              if (!expr) return null;\r\n            }\r\n            elementExpressions.push(expr);\r\n            if (tn.peek() == Token.CLOSEBRACKET) break;\r\n          } while (tn.skip(Token.COMMA));\r\n          if (!tn.skip(Token.CLOSEBRACKET)) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \"]\"\r\n            );\r\n            return null;\r\n          }\r\n        }\r\n        return Node.createArrayLiteralExpression(elementExpressions, tn.range(startPos, tn.pos));\r\n\r\n      // AssertionExpression (unary prefix)\r\n      case Token.LESSTHAN:\r\n        var toType = this.parseType(tn);\r\n        if (!toType) return null;\r\n        if (!tn.skip(Token.GREATERTHAN)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \">\"\r\n          );\r\n          return null;\r\n        }\r\n        expr = this.parseExpression(tn, Precedence.CALL);\r\n        if (!expr) return null;\r\n        return Node.createAssertionExpression(\r\n          AssertionKind.PREFIX,\r\n          expr,\r\n          toType,\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n\r\n      case Token.IDENTIFIER:\r\n        return Node.createIdentifierExpression(tn.readIdentifier(), tn.range(startPos, tn.pos));\r\n\r\n      case Token.THIS:\r\n        return Node.createThisExpression(tn.range(startPos, tn.pos));\r\n\r\n      case Token.CONSTRUCTOR:\r\n        return Node.createConstructorExpression(tn.range(startPos, tn.pos));\r\n\r\n      case Token.SUPER:\r\n        return Node.createSuperExpression(tn.range(startPos, tn.pos));\r\n\r\n      case Token.STRINGLITERAL:\r\n        return Node.createStringLiteralExpression(tn.readString(), tn.range(startPos, tn.pos));\r\n\r\n      case Token.INTEGERLITERAL:\r\n        return Node.createIntegerLiteralExpression(tn.readInteger(), tn.range(startPos, tn.pos));\r\n\r\n      case Token.FLOATLITERAL:\r\n        return Node.createFloatLiteralExpression(tn.readFloat(), tn.range(startPos, tn.pos));\r\n\r\n      // RegexpLiteralExpression\r\n      // note that this also continues on invalid ones so the surrounding AST remains intact\r\n      case Token.SLASH:\r\n        var regexpPattern = tn.readRegexpPattern(); // also reports\r\n        if (!tn.skip(Token.SLASH)) {\r\n          this.error(\r\n            DiagnosticCode._0_expected,\r\n            tn.range(), \"/\"\r\n          );\r\n          return null;\r\n        }\r\n        return Node.createRegexpLiteralExpression(\r\n          regexpPattern,\r\n          tn.readRegexpFlags(), // also reports\r\n          tn.range(startPos, tn.pos)\r\n        );\r\n\r\n      case Token.FUNCTION:\r\n        return this.parseFunctionExpression(tn);\r\n\r\n      default:\r\n        this.error(\r\n          DiagnosticCode.Expression_expected,\r\n          tn.range()\r\n        );\r\n        return null;\r\n    }\r\n  }\r\n\r\n  tryParseTypeArgumentsBeforeArguments(\r\n    tn: Tokenizer\r\n  ): TypeNode[] | null {\r\n\r\n    // at '<': Type (',' Type)* '>' '('\r\n\r\n    tn.mark();\r\n    if (!tn.skip(Token.LESSTHAN)) return null;\r\n    var typeArguments = new Array<TypeNode>();\r\n    do {\r\n      var type = this.parseType(tn, true, true);\r\n      if (!type) {\r\n        tn.reset();\r\n        return null;\r\n      }\r\n      typeArguments.push(type);\r\n    } while (tn.skip(Token.COMMA));\r\n    if (tn.skip(Token.GREATERTHAN) && tn.skip(Token.OPENPAREN)) {\r\n      return typeArguments;\r\n    }\r\n    tn.reset();\r\n    return null;\r\n  }\r\n\r\n  parseArguments(\r\n    tn: Tokenizer\r\n  ): Expression[] | null {\r\n\r\n    // at '(': (Expression (',' Expression)*)? ')'\r\n\r\n    var args = new Array<Expression>();\r\n    if (!tn.skip(Token.CLOSEPAREN)) {\r\n      do {\r\n        var expr = this.parseExpression(tn, Precedence.COMMA + 1);\r\n        if (!expr) return null;\r\n        args.push(expr);\r\n      } while (tn.skip(Token.COMMA));\r\n      if (!tn.skip(Token.CLOSEPAREN)) {\r\n        this.error(\r\n          DiagnosticCode._0_expected,\r\n          tn.range(), \")\"\r\n        );\r\n        return null;\r\n      }\r\n    }\r\n    return args;\r\n  }\r\n\r\n  parseExpression(\r\n    tn: Tokenizer,\r\n    precedence: Precedence = 0\r\n  ): Expression | null {\r\n\r\n    var expr = this.parseExpressionStart(tn);\r\n    if (!expr) return null;\r\n    var startPos = expr.range.start;\r\n\r\n    // CallExpression\r\n    var typeArguments = this.tryParseTypeArgumentsBeforeArguments(tn); // skips '(' on success\r\n    // there might be better ways to distinguish a LESSTHAN from a CALL with type arguments\r\n    if (typeArguments || tn.skip(Token.OPENPAREN)) {\r\n      var args = this.parseArguments(tn);\r\n      if (!args) return null;\r\n      expr = Node.createCallExpression(expr, typeArguments, args, tn.range(startPos, tn.pos));\r\n    }\r\n\r\n    var token: Token;\r\n    var next: Expression | null = null;\r\n    var nextPrecedence: Precedence;\r\n    while (\r\n      (nextPrecedence = determinePrecedence(token = tn.peek())) >= precedence\r\n    ) { // precedence climbing\r\n      tn.next();\r\n\r\n      switch (token) {\r\n\r\n        // AssertionExpression\r\n        case Token.AS:\r\n          var toType = this.parseType(tn);\r\n          if (!toType) return null;\r\n          expr = Node.createAssertionExpression(\r\n            AssertionKind.AS,\r\n            expr,\r\n            toType,\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n          break;\r\n\r\n        // ElementAccessExpression\r\n        case Token.OPENBRACKET:\r\n          next = this.parseExpression(tn);\r\n          if (!next) return null;\r\n          if (!tn.skip(Token.CLOSEBRACKET)) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \"]\"\r\n            );\r\n            return null;\r\n          }\r\n          expr = Node.createElementAccessExpression(\r\n            expr,\r\n            next,\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n          break;\r\n\r\n        // UnaryPostfixExpression\r\n        case Token.PLUS_PLUS:\r\n        case Token.MINUS_MINUS:\r\n          if (\r\n            expr.kind != NodeKind.IDENTIFIER &&\r\n            expr.kind != NodeKind.ELEMENTACCESS &&\r\n            expr.kind != NodeKind.PROPERTYACCESS\r\n          ) {\r\n            this.error(\r\n              DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access,\r\n              expr.range\r\n            );\r\n          }\r\n          expr = Node.createUnaryPostfixExpression(\r\n            token,\r\n            expr,\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n          break;\r\n\r\n        // TernaryExpression\r\n        case Token.QUESTION:\r\n          var ifThen = this.parseExpression(tn);\r\n          if (!ifThen) return null;\r\n          if (!tn.skip(Token.COLON)) {\r\n            this.error(\r\n              DiagnosticCode._0_expected,\r\n              tn.range(), \":\"\r\n            );\r\n            return null;\r\n          }\r\n          var ifElse = this.parseExpression(tn);\r\n          if (!ifElse) return null;\r\n          expr = Node.createTernaryExpression(\r\n            expr,\r\n            ifThen,\r\n            ifElse,\r\n            tn.range(startPos, tn.pos)\r\n          );\r\n          break;\r\n\r\n        // CommaExpression\r\n        case Token.COMMA:\r\n          var commaExprs: Expression[] = [ expr ];\r\n          do {\r\n            expr = this.parseExpression(tn, Precedence.COMMA + 1);\r\n            if (!expr) return null;\r\n            commaExprs.push(expr);\r\n          } while (tn.skip(Token.COMMA));\r\n          expr = Node.createCommaExpression(commaExprs, tn.range(startPos, tn.pos));\r\n          break;\r\n\r\n        default:\r\n          next = this.parseExpression(tn,\r\n            isRightAssociative(token)\r\n              ? nextPrecedence\r\n              : nextPrecedence + 1\r\n          );\r\n          if (!next) return null;\r\n\r\n          // PropertyAccessExpression\r\n          if (token == Token.DOT) {\r\n            if (next.kind == NodeKind.IDENTIFIER) {\r\n              expr = Node.createPropertyAccessExpression(\r\n                expr,\r\n                <IdentifierExpression>next,\r\n                tn.range(startPos, tn.pos)\r\n              );\r\n            } else if (next.kind == NodeKind.CALL) { // join\r\n              var propertyCall = <CallExpression>next;\r\n              if (propertyCall.expression.kind == NodeKind.IDENTIFIER) {\r\n                propertyCall.expression = Node.createPropertyAccessExpression(\r\n                  expr,\r\n                  <IdentifierExpression>propertyCall.expression,\r\n                  tn.range(startPos, tn.pos)\r\n                );\r\n              } else {\r\n                this.error(\r\n                  DiagnosticCode.Identifier_expected,\r\n                  propertyCall.expression.range\r\n                );\r\n                return null;\r\n              }\r\n              expr = propertyCall;\r\n            } else {\r\n              this.error(\r\n                DiagnosticCode.Identifier_expected,\r\n                next.range\r\n              );\r\n              return null;\r\n            }\r\n\r\n          // BinaryExpression\r\n          } else {\r\n            expr = Node.createBinaryExpression(token, expr, next, tn.range(startPos, tn.pos));\r\n          }\r\n          break;\r\n      }\r\n    }\r\n    return expr;\r\n  }\r\n}\r\n\r\n/** Operator precedence from least to largest. */\r\nexport const enum Precedence {\r\n  COMMA,\r\n  SPREAD,\r\n  YIELD,\r\n  ASSIGNMENT,\r\n  CONDITIONAL,\r\n  LOGICAL_OR,\r\n  LOGICAL_AND,\r\n  BITWISE_OR,\r\n  BITWISE_XOR,\r\n  BITWISE_AND,\r\n  EQUALITY,\r\n  RELATIONAL,\r\n  SHIFT,\r\n  ADDITIVE,\r\n  MULTIPLICATIVE,\r\n  EXPONENTIATED,\r\n  UNARY_PREFIX,\r\n  UNARY_POSTFIX,\r\n  CALL,\r\n  MEMBERACCESS,\r\n  GROUPING,\r\n  INVALID = -1\r\n}\r\n\r\n/** Determines the precedence of a starting token. */\r\nfunction determinePrecedenceStart(kind: Token): i32 {\r\n  switch (kind) {\r\n\r\n    case Token.DOT_DOT_DOT:\r\n      return Precedence.SPREAD;\r\n\r\n    case Token.YIELD:\r\n      return Precedence.YIELD;\r\n\r\n    case Token.EXCLAMATION:\r\n    case Token.TILDE:\r\n    case Token.PLUS:\r\n    case Token.MINUS:\r\n    case Token.PLUS_PLUS:\r\n    case Token.MINUS_MINUS:\r\n    case Token.TYPEOF:\r\n    case Token.VOID:\r\n    case Token.DELETE:\r\n      return Precedence.UNARY_PREFIX;\r\n\r\n    case Token.NEW:\r\n      return Precedence.MEMBERACCESS;\r\n\r\n    default:\r\n      return Precedence.INVALID;\r\n  }\r\n}\r\n\r\n/** Determines the precende of a non-starting token. */\r\nfunction determinePrecedence(kind: Token): i32 {\r\n  switch (kind) {\r\n\r\n    case Token.COMMA:\r\n      return Precedence.COMMA;\r\n\r\n    case Token.EQUALS:\r\n    case Token.PLUS_EQUALS:\r\n    case Token.MINUS_EQUALS:\r\n    case Token.ASTERISK_ASTERISK_EQUALS:\r\n    case Token.ASTERISK_EQUALS:\r\n    case Token.SLASH_EQUALS:\r\n    case Token.PERCENT_EQUALS:\r\n    case Token.LESSTHAN_LESSTHAN_EQUALS:\r\n    case Token.GREATERTHAN_GREATERTHAN_EQUALS:\r\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\r\n    case Token.AMPERSAND_EQUALS:\r\n    case Token.CARET_EQUALS:\r\n    case Token.BAR_EQUALS:\r\n      return Precedence.ASSIGNMENT;\r\n\r\n    case Token.QUESTION:\r\n      return Precedence.CONDITIONAL;\r\n\r\n    case Token.BAR_BAR:\r\n      return Precedence.LOGICAL_OR;\r\n\r\n    case Token.AMPERSAND_AMPERSAND:\r\n      return Precedence.LOGICAL_AND;\r\n\r\n    case Token.BAR:\r\n      return Precedence.BITWISE_OR;\r\n\r\n    case Token.CARET:\r\n      return Precedence.BITWISE_XOR;\r\n\r\n    case Token.AMPERSAND:\r\n      return Precedence.BITWISE_AND;\r\n\r\n    case Token.EQUALS_EQUALS:\r\n    case Token.EXCLAMATION_EQUALS:\r\n    case Token.EQUALS_EQUALS_EQUALS:\r\n    case Token.EXCLAMATION_EQUALS_EQUALS:\r\n      return Precedence.EQUALITY;\r\n\r\n    case Token.AS:\r\n    case Token.IN:\r\n    case Token.INSTANCEOF:\r\n    case Token.LESSTHAN:\r\n    case Token.GREATERTHAN:\r\n    case Token.LESSTHAN_EQUALS:\r\n    case Token.GREATERTHAN_EQUALS:\r\n      return Precedence.RELATIONAL;\r\n\r\n    case Token.LESSTHAN_LESSTHAN:\r\n    case Token.GREATERTHAN_GREATERTHAN:\r\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN:\r\n      return Precedence.SHIFT;\r\n\r\n    case Token.PLUS:\r\n    case Token.MINUS:\r\n      return Precedence.ADDITIVE;\r\n\r\n    case Token.ASTERISK:\r\n    case Token.SLASH:\r\n    case Token.PERCENT:\r\n      return Precedence.MULTIPLICATIVE;\r\n\r\n    case Token.ASTERISK_ASTERISK:\r\n      return Precedence.EXPONENTIATED;\r\n\r\n    case Token.PLUS_PLUS:\r\n    case Token.MINUS_MINUS:\r\n      return Precedence.UNARY_POSTFIX;\r\n\r\n    case Token.DOT:\r\n    case Token.NEW:\r\n    case Token.OPENBRACKET:\r\n      return Precedence.MEMBERACCESS;\r\n\r\n    default:\r\n      return Precedence.INVALID;\r\n  }\r\n}\r\n\r\n/** Determines whether a non-starting token is right associative. */\r\nfunction isRightAssociative(kind: Token): bool {\r\n  switch (kind) {\r\n\r\n    case Token.EQUALS:\r\n    case Token.PLUS_EQUALS:\r\n    case Token.MINUS_EQUALS:\r\n    case Token.ASTERISK_ASTERISK_EQUALS:\r\n    case Token.ASTERISK_EQUALS:\r\n    case Token.SLASH_EQUALS:\r\n    case Token.PERCENT_EQUALS:\r\n    case Token.LESSTHAN_LESSTHAN_EQUALS:\r\n    case Token.GREATERTHAN_GREATERTHAN_EQUALS:\r\n    case Token.GREATERTHAN_GREATERTHAN_GREATERTHAN_EQUALS:\r\n    case Token.AMPERSAND_EQUALS:\r\n    case Token.CARET_EQUALS:\r\n    case Token.BAR_EQUALS:\r\n    case Token.QUESTION:\r\n    case Token.ASTERISK_ASTERISK:\r\n      return true;\r\n\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/parser.ts"],"sourceRoot":""}